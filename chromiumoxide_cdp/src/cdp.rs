#[doc = r" This file is generated and should not be edited directly."]
pub use events::*;
#[doc = r" This trait allows for implementing custom events that are not covered by the"]
#[doc = r" chrome protocol definitions."]
#[doc = r""]
#[doc = r" Every `CustomEvent` also requires an implementation of"]
#[doc = r" `chromiumoxide_types::MethodType` and it must be `DeserializeOwned`"]
#[doc = r" (`#[derive(serde::Deserialize)]`). This is necessary to identify match this"]
#[doc = r" type against the provided `method` identifier of a `CdpEventMessage`"]
#[doc = r" and to properly deserialize it from a `serde_json::Value`"]
pub trait CustomEvent:
    ::std::any::Any + serde::de::DeserializeOwned + chromiumoxide_types::MethodType + Send + Sync
{
    #[doc = r" Used to convert the json event into in instance of this type"]
    fn from_json(event: serde_json::Value) -> serde_json::Result<Self>
    where
        Self: Sized + 'static,
    {
        serde_json::from_value(event)
    }
}
impl<T: CustomEvent> sealed::SealedEvent for T {
    fn as_any(&self) -> &dyn ::std::any::Any {
        self
    }
}
#[doc = r" This is trait that all Events share"]
#[doc = r""]
#[doc = r" This trait is sealed to prevent implementation. The only way to implement a new `Event` is by implementing `CustomEvent`"]
pub trait Event: sealed::SealedEvent {}
impl<T: sealed::SealedEvent> Event for T {}
impl<T: CustomEvent + Event> sealed::SealedCustomEventConverter for T {}
#[doc = r" Function type to convert a json event into an instance of it self but as dyn Event"]
pub type EventConversion = Box<
    dyn Fn(serde_json::Value) -> serde_json::Result<::std::sync::Arc<dyn Event>> + Send + 'static,
>;
#[doc = r" An enum that does nothing for built in types but contains the conversion method for custom events"]
pub enum EventKind {
    BuiltIn,
    Custom(EventConversion),
}
impl EventKind {
    #[doc = r" Whether this is a custom event"]
    pub fn is_custom(&self) -> bool {
        matches!(self, EventKind::Custom(_))
    }
}
impl ::std::fmt::Debug for EventKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            EventKind::BuiltIn => f.debug_tuple("BuiltIn").finish(),
            EventKind::Custom(_) => f.debug_tuple("Custom").finish(),
        }
    }
}
#[doc = r" A trait on top of the `Event` trait"]
pub trait IntoEventKind: Event {
    #[doc = r" What kind of event this type is"]
    fn event_kind() -> EventKind
    where
        Self: Sized + 'static;
}
impl<T: sealed::SealedCustomEventConverter> IntoEventKind for T {
    fn event_kind() -> EventKind
    where
        Self: Sized + 'static,
    {
        EventKind::Custom(Box::new(Self::event_arc))
    }
}
pub(crate) mod sealed {
    pub trait SealedCustomEventConverter: super::CustomEvent + super::Event {
        fn event_arc(
            event: serde_json::Value,
        ) -> serde_json::Result<::std::sync::Arc<dyn super::Event>>
        where
            Self: Sized + 'static,
        {
            Ok(::std::sync::Arc::new(Self::from_json(event)?))
        }
    }
    pub trait SealedEvent: ArcAny + chromiumoxide_types::MethodType {
        #[doc = r" generate `&::std::any::Any`'s vtable from `&Trait`'s."]
        fn as_any(&self) -> &dyn ::std::any::Any;
    }
    pub trait ArcAny: ::std::any::Any + Send + Sync {
        fn into_any_arc(
            self: ::std::sync::Arc<Self>,
        ) -> ::std::sync::Arc<dyn ::std::any::Any + Send + Sync>;
    }
    impl<T: ::std::any::Any + Send + Sync> ArcAny for T {
        fn into_any_arc(
            self: ::std::sync::Arc<Self>,
        ) -> ::std::sync::Arc<dyn ::std::any::Any + Send + Sync> {
            self
        }
    }
    impl dyn SealedEvent {
        #[doc = r" Returns true if the trait object wraps an object of type `T`."]
        #[inline]
        pub fn is<T: SealedEvent>(&self) -> bool {
            self.as_any().is::<T>()
        }
        #[inline]
        pub fn downcast_arc<T: SealedEvent>(
            self: ::std::sync::Arc<Self>,
        ) -> Result<::std::sync::Arc<T>, ::std::sync::Arc<Self>>
        where
            T: ::std::any::Any + Send + Sync,
        {
            if self.is::<T>() {
                Ok(ArcAny::into_any_arc(self).downcast::<T>().unwrap())
            } else {
                Err(self)
            }
        }
    }
}
pub mod events {
    use serde::Deserialize;
    #[derive(Debug, PartialEq, Clone)]
    pub struct CdpEventMessage {
        #[doc = r" Name of the method"]
        pub method: chromiumoxide_types::MethodId,
        #[doc = r" The chromium session Id"]
        pub session_id: Option<String>,
        #[doc = r" Json params"]
        pub params: CdpEvent,
    }
    impl chromiumoxide_types::Method for CdpEventMessage {
        fn identifier(&self) -> chromiumoxide_types::MethodId {
            match &self.params {
                CdpEvent::DebuggerBreakpointResolved(inner) => inner.identifier(),
                CdpEvent::DebuggerPaused(inner) => inner.identifier(),
                CdpEvent::DebuggerResumed(inner) => inner.identifier(),
                CdpEvent::DebuggerScriptFailedToParse(inner) => inner.identifier(),
                CdpEvent::DebuggerScriptParsed(inner) => inner.identifier(),
                CdpEvent::HeapProfilerAddHeapSnapshotChunk(inner) => inner.identifier(),
                CdpEvent::HeapProfilerHeapStatsUpdate(inner) => inner.identifier(),
                CdpEvent::HeapProfilerLastSeenObjectId(inner) => inner.identifier(),
                CdpEvent::HeapProfilerReportHeapSnapshotProgress(inner) => inner.identifier(),
                CdpEvent::HeapProfilerResetProfiles(inner) => inner.identifier(),
                CdpEvent::ProfilerConsoleProfileFinished(inner) => inner.identifier(),
                CdpEvent::ProfilerConsoleProfileStarted(inner) => inner.identifier(),
                CdpEvent::ProfilerPreciseCoverageDeltaUpdate(inner) => inner.identifier(),
                CdpEvent::RuntimeBindingCalled(inner) => inner.identifier(),
                CdpEvent::RuntimeConsoleApiCalled(inner) => inner.identifier(),
                CdpEvent::RuntimeExceptionRevoked(inner) => inner.identifier(),
                CdpEvent::RuntimeExceptionThrown(inner) => inner.identifier(),
                CdpEvent::RuntimeExecutionContextCreated(inner) => inner.identifier(),
                CdpEvent::RuntimeExecutionContextDestroyed(inner) => inner.identifier(),
                CdpEvent::RuntimeExecutionContextsCleared(inner) => inner.identifier(),
                CdpEvent::RuntimeInspectRequested(inner) => inner.identifier(),
                CdpEvent::AccessibilityLoadComplete(inner) => inner.identifier(),
                CdpEvent::AccessibilityNodesUpdated(inner) => inner.identifier(),
                CdpEvent::AnimationAnimationCanceled(inner) => inner.identifier(),
                CdpEvent::AnimationAnimationCreated(inner) => inner.identifier(),
                CdpEvent::AnimationAnimationStarted(inner) => inner.identifier(),
                CdpEvent::AuditsIssueAdded(inner) => inner.identifier(),
                CdpEvent::BackgroundServiceRecordingStateChanged(inner) => inner.identifier(),
                CdpEvent::BackgroundServiceBackgroundServiceEventReceived(inner) => {
                    inner.identifier()
                }
                CdpEvent::BrowserDownloadWillBegin(inner) => inner.identifier(),
                CdpEvent::BrowserDownloadProgress(inner) => inner.identifier(),
                CdpEvent::CssFontsUpdated(inner) => inner.identifier(),
                CdpEvent::CssMediaQueryResultChanged(inner) => inner.identifier(),
                CdpEvent::CssStyleSheetAdded(inner) => inner.identifier(),
                CdpEvent::CssStyleSheetChanged(inner) => inner.identifier(),
                CdpEvent::CssStyleSheetRemoved(inner) => inner.identifier(),
                CdpEvent::CastSinksUpdated(inner) => inner.identifier(),
                CdpEvent::CastIssueUpdated(inner) => inner.identifier(),
                CdpEvent::DomAttributeModified(inner) => inner.identifier(),
                CdpEvent::DomAttributeRemoved(inner) => inner.identifier(),
                CdpEvent::DomCharacterDataModified(inner) => inner.identifier(),
                CdpEvent::DomChildNodeCountUpdated(inner) => inner.identifier(),
                CdpEvent::DomChildNodeInserted(inner) => inner.identifier(),
                CdpEvent::DomChildNodeRemoved(inner) => inner.identifier(),
                CdpEvent::DomDistributedNodesUpdated(inner) => inner.identifier(),
                CdpEvent::DomDocumentUpdated(inner) => inner.identifier(),
                CdpEvent::DomInlineStyleInvalidated(inner) => inner.identifier(),
                CdpEvent::DomPseudoElementAdded(inner) => inner.identifier(),
                CdpEvent::DomTopLayerElementsUpdated(inner) => inner.identifier(),
                CdpEvent::DomPseudoElementRemoved(inner) => inner.identifier(),
                CdpEvent::DomSetChildNodes(inner) => inner.identifier(),
                CdpEvent::DomShadowRootPopped(inner) => inner.identifier(),
                CdpEvent::DomShadowRootPushed(inner) => inner.identifier(),
                CdpEvent::DomStorageDomStorageItemAdded(inner) => inner.identifier(),
                CdpEvent::DomStorageDomStorageItemRemoved(inner) => inner.identifier(),
                CdpEvent::DomStorageDomStorageItemUpdated(inner) => inner.identifier(),
                CdpEvent::DomStorageDomStorageItemsCleared(inner) => inner.identifier(),
                CdpEvent::DatabaseAddDatabase(inner) => inner.identifier(),
                CdpEvent::EmulationVirtualTimeBudgetExpired(inner) => inner.identifier(),
                CdpEvent::InputDragIntercepted(inner) => inner.identifier(),
                CdpEvent::InspectorDetached(inner) => inner.identifier(),
                CdpEvent::InspectorTargetCrashed(inner) => inner.identifier(),
                CdpEvent::InspectorTargetReloadedAfterCrash(inner) => inner.identifier(),
                CdpEvent::LayerTreeLayerPainted(inner) => inner.identifier(),
                CdpEvent::LayerTreeLayerTreeDidChange(inner) => inner.identifier(),
                CdpEvent::LogEntryAdded(inner) => inner.identifier(),
                CdpEvent::NetworkDataReceived(inner) => inner.identifier(),
                CdpEvent::NetworkEventSourceMessageReceived(inner) => inner.identifier(),
                CdpEvent::NetworkLoadingFailed(inner) => inner.identifier(),
                CdpEvent::NetworkLoadingFinished(inner) => inner.identifier(),
                CdpEvent::NetworkRequestServedFromCache(inner) => inner.identifier(),
                CdpEvent::NetworkRequestWillBeSent(inner) => inner.identifier(),
                CdpEvent::NetworkResourceChangedPriority(inner) => inner.identifier(),
                CdpEvent::NetworkSignedExchangeReceived(inner) => inner.identifier(),
                CdpEvent::NetworkResponseReceived(inner) => inner.identifier(),
                CdpEvent::NetworkWebSocketClosed(inner) => inner.identifier(),
                CdpEvent::NetworkWebSocketCreated(inner) => inner.identifier(),
                CdpEvent::NetworkWebSocketFrameError(inner) => inner.identifier(),
                CdpEvent::NetworkWebSocketFrameReceived(inner) => inner.identifier(),
                CdpEvent::NetworkWebSocketFrameSent(inner) => inner.identifier(),
                CdpEvent::NetworkWebSocketHandshakeResponseReceived(inner) => inner.identifier(),
                CdpEvent::NetworkWebSocketWillSendHandshakeRequest(inner) => inner.identifier(),
                CdpEvent::NetworkWebTransportCreated(inner) => inner.identifier(),
                CdpEvent::NetworkWebTransportConnectionEstablished(inner) => inner.identifier(),
                CdpEvent::NetworkWebTransportClosed(inner) => inner.identifier(),
                CdpEvent::NetworkRequestWillBeSentExtraInfo(inner) => inner.identifier(),
                CdpEvent::NetworkResponseReceivedExtraInfo(inner) => inner.identifier(),
                CdpEvent::NetworkTrustTokenOperationDone(inner) => inner.identifier(),
                CdpEvent::NetworkSubresourceWebBundleMetadataReceived(inner) => inner.identifier(),
                CdpEvent::NetworkSubresourceWebBundleMetadataError(inner) => inner.identifier(),
                CdpEvent::NetworkSubresourceWebBundleInnerResponseParsed(inner) => {
                    inner.identifier()
                }
                CdpEvent::NetworkSubresourceWebBundleInnerResponseError(inner) => {
                    inner.identifier()
                }
                CdpEvent::NetworkReportingApiReportAdded(inner) => inner.identifier(),
                CdpEvent::NetworkReportingApiReportUpdated(inner) => inner.identifier(),
                CdpEvent::NetworkReportingApiEndpointsChangedForOrigin(inner) => inner.identifier(),
                CdpEvent::OverlayInspectNodeRequested(inner) => inner.identifier(),
                CdpEvent::OverlayNodeHighlightRequested(inner) => inner.identifier(),
                CdpEvent::OverlayScreenshotRequested(inner) => inner.identifier(),
                CdpEvent::OverlayInspectModeCanceled(inner) => inner.identifier(),
                CdpEvent::PageDomContentEventFired(inner) => inner.identifier(),
                CdpEvent::PageFileChooserOpened(inner) => inner.identifier(),
                CdpEvent::PageFrameAttached(inner) => inner.identifier(),
                CdpEvent::PageFrameDetached(inner) => inner.identifier(),
                CdpEvent::PageFrameNavigated(inner) => inner.identifier(),
                CdpEvent::PageDocumentOpened(inner) => inner.identifier(),
                CdpEvent::PageFrameResized(inner) => inner.identifier(),
                CdpEvent::PageFrameRequestedNavigation(inner) => inner.identifier(),
                CdpEvent::PageFrameStartedLoading(inner) => inner.identifier(),
                CdpEvent::PageFrameStoppedLoading(inner) => inner.identifier(),
                CdpEvent::PageInterstitialHidden(inner) => inner.identifier(),
                CdpEvent::PageInterstitialShown(inner) => inner.identifier(),
                CdpEvent::PageJavascriptDialogClosed(inner) => inner.identifier(),
                CdpEvent::PageJavascriptDialogOpening(inner) => inner.identifier(),
                CdpEvent::PageLifecycleEvent(inner) => inner.identifier(),
                CdpEvent::PageBackForwardCacheNotUsed(inner) => inner.identifier(),
                CdpEvent::PagePrerenderAttemptCompleted(inner) => inner.identifier(),
                CdpEvent::PageLoadEventFired(inner) => inner.identifier(),
                CdpEvent::PageNavigatedWithinDocument(inner) => inner.identifier(),
                CdpEvent::PageScreencastFrame(inner) => inner.identifier(),
                CdpEvent::PageScreencastVisibilityChanged(inner) => inner.identifier(),
                CdpEvent::PageWindowOpen(inner) => inner.identifier(),
                CdpEvent::PageCompilationCacheProduced(inner) => inner.identifier(),
                CdpEvent::PerformanceMetrics(inner) => inner.identifier(),
                CdpEvent::PerformanceTimelineTimelineEventAdded(inner) => inner.identifier(),
                CdpEvent::SecurityVisibleSecurityStateChanged(inner) => inner.identifier(),
                CdpEvent::ServiceWorkerWorkerErrorReported(inner) => inner.identifier(),
                CdpEvent::ServiceWorkerWorkerRegistrationUpdated(inner) => inner.identifier(),
                CdpEvent::ServiceWorkerWorkerVersionUpdated(inner) => inner.identifier(),
                CdpEvent::StorageCacheStorageContentUpdated(inner) => inner.identifier(),
                CdpEvent::StorageCacheStorageListUpdated(inner) => inner.identifier(),
                CdpEvent::StorageIndexedDbContentUpdated(inner) => inner.identifier(),
                CdpEvent::StorageIndexedDbListUpdated(inner) => inner.identifier(),
                CdpEvent::StorageInterestGroupAccessed(inner) => inner.identifier(),
                CdpEvent::TargetAttachedToTarget(inner) => inner.identifier(),
                CdpEvent::TargetDetachedFromTarget(inner) => inner.identifier(),
                CdpEvent::TargetReceivedMessageFromTarget(inner) => inner.identifier(),
                CdpEvent::TargetTargetCreated(inner) => inner.identifier(),
                CdpEvent::TargetTargetDestroyed(inner) => inner.identifier(),
                CdpEvent::TargetTargetCrashed(inner) => inner.identifier(),
                CdpEvent::TargetTargetInfoChanged(inner) => inner.identifier(),
                CdpEvent::TetheringAccepted(inner) => inner.identifier(),
                CdpEvent::TracingBufferUsage(inner) => inner.identifier(),
                CdpEvent::TracingDataCollected(inner) => inner.identifier(),
                CdpEvent::TracingTracingComplete(inner) => inner.identifier(),
                CdpEvent::FetchRequestPaused(inner) => inner.identifier(),
                CdpEvent::FetchAuthRequired(inner) => inner.identifier(),
                CdpEvent::WebAudioContextCreated(inner) => inner.identifier(),
                CdpEvent::WebAudioContextWillBeDestroyed(inner) => inner.identifier(),
                CdpEvent::WebAudioContextChanged(inner) => inner.identifier(),
                CdpEvent::WebAudioAudioListenerCreated(inner) => inner.identifier(),
                CdpEvent::WebAudioAudioListenerWillBeDestroyed(inner) => inner.identifier(),
                CdpEvent::WebAudioAudioNodeCreated(inner) => inner.identifier(),
                CdpEvent::WebAudioAudioNodeWillBeDestroyed(inner) => inner.identifier(),
                CdpEvent::WebAudioAudioParamCreated(inner) => inner.identifier(),
                CdpEvent::WebAudioAudioParamWillBeDestroyed(inner) => inner.identifier(),
                CdpEvent::WebAudioNodesConnected(inner) => inner.identifier(),
                CdpEvent::WebAudioNodesDisconnected(inner) => inner.identifier(),
                CdpEvent::WebAudioNodeParamConnected(inner) => inner.identifier(),
                CdpEvent::WebAudioNodeParamDisconnected(inner) => inner.identifier(),
                CdpEvent::MediaPlayerPropertiesChanged(inner) => inner.identifier(),
                CdpEvent::MediaPlayerEventsAdded(inner) => inner.identifier(),
                CdpEvent::MediaPlayerMessagesLogged(inner) => inner.identifier(),
                CdpEvent::MediaPlayerErrorsRaised(inner) => inner.identifier(),
                CdpEvent::MediaPlayersCreated(inner) => inner.identifier(),
                _ => self.method.clone(),
            }
        }
    }
    impl chromiumoxide_types::EventMessage for CdpEventMessage {
        fn session_id(&self) -> Option<&str> {
            self.session_id.as_deref()
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub enum CdpEvent {
        DebuggerBreakpointResolved(super::js_protocol::debugger::EventBreakpointResolved),
        DebuggerPaused(super::js_protocol::debugger::EventPaused),
        DebuggerResumed(super::js_protocol::debugger::EventResumed),
        DebuggerScriptFailedToParse(Box<super::js_protocol::debugger::EventScriptFailedToParse>),
        DebuggerScriptParsed(Box<super::js_protocol::debugger::EventScriptParsed>),
        HeapProfilerAddHeapSnapshotChunk(
            super::js_protocol::heap_profiler::EventAddHeapSnapshotChunk,
        ),
        HeapProfilerHeapStatsUpdate(super::js_protocol::heap_profiler::EventHeapStatsUpdate),
        HeapProfilerLastSeenObjectId(super::js_protocol::heap_profiler::EventLastSeenObjectId),
        HeapProfilerReportHeapSnapshotProgress(
            super::js_protocol::heap_profiler::EventReportHeapSnapshotProgress,
        ),
        HeapProfilerResetProfiles(super::js_protocol::heap_profiler::EventResetProfiles),
        ProfilerConsoleProfileFinished(super::js_protocol::profiler::EventConsoleProfileFinished),
        ProfilerConsoleProfileStarted(super::js_protocol::profiler::EventConsoleProfileStarted),
        ProfilerPreciseCoverageDeltaUpdate(
            super::js_protocol::profiler::EventPreciseCoverageDeltaUpdate,
        ),
        RuntimeBindingCalled(super::js_protocol::runtime::EventBindingCalled),
        RuntimeConsoleApiCalled(super::js_protocol::runtime::EventConsoleApiCalled),
        RuntimeExceptionRevoked(super::js_protocol::runtime::EventExceptionRevoked),
        RuntimeExceptionThrown(Box<super::js_protocol::runtime::EventExceptionThrown>),
        RuntimeExecutionContextCreated(super::js_protocol::runtime::EventExecutionContextCreated),
        RuntimeExecutionContextDestroyed(
            super::js_protocol::runtime::EventExecutionContextDestroyed,
        ),
        RuntimeExecutionContextsCleared(super::js_protocol::runtime::EventExecutionContextsCleared),
        RuntimeInspectRequested(Box<super::js_protocol::runtime::EventInspectRequested>),
        AccessibilityLoadComplete(Box<super::browser_protocol::accessibility::EventLoadComplete>),
        AccessibilityNodesUpdated(super::browser_protocol::accessibility::EventNodesUpdated),
        AnimationAnimationCanceled(super::browser_protocol::animation::EventAnimationCanceled),
        AnimationAnimationCreated(super::browser_protocol::animation::EventAnimationCreated),
        AnimationAnimationStarted(Box<super::browser_protocol::animation::EventAnimationStarted>),
        AuditsIssueAdded(Box<super::browser_protocol::audits::EventIssueAdded>),
        BackgroundServiceRecordingStateChanged(
            super::browser_protocol::background_service::EventRecordingStateChanged,
        ),
        BackgroundServiceBackgroundServiceEventReceived(
            super::browser_protocol::background_service::EventBackgroundServiceEventReceived,
        ),
        BrowserDownloadWillBegin(super::browser_protocol::browser::EventDownloadWillBegin),
        BrowserDownloadProgress(super::browser_protocol::browser::EventDownloadProgress),
        CssFontsUpdated(Box<super::browser_protocol::css::EventFontsUpdated>),
        CssMediaQueryResultChanged(super::browser_protocol::css::EventMediaQueryResultChanged),
        CssStyleSheetAdded(super::browser_protocol::css::EventStyleSheetAdded),
        CssStyleSheetChanged(super::browser_protocol::css::EventStyleSheetChanged),
        CssStyleSheetRemoved(super::browser_protocol::css::EventStyleSheetRemoved),
        CastSinksUpdated(super::browser_protocol::cast::EventSinksUpdated),
        CastIssueUpdated(super::browser_protocol::cast::EventIssueUpdated),
        DomAttributeModified(super::browser_protocol::dom::EventAttributeModified),
        DomAttributeRemoved(super::browser_protocol::dom::EventAttributeRemoved),
        DomCharacterDataModified(super::browser_protocol::dom::EventCharacterDataModified),
        DomChildNodeCountUpdated(super::browser_protocol::dom::EventChildNodeCountUpdated),
        DomChildNodeInserted(Box<super::browser_protocol::dom::EventChildNodeInserted>),
        DomChildNodeRemoved(super::browser_protocol::dom::EventChildNodeRemoved),
        DomDistributedNodesUpdated(super::browser_protocol::dom::EventDistributedNodesUpdated),
        DomDocumentUpdated(super::browser_protocol::dom::EventDocumentUpdated),
        DomInlineStyleInvalidated(super::browser_protocol::dom::EventInlineStyleInvalidated),
        DomPseudoElementAdded(Box<super::browser_protocol::dom::EventPseudoElementAdded>),
        DomTopLayerElementsUpdated(super::browser_protocol::dom::EventTopLayerElementsUpdated),
        DomPseudoElementRemoved(super::browser_protocol::dom::EventPseudoElementRemoved),
        DomSetChildNodes(super::browser_protocol::dom::EventSetChildNodes),
        DomShadowRootPopped(super::browser_protocol::dom::EventShadowRootPopped),
        DomShadowRootPushed(Box<super::browser_protocol::dom::EventShadowRootPushed>),
        DomStorageDomStorageItemAdded(
            super::browser_protocol::dom_storage::EventDomStorageItemAdded,
        ),
        DomStorageDomStorageItemRemoved(
            super::browser_protocol::dom_storage::EventDomStorageItemRemoved,
        ),
        DomStorageDomStorageItemUpdated(
            super::browser_protocol::dom_storage::EventDomStorageItemUpdated,
        ),
        DomStorageDomStorageItemsCleared(
            super::browser_protocol::dom_storage::EventDomStorageItemsCleared,
        ),
        DatabaseAddDatabase(super::browser_protocol::database::EventAddDatabase),
        EmulationVirtualTimeBudgetExpired(
            super::browser_protocol::emulation::EventVirtualTimeBudgetExpired,
        ),
        InputDragIntercepted(super::browser_protocol::input::EventDragIntercepted),
        InspectorDetached(super::browser_protocol::inspector::EventDetached),
        InspectorTargetCrashed(super::browser_protocol::inspector::EventTargetCrashed),
        InspectorTargetReloadedAfterCrash(
            super::browser_protocol::inspector::EventTargetReloadedAfterCrash,
        ),
        LayerTreeLayerPainted(super::browser_protocol::layer_tree::EventLayerPainted),
        LayerTreeLayerTreeDidChange(super::browser_protocol::layer_tree::EventLayerTreeDidChange),
        LogEntryAdded(Box<super::browser_protocol::log::EventEntryAdded>),
        NetworkDataReceived(super::browser_protocol::network::EventDataReceived),
        NetworkEventSourceMessageReceived(
            super::browser_protocol::network::EventEventSourceMessageReceived,
        ),
        NetworkLoadingFailed(super::browser_protocol::network::EventLoadingFailed),
        NetworkLoadingFinished(super::browser_protocol::network::EventLoadingFinished),
        NetworkRequestServedFromCache(
            super::browser_protocol::network::EventRequestServedFromCache,
        ),
        NetworkRequestWillBeSent(Box<super::browser_protocol::network::EventRequestWillBeSent>),
        NetworkResourceChangedPriority(
            super::browser_protocol::network::EventResourceChangedPriority,
        ),
        NetworkSignedExchangeReceived(
            Box<super::browser_protocol::network::EventSignedExchangeReceived>,
        ),
        NetworkResponseReceived(Box<super::browser_protocol::network::EventResponseReceived>),
        NetworkWebSocketClosed(super::browser_protocol::network::EventWebSocketClosed),
        NetworkWebSocketCreated(Box<super::browser_protocol::network::EventWebSocketCreated>),
        NetworkWebSocketFrameError(super::browser_protocol::network::EventWebSocketFrameError),
        NetworkWebSocketFrameReceived(
            super::browser_protocol::network::EventWebSocketFrameReceived,
        ),
        NetworkWebSocketFrameSent(super::browser_protocol::network::EventWebSocketFrameSent),
        NetworkWebSocketHandshakeResponseReceived(
            super::browser_protocol::network::EventWebSocketHandshakeResponseReceived,
        ),
        NetworkWebSocketWillSendHandshakeRequest(
            super::browser_protocol::network::EventWebSocketWillSendHandshakeRequest,
        ),
        NetworkWebTransportCreated(Box<super::browser_protocol::network::EventWebTransportCreated>),
        NetworkWebTransportConnectionEstablished(
            super::browser_protocol::network::EventWebTransportConnectionEstablished,
        ),
        NetworkWebTransportClosed(super::browser_protocol::network::EventWebTransportClosed),
        NetworkRequestWillBeSentExtraInfo(
            super::browser_protocol::network::EventRequestWillBeSentExtraInfo,
        ),
        NetworkResponseReceivedExtraInfo(
            super::browser_protocol::network::EventResponseReceivedExtraInfo,
        ),
        NetworkTrustTokenOperationDone(
            super::browser_protocol::network::EventTrustTokenOperationDone,
        ),
        NetworkSubresourceWebBundleMetadataReceived(
            super::browser_protocol::network::EventSubresourceWebBundleMetadataReceived,
        ),
        NetworkSubresourceWebBundleMetadataError(
            super::browser_protocol::network::EventSubresourceWebBundleMetadataError,
        ),
        NetworkSubresourceWebBundleInnerResponseParsed(
            super::browser_protocol::network::EventSubresourceWebBundleInnerResponseParsed,
        ),
        NetworkSubresourceWebBundleInnerResponseError(
            super::browser_protocol::network::EventSubresourceWebBundleInnerResponseError,
        ),
        NetworkReportingApiReportAdded(
            super::browser_protocol::network::EventReportingApiReportAdded,
        ),
        NetworkReportingApiReportUpdated(
            super::browser_protocol::network::EventReportingApiReportUpdated,
        ),
        NetworkReportingApiEndpointsChangedForOrigin(
            super::browser_protocol::network::EventReportingApiEndpointsChangedForOrigin,
        ),
        OverlayInspectNodeRequested(super::browser_protocol::overlay::EventInspectNodeRequested),
        OverlayNodeHighlightRequested(
            super::browser_protocol::overlay::EventNodeHighlightRequested,
        ),
        OverlayScreenshotRequested(super::browser_protocol::overlay::EventScreenshotRequested),
        OverlayInspectModeCanceled(super::browser_protocol::overlay::EventInspectModeCanceled),
        PageDomContentEventFired(super::browser_protocol::page::EventDomContentEventFired),
        PageFileChooserOpened(super::browser_protocol::page::EventFileChooserOpened),
        PageFrameAttached(super::browser_protocol::page::EventFrameAttached),
        PageFrameDetached(super::browser_protocol::page::EventFrameDetached),
        PageFrameNavigated(Box<super::browser_protocol::page::EventFrameNavigated>),
        PageDocumentOpened(Box<super::browser_protocol::page::EventDocumentOpened>),
        PageFrameResized(super::browser_protocol::page::EventFrameResized),
        PageFrameRequestedNavigation(super::browser_protocol::page::EventFrameRequestedNavigation),
        PageFrameStartedLoading(super::browser_protocol::page::EventFrameStartedLoading),
        PageFrameStoppedLoading(super::browser_protocol::page::EventFrameStoppedLoading),
        PageInterstitialHidden(super::browser_protocol::page::EventInterstitialHidden),
        PageInterstitialShown(super::browser_protocol::page::EventInterstitialShown),
        PageJavascriptDialogClosed(super::browser_protocol::page::EventJavascriptDialogClosed),
        PageJavascriptDialogOpening(super::browser_protocol::page::EventJavascriptDialogOpening),
        PageLifecycleEvent(super::browser_protocol::page::EventLifecycleEvent),
        PageBackForwardCacheNotUsed(super::browser_protocol::page::EventBackForwardCacheNotUsed),
        PagePrerenderAttemptCompleted(
            super::browser_protocol::page::EventPrerenderAttemptCompleted,
        ),
        PageLoadEventFired(super::browser_protocol::page::EventLoadEventFired),
        PageNavigatedWithinDocument(super::browser_protocol::page::EventNavigatedWithinDocument),
        PageScreencastFrame(super::browser_protocol::page::EventScreencastFrame),
        PageScreencastVisibilityChanged(
            super::browser_protocol::page::EventScreencastVisibilityChanged,
        ),
        PageWindowOpen(super::browser_protocol::page::EventWindowOpen),
        PageCompilationCacheProduced(super::browser_protocol::page::EventCompilationCacheProduced),
        PerformanceMetrics(super::browser_protocol::performance::EventMetrics),
        PerformanceTimelineTimelineEventAdded(
            Box<super::browser_protocol::performance_timeline::EventTimelineEventAdded>,
        ),
        SecurityVisibleSecurityStateChanged(
            Box<super::browser_protocol::security::EventVisibleSecurityStateChanged>,
        ),
        ServiceWorkerWorkerErrorReported(
            super::browser_protocol::service_worker::EventWorkerErrorReported,
        ),
        ServiceWorkerWorkerRegistrationUpdated(
            super::browser_protocol::service_worker::EventWorkerRegistrationUpdated,
        ),
        ServiceWorkerWorkerVersionUpdated(
            super::browser_protocol::service_worker::EventWorkerVersionUpdated,
        ),
        StorageCacheStorageContentUpdated(
            super::browser_protocol::storage::EventCacheStorageContentUpdated,
        ),
        StorageCacheStorageListUpdated(
            super::browser_protocol::storage::EventCacheStorageListUpdated,
        ),
        StorageIndexedDbContentUpdated(
            super::browser_protocol::storage::EventIndexedDbContentUpdated,
        ),
        StorageIndexedDbListUpdated(super::browser_protocol::storage::EventIndexedDbListUpdated),
        StorageInterestGroupAccessed(super::browser_protocol::storage::EventInterestGroupAccessed),
        TargetAttachedToTarget(super::browser_protocol::target::EventAttachedToTarget),
        TargetDetachedFromTarget(super::browser_protocol::target::EventDetachedFromTarget),
        TargetReceivedMessageFromTarget(
            super::browser_protocol::target::EventReceivedMessageFromTarget,
        ),
        TargetTargetCreated(super::browser_protocol::target::EventTargetCreated),
        TargetTargetDestroyed(super::browser_protocol::target::EventTargetDestroyed),
        TargetTargetCrashed(super::browser_protocol::target::EventTargetCrashed),
        TargetTargetInfoChanged(super::browser_protocol::target::EventTargetInfoChanged),
        TetheringAccepted(super::browser_protocol::tethering::EventAccepted),
        TracingBufferUsage(super::browser_protocol::tracing::EventBufferUsage),
        TracingDataCollected(super::browser_protocol::tracing::EventDataCollected),
        TracingTracingComplete(super::browser_protocol::tracing::EventTracingComplete),
        FetchRequestPaused(Box<super::browser_protocol::fetch::EventRequestPaused>),
        FetchAuthRequired(Box<super::browser_protocol::fetch::EventAuthRequired>),
        WebAudioContextCreated(super::browser_protocol::web_audio::EventContextCreated),
        WebAudioContextWillBeDestroyed(
            super::browser_protocol::web_audio::EventContextWillBeDestroyed,
        ),
        WebAudioContextChanged(super::browser_protocol::web_audio::EventContextChanged),
        WebAudioAudioListenerCreated(super::browser_protocol::web_audio::EventAudioListenerCreated),
        WebAudioAudioListenerWillBeDestroyed(
            super::browser_protocol::web_audio::EventAudioListenerWillBeDestroyed,
        ),
        WebAudioAudioNodeCreated(super::browser_protocol::web_audio::EventAudioNodeCreated),
        WebAudioAudioNodeWillBeDestroyed(
            super::browser_protocol::web_audio::EventAudioNodeWillBeDestroyed,
        ),
        WebAudioAudioParamCreated(super::browser_protocol::web_audio::EventAudioParamCreated),
        WebAudioAudioParamWillBeDestroyed(
            super::browser_protocol::web_audio::EventAudioParamWillBeDestroyed,
        ),
        WebAudioNodesConnected(super::browser_protocol::web_audio::EventNodesConnected),
        WebAudioNodesDisconnected(super::browser_protocol::web_audio::EventNodesDisconnected),
        WebAudioNodeParamConnected(super::browser_protocol::web_audio::EventNodeParamConnected),
        WebAudioNodeParamDisconnected(
            super::browser_protocol::web_audio::EventNodeParamDisconnected,
        ),
        MediaPlayerPropertiesChanged(super::browser_protocol::media::EventPlayerPropertiesChanged),
        MediaPlayerEventsAdded(super::browser_protocol::media::EventPlayerEventsAdded),
        MediaPlayerMessagesLogged(super::browser_protocol::media::EventPlayerMessagesLogged),
        MediaPlayerErrorsRaised(super::browser_protocol::media::EventPlayerErrorsRaised),
        MediaPlayersCreated(super::browser_protocol::media::EventPlayersCreated),
        Other(serde_json::Value),
    }
    impl CdpEvent {
        pub fn other(other: serde_json::Value) -> Self {
            CdpEvent::Other(other)
        }
        #[doc = r" Serializes the event as Json"]
        pub fn into_json(self) -> serde_json::Result<serde_json::Value> {
            match self {
                CdpEvent::DebuggerBreakpointResolved(inner) => serde_json::to_value(inner),
                CdpEvent::DebuggerPaused(inner) => serde_json::to_value(inner),
                CdpEvent::DebuggerResumed(inner) => serde_json::to_value(inner),
                CdpEvent::DebuggerScriptFailedToParse(inner) => serde_json::to_value(inner),
                CdpEvent::DebuggerScriptParsed(inner) => serde_json::to_value(inner),
                CdpEvent::HeapProfilerAddHeapSnapshotChunk(inner) => serde_json::to_value(inner),
                CdpEvent::HeapProfilerHeapStatsUpdate(inner) => serde_json::to_value(inner),
                CdpEvent::HeapProfilerLastSeenObjectId(inner) => serde_json::to_value(inner),
                CdpEvent::HeapProfilerReportHeapSnapshotProgress(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::HeapProfilerResetProfiles(inner) => serde_json::to_value(inner),
                CdpEvent::ProfilerConsoleProfileFinished(inner) => serde_json::to_value(inner),
                CdpEvent::ProfilerConsoleProfileStarted(inner) => serde_json::to_value(inner),
                CdpEvent::ProfilerPreciseCoverageDeltaUpdate(inner) => serde_json::to_value(inner),
                CdpEvent::RuntimeBindingCalled(inner) => serde_json::to_value(inner),
                CdpEvent::RuntimeConsoleApiCalled(inner) => serde_json::to_value(inner),
                CdpEvent::RuntimeExceptionRevoked(inner) => serde_json::to_value(inner),
                CdpEvent::RuntimeExceptionThrown(inner) => serde_json::to_value(inner),
                CdpEvent::RuntimeExecutionContextCreated(inner) => serde_json::to_value(inner),
                CdpEvent::RuntimeExecutionContextDestroyed(inner) => serde_json::to_value(inner),
                CdpEvent::RuntimeExecutionContextsCleared(inner) => serde_json::to_value(inner),
                CdpEvent::RuntimeInspectRequested(inner) => serde_json::to_value(inner),
                CdpEvent::AccessibilityLoadComplete(inner) => serde_json::to_value(inner),
                CdpEvent::AccessibilityNodesUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::AnimationAnimationCanceled(inner) => serde_json::to_value(inner),
                CdpEvent::AnimationAnimationCreated(inner) => serde_json::to_value(inner),
                CdpEvent::AnimationAnimationStarted(inner) => serde_json::to_value(inner),
                CdpEvent::AuditsIssueAdded(inner) => serde_json::to_value(inner),
                CdpEvent::BackgroundServiceRecordingStateChanged(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::BackgroundServiceBackgroundServiceEventReceived(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::BrowserDownloadWillBegin(inner) => serde_json::to_value(inner),
                CdpEvent::BrowserDownloadProgress(inner) => serde_json::to_value(inner),
                CdpEvent::CssFontsUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::CssMediaQueryResultChanged(inner) => serde_json::to_value(inner),
                CdpEvent::CssStyleSheetAdded(inner) => serde_json::to_value(inner),
                CdpEvent::CssStyleSheetChanged(inner) => serde_json::to_value(inner),
                CdpEvent::CssStyleSheetRemoved(inner) => serde_json::to_value(inner),
                CdpEvent::CastSinksUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::CastIssueUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::DomAttributeModified(inner) => serde_json::to_value(inner),
                CdpEvent::DomAttributeRemoved(inner) => serde_json::to_value(inner),
                CdpEvent::DomCharacterDataModified(inner) => serde_json::to_value(inner),
                CdpEvent::DomChildNodeCountUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::DomChildNodeInserted(inner) => serde_json::to_value(inner),
                CdpEvent::DomChildNodeRemoved(inner) => serde_json::to_value(inner),
                CdpEvent::DomDistributedNodesUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::DomDocumentUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::DomInlineStyleInvalidated(inner) => serde_json::to_value(inner),
                CdpEvent::DomPseudoElementAdded(inner) => serde_json::to_value(inner),
                CdpEvent::DomTopLayerElementsUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::DomPseudoElementRemoved(inner) => serde_json::to_value(inner),
                CdpEvent::DomSetChildNodes(inner) => serde_json::to_value(inner),
                CdpEvent::DomShadowRootPopped(inner) => serde_json::to_value(inner),
                CdpEvent::DomShadowRootPushed(inner) => serde_json::to_value(inner),
                CdpEvent::DomStorageDomStorageItemAdded(inner) => serde_json::to_value(inner),
                CdpEvent::DomStorageDomStorageItemRemoved(inner) => serde_json::to_value(inner),
                CdpEvent::DomStorageDomStorageItemUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::DomStorageDomStorageItemsCleared(inner) => serde_json::to_value(inner),
                CdpEvent::DatabaseAddDatabase(inner) => serde_json::to_value(inner),
                CdpEvent::EmulationVirtualTimeBudgetExpired(inner) => serde_json::to_value(inner),
                CdpEvent::InputDragIntercepted(inner) => serde_json::to_value(inner),
                CdpEvent::InspectorDetached(inner) => serde_json::to_value(inner),
                CdpEvent::InspectorTargetCrashed(inner) => serde_json::to_value(inner),
                CdpEvent::InspectorTargetReloadedAfterCrash(inner) => serde_json::to_value(inner),
                CdpEvent::LayerTreeLayerPainted(inner) => serde_json::to_value(inner),
                CdpEvent::LayerTreeLayerTreeDidChange(inner) => serde_json::to_value(inner),
                CdpEvent::LogEntryAdded(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkDataReceived(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkEventSourceMessageReceived(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkLoadingFailed(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkLoadingFinished(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkRequestServedFromCache(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkRequestWillBeSent(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkResourceChangedPriority(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkSignedExchangeReceived(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkResponseReceived(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkWebSocketClosed(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkWebSocketCreated(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkWebSocketFrameError(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkWebSocketFrameReceived(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkWebSocketFrameSent(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkWebSocketHandshakeResponseReceived(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::NetworkWebSocketWillSendHandshakeRequest(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::NetworkWebTransportCreated(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkWebTransportConnectionEstablished(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::NetworkWebTransportClosed(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkRequestWillBeSentExtraInfo(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkResponseReceivedExtraInfo(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkTrustTokenOperationDone(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkSubresourceWebBundleMetadataReceived(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::NetworkSubresourceWebBundleMetadataError(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::NetworkSubresourceWebBundleInnerResponseParsed(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::NetworkSubresourceWebBundleInnerResponseError(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::NetworkReportingApiReportAdded(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkReportingApiReportUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::NetworkReportingApiEndpointsChangedForOrigin(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::OverlayInspectNodeRequested(inner) => serde_json::to_value(inner),
                CdpEvent::OverlayNodeHighlightRequested(inner) => serde_json::to_value(inner),
                CdpEvent::OverlayScreenshotRequested(inner) => serde_json::to_value(inner),
                CdpEvent::OverlayInspectModeCanceled(inner) => serde_json::to_value(inner),
                CdpEvent::PageDomContentEventFired(inner) => serde_json::to_value(inner),
                CdpEvent::PageFileChooserOpened(inner) => serde_json::to_value(inner),
                CdpEvent::PageFrameAttached(inner) => serde_json::to_value(inner),
                CdpEvent::PageFrameDetached(inner) => serde_json::to_value(inner),
                CdpEvent::PageFrameNavigated(inner) => serde_json::to_value(inner),
                CdpEvent::PageDocumentOpened(inner) => serde_json::to_value(inner),
                CdpEvent::PageFrameResized(inner) => serde_json::to_value(inner),
                CdpEvent::PageFrameRequestedNavigation(inner) => serde_json::to_value(inner),
                CdpEvent::PageFrameStartedLoading(inner) => serde_json::to_value(inner),
                CdpEvent::PageFrameStoppedLoading(inner) => serde_json::to_value(inner),
                CdpEvent::PageInterstitialHidden(inner) => serde_json::to_value(inner),
                CdpEvent::PageInterstitialShown(inner) => serde_json::to_value(inner),
                CdpEvent::PageJavascriptDialogClosed(inner) => serde_json::to_value(inner),
                CdpEvent::PageJavascriptDialogOpening(inner) => serde_json::to_value(inner),
                CdpEvent::PageLifecycleEvent(inner) => serde_json::to_value(inner),
                CdpEvent::PageBackForwardCacheNotUsed(inner) => serde_json::to_value(inner),
                CdpEvent::PagePrerenderAttemptCompleted(inner) => serde_json::to_value(inner),
                CdpEvent::PageLoadEventFired(inner) => serde_json::to_value(inner),
                CdpEvent::PageNavigatedWithinDocument(inner) => serde_json::to_value(inner),
                CdpEvent::PageScreencastFrame(inner) => serde_json::to_value(inner),
                CdpEvent::PageScreencastVisibilityChanged(inner) => serde_json::to_value(inner),
                CdpEvent::PageWindowOpen(inner) => serde_json::to_value(inner),
                CdpEvent::PageCompilationCacheProduced(inner) => serde_json::to_value(inner),
                CdpEvent::PerformanceMetrics(inner) => serde_json::to_value(inner),
                CdpEvent::PerformanceTimelineTimelineEventAdded(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::SecurityVisibleSecurityStateChanged(inner) => serde_json::to_value(inner),
                CdpEvent::ServiceWorkerWorkerErrorReported(inner) => serde_json::to_value(inner),
                CdpEvent::ServiceWorkerWorkerRegistrationUpdated(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::ServiceWorkerWorkerVersionUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::StorageCacheStorageContentUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::StorageCacheStorageListUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::StorageIndexedDbContentUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::StorageIndexedDbListUpdated(inner) => serde_json::to_value(inner),
                CdpEvent::StorageInterestGroupAccessed(inner) => serde_json::to_value(inner),
                CdpEvent::TargetAttachedToTarget(inner) => serde_json::to_value(inner),
                CdpEvent::TargetDetachedFromTarget(inner) => serde_json::to_value(inner),
                CdpEvent::TargetReceivedMessageFromTarget(inner) => serde_json::to_value(inner),
                CdpEvent::TargetTargetCreated(inner) => serde_json::to_value(inner),
                CdpEvent::TargetTargetDestroyed(inner) => serde_json::to_value(inner),
                CdpEvent::TargetTargetCrashed(inner) => serde_json::to_value(inner),
                CdpEvent::TargetTargetInfoChanged(inner) => serde_json::to_value(inner),
                CdpEvent::TetheringAccepted(inner) => serde_json::to_value(inner),
                CdpEvent::TracingBufferUsage(inner) => serde_json::to_value(inner),
                CdpEvent::TracingDataCollected(inner) => serde_json::to_value(inner),
                CdpEvent::TracingTracingComplete(inner) => serde_json::to_value(inner),
                CdpEvent::FetchRequestPaused(inner) => serde_json::to_value(inner),
                CdpEvent::FetchAuthRequired(inner) => serde_json::to_value(inner),
                CdpEvent::WebAudioContextCreated(inner) => serde_json::to_value(inner),
                CdpEvent::WebAudioContextWillBeDestroyed(inner) => serde_json::to_value(inner),
                CdpEvent::WebAudioContextChanged(inner) => serde_json::to_value(inner),
                CdpEvent::WebAudioAudioListenerCreated(inner) => serde_json::to_value(inner),
                CdpEvent::WebAudioAudioListenerWillBeDestroyed(inner) => {
                    serde_json::to_value(inner)
                }
                CdpEvent::WebAudioAudioNodeCreated(inner) => serde_json::to_value(inner),
                CdpEvent::WebAudioAudioNodeWillBeDestroyed(inner) => serde_json::to_value(inner),
                CdpEvent::WebAudioAudioParamCreated(inner) => serde_json::to_value(inner),
                CdpEvent::WebAudioAudioParamWillBeDestroyed(inner) => serde_json::to_value(inner),
                CdpEvent::WebAudioNodesConnected(inner) => serde_json::to_value(inner),
                CdpEvent::WebAudioNodesDisconnected(inner) => serde_json::to_value(inner),
                CdpEvent::WebAudioNodeParamConnected(inner) => serde_json::to_value(inner),
                CdpEvent::WebAudioNodeParamDisconnected(inner) => serde_json::to_value(inner),
                CdpEvent::MediaPlayerPropertiesChanged(inner) => serde_json::to_value(inner),
                CdpEvent::MediaPlayerEventsAdded(inner) => serde_json::to_value(inner),
                CdpEvent::MediaPlayerMessagesLogged(inner) => serde_json::to_value(inner),
                CdpEvent::MediaPlayerErrorsRaised(inner) => serde_json::to_value(inner),
                CdpEvent::MediaPlayersCreated(inner) => serde_json::to_value(inner),
                CdpEvent::Other(val) => Ok(val),
            }
        }
        pub fn into_event(self) -> ::std::result::Result<Box<dyn super::Event>, serde_json::Value> {
            match self {
                CdpEvent::DebuggerBreakpointResolved(event) => Ok(Box::new(event)),
                CdpEvent::DebuggerPaused(event) => Ok(Box::new(event)),
                CdpEvent::DebuggerResumed(event) => Ok(Box::new(event)),
                CdpEvent::DebuggerScriptFailedToParse(event) => Ok(Box::new(*event)),
                CdpEvent::DebuggerScriptParsed(event) => Ok(Box::new(*event)),
                CdpEvent::HeapProfilerAddHeapSnapshotChunk(event) => Ok(Box::new(event)),
                CdpEvent::HeapProfilerHeapStatsUpdate(event) => Ok(Box::new(event)),
                CdpEvent::HeapProfilerLastSeenObjectId(event) => Ok(Box::new(event)),
                CdpEvent::HeapProfilerReportHeapSnapshotProgress(event) => Ok(Box::new(event)),
                CdpEvent::HeapProfilerResetProfiles(event) => Ok(Box::new(event)),
                CdpEvent::ProfilerConsoleProfileFinished(event) => Ok(Box::new(event)),
                CdpEvent::ProfilerConsoleProfileStarted(event) => Ok(Box::new(event)),
                CdpEvent::ProfilerPreciseCoverageDeltaUpdate(event) => Ok(Box::new(event)),
                CdpEvent::RuntimeBindingCalled(event) => Ok(Box::new(event)),
                CdpEvent::RuntimeConsoleApiCalled(event) => Ok(Box::new(event)),
                CdpEvent::RuntimeExceptionRevoked(event) => Ok(Box::new(event)),
                CdpEvent::RuntimeExceptionThrown(event) => Ok(Box::new(*event)),
                CdpEvent::RuntimeExecutionContextCreated(event) => Ok(Box::new(event)),
                CdpEvent::RuntimeExecutionContextDestroyed(event) => Ok(Box::new(event)),
                CdpEvent::RuntimeExecutionContextsCleared(event) => Ok(Box::new(event)),
                CdpEvent::RuntimeInspectRequested(event) => Ok(Box::new(*event)),
                CdpEvent::AccessibilityLoadComplete(event) => Ok(Box::new(*event)),
                CdpEvent::AccessibilityNodesUpdated(event) => Ok(Box::new(event)),
                CdpEvent::AnimationAnimationCanceled(event) => Ok(Box::new(event)),
                CdpEvent::AnimationAnimationCreated(event) => Ok(Box::new(event)),
                CdpEvent::AnimationAnimationStarted(event) => Ok(Box::new(*event)),
                CdpEvent::AuditsIssueAdded(event) => Ok(Box::new(*event)),
                CdpEvent::BackgroundServiceRecordingStateChanged(event) => Ok(Box::new(event)),
                CdpEvent::BackgroundServiceBackgroundServiceEventReceived(event) => {
                    Ok(Box::new(event))
                }
                CdpEvent::BrowserDownloadWillBegin(event) => Ok(Box::new(event)),
                CdpEvent::BrowserDownloadProgress(event) => Ok(Box::new(event)),
                CdpEvent::CssFontsUpdated(event) => Ok(Box::new(*event)),
                CdpEvent::CssMediaQueryResultChanged(event) => Ok(Box::new(event)),
                CdpEvent::CssStyleSheetAdded(event) => Ok(Box::new(event)),
                CdpEvent::CssStyleSheetChanged(event) => Ok(Box::new(event)),
                CdpEvent::CssStyleSheetRemoved(event) => Ok(Box::new(event)),
                CdpEvent::CastSinksUpdated(event) => Ok(Box::new(event)),
                CdpEvent::CastIssueUpdated(event) => Ok(Box::new(event)),
                CdpEvent::DomAttributeModified(event) => Ok(Box::new(event)),
                CdpEvent::DomAttributeRemoved(event) => Ok(Box::new(event)),
                CdpEvent::DomCharacterDataModified(event) => Ok(Box::new(event)),
                CdpEvent::DomChildNodeCountUpdated(event) => Ok(Box::new(event)),
                CdpEvent::DomChildNodeInserted(event) => Ok(Box::new(*event)),
                CdpEvent::DomChildNodeRemoved(event) => Ok(Box::new(event)),
                CdpEvent::DomDistributedNodesUpdated(event) => Ok(Box::new(event)),
                CdpEvent::DomDocumentUpdated(event) => Ok(Box::new(event)),
                CdpEvent::DomInlineStyleInvalidated(event) => Ok(Box::new(event)),
                CdpEvent::DomPseudoElementAdded(event) => Ok(Box::new(*event)),
                CdpEvent::DomTopLayerElementsUpdated(event) => Ok(Box::new(event)),
                CdpEvent::DomPseudoElementRemoved(event) => Ok(Box::new(event)),
                CdpEvent::DomSetChildNodes(event) => Ok(Box::new(event)),
                CdpEvent::DomShadowRootPopped(event) => Ok(Box::new(event)),
                CdpEvent::DomShadowRootPushed(event) => Ok(Box::new(*event)),
                CdpEvent::DomStorageDomStorageItemAdded(event) => Ok(Box::new(event)),
                CdpEvent::DomStorageDomStorageItemRemoved(event) => Ok(Box::new(event)),
                CdpEvent::DomStorageDomStorageItemUpdated(event) => Ok(Box::new(event)),
                CdpEvent::DomStorageDomStorageItemsCleared(event) => Ok(Box::new(event)),
                CdpEvent::DatabaseAddDatabase(event) => Ok(Box::new(event)),
                CdpEvent::EmulationVirtualTimeBudgetExpired(event) => Ok(Box::new(event)),
                CdpEvent::InputDragIntercepted(event) => Ok(Box::new(event)),
                CdpEvent::InspectorDetached(event) => Ok(Box::new(event)),
                CdpEvent::InspectorTargetCrashed(event) => Ok(Box::new(event)),
                CdpEvent::InspectorTargetReloadedAfterCrash(event) => Ok(Box::new(event)),
                CdpEvent::LayerTreeLayerPainted(event) => Ok(Box::new(event)),
                CdpEvent::LayerTreeLayerTreeDidChange(event) => Ok(Box::new(event)),
                CdpEvent::LogEntryAdded(event) => Ok(Box::new(*event)),
                CdpEvent::NetworkDataReceived(event) => Ok(Box::new(event)),
                CdpEvent::NetworkEventSourceMessageReceived(event) => Ok(Box::new(event)),
                CdpEvent::NetworkLoadingFailed(event) => Ok(Box::new(event)),
                CdpEvent::NetworkLoadingFinished(event) => Ok(Box::new(event)),
                CdpEvent::NetworkRequestServedFromCache(event) => Ok(Box::new(event)),
                CdpEvent::NetworkRequestWillBeSent(event) => Ok(Box::new(*event)),
                CdpEvent::NetworkResourceChangedPriority(event) => Ok(Box::new(event)),
                CdpEvent::NetworkSignedExchangeReceived(event) => Ok(Box::new(*event)),
                CdpEvent::NetworkResponseReceived(event) => Ok(Box::new(*event)),
                CdpEvent::NetworkWebSocketClosed(event) => Ok(Box::new(event)),
                CdpEvent::NetworkWebSocketCreated(event) => Ok(Box::new(*event)),
                CdpEvent::NetworkWebSocketFrameError(event) => Ok(Box::new(event)),
                CdpEvent::NetworkWebSocketFrameReceived(event) => Ok(Box::new(event)),
                CdpEvent::NetworkWebSocketFrameSent(event) => Ok(Box::new(event)),
                CdpEvent::NetworkWebSocketHandshakeResponseReceived(event) => Ok(Box::new(event)),
                CdpEvent::NetworkWebSocketWillSendHandshakeRequest(event) => Ok(Box::new(event)),
                CdpEvent::NetworkWebTransportCreated(event) => Ok(Box::new(*event)),
                CdpEvent::NetworkWebTransportConnectionEstablished(event) => Ok(Box::new(event)),
                CdpEvent::NetworkWebTransportClosed(event) => Ok(Box::new(event)),
                CdpEvent::NetworkRequestWillBeSentExtraInfo(event) => Ok(Box::new(event)),
                CdpEvent::NetworkResponseReceivedExtraInfo(event) => Ok(Box::new(event)),
                CdpEvent::NetworkTrustTokenOperationDone(event) => Ok(Box::new(event)),
                CdpEvent::NetworkSubresourceWebBundleMetadataReceived(event) => Ok(Box::new(event)),
                CdpEvent::NetworkSubresourceWebBundleMetadataError(event) => Ok(Box::new(event)),
                CdpEvent::NetworkSubresourceWebBundleInnerResponseParsed(event) => {
                    Ok(Box::new(event))
                }
                CdpEvent::NetworkSubresourceWebBundleInnerResponseError(event) => {
                    Ok(Box::new(event))
                }
                CdpEvent::NetworkReportingApiReportAdded(event) => Ok(Box::new(event)),
                CdpEvent::NetworkReportingApiReportUpdated(event) => Ok(Box::new(event)),
                CdpEvent::NetworkReportingApiEndpointsChangedForOrigin(event) => {
                    Ok(Box::new(event))
                }
                CdpEvent::OverlayInspectNodeRequested(event) => Ok(Box::new(event)),
                CdpEvent::OverlayNodeHighlightRequested(event) => Ok(Box::new(event)),
                CdpEvent::OverlayScreenshotRequested(event) => Ok(Box::new(event)),
                CdpEvent::OverlayInspectModeCanceled(event) => Ok(Box::new(event)),
                CdpEvent::PageDomContentEventFired(event) => Ok(Box::new(event)),
                CdpEvent::PageFileChooserOpened(event) => Ok(Box::new(event)),
                CdpEvent::PageFrameAttached(event) => Ok(Box::new(event)),
                CdpEvent::PageFrameDetached(event) => Ok(Box::new(event)),
                CdpEvent::PageFrameNavigated(event) => Ok(Box::new(*event)),
                CdpEvent::PageDocumentOpened(event) => Ok(Box::new(*event)),
                CdpEvent::PageFrameResized(event) => Ok(Box::new(event)),
                CdpEvent::PageFrameRequestedNavigation(event) => Ok(Box::new(event)),
                CdpEvent::PageFrameStartedLoading(event) => Ok(Box::new(event)),
                CdpEvent::PageFrameStoppedLoading(event) => Ok(Box::new(event)),
                CdpEvent::PageInterstitialHidden(event) => Ok(Box::new(event)),
                CdpEvent::PageInterstitialShown(event) => Ok(Box::new(event)),
                CdpEvent::PageJavascriptDialogClosed(event) => Ok(Box::new(event)),
                CdpEvent::PageJavascriptDialogOpening(event) => Ok(Box::new(event)),
                CdpEvent::PageLifecycleEvent(event) => Ok(Box::new(event)),
                CdpEvent::PageBackForwardCacheNotUsed(event) => Ok(Box::new(event)),
                CdpEvent::PagePrerenderAttemptCompleted(event) => Ok(Box::new(event)),
                CdpEvent::PageLoadEventFired(event) => Ok(Box::new(event)),
                CdpEvent::PageNavigatedWithinDocument(event) => Ok(Box::new(event)),
                CdpEvent::PageScreencastFrame(event) => Ok(Box::new(event)),
                CdpEvent::PageScreencastVisibilityChanged(event) => Ok(Box::new(event)),
                CdpEvent::PageWindowOpen(event) => Ok(Box::new(event)),
                CdpEvent::PageCompilationCacheProduced(event) => Ok(Box::new(event)),
                CdpEvent::PerformanceMetrics(event) => Ok(Box::new(event)),
                CdpEvent::PerformanceTimelineTimelineEventAdded(event) => Ok(Box::new(*event)),
                CdpEvent::SecurityVisibleSecurityStateChanged(event) => Ok(Box::new(*event)),
                CdpEvent::ServiceWorkerWorkerErrorReported(event) => Ok(Box::new(event)),
                CdpEvent::ServiceWorkerWorkerRegistrationUpdated(event) => Ok(Box::new(event)),
                CdpEvent::ServiceWorkerWorkerVersionUpdated(event) => Ok(Box::new(event)),
                CdpEvent::StorageCacheStorageContentUpdated(event) => Ok(Box::new(event)),
                CdpEvent::StorageCacheStorageListUpdated(event) => Ok(Box::new(event)),
                CdpEvent::StorageIndexedDbContentUpdated(event) => Ok(Box::new(event)),
                CdpEvent::StorageIndexedDbListUpdated(event) => Ok(Box::new(event)),
                CdpEvent::StorageInterestGroupAccessed(event) => Ok(Box::new(event)),
                CdpEvent::TargetAttachedToTarget(event) => Ok(Box::new(event)),
                CdpEvent::TargetDetachedFromTarget(event) => Ok(Box::new(event)),
                CdpEvent::TargetReceivedMessageFromTarget(event) => Ok(Box::new(event)),
                CdpEvent::TargetTargetCreated(event) => Ok(Box::new(event)),
                CdpEvent::TargetTargetDestroyed(event) => Ok(Box::new(event)),
                CdpEvent::TargetTargetCrashed(event) => Ok(Box::new(event)),
                CdpEvent::TargetTargetInfoChanged(event) => Ok(Box::new(event)),
                CdpEvent::TetheringAccepted(event) => Ok(Box::new(event)),
                CdpEvent::TracingBufferUsage(event) => Ok(Box::new(event)),
                CdpEvent::TracingDataCollected(event) => Ok(Box::new(event)),
                CdpEvent::TracingTracingComplete(event) => Ok(Box::new(event)),
                CdpEvent::FetchRequestPaused(event) => Ok(Box::new(*event)),
                CdpEvent::FetchAuthRequired(event) => Ok(Box::new(*event)),
                CdpEvent::WebAudioContextCreated(event) => Ok(Box::new(event)),
                CdpEvent::WebAudioContextWillBeDestroyed(event) => Ok(Box::new(event)),
                CdpEvent::WebAudioContextChanged(event) => Ok(Box::new(event)),
                CdpEvent::WebAudioAudioListenerCreated(event) => Ok(Box::new(event)),
                CdpEvent::WebAudioAudioListenerWillBeDestroyed(event) => Ok(Box::new(event)),
                CdpEvent::WebAudioAudioNodeCreated(event) => Ok(Box::new(event)),
                CdpEvent::WebAudioAudioNodeWillBeDestroyed(event) => Ok(Box::new(event)),
                CdpEvent::WebAudioAudioParamCreated(event) => Ok(Box::new(event)),
                CdpEvent::WebAudioAudioParamWillBeDestroyed(event) => Ok(Box::new(event)),
                CdpEvent::WebAudioNodesConnected(event) => Ok(Box::new(event)),
                CdpEvent::WebAudioNodesDisconnected(event) => Ok(Box::new(event)),
                CdpEvent::WebAudioNodeParamConnected(event) => Ok(Box::new(event)),
                CdpEvent::WebAudioNodeParamDisconnected(event) => Ok(Box::new(event)),
                CdpEvent::MediaPlayerPropertiesChanged(event) => Ok(Box::new(event)),
                CdpEvent::MediaPlayerEventsAdded(event) => Ok(Box::new(event)),
                CdpEvent::MediaPlayerMessagesLogged(event) => Ok(Box::new(event)),
                CdpEvent::MediaPlayerErrorsRaised(event) => Ok(Box::new(event)),
                CdpEvent::MediaPlayersCreated(event) => Ok(Box::new(event)),
                CdpEvent::Other(other) => Err(other),
            }
        }
    }
    use serde::de::{self, Deserializer, MapAccess, Visitor};
    use std::fmt;
    impl<'de> Deserialize<'de> for CdpEventMessage {
        fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
        where
            D: Deserializer<'de>,
        {
            enum Field {
                Method,
                Session,
                Params,
            }
            impl<'de> Deserialize<'de> for Field {
                fn deserialize<D>(deserializer: D) -> Result<Field, D::Error>
                where
                    D: Deserializer<'de>,
                {
                    struct FieldVisitor;
                    impl<'de> Visitor<'de> for FieldVisitor {
                        type Value = Field;
                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("`method` or `sessionId` or `params`")
                        }
                        fn visit_str<E>(self, value: &str) -> Result<Field, E>
                        where
                            E: de::Error,
                        {
                            match value {
                                "method" => Ok(Field::Method),
                                "sessionId" => Ok(Field::Session),
                                "params" => Ok(Field::Params),
                                _ => Err(de::Error::unknown_field(value, FIELDS)),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(FieldVisitor)
                }
            }
            struct MessageVisitor;
            impl<'de> Visitor<'de> for MessageVisitor {
                type Value = CdpEventMessage;
                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("struct CdpEventMessage")
                }
                fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
                where
                    A: MapAccess<'de>,
                {
                    let mut method = None;
                    let mut session_id = None;
                    let mut params = None;
                    while let Some(key) = map.next_key()? {
                        match key {
                            Field::Method => {
                                if method.is_some() {
                                    return Err(de::Error::duplicate_field("method"));
                                }
                                method = Some(map.next_value::<String>()?);
                            }
                            Field::Session => {
                                if session_id.is_some() {
                                    return Err(de::Error::duplicate_field("sessionId"));
                                }
                                session_id = Some(map.next_value::<String>()?);
                            }
                            Field::Params => {
                                if params.is_some() {
                                    return Err(de::Error::duplicate_field("params"));
                                }
                                params = Some (match method . as_ref () . ok_or_else (|| de :: Error :: missing_field ("params")) ? . as_str () { super :: js_protocol :: debugger :: EventBreakpointResolved :: IDENTIFIER => CdpEvent :: DebuggerBreakpointResolved (map . next_value :: < super :: js_protocol :: debugger :: EventBreakpointResolved > () ?) , super :: js_protocol :: debugger :: EventPaused :: IDENTIFIER => CdpEvent :: DebuggerPaused (map . next_value :: < super :: js_protocol :: debugger :: EventPaused > () ?) , super :: js_protocol :: debugger :: EventResumed :: IDENTIFIER => CdpEvent :: DebuggerResumed (map . next_value :: < super :: js_protocol :: debugger :: EventResumed > () ?) , super :: js_protocol :: debugger :: EventScriptFailedToParse :: IDENTIFIER => CdpEvent :: DebuggerScriptFailedToParse (Box :: new (map . next_value :: < super :: js_protocol :: debugger :: EventScriptFailedToParse > () ?)) , super :: js_protocol :: debugger :: EventScriptParsed :: IDENTIFIER => CdpEvent :: DebuggerScriptParsed (Box :: new (map . next_value :: < super :: js_protocol :: debugger :: EventScriptParsed > () ?)) , super :: js_protocol :: heap_profiler :: EventAddHeapSnapshotChunk :: IDENTIFIER => CdpEvent :: HeapProfilerAddHeapSnapshotChunk (map . next_value :: < super :: js_protocol :: heap_profiler :: EventAddHeapSnapshotChunk > () ?) , super :: js_protocol :: heap_profiler :: EventHeapStatsUpdate :: IDENTIFIER => CdpEvent :: HeapProfilerHeapStatsUpdate (map . next_value :: < super :: js_protocol :: heap_profiler :: EventHeapStatsUpdate > () ?) , super :: js_protocol :: heap_profiler :: EventLastSeenObjectId :: IDENTIFIER => CdpEvent :: HeapProfilerLastSeenObjectId (map . next_value :: < super :: js_protocol :: heap_profiler :: EventLastSeenObjectId > () ?) , super :: js_protocol :: heap_profiler :: EventReportHeapSnapshotProgress :: IDENTIFIER => CdpEvent :: HeapProfilerReportHeapSnapshotProgress (map . next_value :: < super :: js_protocol :: heap_profiler :: EventReportHeapSnapshotProgress > () ?) , super :: js_protocol :: heap_profiler :: EventResetProfiles :: IDENTIFIER => CdpEvent :: HeapProfilerResetProfiles (map . next_value :: < super :: js_protocol :: heap_profiler :: EventResetProfiles > () ?) , super :: js_protocol :: profiler :: EventConsoleProfileFinished :: IDENTIFIER => CdpEvent :: ProfilerConsoleProfileFinished (map . next_value :: < super :: js_protocol :: profiler :: EventConsoleProfileFinished > () ?) , super :: js_protocol :: profiler :: EventConsoleProfileStarted :: IDENTIFIER => CdpEvent :: ProfilerConsoleProfileStarted (map . next_value :: < super :: js_protocol :: profiler :: EventConsoleProfileStarted > () ?) , super :: js_protocol :: profiler :: EventPreciseCoverageDeltaUpdate :: IDENTIFIER => CdpEvent :: ProfilerPreciseCoverageDeltaUpdate (map . next_value :: < super :: js_protocol :: profiler :: EventPreciseCoverageDeltaUpdate > () ?) , super :: js_protocol :: runtime :: EventBindingCalled :: IDENTIFIER => CdpEvent :: RuntimeBindingCalled (map . next_value :: < super :: js_protocol :: runtime :: EventBindingCalled > () ?) , super :: js_protocol :: runtime :: EventConsoleApiCalled :: IDENTIFIER => CdpEvent :: RuntimeConsoleApiCalled (map . next_value :: < super :: js_protocol :: runtime :: EventConsoleApiCalled > () ?) , super :: js_protocol :: runtime :: EventExceptionRevoked :: IDENTIFIER => CdpEvent :: RuntimeExceptionRevoked (map . next_value :: < super :: js_protocol :: runtime :: EventExceptionRevoked > () ?) , super :: js_protocol :: runtime :: EventExceptionThrown :: IDENTIFIER => CdpEvent :: RuntimeExceptionThrown (Box :: new (map . next_value :: < super :: js_protocol :: runtime :: EventExceptionThrown > () ?)) , super :: js_protocol :: runtime :: EventExecutionContextCreated :: IDENTIFIER => CdpEvent :: RuntimeExecutionContextCreated (map . next_value :: < super :: js_protocol :: runtime :: EventExecutionContextCreated > () ?) , super :: js_protocol :: runtime :: EventExecutionContextDestroyed :: IDENTIFIER => CdpEvent :: RuntimeExecutionContextDestroyed (map . next_value :: < super :: js_protocol :: runtime :: EventExecutionContextDestroyed > () ?) , super :: js_protocol :: runtime :: EventExecutionContextsCleared :: IDENTIFIER => CdpEvent :: RuntimeExecutionContextsCleared (map . next_value :: < super :: js_protocol :: runtime :: EventExecutionContextsCleared > () ?) , super :: js_protocol :: runtime :: EventInspectRequested :: IDENTIFIER => CdpEvent :: RuntimeInspectRequested (Box :: new (map . next_value :: < super :: js_protocol :: runtime :: EventInspectRequested > () ?)) , super :: browser_protocol :: accessibility :: EventLoadComplete :: IDENTIFIER => CdpEvent :: AccessibilityLoadComplete (Box :: new (map . next_value :: < super :: browser_protocol :: accessibility :: EventLoadComplete > () ?)) , super :: browser_protocol :: accessibility :: EventNodesUpdated :: IDENTIFIER => CdpEvent :: AccessibilityNodesUpdated (map . next_value :: < super :: browser_protocol :: accessibility :: EventNodesUpdated > () ?) , super :: browser_protocol :: animation :: EventAnimationCanceled :: IDENTIFIER => CdpEvent :: AnimationAnimationCanceled (map . next_value :: < super :: browser_protocol :: animation :: EventAnimationCanceled > () ?) , super :: browser_protocol :: animation :: EventAnimationCreated :: IDENTIFIER => CdpEvent :: AnimationAnimationCreated (map . next_value :: < super :: browser_protocol :: animation :: EventAnimationCreated > () ?) , super :: browser_protocol :: animation :: EventAnimationStarted :: IDENTIFIER => CdpEvent :: AnimationAnimationStarted (Box :: new (map . next_value :: < super :: browser_protocol :: animation :: EventAnimationStarted > () ?)) , super :: browser_protocol :: audits :: EventIssueAdded :: IDENTIFIER => CdpEvent :: AuditsIssueAdded (Box :: new (map . next_value :: < super :: browser_protocol :: audits :: EventIssueAdded > () ?)) , super :: browser_protocol :: background_service :: EventRecordingStateChanged :: IDENTIFIER => CdpEvent :: BackgroundServiceRecordingStateChanged (map . next_value :: < super :: browser_protocol :: background_service :: EventRecordingStateChanged > () ?) , super :: browser_protocol :: background_service :: EventBackgroundServiceEventReceived :: IDENTIFIER => CdpEvent :: BackgroundServiceBackgroundServiceEventReceived (map . next_value :: < super :: browser_protocol :: background_service :: EventBackgroundServiceEventReceived > () ?) , super :: browser_protocol :: browser :: EventDownloadWillBegin :: IDENTIFIER => CdpEvent :: BrowserDownloadWillBegin (map . next_value :: < super :: browser_protocol :: browser :: EventDownloadWillBegin > () ?) , super :: browser_protocol :: browser :: EventDownloadProgress :: IDENTIFIER => CdpEvent :: BrowserDownloadProgress (map . next_value :: < super :: browser_protocol :: browser :: EventDownloadProgress > () ?) , super :: browser_protocol :: css :: EventFontsUpdated :: IDENTIFIER => CdpEvent :: CssFontsUpdated (Box :: new (map . next_value :: < super :: browser_protocol :: css :: EventFontsUpdated > () ?)) , super :: browser_protocol :: css :: EventMediaQueryResultChanged :: IDENTIFIER => CdpEvent :: CssMediaQueryResultChanged (map . next_value :: < super :: browser_protocol :: css :: EventMediaQueryResultChanged > () ?) , super :: browser_protocol :: css :: EventStyleSheetAdded :: IDENTIFIER => CdpEvent :: CssStyleSheetAdded (map . next_value :: < super :: browser_protocol :: css :: EventStyleSheetAdded > () ?) , super :: browser_protocol :: css :: EventStyleSheetChanged :: IDENTIFIER => CdpEvent :: CssStyleSheetChanged (map . next_value :: < super :: browser_protocol :: css :: EventStyleSheetChanged > () ?) , super :: browser_protocol :: css :: EventStyleSheetRemoved :: IDENTIFIER => CdpEvent :: CssStyleSheetRemoved (map . next_value :: < super :: browser_protocol :: css :: EventStyleSheetRemoved > () ?) , super :: browser_protocol :: cast :: EventSinksUpdated :: IDENTIFIER => CdpEvent :: CastSinksUpdated (map . next_value :: < super :: browser_protocol :: cast :: EventSinksUpdated > () ?) , super :: browser_protocol :: cast :: EventIssueUpdated :: IDENTIFIER => CdpEvent :: CastIssueUpdated (map . next_value :: < super :: browser_protocol :: cast :: EventIssueUpdated > () ?) , super :: browser_protocol :: dom :: EventAttributeModified :: IDENTIFIER => CdpEvent :: DomAttributeModified (map . next_value :: < super :: browser_protocol :: dom :: EventAttributeModified > () ?) , super :: browser_protocol :: dom :: EventAttributeRemoved :: IDENTIFIER => CdpEvent :: DomAttributeRemoved (map . next_value :: < super :: browser_protocol :: dom :: EventAttributeRemoved > () ?) , super :: browser_protocol :: dom :: EventCharacterDataModified :: IDENTIFIER => CdpEvent :: DomCharacterDataModified (map . next_value :: < super :: browser_protocol :: dom :: EventCharacterDataModified > () ?) , super :: browser_protocol :: dom :: EventChildNodeCountUpdated :: IDENTIFIER => CdpEvent :: DomChildNodeCountUpdated (map . next_value :: < super :: browser_protocol :: dom :: EventChildNodeCountUpdated > () ?) , super :: browser_protocol :: dom :: EventChildNodeInserted :: IDENTIFIER => CdpEvent :: DomChildNodeInserted (Box :: new (map . next_value :: < super :: browser_protocol :: dom :: EventChildNodeInserted > () ?)) , super :: browser_protocol :: dom :: EventChildNodeRemoved :: IDENTIFIER => CdpEvent :: DomChildNodeRemoved (map . next_value :: < super :: browser_protocol :: dom :: EventChildNodeRemoved > () ?) , super :: browser_protocol :: dom :: EventDistributedNodesUpdated :: IDENTIFIER => CdpEvent :: DomDistributedNodesUpdated (map . next_value :: < super :: browser_protocol :: dom :: EventDistributedNodesUpdated > () ?) , super :: browser_protocol :: dom :: EventDocumentUpdated :: IDENTIFIER => CdpEvent :: DomDocumentUpdated (map . next_value :: < super :: browser_protocol :: dom :: EventDocumentUpdated > () ?) , super :: browser_protocol :: dom :: EventInlineStyleInvalidated :: IDENTIFIER => CdpEvent :: DomInlineStyleInvalidated (map . next_value :: < super :: browser_protocol :: dom :: EventInlineStyleInvalidated > () ?) , super :: browser_protocol :: dom :: EventPseudoElementAdded :: IDENTIFIER => CdpEvent :: DomPseudoElementAdded (Box :: new (map . next_value :: < super :: browser_protocol :: dom :: EventPseudoElementAdded > () ?)) , super :: browser_protocol :: dom :: EventTopLayerElementsUpdated :: IDENTIFIER => CdpEvent :: DomTopLayerElementsUpdated (map . next_value :: < super :: browser_protocol :: dom :: EventTopLayerElementsUpdated > () ?) , super :: browser_protocol :: dom :: EventPseudoElementRemoved :: IDENTIFIER => CdpEvent :: DomPseudoElementRemoved (map . next_value :: < super :: browser_protocol :: dom :: EventPseudoElementRemoved > () ?) , super :: browser_protocol :: dom :: EventSetChildNodes :: IDENTIFIER => CdpEvent :: DomSetChildNodes (map . next_value :: < super :: browser_protocol :: dom :: EventSetChildNodes > () ?) , super :: browser_protocol :: dom :: EventShadowRootPopped :: IDENTIFIER => CdpEvent :: DomShadowRootPopped (map . next_value :: < super :: browser_protocol :: dom :: EventShadowRootPopped > () ?) , super :: browser_protocol :: dom :: EventShadowRootPushed :: IDENTIFIER => CdpEvent :: DomShadowRootPushed (Box :: new (map . next_value :: < super :: browser_protocol :: dom :: EventShadowRootPushed > () ?)) , super :: browser_protocol :: dom_storage :: EventDomStorageItemAdded :: IDENTIFIER => CdpEvent :: DomStorageDomStorageItemAdded (map . next_value :: < super :: browser_protocol :: dom_storage :: EventDomStorageItemAdded > () ?) , super :: browser_protocol :: dom_storage :: EventDomStorageItemRemoved :: IDENTIFIER => CdpEvent :: DomStorageDomStorageItemRemoved (map . next_value :: < super :: browser_protocol :: dom_storage :: EventDomStorageItemRemoved > () ?) , super :: browser_protocol :: dom_storage :: EventDomStorageItemUpdated :: IDENTIFIER => CdpEvent :: DomStorageDomStorageItemUpdated (map . next_value :: < super :: browser_protocol :: dom_storage :: EventDomStorageItemUpdated > () ?) , super :: browser_protocol :: dom_storage :: EventDomStorageItemsCleared :: IDENTIFIER => CdpEvent :: DomStorageDomStorageItemsCleared (map . next_value :: < super :: browser_protocol :: dom_storage :: EventDomStorageItemsCleared > () ?) , super :: browser_protocol :: database :: EventAddDatabase :: IDENTIFIER => CdpEvent :: DatabaseAddDatabase (map . next_value :: < super :: browser_protocol :: database :: EventAddDatabase > () ?) , super :: browser_protocol :: emulation :: EventVirtualTimeBudgetExpired :: IDENTIFIER => CdpEvent :: EmulationVirtualTimeBudgetExpired (map . next_value :: < super :: browser_protocol :: emulation :: EventVirtualTimeBudgetExpired > () ?) , super :: browser_protocol :: input :: EventDragIntercepted :: IDENTIFIER => CdpEvent :: InputDragIntercepted (map . next_value :: < super :: browser_protocol :: input :: EventDragIntercepted > () ?) , super :: browser_protocol :: inspector :: EventDetached :: IDENTIFIER => CdpEvent :: InspectorDetached (map . next_value :: < super :: browser_protocol :: inspector :: EventDetached > () ?) , super :: browser_protocol :: inspector :: EventTargetCrashed :: IDENTIFIER => CdpEvent :: InspectorTargetCrashed (map . next_value :: < super :: browser_protocol :: inspector :: EventTargetCrashed > () ?) , super :: browser_protocol :: inspector :: EventTargetReloadedAfterCrash :: IDENTIFIER => CdpEvent :: InspectorTargetReloadedAfterCrash (map . next_value :: < super :: browser_protocol :: inspector :: EventTargetReloadedAfterCrash > () ?) , super :: browser_protocol :: layer_tree :: EventLayerPainted :: IDENTIFIER => CdpEvent :: LayerTreeLayerPainted (map . next_value :: < super :: browser_protocol :: layer_tree :: EventLayerPainted > () ?) , super :: browser_protocol :: layer_tree :: EventLayerTreeDidChange :: IDENTIFIER => CdpEvent :: LayerTreeLayerTreeDidChange (map . next_value :: < super :: browser_protocol :: layer_tree :: EventLayerTreeDidChange > () ?) , super :: browser_protocol :: log :: EventEntryAdded :: IDENTIFIER => CdpEvent :: LogEntryAdded (Box :: new (map . next_value :: < super :: browser_protocol :: log :: EventEntryAdded > () ?)) , super :: browser_protocol :: network :: EventDataReceived :: IDENTIFIER => CdpEvent :: NetworkDataReceived (map . next_value :: < super :: browser_protocol :: network :: EventDataReceived > () ?) , super :: browser_protocol :: network :: EventEventSourceMessageReceived :: IDENTIFIER => CdpEvent :: NetworkEventSourceMessageReceived (map . next_value :: < super :: browser_protocol :: network :: EventEventSourceMessageReceived > () ?) , super :: browser_protocol :: network :: EventLoadingFailed :: IDENTIFIER => CdpEvent :: NetworkLoadingFailed (map . next_value :: < super :: browser_protocol :: network :: EventLoadingFailed > () ?) , super :: browser_protocol :: network :: EventLoadingFinished :: IDENTIFIER => CdpEvent :: NetworkLoadingFinished (map . next_value :: < super :: browser_protocol :: network :: EventLoadingFinished > () ?) , super :: browser_protocol :: network :: EventRequestServedFromCache :: IDENTIFIER => CdpEvent :: NetworkRequestServedFromCache (map . next_value :: < super :: browser_protocol :: network :: EventRequestServedFromCache > () ?) , super :: browser_protocol :: network :: EventRequestWillBeSent :: IDENTIFIER => CdpEvent :: NetworkRequestWillBeSent (Box :: new (map . next_value :: < super :: browser_protocol :: network :: EventRequestWillBeSent > () ?)) , super :: browser_protocol :: network :: EventResourceChangedPriority :: IDENTIFIER => CdpEvent :: NetworkResourceChangedPriority (map . next_value :: < super :: browser_protocol :: network :: EventResourceChangedPriority > () ?) , super :: browser_protocol :: network :: EventSignedExchangeReceived :: IDENTIFIER => CdpEvent :: NetworkSignedExchangeReceived (Box :: new (map . next_value :: < super :: browser_protocol :: network :: EventSignedExchangeReceived > () ?)) , super :: browser_protocol :: network :: EventResponseReceived :: IDENTIFIER => CdpEvent :: NetworkResponseReceived (Box :: new (map . next_value :: < super :: browser_protocol :: network :: EventResponseReceived > () ?)) , super :: browser_protocol :: network :: EventWebSocketClosed :: IDENTIFIER => CdpEvent :: NetworkWebSocketClosed (map . next_value :: < super :: browser_protocol :: network :: EventWebSocketClosed > () ?) , super :: browser_protocol :: network :: EventWebSocketCreated :: IDENTIFIER => CdpEvent :: NetworkWebSocketCreated (Box :: new (map . next_value :: < super :: browser_protocol :: network :: EventWebSocketCreated > () ?)) , super :: browser_protocol :: network :: EventWebSocketFrameError :: IDENTIFIER => CdpEvent :: NetworkWebSocketFrameError (map . next_value :: < super :: browser_protocol :: network :: EventWebSocketFrameError > () ?) , super :: browser_protocol :: network :: EventWebSocketFrameReceived :: IDENTIFIER => CdpEvent :: NetworkWebSocketFrameReceived (map . next_value :: < super :: browser_protocol :: network :: EventWebSocketFrameReceived > () ?) , super :: browser_protocol :: network :: EventWebSocketFrameSent :: IDENTIFIER => CdpEvent :: NetworkWebSocketFrameSent (map . next_value :: < super :: browser_protocol :: network :: EventWebSocketFrameSent > () ?) , super :: browser_protocol :: network :: EventWebSocketHandshakeResponseReceived :: IDENTIFIER => CdpEvent :: NetworkWebSocketHandshakeResponseReceived (map . next_value :: < super :: browser_protocol :: network :: EventWebSocketHandshakeResponseReceived > () ?) , super :: browser_protocol :: network :: EventWebSocketWillSendHandshakeRequest :: IDENTIFIER => CdpEvent :: NetworkWebSocketWillSendHandshakeRequest (map . next_value :: < super :: browser_protocol :: network :: EventWebSocketWillSendHandshakeRequest > () ?) , super :: browser_protocol :: network :: EventWebTransportCreated :: IDENTIFIER => CdpEvent :: NetworkWebTransportCreated (Box :: new (map . next_value :: < super :: browser_protocol :: network :: EventWebTransportCreated > () ?)) , super :: browser_protocol :: network :: EventWebTransportConnectionEstablished :: IDENTIFIER => CdpEvent :: NetworkWebTransportConnectionEstablished (map . next_value :: < super :: browser_protocol :: network :: EventWebTransportConnectionEstablished > () ?) , super :: browser_protocol :: network :: EventWebTransportClosed :: IDENTIFIER => CdpEvent :: NetworkWebTransportClosed (map . next_value :: < super :: browser_protocol :: network :: EventWebTransportClosed > () ?) , super :: browser_protocol :: network :: EventRequestWillBeSentExtraInfo :: IDENTIFIER => CdpEvent :: NetworkRequestWillBeSentExtraInfo (map . next_value :: < super :: browser_protocol :: network :: EventRequestWillBeSentExtraInfo > () ?) , super :: browser_protocol :: network :: EventResponseReceivedExtraInfo :: IDENTIFIER => CdpEvent :: NetworkResponseReceivedExtraInfo (map . next_value :: < super :: browser_protocol :: network :: EventResponseReceivedExtraInfo > () ?) , super :: browser_protocol :: network :: EventTrustTokenOperationDone :: IDENTIFIER => CdpEvent :: NetworkTrustTokenOperationDone (map . next_value :: < super :: browser_protocol :: network :: EventTrustTokenOperationDone > () ?) , super :: browser_protocol :: network :: EventSubresourceWebBundleMetadataReceived :: IDENTIFIER => CdpEvent :: NetworkSubresourceWebBundleMetadataReceived (map . next_value :: < super :: browser_protocol :: network :: EventSubresourceWebBundleMetadataReceived > () ?) , super :: browser_protocol :: network :: EventSubresourceWebBundleMetadataError :: IDENTIFIER => CdpEvent :: NetworkSubresourceWebBundleMetadataError (map . next_value :: < super :: browser_protocol :: network :: EventSubresourceWebBundleMetadataError > () ?) , super :: browser_protocol :: network :: EventSubresourceWebBundleInnerResponseParsed :: IDENTIFIER => CdpEvent :: NetworkSubresourceWebBundleInnerResponseParsed (map . next_value :: < super :: browser_protocol :: network :: EventSubresourceWebBundleInnerResponseParsed > () ?) , super :: browser_protocol :: network :: EventSubresourceWebBundleInnerResponseError :: IDENTIFIER => CdpEvent :: NetworkSubresourceWebBundleInnerResponseError (map . next_value :: < super :: browser_protocol :: network :: EventSubresourceWebBundleInnerResponseError > () ?) , super :: browser_protocol :: network :: EventReportingApiReportAdded :: IDENTIFIER => CdpEvent :: NetworkReportingApiReportAdded (map . next_value :: < super :: browser_protocol :: network :: EventReportingApiReportAdded > () ?) , super :: browser_protocol :: network :: EventReportingApiReportUpdated :: IDENTIFIER => CdpEvent :: NetworkReportingApiReportUpdated (map . next_value :: < super :: browser_protocol :: network :: EventReportingApiReportUpdated > () ?) , super :: browser_protocol :: network :: EventReportingApiEndpointsChangedForOrigin :: IDENTIFIER => CdpEvent :: NetworkReportingApiEndpointsChangedForOrigin (map . next_value :: < super :: browser_protocol :: network :: EventReportingApiEndpointsChangedForOrigin > () ?) , super :: browser_protocol :: overlay :: EventInspectNodeRequested :: IDENTIFIER => CdpEvent :: OverlayInspectNodeRequested (map . next_value :: < super :: browser_protocol :: overlay :: EventInspectNodeRequested > () ?) , super :: browser_protocol :: overlay :: EventNodeHighlightRequested :: IDENTIFIER => CdpEvent :: OverlayNodeHighlightRequested (map . next_value :: < super :: browser_protocol :: overlay :: EventNodeHighlightRequested > () ?) , super :: browser_protocol :: overlay :: EventScreenshotRequested :: IDENTIFIER => CdpEvent :: OverlayScreenshotRequested (map . next_value :: < super :: browser_protocol :: overlay :: EventScreenshotRequested > () ?) , super :: browser_protocol :: overlay :: EventInspectModeCanceled :: IDENTIFIER => CdpEvent :: OverlayInspectModeCanceled (map . next_value :: < super :: browser_protocol :: overlay :: EventInspectModeCanceled > () ?) , super :: browser_protocol :: page :: EventDomContentEventFired :: IDENTIFIER => CdpEvent :: PageDomContentEventFired (map . next_value :: < super :: browser_protocol :: page :: EventDomContentEventFired > () ?) , super :: browser_protocol :: page :: EventFileChooserOpened :: IDENTIFIER => CdpEvent :: PageFileChooserOpened (map . next_value :: < super :: browser_protocol :: page :: EventFileChooserOpened > () ?) , super :: browser_protocol :: page :: EventFrameAttached :: IDENTIFIER => CdpEvent :: PageFrameAttached (map . next_value :: < super :: browser_protocol :: page :: EventFrameAttached > () ?) , super :: browser_protocol :: page :: EventFrameDetached :: IDENTIFIER => CdpEvent :: PageFrameDetached (map . next_value :: < super :: browser_protocol :: page :: EventFrameDetached > () ?) , super :: browser_protocol :: page :: EventFrameNavigated :: IDENTIFIER => CdpEvent :: PageFrameNavigated (Box :: new (map . next_value :: < super :: browser_protocol :: page :: EventFrameNavigated > () ?)) , super :: browser_protocol :: page :: EventDocumentOpened :: IDENTIFIER => CdpEvent :: PageDocumentOpened (Box :: new (map . next_value :: < super :: browser_protocol :: page :: EventDocumentOpened > () ?)) , super :: browser_protocol :: page :: EventFrameResized :: IDENTIFIER => CdpEvent :: PageFrameResized (map . next_value :: < super :: browser_protocol :: page :: EventFrameResized > () ?) , super :: browser_protocol :: page :: EventFrameRequestedNavigation :: IDENTIFIER => CdpEvent :: PageFrameRequestedNavigation (map . next_value :: < super :: browser_protocol :: page :: EventFrameRequestedNavigation > () ?) , super :: browser_protocol :: page :: EventFrameStartedLoading :: IDENTIFIER => CdpEvent :: PageFrameStartedLoading (map . next_value :: < super :: browser_protocol :: page :: EventFrameStartedLoading > () ?) , super :: browser_protocol :: page :: EventFrameStoppedLoading :: IDENTIFIER => CdpEvent :: PageFrameStoppedLoading (map . next_value :: < super :: browser_protocol :: page :: EventFrameStoppedLoading > () ?) , super :: browser_protocol :: page :: EventInterstitialHidden :: IDENTIFIER => CdpEvent :: PageInterstitialHidden (map . next_value :: < super :: browser_protocol :: page :: EventInterstitialHidden > () ?) , super :: browser_protocol :: page :: EventInterstitialShown :: IDENTIFIER => CdpEvent :: PageInterstitialShown (map . next_value :: < super :: browser_protocol :: page :: EventInterstitialShown > () ?) , super :: browser_protocol :: page :: EventJavascriptDialogClosed :: IDENTIFIER => CdpEvent :: PageJavascriptDialogClosed (map . next_value :: < super :: browser_protocol :: page :: EventJavascriptDialogClosed > () ?) , super :: browser_protocol :: page :: EventJavascriptDialogOpening :: IDENTIFIER => CdpEvent :: PageJavascriptDialogOpening (map . next_value :: < super :: browser_protocol :: page :: EventJavascriptDialogOpening > () ?) , super :: browser_protocol :: page :: EventLifecycleEvent :: IDENTIFIER => CdpEvent :: PageLifecycleEvent (map . next_value :: < super :: browser_protocol :: page :: EventLifecycleEvent > () ?) , super :: browser_protocol :: page :: EventBackForwardCacheNotUsed :: IDENTIFIER => CdpEvent :: PageBackForwardCacheNotUsed (map . next_value :: < super :: browser_protocol :: page :: EventBackForwardCacheNotUsed > () ?) , super :: browser_protocol :: page :: EventPrerenderAttemptCompleted :: IDENTIFIER => CdpEvent :: PagePrerenderAttemptCompleted (map . next_value :: < super :: browser_protocol :: page :: EventPrerenderAttemptCompleted > () ?) , super :: browser_protocol :: page :: EventLoadEventFired :: IDENTIFIER => CdpEvent :: PageLoadEventFired (map . next_value :: < super :: browser_protocol :: page :: EventLoadEventFired > () ?) , super :: browser_protocol :: page :: EventNavigatedWithinDocument :: IDENTIFIER => CdpEvent :: PageNavigatedWithinDocument (map . next_value :: < super :: browser_protocol :: page :: EventNavigatedWithinDocument > () ?) , super :: browser_protocol :: page :: EventScreencastFrame :: IDENTIFIER => CdpEvent :: PageScreencastFrame (map . next_value :: < super :: browser_protocol :: page :: EventScreencastFrame > () ?) , super :: browser_protocol :: page :: EventScreencastVisibilityChanged :: IDENTIFIER => CdpEvent :: PageScreencastVisibilityChanged (map . next_value :: < super :: browser_protocol :: page :: EventScreencastVisibilityChanged > () ?) , super :: browser_protocol :: page :: EventWindowOpen :: IDENTIFIER => CdpEvent :: PageWindowOpen (map . next_value :: < super :: browser_protocol :: page :: EventWindowOpen > () ?) , super :: browser_protocol :: page :: EventCompilationCacheProduced :: IDENTIFIER => CdpEvent :: PageCompilationCacheProduced (map . next_value :: < super :: browser_protocol :: page :: EventCompilationCacheProduced > () ?) , super :: browser_protocol :: performance :: EventMetrics :: IDENTIFIER => CdpEvent :: PerformanceMetrics (map . next_value :: < super :: browser_protocol :: performance :: EventMetrics > () ?) , super :: browser_protocol :: performance_timeline :: EventTimelineEventAdded :: IDENTIFIER => CdpEvent :: PerformanceTimelineTimelineEventAdded (Box :: new (map . next_value :: < super :: browser_protocol :: performance_timeline :: EventTimelineEventAdded > () ?)) , super :: browser_protocol :: security :: EventVisibleSecurityStateChanged :: IDENTIFIER => CdpEvent :: SecurityVisibleSecurityStateChanged (Box :: new (map . next_value :: < super :: browser_protocol :: security :: EventVisibleSecurityStateChanged > () ?)) , super :: browser_protocol :: service_worker :: EventWorkerErrorReported :: IDENTIFIER => CdpEvent :: ServiceWorkerWorkerErrorReported (map . next_value :: < super :: browser_protocol :: service_worker :: EventWorkerErrorReported > () ?) , super :: browser_protocol :: service_worker :: EventWorkerRegistrationUpdated :: IDENTIFIER => CdpEvent :: ServiceWorkerWorkerRegistrationUpdated (map . next_value :: < super :: browser_protocol :: service_worker :: EventWorkerRegistrationUpdated > () ?) , super :: browser_protocol :: service_worker :: EventWorkerVersionUpdated :: IDENTIFIER => CdpEvent :: ServiceWorkerWorkerVersionUpdated (map . next_value :: < super :: browser_protocol :: service_worker :: EventWorkerVersionUpdated > () ?) , super :: browser_protocol :: storage :: EventCacheStorageContentUpdated :: IDENTIFIER => CdpEvent :: StorageCacheStorageContentUpdated (map . next_value :: < super :: browser_protocol :: storage :: EventCacheStorageContentUpdated > () ?) , super :: browser_protocol :: storage :: EventCacheStorageListUpdated :: IDENTIFIER => CdpEvent :: StorageCacheStorageListUpdated (map . next_value :: < super :: browser_protocol :: storage :: EventCacheStorageListUpdated > () ?) , super :: browser_protocol :: storage :: EventIndexedDbContentUpdated :: IDENTIFIER => CdpEvent :: StorageIndexedDbContentUpdated (map . next_value :: < super :: browser_protocol :: storage :: EventIndexedDbContentUpdated > () ?) , super :: browser_protocol :: storage :: EventIndexedDbListUpdated :: IDENTIFIER => CdpEvent :: StorageIndexedDbListUpdated (map . next_value :: < super :: browser_protocol :: storage :: EventIndexedDbListUpdated > () ?) , super :: browser_protocol :: storage :: EventInterestGroupAccessed :: IDENTIFIER => CdpEvent :: StorageInterestGroupAccessed (map . next_value :: < super :: browser_protocol :: storage :: EventInterestGroupAccessed > () ?) , super :: browser_protocol :: target :: EventAttachedToTarget :: IDENTIFIER => CdpEvent :: TargetAttachedToTarget (map . next_value :: < super :: browser_protocol :: target :: EventAttachedToTarget > () ?) , super :: browser_protocol :: target :: EventDetachedFromTarget :: IDENTIFIER => CdpEvent :: TargetDetachedFromTarget (map . next_value :: < super :: browser_protocol :: target :: EventDetachedFromTarget > () ?) , super :: browser_protocol :: target :: EventReceivedMessageFromTarget :: IDENTIFIER => CdpEvent :: TargetReceivedMessageFromTarget (map . next_value :: < super :: browser_protocol :: target :: EventReceivedMessageFromTarget > () ?) , super :: browser_protocol :: target :: EventTargetCreated :: IDENTIFIER => CdpEvent :: TargetTargetCreated (map . next_value :: < super :: browser_protocol :: target :: EventTargetCreated > () ?) , super :: browser_protocol :: target :: EventTargetDestroyed :: IDENTIFIER => CdpEvent :: TargetTargetDestroyed (map . next_value :: < super :: browser_protocol :: target :: EventTargetDestroyed > () ?) , super :: browser_protocol :: target :: EventTargetCrashed :: IDENTIFIER => CdpEvent :: TargetTargetCrashed (map . next_value :: < super :: browser_protocol :: target :: EventTargetCrashed > () ?) , super :: browser_protocol :: target :: EventTargetInfoChanged :: IDENTIFIER => CdpEvent :: TargetTargetInfoChanged (map . next_value :: < super :: browser_protocol :: target :: EventTargetInfoChanged > () ?) , super :: browser_protocol :: tethering :: EventAccepted :: IDENTIFIER => CdpEvent :: TetheringAccepted (map . next_value :: < super :: browser_protocol :: tethering :: EventAccepted > () ?) , super :: browser_protocol :: tracing :: EventBufferUsage :: IDENTIFIER => CdpEvent :: TracingBufferUsage (map . next_value :: < super :: browser_protocol :: tracing :: EventBufferUsage > () ?) , super :: browser_protocol :: tracing :: EventDataCollected :: IDENTIFIER => CdpEvent :: TracingDataCollected (map . next_value :: < super :: browser_protocol :: tracing :: EventDataCollected > () ?) , super :: browser_protocol :: tracing :: EventTracingComplete :: IDENTIFIER => CdpEvent :: TracingTracingComplete (map . next_value :: < super :: browser_protocol :: tracing :: EventTracingComplete > () ?) , super :: browser_protocol :: fetch :: EventRequestPaused :: IDENTIFIER => CdpEvent :: FetchRequestPaused (Box :: new (map . next_value :: < super :: browser_protocol :: fetch :: EventRequestPaused > () ?)) , super :: browser_protocol :: fetch :: EventAuthRequired :: IDENTIFIER => CdpEvent :: FetchAuthRequired (Box :: new (map . next_value :: < super :: browser_protocol :: fetch :: EventAuthRequired > () ?)) , super :: browser_protocol :: web_audio :: EventContextCreated :: IDENTIFIER => CdpEvent :: WebAudioContextCreated (map . next_value :: < super :: browser_protocol :: web_audio :: EventContextCreated > () ?) , super :: browser_protocol :: web_audio :: EventContextWillBeDestroyed :: IDENTIFIER => CdpEvent :: WebAudioContextWillBeDestroyed (map . next_value :: < super :: browser_protocol :: web_audio :: EventContextWillBeDestroyed > () ?) , super :: browser_protocol :: web_audio :: EventContextChanged :: IDENTIFIER => CdpEvent :: WebAudioContextChanged (map . next_value :: < super :: browser_protocol :: web_audio :: EventContextChanged > () ?) , super :: browser_protocol :: web_audio :: EventAudioListenerCreated :: IDENTIFIER => CdpEvent :: WebAudioAudioListenerCreated (map . next_value :: < super :: browser_protocol :: web_audio :: EventAudioListenerCreated > () ?) , super :: browser_protocol :: web_audio :: EventAudioListenerWillBeDestroyed :: IDENTIFIER => CdpEvent :: WebAudioAudioListenerWillBeDestroyed (map . next_value :: < super :: browser_protocol :: web_audio :: EventAudioListenerWillBeDestroyed > () ?) , super :: browser_protocol :: web_audio :: EventAudioNodeCreated :: IDENTIFIER => CdpEvent :: WebAudioAudioNodeCreated (map . next_value :: < super :: browser_protocol :: web_audio :: EventAudioNodeCreated > () ?) , super :: browser_protocol :: web_audio :: EventAudioNodeWillBeDestroyed :: IDENTIFIER => CdpEvent :: WebAudioAudioNodeWillBeDestroyed (map . next_value :: < super :: browser_protocol :: web_audio :: EventAudioNodeWillBeDestroyed > () ?) , super :: browser_protocol :: web_audio :: EventAudioParamCreated :: IDENTIFIER => CdpEvent :: WebAudioAudioParamCreated (map . next_value :: < super :: browser_protocol :: web_audio :: EventAudioParamCreated > () ?) , super :: browser_protocol :: web_audio :: EventAudioParamWillBeDestroyed :: IDENTIFIER => CdpEvent :: WebAudioAudioParamWillBeDestroyed (map . next_value :: < super :: browser_protocol :: web_audio :: EventAudioParamWillBeDestroyed > () ?) , super :: browser_protocol :: web_audio :: EventNodesConnected :: IDENTIFIER => CdpEvent :: WebAudioNodesConnected (map . next_value :: < super :: browser_protocol :: web_audio :: EventNodesConnected > () ?) , super :: browser_protocol :: web_audio :: EventNodesDisconnected :: IDENTIFIER => CdpEvent :: WebAudioNodesDisconnected (map . next_value :: < super :: browser_protocol :: web_audio :: EventNodesDisconnected > () ?) , super :: browser_protocol :: web_audio :: EventNodeParamConnected :: IDENTIFIER => CdpEvent :: WebAudioNodeParamConnected (map . next_value :: < super :: browser_protocol :: web_audio :: EventNodeParamConnected > () ?) , super :: browser_protocol :: web_audio :: EventNodeParamDisconnected :: IDENTIFIER => CdpEvent :: WebAudioNodeParamDisconnected (map . next_value :: < super :: browser_protocol :: web_audio :: EventNodeParamDisconnected > () ?) , super :: browser_protocol :: media :: EventPlayerPropertiesChanged :: IDENTIFIER => CdpEvent :: MediaPlayerPropertiesChanged (map . next_value :: < super :: browser_protocol :: media :: EventPlayerPropertiesChanged > () ?) , super :: browser_protocol :: media :: EventPlayerEventsAdded :: IDENTIFIER => CdpEvent :: MediaPlayerEventsAdded (map . next_value :: < super :: browser_protocol :: media :: EventPlayerEventsAdded > () ?) , super :: browser_protocol :: media :: EventPlayerMessagesLogged :: IDENTIFIER => CdpEvent :: MediaPlayerMessagesLogged (map . next_value :: < super :: browser_protocol :: media :: EventPlayerMessagesLogged > () ?) , super :: browser_protocol :: media :: EventPlayerErrorsRaised :: IDENTIFIER => CdpEvent :: MediaPlayerErrorsRaised (map . next_value :: < super :: browser_protocol :: media :: EventPlayerErrorsRaised > () ?) , super :: browser_protocol :: media :: EventPlayersCreated :: IDENTIFIER => CdpEvent :: MediaPlayersCreated (map . next_value :: < super :: browser_protocol :: media :: EventPlayersCreated > () ?) , _ => CdpEvent :: Other (map . next_value :: < serde_json :: Value > () ?) }) ;
                            }
                        }
                    }
                    let method = method.ok_or_else(|| de::Error::missing_field("method"))?;
                    let params = params.ok_or_else(|| de::Error::missing_field("params"))?;
                    Ok(CdpEventMessage {
                        method: ::std::borrow::Cow::Owned(method),
                        session_id,
                        params,
                    })
                }
            }
            const FIELDS: &[&str] = &["method", "sessionId", "params"];
            deserializer.deserialize_struct("CdpEventMessage", FIELDS, MessageVisitor)
        }
    }
    impl std::convert::TryInto<chromiumoxide_types::CdpJsonEventMessage> for CdpEventMessage {
        type Error = serde_json::Error;
        fn try_into(self) -> Result<chromiumoxide_types::CdpJsonEventMessage, Self::Error> {
            use chromiumoxide_types::Method;
            Ok(chromiumoxide_types::CdpJsonEventMessage {
                method: self.identifier(),
                session_id: self.session_id,
                params: self.params.into_json()?,
            })
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::debugger::EventBreakpointResolved {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DebuggerBreakpointResolved(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::debugger::EventBreakpointResolved> for CdpEvent {
        fn from(el: super::js_protocol::debugger::EventBreakpointResolved) -> CdpEvent {
            CdpEvent::DebuggerBreakpointResolved(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::debugger::EventPaused {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DebuggerPaused(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::debugger::EventPaused> for CdpEvent {
        fn from(el: super::js_protocol::debugger::EventPaused) -> CdpEvent {
            CdpEvent::DebuggerPaused(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::debugger::EventResumed {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DebuggerResumed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::debugger::EventResumed> for CdpEvent {
        fn from(el: super::js_protocol::debugger::EventResumed) -> CdpEvent {
            CdpEvent::DebuggerResumed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::debugger::EventScriptFailedToParse {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DebuggerScriptFailedToParse(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::debugger::EventScriptFailedToParse> for CdpEvent {
        fn from(el: super::js_protocol::debugger::EventScriptFailedToParse) -> CdpEvent {
            CdpEvent::DebuggerScriptFailedToParse(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::debugger::EventScriptParsed {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DebuggerScriptParsed(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::debugger::EventScriptParsed> for CdpEvent {
        fn from(el: super::js_protocol::debugger::EventScriptParsed) -> CdpEvent {
            CdpEvent::DebuggerScriptParsed(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::js_protocol::heap_profiler::EventAddHeapSnapshotChunk
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::HeapProfilerAddHeapSnapshotChunk(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::heap_profiler::EventAddHeapSnapshotChunk> for CdpEvent {
        fn from(el: super::js_protocol::heap_profiler::EventAddHeapSnapshotChunk) -> CdpEvent {
            CdpEvent::HeapProfilerAddHeapSnapshotChunk(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::heap_profiler::EventHeapStatsUpdate {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::HeapProfilerHeapStatsUpdate(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::heap_profiler::EventHeapStatsUpdate> for CdpEvent {
        fn from(el: super::js_protocol::heap_profiler::EventHeapStatsUpdate) -> CdpEvent {
            CdpEvent::HeapProfilerHeapStatsUpdate(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::heap_profiler::EventLastSeenObjectId {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::HeapProfilerLastSeenObjectId(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::heap_profiler::EventLastSeenObjectId> for CdpEvent {
        fn from(el: super::js_protocol::heap_profiler::EventLastSeenObjectId) -> CdpEvent {
            CdpEvent::HeapProfilerLastSeenObjectId(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::js_protocol::heap_profiler::EventReportHeapSnapshotProgress
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::HeapProfilerReportHeapSnapshotProgress(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::heap_profiler::EventReportHeapSnapshotProgress> for CdpEvent {
        fn from(
            el: super::js_protocol::heap_profiler::EventReportHeapSnapshotProgress,
        ) -> CdpEvent {
            CdpEvent::HeapProfilerReportHeapSnapshotProgress(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::heap_profiler::EventResetProfiles {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::HeapProfilerResetProfiles(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::heap_profiler::EventResetProfiles> for CdpEvent {
        fn from(el: super::js_protocol::heap_profiler::EventResetProfiles) -> CdpEvent {
            CdpEvent::HeapProfilerResetProfiles(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::profiler::EventConsoleProfileFinished {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::ProfilerConsoleProfileFinished(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::profiler::EventConsoleProfileFinished> for CdpEvent {
        fn from(el: super::js_protocol::profiler::EventConsoleProfileFinished) -> CdpEvent {
            CdpEvent::ProfilerConsoleProfileFinished(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::profiler::EventConsoleProfileStarted {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::ProfilerConsoleProfileStarted(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::profiler::EventConsoleProfileStarted> for CdpEvent {
        fn from(el: super::js_protocol::profiler::EventConsoleProfileStarted) -> CdpEvent {
            CdpEvent::ProfilerConsoleProfileStarted(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::js_protocol::profiler::EventPreciseCoverageDeltaUpdate
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::ProfilerPreciseCoverageDeltaUpdate(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::profiler::EventPreciseCoverageDeltaUpdate> for CdpEvent {
        fn from(el: super::js_protocol::profiler::EventPreciseCoverageDeltaUpdate) -> CdpEvent {
            CdpEvent::ProfilerPreciseCoverageDeltaUpdate(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::runtime::EventBindingCalled {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::RuntimeBindingCalled(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::runtime::EventBindingCalled> for CdpEvent {
        fn from(el: super::js_protocol::runtime::EventBindingCalled) -> CdpEvent {
            CdpEvent::RuntimeBindingCalled(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::runtime::EventConsoleApiCalled {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::RuntimeConsoleApiCalled(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::runtime::EventConsoleApiCalled> for CdpEvent {
        fn from(el: super::js_protocol::runtime::EventConsoleApiCalled) -> CdpEvent {
            CdpEvent::RuntimeConsoleApiCalled(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::runtime::EventExceptionRevoked {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::RuntimeExceptionRevoked(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::runtime::EventExceptionRevoked> for CdpEvent {
        fn from(el: super::js_protocol::runtime::EventExceptionRevoked) -> CdpEvent {
            CdpEvent::RuntimeExceptionRevoked(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::runtime::EventExceptionThrown {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::RuntimeExceptionThrown(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::runtime::EventExceptionThrown> for CdpEvent {
        fn from(el: super::js_protocol::runtime::EventExceptionThrown) -> CdpEvent {
            CdpEvent::RuntimeExceptionThrown(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::runtime::EventExecutionContextCreated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::RuntimeExecutionContextCreated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::runtime::EventExecutionContextCreated> for CdpEvent {
        fn from(el: super::js_protocol::runtime::EventExecutionContextCreated) -> CdpEvent {
            CdpEvent::RuntimeExecutionContextCreated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::js_protocol::runtime::EventExecutionContextDestroyed
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::RuntimeExecutionContextDestroyed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::runtime::EventExecutionContextDestroyed> for CdpEvent {
        fn from(el: super::js_protocol::runtime::EventExecutionContextDestroyed) -> CdpEvent {
            CdpEvent::RuntimeExecutionContextDestroyed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::js_protocol::runtime::EventExecutionContextsCleared
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::RuntimeExecutionContextsCleared(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::runtime::EventExecutionContextsCleared> for CdpEvent {
        fn from(el: super::js_protocol::runtime::EventExecutionContextsCleared) -> CdpEvent {
            CdpEvent::RuntimeExecutionContextsCleared(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::js_protocol::runtime::EventInspectRequested {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::RuntimeInspectRequested(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::js_protocol::runtime::EventInspectRequested> for CdpEvent {
        fn from(el: super::js_protocol::runtime::EventInspectRequested) -> CdpEvent {
            CdpEvent::RuntimeInspectRequested(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::accessibility::EventLoadComplete {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::AccessibilityLoadComplete(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::accessibility::EventLoadComplete> for CdpEvent {
        fn from(el: super::browser_protocol::accessibility::EventLoadComplete) -> CdpEvent {
            CdpEvent::AccessibilityLoadComplete(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::accessibility::EventNodesUpdated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::AccessibilityNodesUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::accessibility::EventNodesUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::accessibility::EventNodesUpdated) -> CdpEvent {
            CdpEvent::AccessibilityNodesUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::animation::EventAnimationCanceled
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::AnimationAnimationCanceled(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::animation::EventAnimationCanceled> for CdpEvent {
        fn from(el: super::browser_protocol::animation::EventAnimationCanceled) -> CdpEvent {
            CdpEvent::AnimationAnimationCanceled(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::animation::EventAnimationCreated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::AnimationAnimationCreated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::animation::EventAnimationCreated> for CdpEvent {
        fn from(el: super::browser_protocol::animation::EventAnimationCreated) -> CdpEvent {
            CdpEvent::AnimationAnimationCreated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::animation::EventAnimationStarted {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::AnimationAnimationStarted(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::animation::EventAnimationStarted> for CdpEvent {
        fn from(el: super::browser_protocol::animation::EventAnimationStarted) -> CdpEvent {
            CdpEvent::AnimationAnimationStarted(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::audits::EventIssueAdded {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::AuditsIssueAdded(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::audits::EventIssueAdded> for CdpEvent {
        fn from(el: super::browser_protocol::audits::EventIssueAdded) -> CdpEvent {
            CdpEvent::AuditsIssueAdded(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::background_service::EventRecordingStateChanged
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::BackgroundServiceRecordingStateChanged(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::background_service::EventRecordingStateChanged> for CdpEvent {
        fn from(
            el: super::browser_protocol::background_service::EventRecordingStateChanged,
        ) -> CdpEvent {
            CdpEvent::BackgroundServiceRecordingStateChanged(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::background_service::EventBackgroundServiceEventReceived
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::BackgroundServiceBackgroundServiceEventReceived(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::background_service::EventBackgroundServiceEventReceived>
        for CdpEvent
    {
        fn from(
            el: super::browser_protocol::background_service::EventBackgroundServiceEventReceived,
        ) -> CdpEvent {
            CdpEvent::BackgroundServiceBackgroundServiceEventReceived(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::browser::EventDownloadWillBegin {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::BrowserDownloadWillBegin(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::browser::EventDownloadWillBegin> for CdpEvent {
        fn from(el: super::browser_protocol::browser::EventDownloadWillBegin) -> CdpEvent {
            CdpEvent::BrowserDownloadWillBegin(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::browser::EventDownloadProgress {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::BrowserDownloadProgress(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::browser::EventDownloadProgress> for CdpEvent {
        fn from(el: super::browser_protocol::browser::EventDownloadProgress) -> CdpEvent {
            CdpEvent::BrowserDownloadProgress(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::css::EventFontsUpdated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::CssFontsUpdated(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::css::EventFontsUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::css::EventFontsUpdated) -> CdpEvent {
            CdpEvent::CssFontsUpdated(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::css::EventMediaQueryResultChanged
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::CssMediaQueryResultChanged(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::css::EventMediaQueryResultChanged> for CdpEvent {
        fn from(el: super::browser_protocol::css::EventMediaQueryResultChanged) -> CdpEvent {
            CdpEvent::CssMediaQueryResultChanged(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::css::EventStyleSheetAdded {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::CssStyleSheetAdded(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::css::EventStyleSheetAdded> for CdpEvent {
        fn from(el: super::browser_protocol::css::EventStyleSheetAdded) -> CdpEvent {
            CdpEvent::CssStyleSheetAdded(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::css::EventStyleSheetChanged {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::CssStyleSheetChanged(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::css::EventStyleSheetChanged> for CdpEvent {
        fn from(el: super::browser_protocol::css::EventStyleSheetChanged) -> CdpEvent {
            CdpEvent::CssStyleSheetChanged(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::css::EventStyleSheetRemoved {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::CssStyleSheetRemoved(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::css::EventStyleSheetRemoved> for CdpEvent {
        fn from(el: super::browser_protocol::css::EventStyleSheetRemoved) -> CdpEvent {
            CdpEvent::CssStyleSheetRemoved(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::cast::EventSinksUpdated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::CastSinksUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::cast::EventSinksUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::cast::EventSinksUpdated) -> CdpEvent {
            CdpEvent::CastSinksUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::cast::EventIssueUpdated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::CastIssueUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::cast::EventIssueUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::cast::EventIssueUpdated) -> CdpEvent {
            CdpEvent::CastIssueUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::dom::EventAttributeModified {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomAttributeModified(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventAttributeModified> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventAttributeModified) -> CdpEvent {
            CdpEvent::DomAttributeModified(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::dom::EventAttributeRemoved {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomAttributeRemoved(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventAttributeRemoved> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventAttributeRemoved) -> CdpEvent {
            CdpEvent::DomAttributeRemoved(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::dom::EventCharacterDataModified {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomCharacterDataModified(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventCharacterDataModified> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventCharacterDataModified) -> CdpEvent {
            CdpEvent::DomCharacterDataModified(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::dom::EventChildNodeCountUpdated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomChildNodeCountUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventChildNodeCountUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventChildNodeCountUpdated) -> CdpEvent {
            CdpEvent::DomChildNodeCountUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::dom::EventChildNodeInserted {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomChildNodeInserted(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventChildNodeInserted> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventChildNodeInserted) -> CdpEvent {
            CdpEvent::DomChildNodeInserted(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::dom::EventChildNodeRemoved {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomChildNodeRemoved(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventChildNodeRemoved> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventChildNodeRemoved) -> CdpEvent {
            CdpEvent::DomChildNodeRemoved(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::dom::EventDistributedNodesUpdated
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomDistributedNodesUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventDistributedNodesUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventDistributedNodesUpdated) -> CdpEvent {
            CdpEvent::DomDistributedNodesUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::dom::EventDocumentUpdated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomDocumentUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventDocumentUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventDocumentUpdated) -> CdpEvent {
            CdpEvent::DomDocumentUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::dom::EventInlineStyleInvalidated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomInlineStyleInvalidated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventInlineStyleInvalidated> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventInlineStyleInvalidated) -> CdpEvent {
            CdpEvent::DomInlineStyleInvalidated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::dom::EventPseudoElementAdded {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomPseudoElementAdded(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventPseudoElementAdded> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventPseudoElementAdded) -> CdpEvent {
            CdpEvent::DomPseudoElementAdded(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::dom::EventTopLayerElementsUpdated
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomTopLayerElementsUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventTopLayerElementsUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventTopLayerElementsUpdated) -> CdpEvent {
            CdpEvent::DomTopLayerElementsUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::dom::EventPseudoElementRemoved {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomPseudoElementRemoved(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventPseudoElementRemoved> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventPseudoElementRemoved) -> CdpEvent {
            CdpEvent::DomPseudoElementRemoved(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::dom::EventSetChildNodes {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomSetChildNodes(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventSetChildNodes> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventSetChildNodes) -> CdpEvent {
            CdpEvent::DomSetChildNodes(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::dom::EventShadowRootPopped {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomShadowRootPopped(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventShadowRootPopped> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventShadowRootPopped) -> CdpEvent {
            CdpEvent::DomShadowRootPopped(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::dom::EventShadowRootPushed {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomShadowRootPushed(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom::EventShadowRootPushed> for CdpEvent {
        fn from(el: super::browser_protocol::dom::EventShadowRootPushed) -> CdpEvent {
            CdpEvent::DomShadowRootPushed(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::dom_storage::EventDomStorageItemAdded
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomStorageDomStorageItemAdded(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom_storage::EventDomStorageItemAdded> for CdpEvent {
        fn from(el: super::browser_protocol::dom_storage::EventDomStorageItemAdded) -> CdpEvent {
            CdpEvent::DomStorageDomStorageItemAdded(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::dom_storage::EventDomStorageItemRemoved
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomStorageDomStorageItemRemoved(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom_storage::EventDomStorageItemRemoved> for CdpEvent {
        fn from(el: super::browser_protocol::dom_storage::EventDomStorageItemRemoved) -> CdpEvent {
            CdpEvent::DomStorageDomStorageItemRemoved(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::dom_storage::EventDomStorageItemUpdated
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomStorageDomStorageItemUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom_storage::EventDomStorageItemUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::dom_storage::EventDomStorageItemUpdated) -> CdpEvent {
            CdpEvent::DomStorageDomStorageItemUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::dom_storage::EventDomStorageItemsCleared
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DomStorageDomStorageItemsCleared(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::dom_storage::EventDomStorageItemsCleared> for CdpEvent {
        fn from(el: super::browser_protocol::dom_storage::EventDomStorageItemsCleared) -> CdpEvent {
            CdpEvent::DomStorageDomStorageItemsCleared(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::database::EventAddDatabase {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::DatabaseAddDatabase(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::database::EventAddDatabase> for CdpEvent {
        fn from(el: super::browser_protocol::database::EventAddDatabase) -> CdpEvent {
            CdpEvent::DatabaseAddDatabase(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::emulation::EventVirtualTimeBudgetExpired
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::EmulationVirtualTimeBudgetExpired(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::emulation::EventVirtualTimeBudgetExpired> for CdpEvent {
        fn from(el: super::browser_protocol::emulation::EventVirtualTimeBudgetExpired) -> CdpEvent {
            CdpEvent::EmulationVirtualTimeBudgetExpired(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::input::EventDragIntercepted {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::InputDragIntercepted(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::input::EventDragIntercepted> for CdpEvent {
        fn from(el: super::browser_protocol::input::EventDragIntercepted) -> CdpEvent {
            CdpEvent::InputDragIntercepted(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::inspector::EventDetached {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::InspectorDetached(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::inspector::EventDetached> for CdpEvent {
        fn from(el: super::browser_protocol::inspector::EventDetached) -> CdpEvent {
            CdpEvent::InspectorDetached(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::inspector::EventTargetCrashed {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::InspectorTargetCrashed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::inspector::EventTargetCrashed> for CdpEvent {
        fn from(el: super::browser_protocol::inspector::EventTargetCrashed) -> CdpEvent {
            CdpEvent::InspectorTargetCrashed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::inspector::EventTargetReloadedAfterCrash
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::InspectorTargetReloadedAfterCrash(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::inspector::EventTargetReloadedAfterCrash> for CdpEvent {
        fn from(el: super::browser_protocol::inspector::EventTargetReloadedAfterCrash) -> CdpEvent {
            CdpEvent::InspectorTargetReloadedAfterCrash(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::layer_tree::EventLayerPainted {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::LayerTreeLayerPainted(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::layer_tree::EventLayerPainted> for CdpEvent {
        fn from(el: super::browser_protocol::layer_tree::EventLayerPainted) -> CdpEvent {
            CdpEvent::LayerTreeLayerPainted(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::layer_tree::EventLayerTreeDidChange
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::LayerTreeLayerTreeDidChange(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::layer_tree::EventLayerTreeDidChange> for CdpEvent {
        fn from(el: super::browser_protocol::layer_tree::EventLayerTreeDidChange) -> CdpEvent {
            CdpEvent::LayerTreeLayerTreeDidChange(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::log::EventEntryAdded {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::LogEntryAdded(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::log::EventEntryAdded> for CdpEvent {
        fn from(el: super::browser_protocol::log::EventEntryAdded) -> CdpEvent {
            CdpEvent::LogEntryAdded(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::network::EventDataReceived {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkDataReceived(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventDataReceived> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventDataReceived) -> CdpEvent {
            CdpEvent::NetworkDataReceived(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventEventSourceMessageReceived
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkEventSourceMessageReceived(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventEventSourceMessageReceived> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventEventSourceMessageReceived) -> CdpEvent {
            CdpEvent::NetworkEventSourceMessageReceived(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::network::EventLoadingFailed {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkLoadingFailed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventLoadingFailed> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventLoadingFailed) -> CdpEvent {
            CdpEvent::NetworkLoadingFailed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::network::EventLoadingFinished {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkLoadingFinished(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventLoadingFinished> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventLoadingFinished) -> CdpEvent {
            CdpEvent::NetworkLoadingFinished(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventRequestServedFromCache
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkRequestServedFromCache(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventRequestServedFromCache> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventRequestServedFromCache) -> CdpEvent {
            CdpEvent::NetworkRequestServedFromCache(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::network::EventRequestWillBeSent {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkRequestWillBeSent(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventRequestWillBeSent> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventRequestWillBeSent) -> CdpEvent {
            CdpEvent::NetworkRequestWillBeSent(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventResourceChangedPriority
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkResourceChangedPriority(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventResourceChangedPriority> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventResourceChangedPriority) -> CdpEvent {
            CdpEvent::NetworkResourceChangedPriority(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventSignedExchangeReceived
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkSignedExchangeReceived(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventSignedExchangeReceived> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventSignedExchangeReceived) -> CdpEvent {
            CdpEvent::NetworkSignedExchangeReceived(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::network::EventResponseReceived {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkResponseReceived(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventResponseReceived> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventResponseReceived) -> CdpEvent {
            CdpEvent::NetworkResponseReceived(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::network::EventWebSocketClosed {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkWebSocketClosed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventWebSocketClosed> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventWebSocketClosed) -> CdpEvent {
            CdpEvent::NetworkWebSocketClosed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::network::EventWebSocketCreated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkWebSocketCreated(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventWebSocketCreated> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventWebSocketCreated) -> CdpEvent {
            CdpEvent::NetworkWebSocketCreated(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventWebSocketFrameError
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkWebSocketFrameError(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventWebSocketFrameError> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventWebSocketFrameError) -> CdpEvent {
            CdpEvent::NetworkWebSocketFrameError(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventWebSocketFrameReceived
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkWebSocketFrameReceived(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventWebSocketFrameReceived> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventWebSocketFrameReceived) -> CdpEvent {
            CdpEvent::NetworkWebSocketFrameReceived(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::network::EventWebSocketFrameSent {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkWebSocketFrameSent(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventWebSocketFrameSent> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventWebSocketFrameSent) -> CdpEvent {
            CdpEvent::NetworkWebSocketFrameSent(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventWebSocketHandshakeResponseReceived
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkWebSocketHandshakeResponseReceived(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventWebSocketHandshakeResponseReceived> for CdpEvent {
        fn from(
            el: super::browser_protocol::network::EventWebSocketHandshakeResponseReceived,
        ) -> CdpEvent {
            CdpEvent::NetworkWebSocketHandshakeResponseReceived(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventWebSocketWillSendHandshakeRequest
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkWebSocketWillSendHandshakeRequest(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventWebSocketWillSendHandshakeRequest> for CdpEvent {
        fn from(
            el: super::browser_protocol::network::EventWebSocketWillSendHandshakeRequest,
        ) -> CdpEvent {
            CdpEvent::NetworkWebSocketWillSendHandshakeRequest(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventWebTransportCreated
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkWebTransportCreated(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventWebTransportCreated> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventWebTransportCreated) -> CdpEvent {
            CdpEvent::NetworkWebTransportCreated(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventWebTransportConnectionEstablished
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkWebTransportConnectionEstablished(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventWebTransportConnectionEstablished> for CdpEvent {
        fn from(
            el: super::browser_protocol::network::EventWebTransportConnectionEstablished,
        ) -> CdpEvent {
            CdpEvent::NetworkWebTransportConnectionEstablished(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::network::EventWebTransportClosed {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkWebTransportClosed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventWebTransportClosed> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventWebTransportClosed) -> CdpEvent {
            CdpEvent::NetworkWebTransportClosed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventRequestWillBeSentExtraInfo
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkRequestWillBeSentExtraInfo(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventRequestWillBeSentExtraInfo> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventRequestWillBeSentExtraInfo) -> CdpEvent {
            CdpEvent::NetworkRequestWillBeSentExtraInfo(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventResponseReceivedExtraInfo
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkResponseReceivedExtraInfo(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventResponseReceivedExtraInfo> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventResponseReceivedExtraInfo) -> CdpEvent {
            CdpEvent::NetworkResponseReceivedExtraInfo(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventTrustTokenOperationDone
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkTrustTokenOperationDone(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventTrustTokenOperationDone> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventTrustTokenOperationDone) -> CdpEvent {
            CdpEvent::NetworkTrustTokenOperationDone(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventSubresourceWebBundleMetadataReceived
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkSubresourceWebBundleMetadataReceived(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventSubresourceWebBundleMetadataReceived>
        for CdpEvent
    {
        fn from(
            el: super::browser_protocol::network::EventSubresourceWebBundleMetadataReceived,
        ) -> CdpEvent {
            CdpEvent::NetworkSubresourceWebBundleMetadataReceived(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventSubresourceWebBundleMetadataError
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkSubresourceWebBundleMetadataError(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventSubresourceWebBundleMetadataError> for CdpEvent {
        fn from(
            el: super::browser_protocol::network::EventSubresourceWebBundleMetadataError,
        ) -> CdpEvent {
            CdpEvent::NetworkSubresourceWebBundleMetadataError(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventSubresourceWebBundleInnerResponseParsed
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkSubresourceWebBundleInnerResponseParsed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventSubresourceWebBundleInnerResponseParsed>
        for CdpEvent
    {
        fn from(
            el: super::browser_protocol::network::EventSubresourceWebBundleInnerResponseParsed,
        ) -> CdpEvent {
            CdpEvent::NetworkSubresourceWebBundleInnerResponseParsed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventSubresourceWebBundleInnerResponseError
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkSubresourceWebBundleInnerResponseError(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventSubresourceWebBundleInnerResponseError>
        for CdpEvent
    {
        fn from(
            el: super::browser_protocol::network::EventSubresourceWebBundleInnerResponseError,
        ) -> CdpEvent {
            CdpEvent::NetworkSubresourceWebBundleInnerResponseError(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventReportingApiReportAdded
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkReportingApiReportAdded(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventReportingApiReportAdded> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventReportingApiReportAdded) -> CdpEvent {
            CdpEvent::NetworkReportingApiReportAdded(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventReportingApiReportUpdated
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkReportingApiReportUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventReportingApiReportUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::network::EventReportingApiReportUpdated) -> CdpEvent {
            CdpEvent::NetworkReportingApiReportUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::network::EventReportingApiEndpointsChangedForOrigin
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::NetworkReportingApiEndpointsChangedForOrigin(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::network::EventReportingApiEndpointsChangedForOrigin>
        for CdpEvent
    {
        fn from(
            el: super::browser_protocol::network::EventReportingApiEndpointsChangedForOrigin,
        ) -> CdpEvent {
            CdpEvent::NetworkReportingApiEndpointsChangedForOrigin(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::overlay::EventInspectNodeRequested
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::OverlayInspectNodeRequested(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::overlay::EventInspectNodeRequested> for CdpEvent {
        fn from(el: super::browser_protocol::overlay::EventInspectNodeRequested) -> CdpEvent {
            CdpEvent::OverlayInspectNodeRequested(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::overlay::EventNodeHighlightRequested
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::OverlayNodeHighlightRequested(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::overlay::EventNodeHighlightRequested> for CdpEvent {
        fn from(el: super::browser_protocol::overlay::EventNodeHighlightRequested) -> CdpEvent {
            CdpEvent::OverlayNodeHighlightRequested(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::overlay::EventScreenshotRequested
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::OverlayScreenshotRequested(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::overlay::EventScreenshotRequested> for CdpEvent {
        fn from(el: super::browser_protocol::overlay::EventScreenshotRequested) -> CdpEvent {
            CdpEvent::OverlayScreenshotRequested(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::overlay::EventInspectModeCanceled
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::OverlayInspectModeCanceled(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::overlay::EventInspectModeCanceled> for CdpEvent {
        fn from(el: super::browser_protocol::overlay::EventInspectModeCanceled) -> CdpEvent {
            CdpEvent::OverlayInspectModeCanceled(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventDomContentEventFired {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageDomContentEventFired(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventDomContentEventFired> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventDomContentEventFired) -> CdpEvent {
            CdpEvent::PageDomContentEventFired(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventFileChooserOpened {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageFileChooserOpened(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventFileChooserOpened> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventFileChooserOpened) -> CdpEvent {
            CdpEvent::PageFileChooserOpened(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventFrameAttached {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageFrameAttached(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventFrameAttached> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventFrameAttached) -> CdpEvent {
            CdpEvent::PageFrameAttached(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventFrameDetached {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageFrameDetached(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventFrameDetached> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventFrameDetached) -> CdpEvent {
            CdpEvent::PageFrameDetached(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventFrameNavigated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageFrameNavigated(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventFrameNavigated> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventFrameNavigated) -> CdpEvent {
            CdpEvent::PageFrameNavigated(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventDocumentOpened {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageDocumentOpened(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventDocumentOpened> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventDocumentOpened) -> CdpEvent {
            CdpEvent::PageDocumentOpened(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventFrameResized {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageFrameResized(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventFrameResized> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventFrameResized) -> CdpEvent {
            CdpEvent::PageFrameResized(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::page::EventFrameRequestedNavigation
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageFrameRequestedNavigation(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventFrameRequestedNavigation> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventFrameRequestedNavigation) -> CdpEvent {
            CdpEvent::PageFrameRequestedNavigation(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventFrameStartedLoading {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageFrameStartedLoading(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventFrameStartedLoading> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventFrameStartedLoading) -> CdpEvent {
            CdpEvent::PageFrameStartedLoading(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventFrameStoppedLoading {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageFrameStoppedLoading(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventFrameStoppedLoading> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventFrameStoppedLoading) -> CdpEvent {
            CdpEvent::PageFrameStoppedLoading(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventInterstitialHidden {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageInterstitialHidden(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventInterstitialHidden> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventInterstitialHidden) -> CdpEvent {
            CdpEvent::PageInterstitialHidden(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventInterstitialShown {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageInterstitialShown(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventInterstitialShown> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventInterstitialShown) -> CdpEvent {
            CdpEvent::PageInterstitialShown(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::page::EventJavascriptDialogClosed
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageJavascriptDialogClosed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventJavascriptDialogClosed> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventJavascriptDialogClosed) -> CdpEvent {
            CdpEvent::PageJavascriptDialogClosed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::page::EventJavascriptDialogOpening
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageJavascriptDialogOpening(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventJavascriptDialogOpening> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventJavascriptDialogOpening) -> CdpEvent {
            CdpEvent::PageJavascriptDialogOpening(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventLifecycleEvent {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageLifecycleEvent(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventLifecycleEvent> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventLifecycleEvent) -> CdpEvent {
            CdpEvent::PageLifecycleEvent(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::page::EventBackForwardCacheNotUsed
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageBackForwardCacheNotUsed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventBackForwardCacheNotUsed> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventBackForwardCacheNotUsed) -> CdpEvent {
            CdpEvent::PageBackForwardCacheNotUsed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::page::EventPrerenderAttemptCompleted
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PagePrerenderAttemptCompleted(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventPrerenderAttemptCompleted> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventPrerenderAttemptCompleted) -> CdpEvent {
            CdpEvent::PagePrerenderAttemptCompleted(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventLoadEventFired {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageLoadEventFired(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventLoadEventFired> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventLoadEventFired) -> CdpEvent {
            CdpEvent::PageLoadEventFired(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::page::EventNavigatedWithinDocument
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageNavigatedWithinDocument(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventNavigatedWithinDocument> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventNavigatedWithinDocument) -> CdpEvent {
            CdpEvent::PageNavigatedWithinDocument(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventScreencastFrame {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageScreencastFrame(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventScreencastFrame> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventScreencastFrame) -> CdpEvent {
            CdpEvent::PageScreencastFrame(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::page::EventScreencastVisibilityChanged
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageScreencastVisibilityChanged(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventScreencastVisibilityChanged> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventScreencastVisibilityChanged) -> CdpEvent {
            CdpEvent::PageScreencastVisibilityChanged(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::page::EventWindowOpen {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageWindowOpen(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventWindowOpen> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventWindowOpen) -> CdpEvent {
            CdpEvent::PageWindowOpen(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::page::EventCompilationCacheProduced
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PageCompilationCacheProduced(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::page::EventCompilationCacheProduced> for CdpEvent {
        fn from(el: super::browser_protocol::page::EventCompilationCacheProduced) -> CdpEvent {
            CdpEvent::PageCompilationCacheProduced(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::performance::EventMetrics {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PerformanceMetrics(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::performance::EventMetrics> for CdpEvent {
        fn from(el: super::browser_protocol::performance::EventMetrics) -> CdpEvent {
            CdpEvent::PerformanceMetrics(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::performance_timeline::EventTimelineEventAdded
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::PerformanceTimelineTimelineEventAdded(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::performance_timeline::EventTimelineEventAdded> for CdpEvent {
        fn from(
            el: super::browser_protocol::performance_timeline::EventTimelineEventAdded,
        ) -> CdpEvent {
            CdpEvent::PerformanceTimelineTimelineEventAdded(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::security::EventVisibleSecurityStateChanged
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::SecurityVisibleSecurityStateChanged(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::security::EventVisibleSecurityStateChanged> for CdpEvent {
        fn from(
            el: super::browser_protocol::security::EventVisibleSecurityStateChanged,
        ) -> CdpEvent {
            CdpEvent::SecurityVisibleSecurityStateChanged(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::service_worker::EventWorkerErrorReported
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::ServiceWorkerWorkerErrorReported(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::service_worker::EventWorkerErrorReported> for CdpEvent {
        fn from(el: super::browser_protocol::service_worker::EventWorkerErrorReported) -> CdpEvent {
            CdpEvent::ServiceWorkerWorkerErrorReported(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::service_worker::EventWorkerRegistrationUpdated
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::ServiceWorkerWorkerRegistrationUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::service_worker::EventWorkerRegistrationUpdated> for CdpEvent {
        fn from(
            el: super::browser_protocol::service_worker::EventWorkerRegistrationUpdated,
        ) -> CdpEvent {
            CdpEvent::ServiceWorkerWorkerRegistrationUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::service_worker::EventWorkerVersionUpdated
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::ServiceWorkerWorkerVersionUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::service_worker::EventWorkerVersionUpdated> for CdpEvent {
        fn from(
            el: super::browser_protocol::service_worker::EventWorkerVersionUpdated,
        ) -> CdpEvent {
            CdpEvent::ServiceWorkerWorkerVersionUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::storage::EventCacheStorageContentUpdated
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::StorageCacheStorageContentUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::storage::EventCacheStorageContentUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::storage::EventCacheStorageContentUpdated) -> CdpEvent {
            CdpEvent::StorageCacheStorageContentUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::storage::EventCacheStorageListUpdated
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::StorageCacheStorageListUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::storage::EventCacheStorageListUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::storage::EventCacheStorageListUpdated) -> CdpEvent {
            CdpEvent::StorageCacheStorageListUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::storage::EventIndexedDbContentUpdated
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::StorageIndexedDbContentUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::storage::EventIndexedDbContentUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::storage::EventIndexedDbContentUpdated) -> CdpEvent {
            CdpEvent::StorageIndexedDbContentUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::storage::EventIndexedDbListUpdated
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::StorageIndexedDbListUpdated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::storage::EventIndexedDbListUpdated> for CdpEvent {
        fn from(el: super::browser_protocol::storage::EventIndexedDbListUpdated) -> CdpEvent {
            CdpEvent::StorageIndexedDbListUpdated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::storage::EventInterestGroupAccessed
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::StorageInterestGroupAccessed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::storage::EventInterestGroupAccessed> for CdpEvent {
        fn from(el: super::browser_protocol::storage::EventInterestGroupAccessed) -> CdpEvent {
            CdpEvent::StorageInterestGroupAccessed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::target::EventAttachedToTarget {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::TargetAttachedToTarget(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::target::EventAttachedToTarget> for CdpEvent {
        fn from(el: super::browser_protocol::target::EventAttachedToTarget) -> CdpEvent {
            CdpEvent::TargetAttachedToTarget(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::target::EventDetachedFromTarget {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::TargetDetachedFromTarget(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::target::EventDetachedFromTarget> for CdpEvent {
        fn from(el: super::browser_protocol::target::EventDetachedFromTarget) -> CdpEvent {
            CdpEvent::TargetDetachedFromTarget(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::target::EventReceivedMessageFromTarget
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::TargetReceivedMessageFromTarget(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::target::EventReceivedMessageFromTarget> for CdpEvent {
        fn from(el: super::browser_protocol::target::EventReceivedMessageFromTarget) -> CdpEvent {
            CdpEvent::TargetReceivedMessageFromTarget(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::target::EventTargetCreated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::TargetTargetCreated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::target::EventTargetCreated> for CdpEvent {
        fn from(el: super::browser_protocol::target::EventTargetCreated) -> CdpEvent {
            CdpEvent::TargetTargetCreated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::target::EventTargetDestroyed {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::TargetTargetDestroyed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::target::EventTargetDestroyed> for CdpEvent {
        fn from(el: super::browser_protocol::target::EventTargetDestroyed) -> CdpEvent {
            CdpEvent::TargetTargetDestroyed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::target::EventTargetCrashed {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::TargetTargetCrashed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::target::EventTargetCrashed> for CdpEvent {
        fn from(el: super::browser_protocol::target::EventTargetCrashed) -> CdpEvent {
            CdpEvent::TargetTargetCrashed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::target::EventTargetInfoChanged {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::TargetTargetInfoChanged(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::target::EventTargetInfoChanged> for CdpEvent {
        fn from(el: super::browser_protocol::target::EventTargetInfoChanged) -> CdpEvent {
            CdpEvent::TargetTargetInfoChanged(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::tethering::EventAccepted {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::TetheringAccepted(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::tethering::EventAccepted> for CdpEvent {
        fn from(el: super::browser_protocol::tethering::EventAccepted) -> CdpEvent {
            CdpEvent::TetheringAccepted(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::tracing::EventBufferUsage {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::TracingBufferUsage(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::tracing::EventBufferUsage> for CdpEvent {
        fn from(el: super::browser_protocol::tracing::EventBufferUsage) -> CdpEvent {
            CdpEvent::TracingBufferUsage(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::tracing::EventDataCollected {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::TracingDataCollected(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::tracing::EventDataCollected> for CdpEvent {
        fn from(el: super::browser_protocol::tracing::EventDataCollected) -> CdpEvent {
            CdpEvent::TracingDataCollected(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::tracing::EventTracingComplete {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::TracingTracingComplete(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::tracing::EventTracingComplete> for CdpEvent {
        fn from(el: super::browser_protocol::tracing::EventTracingComplete) -> CdpEvent {
            CdpEvent::TracingTracingComplete(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::fetch::EventRequestPaused {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::FetchRequestPaused(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::fetch::EventRequestPaused> for CdpEvent {
        fn from(el: super::browser_protocol::fetch::EventRequestPaused) -> CdpEvent {
            CdpEvent::FetchRequestPaused(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::fetch::EventAuthRequired {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::FetchAuthRequired(val) => Ok(*val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::fetch::EventAuthRequired> for CdpEvent {
        fn from(el: super::browser_protocol::fetch::EventAuthRequired) -> CdpEvent {
            CdpEvent::FetchAuthRequired(Box::new(el))
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::web_audio::EventContextCreated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::WebAudioContextCreated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::web_audio::EventContextCreated> for CdpEvent {
        fn from(el: super::browser_protocol::web_audio::EventContextCreated) -> CdpEvent {
            CdpEvent::WebAudioContextCreated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::web_audio::EventContextWillBeDestroyed
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::WebAudioContextWillBeDestroyed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::web_audio::EventContextWillBeDestroyed> for CdpEvent {
        fn from(el: super::browser_protocol::web_audio::EventContextWillBeDestroyed) -> CdpEvent {
            CdpEvent::WebAudioContextWillBeDestroyed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::web_audio::EventContextChanged {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::WebAudioContextChanged(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::web_audio::EventContextChanged> for CdpEvent {
        fn from(el: super::browser_protocol::web_audio::EventContextChanged) -> CdpEvent {
            CdpEvent::WebAudioContextChanged(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::web_audio::EventAudioListenerCreated
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::WebAudioAudioListenerCreated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::web_audio::EventAudioListenerCreated> for CdpEvent {
        fn from(el: super::browser_protocol::web_audio::EventAudioListenerCreated) -> CdpEvent {
            CdpEvent::WebAudioAudioListenerCreated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::web_audio::EventAudioListenerWillBeDestroyed
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::WebAudioAudioListenerWillBeDestroyed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::web_audio::EventAudioListenerWillBeDestroyed> for CdpEvent {
        fn from(
            el: super::browser_protocol::web_audio::EventAudioListenerWillBeDestroyed,
        ) -> CdpEvent {
            CdpEvent::WebAudioAudioListenerWillBeDestroyed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::web_audio::EventAudioNodeCreated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::WebAudioAudioNodeCreated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::web_audio::EventAudioNodeCreated> for CdpEvent {
        fn from(el: super::browser_protocol::web_audio::EventAudioNodeCreated) -> CdpEvent {
            CdpEvent::WebAudioAudioNodeCreated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::web_audio::EventAudioNodeWillBeDestroyed
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::WebAudioAudioNodeWillBeDestroyed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::web_audio::EventAudioNodeWillBeDestroyed> for CdpEvent {
        fn from(el: super::browser_protocol::web_audio::EventAudioNodeWillBeDestroyed) -> CdpEvent {
            CdpEvent::WebAudioAudioNodeWillBeDestroyed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::web_audio::EventAudioParamCreated
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::WebAudioAudioParamCreated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::web_audio::EventAudioParamCreated> for CdpEvent {
        fn from(el: super::browser_protocol::web_audio::EventAudioParamCreated) -> CdpEvent {
            CdpEvent::WebAudioAudioParamCreated(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::web_audio::EventAudioParamWillBeDestroyed
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::WebAudioAudioParamWillBeDestroyed(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::web_audio::EventAudioParamWillBeDestroyed> for CdpEvent {
        fn from(
            el: super::browser_protocol::web_audio::EventAudioParamWillBeDestroyed,
        ) -> CdpEvent {
            CdpEvent::WebAudioAudioParamWillBeDestroyed(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::web_audio::EventNodesConnected {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::WebAudioNodesConnected(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::web_audio::EventNodesConnected> for CdpEvent {
        fn from(el: super::browser_protocol::web_audio::EventNodesConnected) -> CdpEvent {
            CdpEvent::WebAudioNodesConnected(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::web_audio::EventNodesDisconnected
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::WebAudioNodesDisconnected(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::web_audio::EventNodesDisconnected> for CdpEvent {
        fn from(el: super::browser_protocol::web_audio::EventNodesDisconnected) -> CdpEvent {
            CdpEvent::WebAudioNodesDisconnected(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::web_audio::EventNodeParamConnected
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::WebAudioNodeParamConnected(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::web_audio::EventNodeParamConnected> for CdpEvent {
        fn from(el: super::browser_protocol::web_audio::EventNodeParamConnected) -> CdpEvent {
            CdpEvent::WebAudioNodeParamConnected(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::web_audio::EventNodeParamDisconnected
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::WebAudioNodeParamDisconnected(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::web_audio::EventNodeParamDisconnected> for CdpEvent {
        fn from(el: super::browser_protocol::web_audio::EventNodeParamDisconnected) -> CdpEvent {
            CdpEvent::WebAudioNodeParamDisconnected(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent>
        for super::browser_protocol::media::EventPlayerPropertiesChanged
    {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::MediaPlayerPropertiesChanged(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::media::EventPlayerPropertiesChanged> for CdpEvent {
        fn from(el: super::browser_protocol::media::EventPlayerPropertiesChanged) -> CdpEvent {
            CdpEvent::MediaPlayerPropertiesChanged(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::media::EventPlayerEventsAdded {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::MediaPlayerEventsAdded(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::media::EventPlayerEventsAdded> for CdpEvent {
        fn from(el: super::browser_protocol::media::EventPlayerEventsAdded) -> CdpEvent {
            CdpEvent::MediaPlayerEventsAdded(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::media::EventPlayerMessagesLogged {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::MediaPlayerMessagesLogged(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::media::EventPlayerMessagesLogged> for CdpEvent {
        fn from(el: super::browser_protocol::media::EventPlayerMessagesLogged) -> CdpEvent {
            CdpEvent::MediaPlayerMessagesLogged(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::media::EventPlayerErrorsRaised {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::MediaPlayerErrorsRaised(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::media::EventPlayerErrorsRaised> for CdpEvent {
        fn from(el: super::browser_protocol::media::EventPlayerErrorsRaised) -> CdpEvent {
            CdpEvent::MediaPlayerErrorsRaised(el)
        }
    }
    impl std::convert::TryFrom<CdpEvent> for super::browser_protocol::media::EventPlayersCreated {
        type Error = CdpEvent;
        fn try_from(event: CdpEvent) -> Result<Self, Self::Error> {
            match event {
                CdpEvent::MediaPlayersCreated(val) => Ok(val),
                _ => Err(event),
            }
        }
    }
    impl From<super::browser_protocol::media::EventPlayersCreated> for CdpEvent {
        fn from(el: super::browser_protocol::media::EventPlayersCreated) -> CdpEvent {
            CdpEvent::MediaPlayersCreated(el)
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::debugger::EventBreakpointResolved {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::debugger::EventBreakpointResolved {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::debugger::EventPaused {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::debugger::EventPaused {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::debugger::EventResumed {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::debugger::EventResumed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::debugger::EventScriptFailedToParse {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::debugger::EventScriptFailedToParse {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::debugger::EventScriptParsed {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::debugger::EventScriptParsed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::heap_profiler::EventAddHeapSnapshotChunk {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::heap_profiler::EventAddHeapSnapshotChunk {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::heap_profiler::EventHeapStatsUpdate {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::heap_profiler::EventHeapStatsUpdate {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::heap_profiler::EventLastSeenObjectId {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::heap_profiler::EventLastSeenObjectId {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::js_protocol::heap_profiler::EventReportHeapSnapshotProgress
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::heap_profiler::EventReportHeapSnapshotProgress {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::heap_profiler::EventResetProfiles {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::heap_profiler::EventResetProfiles {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::profiler::EventConsoleProfileFinished {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::profiler::EventConsoleProfileFinished {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::profiler::EventConsoleProfileStarted {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::profiler::EventConsoleProfileStarted {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::profiler::EventPreciseCoverageDeltaUpdate {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::profiler::EventPreciseCoverageDeltaUpdate {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::runtime::EventBindingCalled {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::runtime::EventBindingCalled {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::runtime::EventConsoleApiCalled {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::runtime::EventConsoleApiCalled {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::runtime::EventExceptionRevoked {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::runtime::EventExceptionRevoked {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::runtime::EventExceptionThrown {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::runtime::EventExceptionThrown {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::runtime::EventExecutionContextCreated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::runtime::EventExecutionContextCreated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::runtime::EventExecutionContextDestroyed {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::runtime::EventExecutionContextDestroyed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::runtime::EventExecutionContextsCleared {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::runtime::EventExecutionContextsCleared {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::js_protocol::runtime::EventInspectRequested {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::js_protocol::runtime::EventInspectRequested {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::accessibility::EventLoadComplete {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::accessibility::EventLoadComplete {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::accessibility::EventNodesUpdated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::accessibility::EventNodesUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::animation::EventAnimationCanceled {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::animation::EventAnimationCanceled {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::animation::EventAnimationCreated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::animation::EventAnimationCreated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::animation::EventAnimationStarted {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::animation::EventAnimationStarted {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::audits::EventIssueAdded {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::audits::EventIssueAdded {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::background_service::EventRecordingStateChanged
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind
        for super::browser_protocol::background_service::EventRecordingStateChanged
    {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::background_service::EventBackgroundServiceEventReceived
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind
        for super::browser_protocol::background_service::EventBackgroundServiceEventReceived
    {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::browser::EventDownloadWillBegin {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::browser::EventDownloadWillBegin {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::browser::EventDownloadProgress {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::browser::EventDownloadProgress {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::css::EventFontsUpdated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::css::EventFontsUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::css::EventMediaQueryResultChanged {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::css::EventMediaQueryResultChanged {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::css::EventStyleSheetAdded {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::css::EventStyleSheetAdded {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::css::EventStyleSheetChanged {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::css::EventStyleSheetChanged {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::css::EventStyleSheetRemoved {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::css::EventStyleSheetRemoved {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::cast::EventSinksUpdated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::cast::EventSinksUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::cast::EventIssueUpdated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::cast::EventIssueUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventAttributeModified {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventAttributeModified {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventAttributeRemoved {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventAttributeRemoved {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventCharacterDataModified {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventCharacterDataModified {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventChildNodeCountUpdated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventChildNodeCountUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventChildNodeInserted {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventChildNodeInserted {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventChildNodeRemoved {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventChildNodeRemoved {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventDistributedNodesUpdated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventDistributedNodesUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventDocumentUpdated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventDocumentUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventInlineStyleInvalidated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventInlineStyleInvalidated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventPseudoElementAdded {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventPseudoElementAdded {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventTopLayerElementsUpdated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventTopLayerElementsUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventPseudoElementRemoved {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventPseudoElementRemoved {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventSetChildNodes {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventSetChildNodes {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventShadowRootPopped {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventShadowRootPopped {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom::EventShadowRootPushed {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom::EventShadowRootPushed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::dom_storage::EventDomStorageItemAdded {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom_storage::EventDomStorageItemAdded {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::dom_storage::EventDomStorageItemRemoved
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom_storage::EventDomStorageItemRemoved {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::dom_storage::EventDomStorageItemUpdated
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom_storage::EventDomStorageItemUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::dom_storage::EventDomStorageItemsCleared
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::dom_storage::EventDomStorageItemsCleared {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::database::EventAddDatabase {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::database::EventAddDatabase {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::emulation::EventVirtualTimeBudgetExpired
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::emulation::EventVirtualTimeBudgetExpired {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::input::EventDragIntercepted {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::input::EventDragIntercepted {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::inspector::EventDetached {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::inspector::EventDetached {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::inspector::EventTargetCrashed {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::inspector::EventTargetCrashed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::inspector::EventTargetReloadedAfterCrash
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::inspector::EventTargetReloadedAfterCrash {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::layer_tree::EventLayerPainted {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::layer_tree::EventLayerPainted {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::layer_tree::EventLayerTreeDidChange {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::layer_tree::EventLayerTreeDidChange {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::log::EventEntryAdded {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::log::EventEntryAdded {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventDataReceived {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventDataReceived {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::network::EventEventSourceMessageReceived
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventEventSourceMessageReceived {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventLoadingFailed {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventLoadingFailed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventLoadingFinished {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventLoadingFinished {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventRequestServedFromCache {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventRequestServedFromCache {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventRequestWillBeSent {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventRequestWillBeSent {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventResourceChangedPriority {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventResourceChangedPriority {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventSignedExchangeReceived {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventSignedExchangeReceived {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventResponseReceived {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventResponseReceived {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventWebSocketClosed {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventWebSocketClosed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventWebSocketCreated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventWebSocketCreated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventWebSocketFrameError {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventWebSocketFrameError {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventWebSocketFrameReceived {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventWebSocketFrameReceived {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventWebSocketFrameSent {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventWebSocketFrameSent {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::network::EventWebSocketHandshakeResponseReceived
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind
        for super::browser_protocol::network::EventWebSocketHandshakeResponseReceived
    {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::network::EventWebSocketWillSendHandshakeRequest
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind
        for super::browser_protocol::network::EventWebSocketWillSendHandshakeRequest
    {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventWebTransportCreated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventWebTransportCreated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::network::EventWebTransportConnectionEstablished
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind
        for super::browser_protocol::network::EventWebTransportConnectionEstablished
    {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventWebTransportClosed {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventWebTransportClosed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::network::EventRequestWillBeSentExtraInfo
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventRequestWillBeSentExtraInfo {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::network::EventResponseReceivedExtraInfo
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventResponseReceivedExtraInfo {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventTrustTokenOperationDone {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventTrustTokenOperationDone {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::network::EventSubresourceWebBundleMetadataReceived
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind
        for super::browser_protocol::network::EventSubresourceWebBundleMetadataReceived
    {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::network::EventSubresourceWebBundleMetadataError
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind
        for super::browser_protocol::network::EventSubresourceWebBundleMetadataError
    {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::network::EventSubresourceWebBundleInnerResponseParsed
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind
        for super::browser_protocol::network::EventSubresourceWebBundleInnerResponseParsed
    {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::network::EventSubresourceWebBundleInnerResponseError
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind
        for super::browser_protocol::network::EventSubresourceWebBundleInnerResponseError
    {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::network::EventReportingApiReportAdded {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventReportingApiReportAdded {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::network::EventReportingApiReportUpdated
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::network::EventReportingApiReportUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::network::EventReportingApiEndpointsChangedForOrigin
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind
        for super::browser_protocol::network::EventReportingApiEndpointsChangedForOrigin
    {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::overlay::EventInspectNodeRequested {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::overlay::EventInspectNodeRequested {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::overlay::EventNodeHighlightRequested {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::overlay::EventNodeHighlightRequested {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::overlay::EventScreenshotRequested {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::overlay::EventScreenshotRequested {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::overlay::EventInspectModeCanceled {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::overlay::EventInspectModeCanceled {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventDomContentEventFired {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventDomContentEventFired {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventFileChooserOpened {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventFileChooserOpened {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventFrameAttached {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventFrameAttached {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventFrameDetached {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventFrameDetached {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventFrameNavigated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventFrameNavigated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventDocumentOpened {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventDocumentOpened {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventFrameResized {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventFrameResized {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventFrameRequestedNavigation {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventFrameRequestedNavigation {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventFrameStartedLoading {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventFrameStartedLoading {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventFrameStoppedLoading {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventFrameStoppedLoading {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventInterstitialHidden {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventInterstitialHidden {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventInterstitialShown {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventInterstitialShown {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventJavascriptDialogClosed {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventJavascriptDialogClosed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventJavascriptDialogOpening {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventJavascriptDialogOpening {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventLifecycleEvent {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventLifecycleEvent {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventBackForwardCacheNotUsed {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventBackForwardCacheNotUsed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventPrerenderAttemptCompleted {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventPrerenderAttemptCompleted {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventLoadEventFired {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventLoadEventFired {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventNavigatedWithinDocument {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventNavigatedWithinDocument {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventScreencastFrame {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventScreencastFrame {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::page::EventScreencastVisibilityChanged
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventScreencastVisibilityChanged {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventWindowOpen {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventWindowOpen {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::page::EventCompilationCacheProduced {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::page::EventCompilationCacheProduced {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::performance::EventMetrics {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::performance::EventMetrics {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::performance_timeline::EventTimelineEventAdded
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind
        for super::browser_protocol::performance_timeline::EventTimelineEventAdded
    {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::security::EventVisibleSecurityStateChanged
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::security::EventVisibleSecurityStateChanged {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::service_worker::EventWorkerErrorReported
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::service_worker::EventWorkerErrorReported {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::service_worker::EventWorkerRegistrationUpdated
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind
        for super::browser_protocol::service_worker::EventWorkerRegistrationUpdated
    {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::service_worker::EventWorkerVersionUpdated
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::service_worker::EventWorkerVersionUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::storage::EventCacheStorageContentUpdated
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::storage::EventCacheStorageContentUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::storage::EventCacheStorageListUpdated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::storage::EventCacheStorageListUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::storage::EventIndexedDbContentUpdated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::storage::EventIndexedDbContentUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::storage::EventIndexedDbListUpdated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::storage::EventIndexedDbListUpdated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::storage::EventInterestGroupAccessed {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::storage::EventInterestGroupAccessed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::target::EventAttachedToTarget {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::target::EventAttachedToTarget {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::target::EventDetachedFromTarget {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::target::EventDetachedFromTarget {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::target::EventReceivedMessageFromTarget
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::target::EventReceivedMessageFromTarget {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::target::EventTargetCreated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::target::EventTargetCreated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::target::EventTargetDestroyed {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::target::EventTargetDestroyed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::target::EventTargetCrashed {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::target::EventTargetCrashed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::target::EventTargetInfoChanged {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::target::EventTargetInfoChanged {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::tethering::EventAccepted {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::tethering::EventAccepted {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::tracing::EventBufferUsage {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::tracing::EventBufferUsage {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::tracing::EventDataCollected {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::tracing::EventDataCollected {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::tracing::EventTracingComplete {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::tracing::EventTracingComplete {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::fetch::EventRequestPaused {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::fetch::EventRequestPaused {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::fetch::EventAuthRequired {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::fetch::EventAuthRequired {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::web_audio::EventContextCreated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::web_audio::EventContextCreated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::web_audio::EventContextWillBeDestroyed
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::web_audio::EventContextWillBeDestroyed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::web_audio::EventContextChanged {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::web_audio::EventContextChanged {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::web_audio::EventAudioListenerCreated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::web_audio::EventAudioListenerCreated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::web_audio::EventAudioListenerWillBeDestroyed
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind
        for super::browser_protocol::web_audio::EventAudioListenerWillBeDestroyed
    {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::web_audio::EventAudioNodeCreated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::web_audio::EventAudioNodeCreated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::web_audio::EventAudioNodeWillBeDestroyed
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::web_audio::EventAudioNodeWillBeDestroyed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::web_audio::EventAudioParamCreated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::web_audio::EventAudioParamCreated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent
        for super::browser_protocol::web_audio::EventAudioParamWillBeDestroyed
    {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::web_audio::EventAudioParamWillBeDestroyed {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::web_audio::EventNodesConnected {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::web_audio::EventNodesConnected {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::web_audio::EventNodesDisconnected {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::web_audio::EventNodesDisconnected {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::web_audio::EventNodeParamConnected {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::web_audio::EventNodeParamConnected {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::web_audio::EventNodeParamDisconnected {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::web_audio::EventNodeParamDisconnected {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::media::EventPlayerPropertiesChanged {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::media::EventPlayerPropertiesChanged {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::media::EventPlayerEventsAdded {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::media::EventPlayerEventsAdded {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::media::EventPlayerMessagesLogged {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::media::EventPlayerMessagesLogged {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::media::EventPlayerErrorsRaised {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::media::EventPlayerErrorsRaised {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    impl super::sealed::SealedEvent for super::browser_protocol::media::EventPlayersCreated {
        fn as_any(&self) -> &dyn ::std::any::Any {
            self
        }
    }
    impl super::IntoEventKind for super::browser_protocol::media::EventPlayersCreated {
        fn event_kind() -> super::EventKind
        where
            Self: Sized + 'static,
        {
            super::EventKind::BuiltIn
        }
    }
    #[macro_export]
    #[doc(hidden)]
    macro_rules! consume_event {
        (match $ ev : ident { $ builtin : expr , $ custom : expr }) => {{
            match $ev {
                CdpEvent::DebuggerBreakpointResolved(event) => {
                    $builtin(event);
                }
                CdpEvent::DebuggerPaused(event) => {
                    $builtin(event);
                }
                CdpEvent::DebuggerResumed(event) => {
                    $builtin(event);
                }
                CdpEvent::DebuggerScriptFailedToParse(event) => {
                    $builtin(*event);
                }
                CdpEvent::DebuggerScriptParsed(event) => {
                    $builtin(*event);
                }
                CdpEvent::HeapProfilerAddHeapSnapshotChunk(event) => {
                    $builtin(event);
                }
                CdpEvent::HeapProfilerHeapStatsUpdate(event) => {
                    $builtin(event);
                }
                CdpEvent::HeapProfilerLastSeenObjectId(event) => {
                    $builtin(event);
                }
                CdpEvent::HeapProfilerReportHeapSnapshotProgress(event) => {
                    $builtin(event);
                }
                CdpEvent::HeapProfilerResetProfiles(event) => {
                    $builtin(event);
                }
                CdpEvent::ProfilerConsoleProfileFinished(event) => {
                    $builtin(event);
                }
                CdpEvent::ProfilerConsoleProfileStarted(event) => {
                    $builtin(event);
                }
                CdpEvent::ProfilerPreciseCoverageDeltaUpdate(event) => {
                    $builtin(event);
                }
                CdpEvent::RuntimeBindingCalled(event) => {
                    $builtin(event);
                }
                CdpEvent::RuntimeConsoleApiCalled(event) => {
                    $builtin(event);
                }
                CdpEvent::RuntimeExceptionRevoked(event) => {
                    $builtin(event);
                }
                CdpEvent::RuntimeExceptionThrown(event) => {
                    $builtin(*event);
                }
                CdpEvent::RuntimeExecutionContextCreated(event) => {
                    $builtin(event);
                }
                CdpEvent::RuntimeExecutionContextDestroyed(event) => {
                    $builtin(event);
                }
                CdpEvent::RuntimeExecutionContextsCleared(event) => {
                    $builtin(event);
                }
                CdpEvent::RuntimeInspectRequested(event) => {
                    $builtin(*event);
                }
                CdpEvent::AccessibilityLoadComplete(event) => {
                    $builtin(*event);
                }
                CdpEvent::AccessibilityNodesUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::AnimationAnimationCanceled(event) => {
                    $builtin(event);
                }
                CdpEvent::AnimationAnimationCreated(event) => {
                    $builtin(event);
                }
                CdpEvent::AnimationAnimationStarted(event) => {
                    $builtin(*event);
                }
                CdpEvent::AuditsIssueAdded(event) => {
                    $builtin(*event);
                }
                CdpEvent::BackgroundServiceRecordingStateChanged(event) => {
                    $builtin(event);
                }
                CdpEvent::BackgroundServiceBackgroundServiceEventReceived(event) => {
                    $builtin(event);
                }
                CdpEvent::BrowserDownloadWillBegin(event) => {
                    $builtin(event);
                }
                CdpEvent::BrowserDownloadProgress(event) => {
                    $builtin(event);
                }
                CdpEvent::CssFontsUpdated(event) => {
                    $builtin(*event);
                }
                CdpEvent::CssMediaQueryResultChanged(event) => {
                    $builtin(event);
                }
                CdpEvent::CssStyleSheetAdded(event) => {
                    $builtin(event);
                }
                CdpEvent::CssStyleSheetChanged(event) => {
                    $builtin(event);
                }
                CdpEvent::CssStyleSheetRemoved(event) => {
                    $builtin(event);
                }
                CdpEvent::CastSinksUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::CastIssueUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::DomAttributeModified(event) => {
                    $builtin(event);
                }
                CdpEvent::DomAttributeRemoved(event) => {
                    $builtin(event);
                }
                CdpEvent::DomCharacterDataModified(event) => {
                    $builtin(event);
                }
                CdpEvent::DomChildNodeCountUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::DomChildNodeInserted(event) => {
                    $builtin(*event);
                }
                CdpEvent::DomChildNodeRemoved(event) => {
                    $builtin(event);
                }
                CdpEvent::DomDistributedNodesUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::DomDocumentUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::DomInlineStyleInvalidated(event) => {
                    $builtin(event);
                }
                CdpEvent::DomPseudoElementAdded(event) => {
                    $builtin(*event);
                }
                CdpEvent::DomTopLayerElementsUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::DomPseudoElementRemoved(event) => {
                    $builtin(event);
                }
                CdpEvent::DomSetChildNodes(event) => {
                    $builtin(event);
                }
                CdpEvent::DomShadowRootPopped(event) => {
                    $builtin(event);
                }
                CdpEvent::DomShadowRootPushed(event) => {
                    $builtin(*event);
                }
                CdpEvent::DomStorageDomStorageItemAdded(event) => {
                    $builtin(event);
                }
                CdpEvent::DomStorageDomStorageItemRemoved(event) => {
                    $builtin(event);
                }
                CdpEvent::DomStorageDomStorageItemUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::DomStorageDomStorageItemsCleared(event) => {
                    $builtin(event);
                }
                CdpEvent::DatabaseAddDatabase(event) => {
                    $builtin(event);
                }
                CdpEvent::EmulationVirtualTimeBudgetExpired(event) => {
                    $builtin(event);
                }
                CdpEvent::InputDragIntercepted(event) => {
                    $builtin(event);
                }
                CdpEvent::InspectorDetached(event) => {
                    $builtin(event);
                }
                CdpEvent::InspectorTargetCrashed(event) => {
                    $builtin(event);
                }
                CdpEvent::InspectorTargetReloadedAfterCrash(event) => {
                    $builtin(event);
                }
                CdpEvent::LayerTreeLayerPainted(event) => {
                    $builtin(event);
                }
                CdpEvent::LayerTreeLayerTreeDidChange(event) => {
                    $builtin(event);
                }
                CdpEvent::LogEntryAdded(event) => {
                    $builtin(*event);
                }
                CdpEvent::NetworkDataReceived(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkEventSourceMessageReceived(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkLoadingFailed(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkLoadingFinished(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkRequestServedFromCache(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkRequestWillBeSent(event) => {
                    $builtin(*event);
                }
                CdpEvent::NetworkResourceChangedPriority(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkSignedExchangeReceived(event) => {
                    $builtin(*event);
                }
                CdpEvent::NetworkResponseReceived(event) => {
                    $builtin(*event);
                }
                CdpEvent::NetworkWebSocketClosed(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkWebSocketCreated(event) => {
                    $builtin(*event);
                }
                CdpEvent::NetworkWebSocketFrameError(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkWebSocketFrameReceived(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkWebSocketFrameSent(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkWebSocketHandshakeResponseReceived(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkWebSocketWillSendHandshakeRequest(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkWebTransportCreated(event) => {
                    $builtin(*event);
                }
                CdpEvent::NetworkWebTransportConnectionEstablished(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkWebTransportClosed(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkRequestWillBeSentExtraInfo(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkResponseReceivedExtraInfo(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkTrustTokenOperationDone(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkSubresourceWebBundleMetadataReceived(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkSubresourceWebBundleMetadataError(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkSubresourceWebBundleInnerResponseParsed(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkSubresourceWebBundleInnerResponseError(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkReportingApiReportAdded(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkReportingApiReportUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::NetworkReportingApiEndpointsChangedForOrigin(event) => {
                    $builtin(event);
                }
                CdpEvent::OverlayInspectNodeRequested(event) => {
                    $builtin(event);
                }
                CdpEvent::OverlayNodeHighlightRequested(event) => {
                    $builtin(event);
                }
                CdpEvent::OverlayScreenshotRequested(event) => {
                    $builtin(event);
                }
                CdpEvent::OverlayInspectModeCanceled(event) => {
                    $builtin(event);
                }
                CdpEvent::PageDomContentEventFired(event) => {
                    $builtin(event);
                }
                CdpEvent::PageFileChooserOpened(event) => {
                    $builtin(event);
                }
                CdpEvent::PageFrameAttached(event) => {
                    $builtin(event);
                }
                CdpEvent::PageFrameDetached(event) => {
                    $builtin(event);
                }
                CdpEvent::PageFrameNavigated(event) => {
                    $builtin(*event);
                }
                CdpEvent::PageDocumentOpened(event) => {
                    $builtin(*event);
                }
                CdpEvent::PageFrameResized(event) => {
                    $builtin(event);
                }
                CdpEvent::PageFrameRequestedNavigation(event) => {
                    $builtin(event);
                }
                CdpEvent::PageFrameStartedLoading(event) => {
                    $builtin(event);
                }
                CdpEvent::PageFrameStoppedLoading(event) => {
                    $builtin(event);
                }
                CdpEvent::PageInterstitialHidden(event) => {
                    $builtin(event);
                }
                CdpEvent::PageInterstitialShown(event) => {
                    $builtin(event);
                }
                CdpEvent::PageJavascriptDialogClosed(event) => {
                    $builtin(event);
                }
                CdpEvent::PageJavascriptDialogOpening(event) => {
                    $builtin(event);
                }
                CdpEvent::PageLifecycleEvent(event) => {
                    $builtin(event);
                }
                CdpEvent::PageBackForwardCacheNotUsed(event) => {
                    $builtin(event);
                }
                CdpEvent::PagePrerenderAttemptCompleted(event) => {
                    $builtin(event);
                }
                CdpEvent::PageLoadEventFired(event) => {
                    $builtin(event);
                }
                CdpEvent::PageNavigatedWithinDocument(event) => {
                    $builtin(event);
                }
                CdpEvent::PageScreencastFrame(event) => {
                    $builtin(event);
                }
                CdpEvent::PageScreencastVisibilityChanged(event) => {
                    $builtin(event);
                }
                CdpEvent::PageWindowOpen(event) => {
                    $builtin(event);
                }
                CdpEvent::PageCompilationCacheProduced(event) => {
                    $builtin(event);
                }
                CdpEvent::PerformanceMetrics(event) => {
                    $builtin(event);
                }
                CdpEvent::PerformanceTimelineTimelineEventAdded(event) => {
                    $builtin(*event);
                }
                CdpEvent::SecurityVisibleSecurityStateChanged(event) => {
                    $builtin(*event);
                }
                CdpEvent::ServiceWorkerWorkerErrorReported(event) => {
                    $builtin(event);
                }
                CdpEvent::ServiceWorkerWorkerRegistrationUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::ServiceWorkerWorkerVersionUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::StorageCacheStorageContentUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::StorageCacheStorageListUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::StorageIndexedDbContentUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::StorageIndexedDbListUpdated(event) => {
                    $builtin(event);
                }
                CdpEvent::StorageInterestGroupAccessed(event) => {
                    $builtin(event);
                }
                CdpEvent::TargetAttachedToTarget(event) => {
                    $builtin(event);
                }
                CdpEvent::TargetDetachedFromTarget(event) => {
                    $builtin(event);
                }
                CdpEvent::TargetReceivedMessageFromTarget(event) => {
                    $builtin(event);
                }
                CdpEvent::TargetTargetCreated(event) => {
                    $builtin(event);
                }
                CdpEvent::TargetTargetDestroyed(event) => {
                    $builtin(event);
                }
                CdpEvent::TargetTargetCrashed(event) => {
                    $builtin(event);
                }
                CdpEvent::TargetTargetInfoChanged(event) => {
                    $builtin(event);
                }
                CdpEvent::TetheringAccepted(event) => {
                    $builtin(event);
                }
                CdpEvent::TracingBufferUsage(event) => {
                    $builtin(event);
                }
                CdpEvent::TracingDataCollected(event) => {
                    $builtin(event);
                }
                CdpEvent::TracingTracingComplete(event) => {
                    $builtin(event);
                }
                CdpEvent::FetchRequestPaused(event) => {
                    $builtin(*event);
                }
                CdpEvent::FetchAuthRequired(event) => {
                    $builtin(*event);
                }
                CdpEvent::WebAudioContextCreated(event) => {
                    $builtin(event);
                }
                CdpEvent::WebAudioContextWillBeDestroyed(event) => {
                    $builtin(event);
                }
                CdpEvent::WebAudioContextChanged(event) => {
                    $builtin(event);
                }
                CdpEvent::WebAudioAudioListenerCreated(event) => {
                    $builtin(event);
                }
                CdpEvent::WebAudioAudioListenerWillBeDestroyed(event) => {
                    $builtin(event);
                }
                CdpEvent::WebAudioAudioNodeCreated(event) => {
                    $builtin(event);
                }
                CdpEvent::WebAudioAudioNodeWillBeDestroyed(event) => {
                    $builtin(event);
                }
                CdpEvent::WebAudioAudioParamCreated(event) => {
                    $builtin(event);
                }
                CdpEvent::WebAudioAudioParamWillBeDestroyed(event) => {
                    $builtin(event);
                }
                CdpEvent::WebAudioNodesConnected(event) => {
                    $builtin(event);
                }
                CdpEvent::WebAudioNodesDisconnected(event) => {
                    $builtin(event);
                }
                CdpEvent::WebAudioNodeParamConnected(event) => {
                    $builtin(event);
                }
                CdpEvent::WebAudioNodeParamDisconnected(event) => {
                    $builtin(event);
                }
                CdpEvent::MediaPlayerPropertiesChanged(event) => {
                    $builtin(event);
                }
                CdpEvent::MediaPlayerEventsAdded(event) => {
                    $builtin(event);
                }
                CdpEvent::MediaPlayerMessagesLogged(event) => {
                    $builtin(event);
                }
                CdpEvent::MediaPlayerErrorsRaised(event) => {
                    $builtin(event);
                }
                CdpEvent::MediaPlayersCreated(event) => {
                    $builtin(event);
                }
                CdpEvent::Other(json) => {
                    $custom(json);
                }
            }
        }};
    }
}
#[allow(clippy::wrong_self_convention)]
pub mod js_protocol {
    #[doc = r" The version of this protocol definition"]
    pub const VERSION: &str = "1.3";
    #[doc = "Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing\nbreakpoints, stepping through execution, exploring stack traces, etc."]
    pub mod debugger {
        use serde::{Deserialize, Serialize};
        #[doc = "Breakpoint identifier.\n[BreakpointId](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#type-BreakpointId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct BreakpointId(String);
        impl BreakpointId {
            pub fn new(val: impl Into<String>) -> Self {
                BreakpointId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for BreakpointId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<BreakpointId> for String {
            fn from(el: BreakpointId) -> String {
                el.0
            }
        }
        impl From<String> for BreakpointId {
            fn from(expr: String) -> Self {
                BreakpointId(expr)
            }
        }
        impl std::borrow::Borrow<str> for BreakpointId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl BreakpointId {
            pub const IDENTIFIER: &'static str = "Debugger.BreakpointId";
        }
        #[doc = "Call frame identifier.\n[CallFrameId](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#type-CallFrameId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct CallFrameId(String);
        impl CallFrameId {
            pub fn new(val: impl Into<String>) -> Self {
                CallFrameId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for CallFrameId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<CallFrameId> for String {
            fn from(el: CallFrameId) -> String {
                el.0
            }
        }
        impl From<String> for CallFrameId {
            fn from(expr: String) -> Self {
                CallFrameId(expr)
            }
        }
        impl std::borrow::Borrow<str> for CallFrameId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl CallFrameId {
            pub const IDENTIFIER: &'static str = "Debugger.CallFrameId";
        }
        #[doc = "Location in the source code.\n[Location](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#type-Location)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Location {
            #[doc = "Script identifier as reported in the `Debugger.scriptParsed`."]
            #[serde(rename = "scriptId")]
            pub script_id: super::runtime::ScriptId,
            #[doc = "Line number in the script (0-based)."]
            #[serde(rename = "lineNumber")]
            pub line_number: i64,
            #[doc = "Column number in the script (0-based)."]
            #[serde(rename = "columnNumber")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub column_number: Option<i64>,
        }
        impl Location {
            pub fn new(
                script_id: impl Into<super::runtime::ScriptId>,
                line_number: impl Into<i64>,
            ) -> Self {
                Self {
                    script_id: script_id.into(),
                    line_number: line_number.into(),
                    column_number: None,
                }
            }
        }
        impl Location {
            pub fn builder() -> LocationBuilder {
                LocationBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LocationBuilder {
            script_id: Option<super::runtime::ScriptId>,
            line_number: Option<i64>,
            column_number: Option<i64>,
        }
        impl LocationBuilder {
            pub fn script_id(mut self, script_id: impl Into<super::runtime::ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn line_number(mut self, line_number: impl Into<i64>) -> Self {
                self.line_number = Some(line_number.into());
                self
            }
            pub fn column_number(mut self, column_number: impl Into<i64>) -> Self {
                self.column_number = Some(column_number.into());
                self
            }
            pub fn build(self) -> Result<Location, String> {
                Ok(Location {
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                    line_number: self.line_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line_number))
                    })?,
                    column_number: self.column_number,
                })
            }
        }
        impl Location {
            pub const IDENTIFIER: &'static str = "Debugger.Location";
        }
        #[doc = "Location in the source code.\n[ScriptPosition](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#type-ScriptPosition)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ScriptPosition {
            #[serde(rename = "lineNumber")]
            pub line_number: i64,
            #[serde(rename = "columnNumber")]
            pub column_number: i64,
        }
        impl ScriptPosition {
            pub fn new(line_number: impl Into<i64>, column_number: impl Into<i64>) -> Self {
                Self {
                    line_number: line_number.into(),
                    column_number: column_number.into(),
                }
            }
        }
        impl ScriptPosition {
            pub fn builder() -> ScriptPositionBuilder {
                ScriptPositionBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ScriptPositionBuilder {
            line_number: Option<i64>,
            column_number: Option<i64>,
        }
        impl ScriptPositionBuilder {
            pub fn line_number(mut self, line_number: impl Into<i64>) -> Self {
                self.line_number = Some(line_number.into());
                self
            }
            pub fn column_number(mut self, column_number: impl Into<i64>) -> Self {
                self.column_number = Some(column_number.into());
                self
            }
            pub fn build(self) -> Result<ScriptPosition, String> {
                Ok(ScriptPosition {
                    line_number: self.line_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line_number))
                    })?,
                    column_number: self.column_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(column_number))
                    })?,
                })
            }
        }
        impl ScriptPosition {
            pub const IDENTIFIER: &'static str = "Debugger.ScriptPosition";
        }
        #[doc = "Location range within one script.\n[LocationRange](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#type-LocationRange)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LocationRange {
            #[serde(rename = "scriptId")]
            pub script_id: super::runtime::ScriptId,
            #[serde(rename = "start")]
            pub start: ScriptPosition,
            #[serde(rename = "end")]
            pub end: ScriptPosition,
        }
        impl LocationRange {
            pub fn new(
                script_id: impl Into<super::runtime::ScriptId>,
                start: impl Into<ScriptPosition>,
                end: impl Into<ScriptPosition>,
            ) -> Self {
                Self {
                    script_id: script_id.into(),
                    start: start.into(),
                    end: end.into(),
                }
            }
        }
        impl LocationRange {
            pub fn builder() -> LocationRangeBuilder {
                LocationRangeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LocationRangeBuilder {
            script_id: Option<super::runtime::ScriptId>,
            start: Option<ScriptPosition>,
            end: Option<ScriptPosition>,
        }
        impl LocationRangeBuilder {
            pub fn script_id(mut self, script_id: impl Into<super::runtime::ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn start(mut self, start: impl Into<ScriptPosition>) -> Self {
                self.start = Some(start.into());
                self
            }
            pub fn end(mut self, end: impl Into<ScriptPosition>) -> Self {
                self.end = Some(end.into());
                self
            }
            pub fn build(self) -> Result<LocationRange, String> {
                Ok(LocationRange {
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                    start: self.start.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(start))
                    })?,
                    end: self
                        .end
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(end)))?,
                })
            }
        }
        impl LocationRange {
            pub const IDENTIFIER: &'static str = "Debugger.LocationRange";
        }
        #[doc = "JavaScript call frame. Array of call frames form the call stack.\n[CallFrame](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#type-CallFrame)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CallFrame {
            #[doc = "Call frame identifier. This identifier is only valid while the virtual machine is paused."]
            #[serde(rename = "callFrameId")]
            pub call_frame_id: CallFrameId,
            #[doc = "Name of the JavaScript function called on this call frame."]
            #[serde(rename = "functionName")]
            pub function_name: String,
            #[doc = "Location in the source code."]
            #[serde(rename = "functionLocation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub function_location: Option<Location>,
            #[doc = "Location in the source code."]
            #[serde(rename = "location")]
            pub location: Location,
            #[doc = "Scope chain for this call frame."]
            #[serde(rename = "scopeChain")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub scope_chain: Vec<Scope>,
            #[doc = "`this` object for this call frame."]
            #[serde(rename = "this")]
            pub this: super::runtime::RemoteObject,
            #[doc = "The value being returned, if the function is at return point."]
            #[serde(rename = "returnValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub return_value: Option<super::runtime::RemoteObject>,
            #[doc = "Valid only while the VM is paused and indicates whether this frame\ncan be restarted or not. Note that a `true` value here does not\nguarantee that Debugger#restartFrame with this CallFrameId will be\nsuccessful, but it is very likely."]
            #[serde(rename = "canBeRestarted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub can_be_restarted: Option<bool>,
        }
        impl CallFrame {
            pub fn builder() -> CallFrameBuilder {
                CallFrameBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CallFrameBuilder {
            call_frame_id: Option<CallFrameId>,
            function_name: Option<String>,
            function_location: Option<Location>,
            location: Option<Location>,
            scope_chain: Option<Vec<Scope>>,
            this: Option<super::runtime::RemoteObject>,
            return_value: Option<super::runtime::RemoteObject>,
            can_be_restarted: Option<bool>,
        }
        impl CallFrameBuilder {
            pub fn call_frame_id(mut self, call_frame_id: impl Into<CallFrameId>) -> Self {
                self.call_frame_id = Some(call_frame_id.into());
                self
            }
            pub fn function_name(mut self, function_name: impl Into<String>) -> Self {
                self.function_name = Some(function_name.into());
                self
            }
            pub fn function_location(mut self, function_location: impl Into<Location>) -> Self {
                self.function_location = Some(function_location.into());
                self
            }
            pub fn location(mut self, location: impl Into<Location>) -> Self {
                self.location = Some(location.into());
                self
            }
            pub fn scope_chain(mut self, scope_chain: impl Into<Scope>) -> Self {
                let v = self.scope_chain.get_or_insert(Vec::new());
                v.push(scope_chain.into());
                self
            }
            pub fn scope_chains<I, S>(mut self, scope_chains: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Scope>,
            {
                let v = self.scope_chain.get_or_insert(Vec::new());
                for val in scope_chains {
                    v.push(val.into());
                }
                self
            }
            pub fn this(mut self, this: impl Into<super::runtime::RemoteObject>) -> Self {
                self.this = Some(this.into());
                self
            }
            pub fn return_value(
                mut self,
                return_value: impl Into<super::runtime::RemoteObject>,
            ) -> Self {
                self.return_value = Some(return_value.into());
                self
            }
            pub fn can_be_restarted(mut self, can_be_restarted: impl Into<bool>) -> Self {
                self.can_be_restarted = Some(can_be_restarted.into());
                self
            }
            pub fn build(self) -> Result<CallFrame, String> {
                Ok(CallFrame {
                    call_frame_id: self.call_frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(call_frame_id))
                    })?,
                    function_name: self.function_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(function_name))
                    })?,
                    function_location: self.function_location,
                    location: self.location.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(location))
                    })?,
                    scope_chain: self.scope_chain.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scope_chain))
                    })?,
                    this: self.this.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(this))
                    })?,
                    return_value: self.return_value,
                    can_be_restarted: self.can_be_restarted,
                })
            }
        }
        impl CallFrame {
            pub const IDENTIFIER: &'static str = "Debugger.CallFrame";
        }
        #[doc = "Scope description.\n[Scope](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#type-Scope)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Scope {
            #[doc = "Scope type."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: ScopeType,
            #[doc = "Object representing the scope. For `global` and `with` scopes it represents the actual\nobject; for the rest of the scopes, it is artificial transient object enumerating scope\nvariables as its properties."]
            #[serde(rename = "object")]
            pub object: super::runtime::RemoteObject,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub name: Option<String>,
            #[doc = "Location in the source code where scope starts"]
            #[serde(rename = "startLocation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub start_location: Option<Location>,
            #[doc = "Location in the source code where scope ends"]
            #[serde(rename = "endLocation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub end_location: Option<Location>,
        }
        #[doc = "Scope type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ScopeType {
            #[serde(rename = "global")]
            Global,
            #[serde(rename = "local")]
            Local,
            #[serde(rename = "with")]
            With,
            #[serde(rename = "closure")]
            Closure,
            #[serde(rename = "catch")]
            Catch,
            #[serde(rename = "block")]
            Block,
            #[serde(rename = "script")]
            Script,
            #[serde(rename = "eval")]
            Eval,
            #[serde(rename = "module")]
            Module,
            #[serde(rename = "wasm-expression-stack")]
            WasmExpressionStack,
        }
        impl AsRef<str> for ScopeType {
            fn as_ref(&self) -> &str {
                match self {
                    ScopeType::Global => "global",
                    ScopeType::Local => "local",
                    ScopeType::With => "with",
                    ScopeType::Closure => "closure",
                    ScopeType::Catch => "catch",
                    ScopeType::Block => "block",
                    ScopeType::Script => "script",
                    ScopeType::Eval => "eval",
                    ScopeType::Module => "module",
                    ScopeType::WasmExpressionStack => "wasm-expression-stack",
                }
            }
        }
        impl ::std::str::FromStr for ScopeType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "global" | "Global" => Ok(ScopeType::Global),
                    "local" | "Local" => Ok(ScopeType::Local),
                    "with" | "With" => Ok(ScopeType::With),
                    "closure" | "Closure" => Ok(ScopeType::Closure),
                    "catch" | "Catch" => Ok(ScopeType::Catch),
                    "block" | "Block" => Ok(ScopeType::Block),
                    "script" | "Script" => Ok(ScopeType::Script),
                    "eval" | "Eval" => Ok(ScopeType::Eval),
                    "module" | "Module" => Ok(ScopeType::Module),
                    "wasm-expression-stack" | "WasmExpressionStack" => {
                        Ok(ScopeType::WasmExpressionStack)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl Scope {
            pub fn new(
                r#type: impl Into<ScopeType>,
                object: impl Into<super::runtime::RemoteObject>,
            ) -> Self {
                Self {
                    r#type: r#type.into(),
                    object: object.into(),
                    name: None,
                    start_location: None,
                    end_location: None,
                }
            }
        }
        impl Scope {
            pub fn builder() -> ScopeBuilder {
                ScopeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ScopeBuilder {
            r#type: Option<ScopeType>,
            object: Option<super::runtime::RemoteObject>,
            name: Option<String>,
            start_location: Option<Location>,
            end_location: Option<Location>,
        }
        impl ScopeBuilder {
            pub fn r#type(mut self, r#type: impl Into<ScopeType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn object(mut self, object: impl Into<super::runtime::RemoteObject>) -> Self {
                self.object = Some(object.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn start_location(mut self, start_location: impl Into<Location>) -> Self {
                self.start_location = Some(start_location.into());
                self
            }
            pub fn end_location(mut self, end_location: impl Into<Location>) -> Self {
                self.end_location = Some(end_location.into());
                self
            }
            pub fn build(self) -> Result<Scope, String> {
                Ok(Scope {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    object: self.object.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(object))
                    })?,
                    name: self.name,
                    start_location: self.start_location,
                    end_location: self.end_location,
                })
            }
        }
        impl Scope {
            pub const IDENTIFIER: &'static str = "Debugger.Scope";
        }
        #[doc = "Search match for resource.\n[SearchMatch](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#type-SearchMatch)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SearchMatch {
            #[doc = "Line number in resource content."]
            #[serde(rename = "lineNumber")]
            pub line_number: f64,
            #[doc = "Line with match content."]
            #[serde(rename = "lineContent")]
            pub line_content: String,
        }
        impl SearchMatch {
            pub fn new(line_number: impl Into<f64>, line_content: impl Into<String>) -> Self {
                Self {
                    line_number: line_number.into(),
                    line_content: line_content.into(),
                }
            }
        }
        impl SearchMatch {
            pub fn builder() -> SearchMatchBuilder {
                SearchMatchBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SearchMatchBuilder {
            line_number: Option<f64>,
            line_content: Option<String>,
        }
        impl SearchMatchBuilder {
            pub fn line_number(mut self, line_number: impl Into<f64>) -> Self {
                self.line_number = Some(line_number.into());
                self
            }
            pub fn line_content(mut self, line_content: impl Into<String>) -> Self {
                self.line_content = Some(line_content.into());
                self
            }
            pub fn build(self) -> Result<SearchMatch, String> {
                Ok(SearchMatch {
                    line_number: self.line_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line_number))
                    })?,
                    line_content: self.line_content.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line_content))
                    })?,
                })
            }
        }
        impl SearchMatch {
            pub const IDENTIFIER: &'static str = "Debugger.SearchMatch";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct BreakLocation {
            #[doc = "Script identifier as reported in the `Debugger.scriptParsed`."]
            #[serde(rename = "scriptId")]
            pub script_id: super::runtime::ScriptId,
            #[doc = "Line number in the script (0-based)."]
            #[serde(rename = "lineNumber")]
            pub line_number: i64,
            #[doc = "Column number in the script (0-based)."]
            #[serde(rename = "columnNumber")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub column_number: Option<i64>,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub r#type: Option<BreakLocationType>,
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum BreakLocationType {
            #[serde(rename = "debuggerStatement")]
            DebuggerStatement,
            #[serde(rename = "call")]
            Call,
            #[serde(rename = "return")]
            Return,
        }
        impl AsRef<str> for BreakLocationType {
            fn as_ref(&self) -> &str {
                match self {
                    BreakLocationType::DebuggerStatement => "debuggerStatement",
                    BreakLocationType::Call => "call",
                    BreakLocationType::Return => "return",
                }
            }
        }
        impl ::std::str::FromStr for BreakLocationType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "debuggerStatement" | "DebuggerStatement" | "debuggerstatement" => {
                        Ok(BreakLocationType::DebuggerStatement)
                    }
                    "call" | "Call" => Ok(BreakLocationType::Call),
                    "return" | "Return" => Ok(BreakLocationType::Return),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl BreakLocation {
            pub fn new(
                script_id: impl Into<super::runtime::ScriptId>,
                line_number: impl Into<i64>,
            ) -> Self {
                Self {
                    script_id: script_id.into(),
                    line_number: line_number.into(),
                    column_number: None,
                    r#type: None,
                }
            }
        }
        impl BreakLocation {
            pub fn builder() -> BreakLocationBuilder {
                BreakLocationBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BreakLocationBuilder {
            script_id: Option<super::runtime::ScriptId>,
            line_number: Option<i64>,
            column_number: Option<i64>,
            r#type: Option<BreakLocationType>,
        }
        impl BreakLocationBuilder {
            pub fn script_id(mut self, script_id: impl Into<super::runtime::ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn line_number(mut self, line_number: impl Into<i64>) -> Self {
                self.line_number = Some(line_number.into());
                self
            }
            pub fn column_number(mut self, column_number: impl Into<i64>) -> Self {
                self.column_number = Some(column_number.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<BreakLocationType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn build(self) -> Result<BreakLocation, String> {
                Ok(BreakLocation {
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                    line_number: self.line_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line_number))
                    })?,
                    column_number: self.column_number,
                    r#type: self.r#type,
                })
            }
        }
        impl BreakLocation {
            pub const IDENTIFIER: &'static str = "Debugger.BreakLocation";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct WasmDisassemblyChunk {
            #[doc = "The next chunk of disassembled lines."]
            #[serde(rename = "lines")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub lines: Vec<String>,
            #[doc = "The bytecode offsets describing the start of each line."]
            #[serde(rename = "bytecodeOffsets")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub bytecode_offsets: Vec<i64>,
        }
        impl WasmDisassemblyChunk {
            pub fn new(lines: Vec<String>, bytecode_offsets: Vec<i64>) -> Self {
                Self {
                    lines,
                    bytecode_offsets,
                }
            }
        }
        impl WasmDisassemblyChunk {
            pub fn builder() -> WasmDisassemblyChunkBuilder {
                WasmDisassemblyChunkBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct WasmDisassemblyChunkBuilder {
            lines: Option<Vec<String>>,
            bytecode_offsets: Option<Vec<i64>>,
        }
        impl WasmDisassemblyChunkBuilder {
            pub fn line(mut self, line: impl Into<String>) -> Self {
                let v = self.lines.get_or_insert(Vec::new());
                v.push(line.into());
                self
            }
            pub fn lines<I, S>(mut self, lines: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.lines.get_or_insert(Vec::new());
                for val in lines {
                    v.push(val.into());
                }
                self
            }
            pub fn bytecode_offset(mut self, bytecode_offset: impl Into<i64>) -> Self {
                let v = self.bytecode_offsets.get_or_insert(Vec::new());
                v.push(bytecode_offset.into());
                self
            }
            pub fn bytecode_offsets<I, S>(mut self, bytecode_offsets: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.bytecode_offsets.get_or_insert(Vec::new());
                for val in bytecode_offsets {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<WasmDisassemblyChunk, String> {
                Ok(WasmDisassemblyChunk {
                    lines: self.lines.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(lines))
                    })?,
                    bytecode_offsets: self.bytecode_offsets.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(bytecode_offsets)
                        )
                    })?,
                })
            }
        }
        impl WasmDisassemblyChunk {
            pub const IDENTIFIER: &'static str = "Debugger.WasmDisassemblyChunk";
        }
        #[doc = "Enum of possible script languages."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ScriptLanguage {
            #[serde(rename = "JavaScript")]
            JavaScript,
            #[serde(rename = "WebAssembly")]
            WebAssembly,
        }
        impl AsRef<str> for ScriptLanguage {
            fn as_ref(&self) -> &str {
                match self {
                    ScriptLanguage::JavaScript => "JavaScript",
                    ScriptLanguage::WebAssembly => "WebAssembly",
                }
            }
        }
        impl ::std::str::FromStr for ScriptLanguage {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "JavaScript" | "javascript" => Ok(ScriptLanguage::JavaScript),
                    "WebAssembly" | "webassembly" => Ok(ScriptLanguage::WebAssembly),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Debug symbols available for a wasm script.\n[DebugSymbols](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#type-DebugSymbols)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DebugSymbols {
            #[doc = "Type of the debug symbols."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: DebugSymbolsType,
            #[doc = "URL of the external symbol source."]
            #[serde(rename = "externalURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub external_url: Option<String>,
        }
        #[doc = "Type of the debug symbols."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum DebugSymbolsType {
            #[serde(rename = "None")]
            None,
            #[serde(rename = "SourceMap")]
            SourceMap,
            #[serde(rename = "EmbeddedDWARF")]
            EmbeddedDwarf,
            #[serde(rename = "ExternalDWARF")]
            ExternalDwarf,
        }
        impl AsRef<str> for DebugSymbolsType {
            fn as_ref(&self) -> &str {
                match self {
                    DebugSymbolsType::None => "None",
                    DebugSymbolsType::SourceMap => "SourceMap",
                    DebugSymbolsType::EmbeddedDwarf => "EmbeddedDWARF",
                    DebugSymbolsType::ExternalDwarf => "ExternalDWARF",
                }
            }
        }
        impl ::std::str::FromStr for DebugSymbolsType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "None" | "none" => Ok(DebugSymbolsType::None),
                    "SourceMap" | "sourcemap" => Ok(DebugSymbolsType::SourceMap),
                    "EmbeddedDWARF" | "EmbeddedDwarf" | "embeddeddwarf" => {
                        Ok(DebugSymbolsType::EmbeddedDwarf)
                    }
                    "ExternalDWARF" | "ExternalDwarf" | "externaldwarf" => {
                        Ok(DebugSymbolsType::ExternalDwarf)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl DebugSymbols {
            pub fn new(r#type: impl Into<DebugSymbolsType>) -> Self {
                Self {
                    r#type: r#type.into(),
                    external_url: None,
                }
            }
        }
        impl DebugSymbols {
            pub fn builder() -> DebugSymbolsBuilder {
                DebugSymbolsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DebugSymbolsBuilder {
            r#type: Option<DebugSymbolsType>,
            external_url: Option<String>,
        }
        impl DebugSymbolsBuilder {
            pub fn r#type(mut self, r#type: impl Into<DebugSymbolsType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn external_url(mut self, external_url: impl Into<String>) -> Self {
                self.external_url = Some(external_url.into());
                self
            }
            pub fn build(self) -> Result<DebugSymbols, String> {
                Ok(DebugSymbols {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    external_url: self.external_url,
                })
            }
        }
        impl DebugSymbols {
            pub const IDENTIFIER: &'static str = "Debugger.DebugSymbols";
        }
        #[doc = "Continues execution until specific location is reached.\n[continueToLocation](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-continueToLocation)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ContinueToLocationParams {
            #[doc = "Location to continue to."]
            #[serde(rename = "location")]
            pub location: Location,
            #[serde(rename = "targetCallFrames")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub target_call_frames: Option<ContinueToLocationTargetCallFrames>,
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ContinueToLocationTargetCallFrames {
            #[serde(rename = "any")]
            Any,
            #[serde(rename = "current")]
            Current,
        }
        impl AsRef<str> for ContinueToLocationTargetCallFrames {
            fn as_ref(&self) -> &str {
                match self {
                    ContinueToLocationTargetCallFrames::Any => "any",
                    ContinueToLocationTargetCallFrames::Current => "current",
                }
            }
        }
        impl ::std::str::FromStr for ContinueToLocationTargetCallFrames {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "any" | "Any" => Ok(ContinueToLocationTargetCallFrames::Any),
                    "current" | "Current" => Ok(ContinueToLocationTargetCallFrames::Current),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl ContinueToLocationParams {
            pub fn new(location: impl Into<Location>) -> Self {
                Self {
                    location: location.into(),
                    target_call_frames: None,
                }
            }
        }
        impl ContinueToLocationParams {
            pub fn builder() -> ContinueToLocationParamsBuilder {
                ContinueToLocationParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ContinueToLocationParamsBuilder {
            location: Option<Location>,
            target_call_frames: Option<ContinueToLocationTargetCallFrames>,
        }
        impl ContinueToLocationParamsBuilder {
            pub fn location(mut self, location: impl Into<Location>) -> Self {
                self.location = Some(location.into());
                self
            }
            pub fn target_call_frames(
                mut self,
                target_call_frames: impl Into<ContinueToLocationTargetCallFrames>,
            ) -> Self {
                self.target_call_frames = Some(target_call_frames.into());
                self
            }
            pub fn build(self) -> Result<ContinueToLocationParams, String> {
                Ok(ContinueToLocationParams {
                    location: self.location.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(location))
                    })?,
                    target_call_frames: self.target_call_frames,
                })
            }
        }
        impl ContinueToLocationParams {
            pub const IDENTIFIER: &'static str = "Debugger.continueToLocation";
        }
        impl chromiumoxide_types::Method for ContinueToLocationParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ContinueToLocationParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Continues execution until specific location is reached.\n[continueToLocation](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-continueToLocation)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ContinueToLocationReturns {}
        impl chromiumoxide_types::Command for ContinueToLocationParams {
            type Response = ContinueToLocationReturns;
        }
        #[doc = "Disables debugger for given page.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Debugger.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables debugger for given page.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables debugger for the given page. Clients should not assume that the debugging has been\nenabled until the result for this command is received.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {
            #[doc = "The maximum size in bytes of collected scripts (not referenced by other heap objects)\nthe debugger can hold. Puts no limit if parameter is omitted."]
            #[serde(rename = "maxScriptsCacheSize")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub max_scripts_cache_size: Option<f64>,
        }
        impl EnableParams {
            pub fn builder() -> EnableParamsBuilder {
                EnableParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EnableParamsBuilder {
            max_scripts_cache_size: Option<f64>,
        }
        impl EnableParamsBuilder {
            pub fn max_scripts_cache_size(
                mut self,
                max_scripts_cache_size: impl Into<f64>,
            ) -> Self {
                self.max_scripts_cache_size = Some(max_scripts_cache_size.into());
                self
            }
            pub fn build(self) -> EnableParams {
                EnableParams {
                    max_scripts_cache_size: self.max_scripts_cache_size,
                }
            }
        }
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Debugger.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables debugger for the given page. Clients should not assume that the debugging has been\nenabled until the result for this command is received.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EnableReturns {
            #[doc = "Unique identifier of the debugger."]
            #[serde(rename = "debuggerId")]
            pub debugger_id: super::runtime::UniqueDebuggerId,
        }
        impl EnableReturns {
            pub fn new(debugger_id: impl Into<super::runtime::UniqueDebuggerId>) -> Self {
                Self {
                    debugger_id: debugger_id.into(),
                }
            }
        }
        impl EnableReturns {
            pub fn builder() -> EnableReturnsBuilder {
                EnableReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EnableReturnsBuilder {
            debugger_id: Option<super::runtime::UniqueDebuggerId>,
        }
        impl EnableReturnsBuilder {
            pub fn debugger_id(
                mut self,
                debugger_id: impl Into<super::runtime::UniqueDebuggerId>,
            ) -> Self {
                self.debugger_id = Some(debugger_id.into());
                self
            }
            pub fn build(self) -> Result<EnableReturns, String> {
                Ok(EnableReturns {
                    debugger_id: self.debugger_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(debugger_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Evaluates expression on a given call frame.\n[evaluateOnCallFrame](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-evaluateOnCallFrame)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EvaluateOnCallFrameParams {
            #[doc = "Call frame identifier to evaluate on."]
            #[serde(rename = "callFrameId")]
            pub call_frame_id: CallFrameId,
            #[doc = "Expression to evaluate."]
            #[serde(rename = "expression")]
            pub expression: String,
            #[doc = "String object group name to put result into (allows rapid releasing resulting object handles\nusing `releaseObjectGroup`)."]
            #[serde(rename = "objectGroup")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_group: Option<String>,
            #[doc = "Specifies whether command line API should be available to the evaluated expression, defaults\nto false."]
            #[serde(rename = "includeCommandLineAPI")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub include_command_line_api: Option<bool>,
            #[doc = "In silent mode exceptions thrown during evaluation are not reported and do not pause\nexecution. Overrides `setPauseOnException` state."]
            #[serde(rename = "silent")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub silent: Option<bool>,
            #[doc = "Whether the result is expected to be a JSON object that should be sent by value."]
            #[serde(rename = "returnByValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub return_by_value: Option<bool>,
            #[doc = "Whether preview should be generated for the result."]
            #[serde(rename = "generatePreview")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub generate_preview: Option<bool>,
            #[doc = "Whether to throw an exception if side effect cannot be ruled out during evaluation."]
            #[serde(rename = "throwOnSideEffect")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub throw_on_side_effect: Option<bool>,
            #[doc = "Terminate execution after timing out (number of milliseconds)."]
            #[serde(rename = "timeout")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub timeout: Option<super::runtime::TimeDelta>,
        }
        impl EvaluateOnCallFrameParams {
            pub fn new(
                call_frame_id: impl Into<CallFrameId>,
                expression: impl Into<String>,
            ) -> Self {
                Self {
                    call_frame_id: call_frame_id.into(),
                    expression: expression.into(),
                    object_group: None,
                    include_command_line_api: None,
                    silent: None,
                    return_by_value: None,
                    generate_preview: None,
                    throw_on_side_effect: None,
                    timeout: None,
                }
            }
        }
        impl EvaluateOnCallFrameParams {
            pub fn builder() -> EvaluateOnCallFrameParamsBuilder {
                EvaluateOnCallFrameParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EvaluateOnCallFrameParamsBuilder {
            call_frame_id: Option<CallFrameId>,
            expression: Option<String>,
            object_group: Option<String>,
            include_command_line_api: Option<bool>,
            silent: Option<bool>,
            return_by_value: Option<bool>,
            generate_preview: Option<bool>,
            throw_on_side_effect: Option<bool>,
            timeout: Option<super::runtime::TimeDelta>,
        }
        impl EvaluateOnCallFrameParamsBuilder {
            pub fn call_frame_id(mut self, call_frame_id: impl Into<CallFrameId>) -> Self {
                self.call_frame_id = Some(call_frame_id.into());
                self
            }
            pub fn expression(mut self, expression: impl Into<String>) -> Self {
                self.expression = Some(expression.into());
                self
            }
            pub fn object_group(mut self, object_group: impl Into<String>) -> Self {
                self.object_group = Some(object_group.into());
                self
            }
            pub fn include_command_line_api(
                mut self,
                include_command_line_api: impl Into<bool>,
            ) -> Self {
                self.include_command_line_api = Some(include_command_line_api.into());
                self
            }
            pub fn silent(mut self, silent: impl Into<bool>) -> Self {
                self.silent = Some(silent.into());
                self
            }
            pub fn return_by_value(mut self, return_by_value: impl Into<bool>) -> Self {
                self.return_by_value = Some(return_by_value.into());
                self
            }
            pub fn generate_preview(mut self, generate_preview: impl Into<bool>) -> Self {
                self.generate_preview = Some(generate_preview.into());
                self
            }
            pub fn throw_on_side_effect(mut self, throw_on_side_effect: impl Into<bool>) -> Self {
                self.throw_on_side_effect = Some(throw_on_side_effect.into());
                self
            }
            pub fn timeout(mut self, timeout: impl Into<super::runtime::TimeDelta>) -> Self {
                self.timeout = Some(timeout.into());
                self
            }
            pub fn build(self) -> Result<EvaluateOnCallFrameParams, String> {
                Ok(EvaluateOnCallFrameParams {
                    call_frame_id: self.call_frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(call_frame_id))
                    })?,
                    expression: self.expression.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(expression))
                    })?,
                    object_group: self.object_group,
                    include_command_line_api: self.include_command_line_api,
                    silent: self.silent,
                    return_by_value: self.return_by_value,
                    generate_preview: self.generate_preview,
                    throw_on_side_effect: self.throw_on_side_effect,
                    timeout: self.timeout,
                })
            }
        }
        impl EvaluateOnCallFrameParams {
            pub const IDENTIFIER: &'static str = "Debugger.evaluateOnCallFrame";
        }
        impl chromiumoxide_types::Method for EvaluateOnCallFrameParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EvaluateOnCallFrameParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Evaluates expression on a given call frame.\n[evaluateOnCallFrame](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-evaluateOnCallFrame)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EvaluateOnCallFrameReturns {
            #[doc = "Object wrapper for the evaluation result."]
            #[serde(rename = "result")]
            pub result: super::runtime::RemoteObject,
            #[doc = "Exception details."]
            #[serde(rename = "exceptionDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub exception_details: Option<super::runtime::ExceptionDetails>,
        }
        impl EvaluateOnCallFrameReturns {
            pub fn new(result: impl Into<super::runtime::RemoteObject>) -> Self {
                Self {
                    result: result.into(),
                    exception_details: None,
                }
            }
        }
        impl EvaluateOnCallFrameReturns {
            pub fn builder() -> EvaluateOnCallFrameReturnsBuilder {
                EvaluateOnCallFrameReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EvaluateOnCallFrameReturnsBuilder {
            result: Option<super::runtime::RemoteObject>,
            exception_details: Option<super::runtime::ExceptionDetails>,
        }
        impl EvaluateOnCallFrameReturnsBuilder {
            pub fn result(mut self, result: impl Into<super::runtime::RemoteObject>) -> Self {
                self.result = Some(result.into());
                self
            }
            pub fn exception_details(
                mut self,
                exception_details: impl Into<super::runtime::ExceptionDetails>,
            ) -> Self {
                self.exception_details = Some(exception_details.into());
                self
            }
            pub fn build(self) -> Result<EvaluateOnCallFrameReturns, String> {
                Ok(EvaluateOnCallFrameReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                    exception_details: self.exception_details,
                })
            }
        }
        impl chromiumoxide_types::Command for EvaluateOnCallFrameParams {
            type Response = EvaluateOnCallFrameReturns;
        }
        #[doc = "Returns possible locations for breakpoint. scriptId in start and end range locations should be\nthe same.\n[getPossibleBreakpoints](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-getPossibleBreakpoints)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetPossibleBreakpointsParams {
            #[doc = "Start of range to search possible breakpoint locations in."]
            #[serde(rename = "start")]
            pub start: Location,
            #[doc = "End of range to search possible breakpoint locations in (excluding). When not specified, end\nof scripts is used as end of range."]
            #[serde(rename = "end")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub end: Option<Location>,
            #[doc = "Only consider locations which are in the same (non-nested) function as start."]
            #[serde(rename = "restrictToFunction")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub restrict_to_function: Option<bool>,
        }
        impl GetPossibleBreakpointsParams {
            pub fn new(start: impl Into<Location>) -> Self {
                Self {
                    start: start.into(),
                    end: None,
                    restrict_to_function: None,
                }
            }
        }
        impl GetPossibleBreakpointsParams {
            pub fn builder() -> GetPossibleBreakpointsParamsBuilder {
                GetPossibleBreakpointsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetPossibleBreakpointsParamsBuilder {
            start: Option<Location>,
            end: Option<Location>,
            restrict_to_function: Option<bool>,
        }
        impl GetPossibleBreakpointsParamsBuilder {
            pub fn start(mut self, start: impl Into<Location>) -> Self {
                self.start = Some(start.into());
                self
            }
            pub fn end(mut self, end: impl Into<Location>) -> Self {
                self.end = Some(end.into());
                self
            }
            pub fn restrict_to_function(mut self, restrict_to_function: impl Into<bool>) -> Self {
                self.restrict_to_function = Some(restrict_to_function.into());
                self
            }
            pub fn build(self) -> Result<GetPossibleBreakpointsParams, String> {
                Ok(GetPossibleBreakpointsParams {
                    start: self.start.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(start))
                    })?,
                    end: self.end,
                    restrict_to_function: self.restrict_to_function,
                })
            }
        }
        impl GetPossibleBreakpointsParams {
            pub const IDENTIFIER: &'static str = "Debugger.getPossibleBreakpoints";
        }
        impl chromiumoxide_types::Method for GetPossibleBreakpointsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetPossibleBreakpointsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns possible locations for breakpoint. scriptId in start and end range locations should be\nthe same.\n[getPossibleBreakpoints](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-getPossibleBreakpoints)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetPossibleBreakpointsReturns {
            #[doc = "List of the possible breakpoint locations."]
            #[serde(rename = "locations")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub locations: Vec<BreakLocation>,
        }
        impl GetPossibleBreakpointsReturns {
            pub fn new(locations: Vec<BreakLocation>) -> Self {
                Self { locations }
            }
        }
        impl GetPossibleBreakpointsReturns {
            pub fn builder() -> GetPossibleBreakpointsReturnsBuilder {
                GetPossibleBreakpointsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetPossibleBreakpointsReturnsBuilder {
            locations: Option<Vec<BreakLocation>>,
        }
        impl GetPossibleBreakpointsReturnsBuilder {
            pub fn location(mut self, location: impl Into<BreakLocation>) -> Self {
                let v = self.locations.get_or_insert(Vec::new());
                v.push(location.into());
                self
            }
            pub fn locations<I, S>(mut self, locations: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<BreakLocation>,
            {
                let v = self.locations.get_or_insert(Vec::new());
                for val in locations {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetPossibleBreakpointsReturns, String> {
                Ok(GetPossibleBreakpointsReturns {
                    locations: self.locations.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(locations))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetPossibleBreakpointsParams {
            type Response = GetPossibleBreakpointsReturns;
        }
        #[doc = "Returns source for the script with given id.\n[getScriptSource](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-getScriptSource)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetScriptSourceParams {
            #[doc = "Id of the script to get source for."]
            #[serde(rename = "scriptId")]
            pub script_id: super::runtime::ScriptId,
        }
        impl GetScriptSourceParams {
            pub fn new(script_id: impl Into<super::runtime::ScriptId>) -> Self {
                Self {
                    script_id: script_id.into(),
                }
            }
        }
        impl GetScriptSourceParams {
            pub fn builder() -> GetScriptSourceParamsBuilder {
                GetScriptSourceParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetScriptSourceParamsBuilder {
            script_id: Option<super::runtime::ScriptId>,
        }
        impl GetScriptSourceParamsBuilder {
            pub fn script_id(mut self, script_id: impl Into<super::runtime::ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn build(self) -> Result<GetScriptSourceParams, String> {
                Ok(GetScriptSourceParams {
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                })
            }
        }
        impl GetScriptSourceParams {
            pub const IDENTIFIER: &'static str = "Debugger.getScriptSource";
        }
        impl chromiumoxide_types::Method for GetScriptSourceParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetScriptSourceParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns source for the script with given id.\n[getScriptSource](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-getScriptSource)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetScriptSourceReturns {
            #[doc = "Script source (empty in case of Wasm bytecode)."]
            #[serde(rename = "scriptSource")]
            pub script_source: String,
            #[doc = "Wasm bytecode."]
            #[serde(rename = "bytecode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub bytecode: Option<chromiumoxide_types::Binary>,
        }
        impl GetScriptSourceReturns {
            pub fn new(script_source: impl Into<String>) -> Self {
                Self {
                    script_source: script_source.into(),
                    bytecode: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for GetScriptSourceReturns {
            fn from(url: T) -> Self {
                GetScriptSourceReturns::new(url)
            }
        }
        impl GetScriptSourceReturns {
            pub fn builder() -> GetScriptSourceReturnsBuilder {
                GetScriptSourceReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetScriptSourceReturnsBuilder {
            script_source: Option<String>,
            bytecode: Option<chromiumoxide_types::Binary>,
        }
        impl GetScriptSourceReturnsBuilder {
            pub fn script_source(mut self, script_source: impl Into<String>) -> Self {
                self.script_source = Some(script_source.into());
                self
            }
            pub fn bytecode(mut self, bytecode: impl Into<chromiumoxide_types::Binary>) -> Self {
                self.bytecode = Some(bytecode.into());
                self
            }
            pub fn build(self) -> Result<GetScriptSourceReturns, String> {
                Ok(GetScriptSourceReturns {
                    script_source: self.script_source.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_source))
                    })?,
                    bytecode: self.bytecode,
                })
            }
        }
        impl chromiumoxide_types::Command for GetScriptSourceParams {
            type Response = GetScriptSourceReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DisassembleWasmModuleParams {
            #[doc = "Id of the script to disassemble"]
            #[serde(rename = "scriptId")]
            pub script_id: super::runtime::ScriptId,
        }
        impl DisassembleWasmModuleParams {
            pub fn new(script_id: impl Into<super::runtime::ScriptId>) -> Self {
                Self {
                    script_id: script_id.into(),
                }
            }
        }
        impl DisassembleWasmModuleParams {
            pub fn builder() -> DisassembleWasmModuleParamsBuilder {
                DisassembleWasmModuleParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DisassembleWasmModuleParamsBuilder {
            script_id: Option<super::runtime::ScriptId>,
        }
        impl DisassembleWasmModuleParamsBuilder {
            pub fn script_id(mut self, script_id: impl Into<super::runtime::ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn build(self) -> Result<DisassembleWasmModuleParams, String> {
                Ok(DisassembleWasmModuleParams {
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                })
            }
        }
        impl DisassembleWasmModuleParams {
            pub const IDENTIFIER: &'static str = "Debugger.disassembleWasmModule";
        }
        impl chromiumoxide_types::Method for DisassembleWasmModuleParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisassembleWasmModuleParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DisassembleWasmModuleReturns {
            #[doc = "For large modules, return a stream from which additional chunks of\ndisassembly can be read successively."]
            #[serde(rename = "streamId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub stream_id: Option<String>,
            #[doc = "The total number of lines in the disassembly text."]
            #[serde(rename = "totalNumberOfLines")]
            pub total_number_of_lines: i64,
            #[doc = "The offsets of all function bodies, in the format [start1, end1,\nstart2, end2, ...] where all ends are exclusive."]
            #[serde(rename = "functionBodyOffsets")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub function_body_offsets: Vec<i64>,
            #[doc = "The first chunk of disassembly."]
            #[serde(rename = "chunk")]
            pub chunk: WasmDisassemblyChunk,
        }
        impl DisassembleWasmModuleReturns {
            pub fn new(
                total_number_of_lines: impl Into<i64>,
                function_body_offsets: Vec<i64>,
                chunk: impl Into<WasmDisassemblyChunk>,
            ) -> Self {
                Self {
                    total_number_of_lines: total_number_of_lines.into(),
                    function_body_offsets,
                    chunk: chunk.into(),
                    stream_id: None,
                }
            }
        }
        impl DisassembleWasmModuleReturns {
            pub fn builder() -> DisassembleWasmModuleReturnsBuilder {
                DisassembleWasmModuleReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DisassembleWasmModuleReturnsBuilder {
            stream_id: Option<String>,
            total_number_of_lines: Option<i64>,
            function_body_offsets: Option<Vec<i64>>,
            chunk: Option<WasmDisassemblyChunk>,
        }
        impl DisassembleWasmModuleReturnsBuilder {
            pub fn stream_id(mut self, stream_id: impl Into<String>) -> Self {
                self.stream_id = Some(stream_id.into());
                self
            }
            pub fn total_number_of_lines(mut self, total_number_of_lines: impl Into<i64>) -> Self {
                self.total_number_of_lines = Some(total_number_of_lines.into());
                self
            }
            pub fn function_body_offset(mut self, function_body_offset: impl Into<i64>) -> Self {
                let v = self.function_body_offsets.get_or_insert(Vec::new());
                v.push(function_body_offset.into());
                self
            }
            pub fn function_body_offsets<I, S>(mut self, function_body_offsets: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.function_body_offsets.get_or_insert(Vec::new());
                for val in function_body_offsets {
                    v.push(val.into());
                }
                self
            }
            pub fn chunk(mut self, chunk: impl Into<WasmDisassemblyChunk>) -> Self {
                self.chunk = Some(chunk.into());
                self
            }
            pub fn build(self) -> Result<DisassembleWasmModuleReturns, String> {
                Ok(DisassembleWasmModuleReturns {
                    stream_id: self.stream_id,
                    total_number_of_lines: self.total_number_of_lines.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(total_number_of_lines)
                        )
                    })?,
                    function_body_offsets: self.function_body_offsets.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(function_body_offsets)
                        )
                    })?,
                    chunk: self.chunk.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(chunk))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for DisassembleWasmModuleParams {
            type Response = DisassembleWasmModuleReturns;
        }
        #[doc = "Disassemble the next chunk of lines for the module corresponding to the\nstream. If disassembly is complete, this API will invalidate the streamId\nand return an empty chunk. Any subsequent calls for the now invalid stream\nwill return errors.\n[nextWasmDisassemblyChunk](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-nextWasmDisassemblyChunk)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct NextWasmDisassemblyChunkParams {
            #[serde(rename = "streamId")]
            pub stream_id: String,
        }
        impl NextWasmDisassemblyChunkParams {
            pub fn new(stream_id: impl Into<String>) -> Self {
                Self {
                    stream_id: stream_id.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for NextWasmDisassemblyChunkParams {
            fn from(url: T) -> Self {
                NextWasmDisassemblyChunkParams::new(url)
            }
        }
        impl NextWasmDisassemblyChunkParams {
            pub fn builder() -> NextWasmDisassemblyChunkParamsBuilder {
                NextWasmDisassemblyChunkParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct NextWasmDisassemblyChunkParamsBuilder {
            stream_id: Option<String>,
        }
        impl NextWasmDisassemblyChunkParamsBuilder {
            pub fn stream_id(mut self, stream_id: impl Into<String>) -> Self {
                self.stream_id = Some(stream_id.into());
                self
            }
            pub fn build(self) -> Result<NextWasmDisassemblyChunkParams, String> {
                Ok(NextWasmDisassemblyChunkParams {
                    stream_id: self.stream_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(stream_id))
                    })?,
                })
            }
        }
        impl NextWasmDisassemblyChunkParams {
            pub const IDENTIFIER: &'static str = "Debugger.nextWasmDisassemblyChunk";
        }
        impl chromiumoxide_types::Method for NextWasmDisassemblyChunkParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for NextWasmDisassemblyChunkParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disassemble the next chunk of lines for the module corresponding to the\nstream. If disassembly is complete, this API will invalidate the streamId\nand return an empty chunk. Any subsequent calls for the now invalid stream\nwill return errors.\n[nextWasmDisassemblyChunk](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-nextWasmDisassemblyChunk)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct NextWasmDisassemblyChunkReturns {
            #[doc = "The next chunk of disassembly."]
            #[serde(rename = "chunk")]
            pub chunk: WasmDisassemblyChunk,
        }
        impl NextWasmDisassemblyChunkReturns {
            pub fn new(chunk: impl Into<WasmDisassemblyChunk>) -> Self {
                Self {
                    chunk: chunk.into(),
                }
            }
        }
        impl NextWasmDisassemblyChunkReturns {
            pub fn builder() -> NextWasmDisassemblyChunkReturnsBuilder {
                NextWasmDisassemblyChunkReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct NextWasmDisassemblyChunkReturnsBuilder {
            chunk: Option<WasmDisassemblyChunk>,
        }
        impl NextWasmDisassemblyChunkReturnsBuilder {
            pub fn chunk(mut self, chunk: impl Into<WasmDisassemblyChunk>) -> Self {
                self.chunk = Some(chunk.into());
                self
            }
            pub fn build(self) -> Result<NextWasmDisassemblyChunkReturns, String> {
                Ok(NextWasmDisassemblyChunkReturns {
                    chunk: self.chunk.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(chunk))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for NextWasmDisassemblyChunkParams {
            type Response = NextWasmDisassemblyChunkReturns;
        }
        #[doc = "Returns stack trace with given `stackTraceId`.\n[getStackTrace](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-getStackTrace)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetStackTraceParams {
            #[serde(rename = "stackTraceId")]
            pub stack_trace_id: super::runtime::StackTraceId,
        }
        impl GetStackTraceParams {
            pub fn new(stack_trace_id: impl Into<super::runtime::StackTraceId>) -> Self {
                Self {
                    stack_trace_id: stack_trace_id.into(),
                }
            }
        }
        impl GetStackTraceParams {
            pub fn builder() -> GetStackTraceParamsBuilder {
                GetStackTraceParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetStackTraceParamsBuilder {
            stack_trace_id: Option<super::runtime::StackTraceId>,
        }
        impl GetStackTraceParamsBuilder {
            pub fn stack_trace_id(
                mut self,
                stack_trace_id: impl Into<super::runtime::StackTraceId>,
            ) -> Self {
                self.stack_trace_id = Some(stack_trace_id.into());
                self
            }
            pub fn build(self) -> Result<GetStackTraceParams, String> {
                Ok(GetStackTraceParams {
                    stack_trace_id: self.stack_trace_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(stack_trace_id))
                    })?,
                })
            }
        }
        impl GetStackTraceParams {
            pub const IDENTIFIER: &'static str = "Debugger.getStackTrace";
        }
        impl chromiumoxide_types::Method for GetStackTraceParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetStackTraceParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns stack trace with given `stackTraceId`.\n[getStackTrace](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-getStackTrace)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetStackTraceReturns {
            #[serde(rename = "stackTrace")]
            pub stack_trace: super::runtime::StackTrace,
        }
        impl GetStackTraceReturns {
            pub fn new(stack_trace: impl Into<super::runtime::StackTrace>) -> Self {
                Self {
                    stack_trace: stack_trace.into(),
                }
            }
        }
        impl GetStackTraceReturns {
            pub fn builder() -> GetStackTraceReturnsBuilder {
                GetStackTraceReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetStackTraceReturnsBuilder {
            stack_trace: Option<super::runtime::StackTrace>,
        }
        impl GetStackTraceReturnsBuilder {
            pub fn stack_trace(
                mut self,
                stack_trace: impl Into<super::runtime::StackTrace>,
            ) -> Self {
                self.stack_trace = Some(stack_trace.into());
                self
            }
            pub fn build(self) -> Result<GetStackTraceReturns, String> {
                Ok(GetStackTraceReturns {
                    stack_trace: self.stack_trace.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(stack_trace))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetStackTraceParams {
            type Response = GetStackTraceReturns;
        }
        #[doc = "Stops on the next JavaScript statement.\n[pause](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-pause)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct PauseParams {}
        impl PauseParams {
            pub const IDENTIFIER: &'static str = "Debugger.pause";
        }
        impl chromiumoxide_types::Method for PauseParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for PauseParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Stops on the next JavaScript statement.\n[pause](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-pause)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct PauseReturns {}
        impl chromiumoxide_types::Command for PauseParams {
            type Response = PauseReturns;
        }
        #[doc = "Removes JavaScript breakpoint.\n[removeBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-removeBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoveBreakpointParams {
            #[serde(rename = "breakpointId")]
            pub breakpoint_id: BreakpointId,
        }
        impl RemoveBreakpointParams {
            pub fn new(breakpoint_id: impl Into<BreakpointId>) -> Self {
                Self {
                    breakpoint_id: breakpoint_id.into(),
                }
            }
        }
        impl RemoveBreakpointParams {
            pub fn builder() -> RemoveBreakpointParamsBuilder {
                RemoveBreakpointParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoveBreakpointParamsBuilder {
            breakpoint_id: Option<BreakpointId>,
        }
        impl RemoveBreakpointParamsBuilder {
            pub fn breakpoint_id(mut self, breakpoint_id: impl Into<BreakpointId>) -> Self {
                self.breakpoint_id = Some(breakpoint_id.into());
                self
            }
            pub fn build(self) -> Result<RemoveBreakpointParams, String> {
                Ok(RemoveBreakpointParams {
                    breakpoint_id: self.breakpoint_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(breakpoint_id))
                    })?,
                })
            }
        }
        impl RemoveBreakpointParams {
            pub const IDENTIFIER: &'static str = "Debugger.removeBreakpoint";
        }
        impl chromiumoxide_types::Method for RemoveBreakpointParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RemoveBreakpointParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Removes JavaScript breakpoint.\n[removeBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-removeBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RemoveBreakpointReturns {}
        impl chromiumoxide_types::Command for RemoveBreakpointParams {
            type Response = RemoveBreakpointReturns;
        }
        #[doc = "Restarts particular call frame from the beginning. The old, deprecated\nbehavior of `restartFrame` is to stay paused and allow further CDP commands\nafter a restart was scheduled. This can cause problems with restarting, so\nwe now continue execution immediatly after it has been scheduled until we\nreach the beginning of the restarted frame.\n\nTo stay back-wards compatible, `restartFrame` now expects a `mode`\nparameter to be present. If the `mode` parameter is missing, `restartFrame`\nerrors out.\n\nThe various return values are deprecated and `callFrames` is always empty.\nUse the call frames from the `Debugger#paused` events instead, that fires\nonce V8 pauses at the beginning of the restarted function.\n[restartFrame](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-restartFrame)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RestartFrameParams {
            #[doc = "Call frame identifier to evaluate on."]
            #[serde(rename = "callFrameId")]
            pub call_frame_id: CallFrameId,
            #[doc = "The `mode` parameter must be present and set to 'StepInto', otherwise\n`restartFrame` will error out."]
            #[serde(rename = "mode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub mode: Option<RestartFrameMode>,
        }
        #[doc = "The `mode` parameter must be present and set to 'StepInto', otherwise\n`restartFrame` will error out."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum RestartFrameMode {
            #[doc = "Pause at the beginning of the restarted function"]
            #[serde(rename = "StepInto")]
            StepInto,
        }
        impl AsRef<str> for RestartFrameMode {
            fn as_ref(&self) -> &str {
                match self {
                    RestartFrameMode::StepInto => "StepInto",
                }
            }
        }
        impl ::std::str::FromStr for RestartFrameMode {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "StepInto" | "stepinto" => Ok(RestartFrameMode::StepInto),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl RestartFrameParams {
            pub fn new(call_frame_id: impl Into<CallFrameId>) -> Self {
                Self {
                    call_frame_id: call_frame_id.into(),
                    mode: None,
                }
            }
        }
        impl RestartFrameParams {
            pub fn builder() -> RestartFrameParamsBuilder {
                RestartFrameParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RestartFrameParamsBuilder {
            call_frame_id: Option<CallFrameId>,
            mode: Option<RestartFrameMode>,
        }
        impl RestartFrameParamsBuilder {
            pub fn call_frame_id(mut self, call_frame_id: impl Into<CallFrameId>) -> Self {
                self.call_frame_id = Some(call_frame_id.into());
                self
            }
            pub fn mode(mut self, mode: impl Into<RestartFrameMode>) -> Self {
                self.mode = Some(mode.into());
                self
            }
            pub fn build(self) -> Result<RestartFrameParams, String> {
                Ok(RestartFrameParams {
                    call_frame_id: self.call_frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(call_frame_id))
                    })?,
                    mode: self.mode,
                })
            }
        }
        impl RestartFrameParams {
            pub const IDENTIFIER: &'static str = "Debugger.restartFrame";
        }
        impl chromiumoxide_types::Method for RestartFrameParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RestartFrameParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Restarts particular call frame from the beginning. The old, deprecated\nbehavior of `restartFrame` is to stay paused and allow further CDP commands\nafter a restart was scheduled. This can cause problems with restarting, so\nwe now continue execution immediatly after it has been scheduled until we\nreach the beginning of the restarted frame.\n\nTo stay back-wards compatible, `restartFrame` now expects a `mode`\nparameter to be present. If the `mode` parameter is missing, `restartFrame`\nerrors out.\n\nThe various return values are deprecated and `callFrames` is always empty.\nUse the call frames from the `Debugger#paused` events instead, that fires\nonce V8 pauses at the beginning of the restarted function.\n[restartFrame](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-restartFrame)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RestartFrameReturns {}
        impl chromiumoxide_types::Command for RestartFrameParams {
            type Response = RestartFrameReturns;
        }
        #[doc = "Resumes JavaScript execution.\n[resume](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-resume)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ResumeParams {
            #[doc = "Set to true to terminate execution upon resuming execution. In contrast\nto Runtime.terminateExecution, this will allows to execute further\nJavaScript (i.e. via evaluation) until execution of the paused code\nis actually resumed, at which point termination is triggered.\nIf execution is currently not paused, this parameter has no effect."]
            #[serde(rename = "terminateOnResume")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub terminate_on_resume: Option<bool>,
        }
        impl ResumeParams {
            pub fn builder() -> ResumeParamsBuilder {
                ResumeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ResumeParamsBuilder {
            terminate_on_resume: Option<bool>,
        }
        impl ResumeParamsBuilder {
            pub fn terminate_on_resume(mut self, terminate_on_resume: impl Into<bool>) -> Self {
                self.terminate_on_resume = Some(terminate_on_resume.into());
                self
            }
            pub fn build(self) -> ResumeParams {
                ResumeParams {
                    terminate_on_resume: self.terminate_on_resume,
                }
            }
        }
        impl ResumeParams {
            pub const IDENTIFIER: &'static str = "Debugger.resume";
        }
        impl chromiumoxide_types::Method for ResumeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ResumeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Resumes JavaScript execution.\n[resume](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-resume)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ResumeReturns {}
        impl chromiumoxide_types::Command for ResumeParams {
            type Response = ResumeReturns;
        }
        #[doc = "Searches for given string in script content.\n[searchInContent](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-searchInContent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SearchInContentParams {
            #[doc = "Id of the script to search in."]
            #[serde(rename = "scriptId")]
            pub script_id: super::runtime::ScriptId,
            #[doc = "String to search for."]
            #[serde(rename = "query")]
            pub query: String,
            #[doc = "If true, search is case sensitive."]
            #[serde(rename = "caseSensitive")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub case_sensitive: Option<bool>,
            #[doc = "If true, treats string parameter as regex."]
            #[serde(rename = "isRegex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_regex: Option<bool>,
        }
        impl SearchInContentParams {
            pub fn new(
                script_id: impl Into<super::runtime::ScriptId>,
                query: impl Into<String>,
            ) -> Self {
                Self {
                    script_id: script_id.into(),
                    query: query.into(),
                    case_sensitive: None,
                    is_regex: None,
                }
            }
        }
        impl SearchInContentParams {
            pub fn builder() -> SearchInContentParamsBuilder {
                SearchInContentParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SearchInContentParamsBuilder {
            script_id: Option<super::runtime::ScriptId>,
            query: Option<String>,
            case_sensitive: Option<bool>,
            is_regex: Option<bool>,
        }
        impl SearchInContentParamsBuilder {
            pub fn script_id(mut self, script_id: impl Into<super::runtime::ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn query(mut self, query: impl Into<String>) -> Self {
                self.query = Some(query.into());
                self
            }
            pub fn case_sensitive(mut self, case_sensitive: impl Into<bool>) -> Self {
                self.case_sensitive = Some(case_sensitive.into());
                self
            }
            pub fn is_regex(mut self, is_regex: impl Into<bool>) -> Self {
                self.is_regex = Some(is_regex.into());
                self
            }
            pub fn build(self) -> Result<SearchInContentParams, String> {
                Ok(SearchInContentParams {
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                    query: self.query.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(query))
                    })?,
                    case_sensitive: self.case_sensitive,
                    is_regex: self.is_regex,
                })
            }
        }
        impl SearchInContentParams {
            pub const IDENTIFIER: &'static str = "Debugger.searchInContent";
        }
        impl chromiumoxide_types::Method for SearchInContentParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SearchInContentParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Searches for given string in script content.\n[searchInContent](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-searchInContent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SearchInContentReturns {
            #[doc = "List of search matches."]
            #[serde(rename = "result")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub result: Vec<SearchMatch>,
        }
        impl SearchInContentReturns {
            pub fn new(result: Vec<SearchMatch>) -> Self {
                Self { result }
            }
        }
        impl SearchInContentReturns {
            pub fn builder() -> SearchInContentReturnsBuilder {
                SearchInContentReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SearchInContentReturnsBuilder {
            result: Option<Vec<SearchMatch>>,
        }
        impl SearchInContentReturnsBuilder {
            pub fn result(mut self, result: impl Into<SearchMatch>) -> Self {
                let v = self.result.get_or_insert(Vec::new());
                v.push(result.into());
                self
            }
            pub fn results<I, S>(mut self, results: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<SearchMatch>,
            {
                let v = self.result.get_or_insert(Vec::new());
                for val in results {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SearchInContentReturns, String> {
                Ok(SearchInContentReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SearchInContentParams {
            type Response = SearchInContentReturns;
        }
        #[doc = "Enables or disables async call stacks tracking.\n[setAsyncCallStackDepth](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setAsyncCallStackDepth)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetAsyncCallStackDepthParams {
            #[doc = "Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async\ncall stacks (default)."]
            #[serde(rename = "maxDepth")]
            pub max_depth: i64,
        }
        impl SetAsyncCallStackDepthParams {
            pub fn new(max_depth: impl Into<i64>) -> Self {
                Self {
                    max_depth: max_depth.into(),
                }
            }
        }
        impl SetAsyncCallStackDepthParams {
            pub fn builder() -> SetAsyncCallStackDepthParamsBuilder {
                SetAsyncCallStackDepthParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetAsyncCallStackDepthParamsBuilder {
            max_depth: Option<i64>,
        }
        impl SetAsyncCallStackDepthParamsBuilder {
            pub fn max_depth(mut self, max_depth: impl Into<i64>) -> Self {
                self.max_depth = Some(max_depth.into());
                self
            }
            pub fn build(self) -> Result<SetAsyncCallStackDepthParams, String> {
                Ok(SetAsyncCallStackDepthParams {
                    max_depth: self.max_depth.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(max_depth))
                    })?,
                })
            }
        }
        impl SetAsyncCallStackDepthParams {
            pub const IDENTIFIER: &'static str = "Debugger.setAsyncCallStackDepth";
        }
        impl chromiumoxide_types::Method for SetAsyncCallStackDepthParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetAsyncCallStackDepthParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables or disables async call stacks tracking.\n[setAsyncCallStackDepth](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setAsyncCallStackDepth)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetAsyncCallStackDepthReturns {}
        impl chromiumoxide_types::Command for SetAsyncCallStackDepthParams {
            type Response = SetAsyncCallStackDepthReturns;
        }
        #[doc = "Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in\nscripts with url matching one of the patterns. VM will try to leave blackboxed script by\nperforming 'step in' several times, finally resorting to 'step out' if unsuccessful.\n[setBlackboxPatterns](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBlackboxPatterns)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetBlackboxPatternsParams {
            #[doc = "Array of regexps that will be used to check script url for blackbox state."]
            #[serde(rename = "patterns")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub patterns: Vec<String>,
        }
        impl SetBlackboxPatternsParams {
            pub fn new(patterns: Vec<String>) -> Self {
                Self { patterns }
            }
        }
        impl SetBlackboxPatternsParams {
            pub fn builder() -> SetBlackboxPatternsParamsBuilder {
                SetBlackboxPatternsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetBlackboxPatternsParamsBuilder {
            patterns: Option<Vec<String>>,
        }
        impl SetBlackboxPatternsParamsBuilder {
            pub fn pattern(mut self, pattern: impl Into<String>) -> Self {
                let v = self.patterns.get_or_insert(Vec::new());
                v.push(pattern.into());
                self
            }
            pub fn patterns<I, S>(mut self, patterns: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.patterns.get_or_insert(Vec::new());
                for val in patterns {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetBlackboxPatternsParams, String> {
                Ok(SetBlackboxPatternsParams {
                    patterns: self.patterns.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(patterns))
                    })?,
                })
            }
        }
        impl SetBlackboxPatternsParams {
            pub const IDENTIFIER: &'static str = "Debugger.setBlackboxPatterns";
        }
        impl chromiumoxide_types::Method for SetBlackboxPatternsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetBlackboxPatternsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in\nscripts with url matching one of the patterns. VM will try to leave blackboxed script by\nperforming 'step in' several times, finally resorting to 'step out' if unsuccessful.\n[setBlackboxPatterns](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBlackboxPatterns)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetBlackboxPatternsReturns {}
        impl chromiumoxide_types::Command for SetBlackboxPatternsParams {
            type Response = SetBlackboxPatternsReturns;
        }
        #[doc = "Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted\nscripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.\nPositions array contains positions where blackbox state is changed. First interval isn't\nblackboxed. Array should be sorted.\n[setBlackboxedRanges](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBlackboxedRanges)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetBlackboxedRangesParams {
            #[doc = "Id of the script."]
            #[serde(rename = "scriptId")]
            pub script_id: super::runtime::ScriptId,
            #[serde(rename = "positions")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub positions: Vec<ScriptPosition>,
        }
        impl SetBlackboxedRangesParams {
            pub fn new(
                script_id: impl Into<super::runtime::ScriptId>,
                positions: Vec<ScriptPosition>,
            ) -> Self {
                Self {
                    script_id: script_id.into(),
                    positions,
                }
            }
        }
        impl SetBlackboxedRangesParams {
            pub fn builder() -> SetBlackboxedRangesParamsBuilder {
                SetBlackboxedRangesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetBlackboxedRangesParamsBuilder {
            script_id: Option<super::runtime::ScriptId>,
            positions: Option<Vec<ScriptPosition>>,
        }
        impl SetBlackboxedRangesParamsBuilder {
            pub fn script_id(mut self, script_id: impl Into<super::runtime::ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn position(mut self, position: impl Into<ScriptPosition>) -> Self {
                let v = self.positions.get_or_insert(Vec::new());
                v.push(position.into());
                self
            }
            pub fn positions<I, S>(mut self, positions: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ScriptPosition>,
            {
                let v = self.positions.get_or_insert(Vec::new());
                for val in positions {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetBlackboxedRangesParams, String> {
                Ok(SetBlackboxedRangesParams {
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                    positions: self.positions.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(positions))
                    })?,
                })
            }
        }
        impl SetBlackboxedRangesParams {
            pub const IDENTIFIER: &'static str = "Debugger.setBlackboxedRanges";
        }
        impl chromiumoxide_types::Method for SetBlackboxedRangesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetBlackboxedRangesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted\nscripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.\nPositions array contains positions where blackbox state is changed. First interval isn't\nblackboxed. Array should be sorted.\n[setBlackboxedRanges](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBlackboxedRanges)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetBlackboxedRangesReturns {}
        impl chromiumoxide_types::Command for SetBlackboxedRangesParams {
            type Response = SetBlackboxedRangesReturns;
        }
        #[doc = "Sets JavaScript breakpoint at a given location.\n[setBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetBreakpointParams {
            #[doc = "Location to set breakpoint in."]
            #[serde(rename = "location")]
            pub location: Location,
            #[doc = "Expression to use as a breakpoint condition. When specified, debugger will only stop on the\nbreakpoint if this expression evaluates to true."]
            #[serde(rename = "condition")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub condition: Option<String>,
        }
        impl SetBreakpointParams {
            pub fn new(location: impl Into<Location>) -> Self {
                Self {
                    location: location.into(),
                    condition: None,
                }
            }
        }
        impl SetBreakpointParams {
            pub fn builder() -> SetBreakpointParamsBuilder {
                SetBreakpointParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetBreakpointParamsBuilder {
            location: Option<Location>,
            condition: Option<String>,
        }
        impl SetBreakpointParamsBuilder {
            pub fn location(mut self, location: impl Into<Location>) -> Self {
                self.location = Some(location.into());
                self
            }
            pub fn condition(mut self, condition: impl Into<String>) -> Self {
                self.condition = Some(condition.into());
                self
            }
            pub fn build(self) -> Result<SetBreakpointParams, String> {
                Ok(SetBreakpointParams {
                    location: self.location.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(location))
                    })?,
                    condition: self.condition,
                })
            }
        }
        impl SetBreakpointParams {
            pub const IDENTIFIER: &'static str = "Debugger.setBreakpoint";
        }
        impl chromiumoxide_types::Method for SetBreakpointParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetBreakpointParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets JavaScript breakpoint at a given location.\n[setBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetBreakpointReturns {
            #[doc = "Id of the created breakpoint for further reference."]
            #[serde(rename = "breakpointId")]
            pub breakpoint_id: BreakpointId,
            #[doc = "Location this breakpoint resolved into."]
            #[serde(rename = "actualLocation")]
            pub actual_location: Location,
        }
        impl SetBreakpointReturns {
            pub fn new(
                breakpoint_id: impl Into<BreakpointId>,
                actual_location: impl Into<Location>,
            ) -> Self {
                Self {
                    breakpoint_id: breakpoint_id.into(),
                    actual_location: actual_location.into(),
                }
            }
        }
        impl SetBreakpointReturns {
            pub fn builder() -> SetBreakpointReturnsBuilder {
                SetBreakpointReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetBreakpointReturnsBuilder {
            breakpoint_id: Option<BreakpointId>,
            actual_location: Option<Location>,
        }
        impl SetBreakpointReturnsBuilder {
            pub fn breakpoint_id(mut self, breakpoint_id: impl Into<BreakpointId>) -> Self {
                self.breakpoint_id = Some(breakpoint_id.into());
                self
            }
            pub fn actual_location(mut self, actual_location: impl Into<Location>) -> Self {
                self.actual_location = Some(actual_location.into());
                self
            }
            pub fn build(self) -> Result<SetBreakpointReturns, String> {
                Ok(SetBreakpointReturns {
                    breakpoint_id: self.breakpoint_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(breakpoint_id))
                    })?,
                    actual_location: self.actual_location.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(actual_location))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SetBreakpointParams {
            type Response = SetBreakpointReturns;
        }
        #[doc = "Sets instrumentation breakpoint.\n[setInstrumentationBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setInstrumentationBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetInstrumentationBreakpointParams {
            #[doc = "Instrumentation name."]
            #[serde(rename = "instrumentation")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub instrumentation: SetInstrumentationBreakpointInstrumentation,
        }
        #[doc = "Instrumentation name."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SetInstrumentationBreakpointInstrumentation {
            #[serde(rename = "beforeScriptExecution")]
            BeforeScriptExecution,
            #[serde(rename = "beforeScriptWithSourceMapExecution")]
            BeforeScriptWithSourceMapExecution,
        }
        impl AsRef<str> for SetInstrumentationBreakpointInstrumentation {
            fn as_ref(&self) -> &str {
                match self { SetInstrumentationBreakpointInstrumentation :: BeforeScriptExecution => "beforeScriptExecution" , SetInstrumentationBreakpointInstrumentation :: BeforeScriptWithSourceMapExecution => "beforeScriptWithSourceMapExecution" }
            }
        }
        impl ::std::str::FromStr for SetInstrumentationBreakpointInstrumentation {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s { "beforeScriptExecution" | "BeforeScriptExecution" | "beforescriptexecution" => Ok (SetInstrumentationBreakpointInstrumentation :: BeforeScriptExecution) , "beforeScriptWithSourceMapExecution" | "BeforeScriptWithSourceMapExecution" | "beforescriptwithsourcemapexecution" => Ok (SetInstrumentationBreakpointInstrumentation :: BeforeScriptWithSourceMapExecution) , _ => Err (s . to_string ()) }
            }
        }
        impl SetInstrumentationBreakpointParams {
            pub fn new(
                instrumentation: impl Into<SetInstrumentationBreakpointInstrumentation>,
            ) -> Self {
                Self {
                    instrumentation: instrumentation.into(),
                }
            }
        }
        impl SetInstrumentationBreakpointParams {
            pub fn builder() -> SetInstrumentationBreakpointParamsBuilder {
                SetInstrumentationBreakpointParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetInstrumentationBreakpointParamsBuilder {
            instrumentation: Option<SetInstrumentationBreakpointInstrumentation>,
        }
        impl SetInstrumentationBreakpointParamsBuilder {
            pub fn instrumentation(
                mut self,
                instrumentation: impl Into<SetInstrumentationBreakpointInstrumentation>,
            ) -> Self {
                self.instrumentation = Some(instrumentation.into());
                self
            }
            pub fn build(self) -> Result<SetInstrumentationBreakpointParams, String> {
                Ok(SetInstrumentationBreakpointParams {
                    instrumentation: self.instrumentation.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(instrumentation))
                    })?,
                })
            }
        }
        impl SetInstrumentationBreakpointParams {
            pub const IDENTIFIER: &'static str = "Debugger.setInstrumentationBreakpoint";
        }
        impl chromiumoxide_types::Method for SetInstrumentationBreakpointParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetInstrumentationBreakpointParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets instrumentation breakpoint.\n[setInstrumentationBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setInstrumentationBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetInstrumentationBreakpointReturns {
            #[doc = "Id of the created breakpoint for further reference."]
            #[serde(rename = "breakpointId")]
            pub breakpoint_id: BreakpointId,
        }
        impl SetInstrumentationBreakpointReturns {
            pub fn new(breakpoint_id: impl Into<BreakpointId>) -> Self {
                Self {
                    breakpoint_id: breakpoint_id.into(),
                }
            }
        }
        impl SetInstrumentationBreakpointReturns {
            pub fn builder() -> SetInstrumentationBreakpointReturnsBuilder {
                SetInstrumentationBreakpointReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetInstrumentationBreakpointReturnsBuilder {
            breakpoint_id: Option<BreakpointId>,
        }
        impl SetInstrumentationBreakpointReturnsBuilder {
            pub fn breakpoint_id(mut self, breakpoint_id: impl Into<BreakpointId>) -> Self {
                self.breakpoint_id = Some(breakpoint_id.into());
                self
            }
            pub fn build(self) -> Result<SetInstrumentationBreakpointReturns, String> {
                Ok(SetInstrumentationBreakpointReturns {
                    breakpoint_id: self.breakpoint_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(breakpoint_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SetInstrumentationBreakpointParams {
            type Response = SetInstrumentationBreakpointReturns;
        }
        #[doc = "Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this\ncommand is issued, all existing parsed scripts will have breakpoints resolved and returned in\n`locations` property. Further matching script parsing will result in subsequent\n`breakpointResolved` events issued. This logical breakpoint will survive page reloads.\n[setBreakpointByUrl](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBreakpointByUrl)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetBreakpointByUrlParams {
            #[doc = "Line number to set breakpoint at."]
            #[serde(rename = "lineNumber")]
            pub line_number: i64,
            #[doc = "URL of the resources to set breakpoint on."]
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url: Option<String>,
            #[doc = "Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or\n`urlRegex` must be specified."]
            #[serde(rename = "urlRegex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url_regex: Option<String>,
            #[doc = "Script hash of the resources to set breakpoint on."]
            #[serde(rename = "scriptHash")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub script_hash: Option<String>,
            #[doc = "Offset in the line to set breakpoint at."]
            #[serde(rename = "columnNumber")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub column_number: Option<i64>,
            #[doc = "Expression to use as a breakpoint condition. When specified, debugger will only stop on the\nbreakpoint if this expression evaluates to true."]
            #[serde(rename = "condition")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub condition: Option<String>,
        }
        impl SetBreakpointByUrlParams {
            pub fn new(line_number: impl Into<i64>) -> Self {
                Self {
                    line_number: line_number.into(),
                    url: None,
                    url_regex: None,
                    script_hash: None,
                    column_number: None,
                    condition: None,
                }
            }
        }
        impl SetBreakpointByUrlParams {
            pub fn builder() -> SetBreakpointByUrlParamsBuilder {
                SetBreakpointByUrlParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetBreakpointByUrlParamsBuilder {
            line_number: Option<i64>,
            url: Option<String>,
            url_regex: Option<String>,
            script_hash: Option<String>,
            column_number: Option<i64>,
            condition: Option<String>,
        }
        impl SetBreakpointByUrlParamsBuilder {
            pub fn line_number(mut self, line_number: impl Into<i64>) -> Self {
                self.line_number = Some(line_number.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn url_regex(mut self, url_regex: impl Into<String>) -> Self {
                self.url_regex = Some(url_regex.into());
                self
            }
            pub fn script_hash(mut self, script_hash: impl Into<String>) -> Self {
                self.script_hash = Some(script_hash.into());
                self
            }
            pub fn column_number(mut self, column_number: impl Into<i64>) -> Self {
                self.column_number = Some(column_number.into());
                self
            }
            pub fn condition(mut self, condition: impl Into<String>) -> Self {
                self.condition = Some(condition.into());
                self
            }
            pub fn build(self) -> Result<SetBreakpointByUrlParams, String> {
                Ok(SetBreakpointByUrlParams {
                    line_number: self.line_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line_number))
                    })?,
                    url: self.url,
                    url_regex: self.url_regex,
                    script_hash: self.script_hash,
                    column_number: self.column_number,
                    condition: self.condition,
                })
            }
        }
        impl SetBreakpointByUrlParams {
            pub const IDENTIFIER: &'static str = "Debugger.setBreakpointByUrl";
        }
        impl chromiumoxide_types::Method for SetBreakpointByUrlParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetBreakpointByUrlParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this\ncommand is issued, all existing parsed scripts will have breakpoints resolved and returned in\n`locations` property. Further matching script parsing will result in subsequent\n`breakpointResolved` events issued. This logical breakpoint will survive page reloads.\n[setBreakpointByUrl](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBreakpointByUrl)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetBreakpointByUrlReturns {
            #[doc = "Id of the created breakpoint for further reference."]
            #[serde(rename = "breakpointId")]
            pub breakpoint_id: BreakpointId,
            #[doc = "List of the locations this breakpoint resolved into upon addition."]
            #[serde(rename = "locations")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub locations: Vec<Location>,
        }
        impl SetBreakpointByUrlReturns {
            pub fn new(breakpoint_id: impl Into<BreakpointId>, locations: Vec<Location>) -> Self {
                Self {
                    breakpoint_id: breakpoint_id.into(),
                    locations,
                }
            }
        }
        impl SetBreakpointByUrlReturns {
            pub fn builder() -> SetBreakpointByUrlReturnsBuilder {
                SetBreakpointByUrlReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetBreakpointByUrlReturnsBuilder {
            breakpoint_id: Option<BreakpointId>,
            locations: Option<Vec<Location>>,
        }
        impl SetBreakpointByUrlReturnsBuilder {
            pub fn breakpoint_id(mut self, breakpoint_id: impl Into<BreakpointId>) -> Self {
                self.breakpoint_id = Some(breakpoint_id.into());
                self
            }
            pub fn location(mut self, location: impl Into<Location>) -> Self {
                let v = self.locations.get_or_insert(Vec::new());
                v.push(location.into());
                self
            }
            pub fn locations<I, S>(mut self, locations: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Location>,
            {
                let v = self.locations.get_or_insert(Vec::new());
                for val in locations {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetBreakpointByUrlReturns, String> {
                Ok(SetBreakpointByUrlReturns {
                    breakpoint_id: self.breakpoint_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(breakpoint_id))
                    })?,
                    locations: self.locations.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(locations))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SetBreakpointByUrlParams {
            type Response = SetBreakpointByUrlReturns;
        }
        #[doc = "Sets JavaScript breakpoint before each call to the given function.\nIf another function was created from the same source as a given one,\ncalling it will also trigger the breakpoint.\n[setBreakpointOnFunctionCall](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBreakpointOnFunctionCall)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetBreakpointOnFunctionCallParams {
            #[doc = "Function object id."]
            #[serde(rename = "objectId")]
            pub object_id: super::runtime::RemoteObjectId,
            #[doc = "Expression to use as a breakpoint condition. When specified, debugger will\nstop on the breakpoint if this expression evaluates to true."]
            #[serde(rename = "condition")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub condition: Option<String>,
        }
        impl SetBreakpointOnFunctionCallParams {
            pub fn new(object_id: impl Into<super::runtime::RemoteObjectId>) -> Self {
                Self {
                    object_id: object_id.into(),
                    condition: None,
                }
            }
        }
        impl SetBreakpointOnFunctionCallParams {
            pub fn builder() -> SetBreakpointOnFunctionCallParamsBuilder {
                SetBreakpointOnFunctionCallParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetBreakpointOnFunctionCallParamsBuilder {
            object_id: Option<super::runtime::RemoteObjectId>,
            condition: Option<String>,
        }
        impl SetBreakpointOnFunctionCallParamsBuilder {
            pub fn object_id(
                mut self,
                object_id: impl Into<super::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn condition(mut self, condition: impl Into<String>) -> Self {
                self.condition = Some(condition.into());
                self
            }
            pub fn build(self) -> Result<SetBreakpointOnFunctionCallParams, String> {
                Ok(SetBreakpointOnFunctionCallParams {
                    object_id: self.object_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(object_id))
                    })?,
                    condition: self.condition,
                })
            }
        }
        impl SetBreakpointOnFunctionCallParams {
            pub const IDENTIFIER: &'static str = "Debugger.setBreakpointOnFunctionCall";
        }
        impl chromiumoxide_types::Method for SetBreakpointOnFunctionCallParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetBreakpointOnFunctionCallParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets JavaScript breakpoint before each call to the given function.\nIf another function was created from the same source as a given one,\ncalling it will also trigger the breakpoint.\n[setBreakpointOnFunctionCall](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBreakpointOnFunctionCall)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetBreakpointOnFunctionCallReturns {
            #[doc = "Id of the created breakpoint for further reference."]
            #[serde(rename = "breakpointId")]
            pub breakpoint_id: BreakpointId,
        }
        impl SetBreakpointOnFunctionCallReturns {
            pub fn new(breakpoint_id: impl Into<BreakpointId>) -> Self {
                Self {
                    breakpoint_id: breakpoint_id.into(),
                }
            }
        }
        impl SetBreakpointOnFunctionCallReturns {
            pub fn builder() -> SetBreakpointOnFunctionCallReturnsBuilder {
                SetBreakpointOnFunctionCallReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetBreakpointOnFunctionCallReturnsBuilder {
            breakpoint_id: Option<BreakpointId>,
        }
        impl SetBreakpointOnFunctionCallReturnsBuilder {
            pub fn breakpoint_id(mut self, breakpoint_id: impl Into<BreakpointId>) -> Self {
                self.breakpoint_id = Some(breakpoint_id.into());
                self
            }
            pub fn build(self) -> Result<SetBreakpointOnFunctionCallReturns, String> {
                Ok(SetBreakpointOnFunctionCallReturns {
                    breakpoint_id: self.breakpoint_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(breakpoint_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SetBreakpointOnFunctionCallParams {
            type Response = SetBreakpointOnFunctionCallReturns;
        }
        #[doc = "Activates / deactivates all breakpoints on the page.\n[setBreakpointsActive](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBreakpointsActive)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetBreakpointsActiveParams {
            #[doc = "New value for breakpoints active state."]
            #[serde(rename = "active")]
            pub active: bool,
        }
        impl SetBreakpointsActiveParams {
            pub fn new(active: impl Into<bool>) -> Self {
                Self {
                    active: active.into(),
                }
            }
        }
        impl SetBreakpointsActiveParams {
            pub fn builder() -> SetBreakpointsActiveParamsBuilder {
                SetBreakpointsActiveParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetBreakpointsActiveParamsBuilder {
            active: Option<bool>,
        }
        impl SetBreakpointsActiveParamsBuilder {
            pub fn active(mut self, active: impl Into<bool>) -> Self {
                self.active = Some(active.into());
                self
            }
            pub fn build(self) -> Result<SetBreakpointsActiveParams, String> {
                Ok(SetBreakpointsActiveParams {
                    active: self.active.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(active))
                    })?,
                })
            }
        }
        impl SetBreakpointsActiveParams {
            pub const IDENTIFIER: &'static str = "Debugger.setBreakpointsActive";
        }
        impl chromiumoxide_types::Method for SetBreakpointsActiveParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetBreakpointsActiveParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Activates / deactivates all breakpoints on the page.\n[setBreakpointsActive](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBreakpointsActive)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetBreakpointsActiveReturns {}
        impl chromiumoxide_types::Command for SetBreakpointsActiveParams {
            type Response = SetBreakpointsActiveReturns;
        }
        #[doc = "Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or\nno exceptions. Initial pause on exceptions state is `none`.\n[setPauseOnExceptions](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setPauseOnExceptions)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetPauseOnExceptionsParams {
            #[doc = "Pause on exceptions mode."]
            #[serde(rename = "state")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub state: SetPauseOnExceptionsState,
        }
        #[doc = "Pause on exceptions mode."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SetPauseOnExceptionsState {
            #[serde(rename = "none")]
            None,
            #[serde(rename = "uncaught")]
            Uncaught,
            #[serde(rename = "all")]
            All,
        }
        impl AsRef<str> for SetPauseOnExceptionsState {
            fn as_ref(&self) -> &str {
                match self {
                    SetPauseOnExceptionsState::None => "none",
                    SetPauseOnExceptionsState::Uncaught => "uncaught",
                    SetPauseOnExceptionsState::All => "all",
                }
            }
        }
        impl ::std::str::FromStr for SetPauseOnExceptionsState {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "none" | "None" => Ok(SetPauseOnExceptionsState::None),
                    "uncaught" | "Uncaught" => Ok(SetPauseOnExceptionsState::Uncaught),
                    "all" | "All" => Ok(SetPauseOnExceptionsState::All),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl SetPauseOnExceptionsParams {
            pub fn new(state: impl Into<SetPauseOnExceptionsState>) -> Self {
                Self {
                    state: state.into(),
                }
            }
        }
        impl SetPauseOnExceptionsParams {
            pub fn builder() -> SetPauseOnExceptionsParamsBuilder {
                SetPauseOnExceptionsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetPauseOnExceptionsParamsBuilder {
            state: Option<SetPauseOnExceptionsState>,
        }
        impl SetPauseOnExceptionsParamsBuilder {
            pub fn state(mut self, state: impl Into<SetPauseOnExceptionsState>) -> Self {
                self.state = Some(state.into());
                self
            }
            pub fn build(self) -> Result<SetPauseOnExceptionsParams, String> {
                Ok(SetPauseOnExceptionsParams {
                    state: self.state.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(state))
                    })?,
                })
            }
        }
        impl SetPauseOnExceptionsParams {
            pub const IDENTIFIER: &'static str = "Debugger.setPauseOnExceptions";
        }
        impl chromiumoxide_types::Method for SetPauseOnExceptionsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetPauseOnExceptionsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or\nno exceptions. Initial pause on exceptions state is `none`.\n[setPauseOnExceptions](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setPauseOnExceptions)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetPauseOnExceptionsReturns {}
        impl chromiumoxide_types::Command for SetPauseOnExceptionsParams {
            type Response = SetPauseOnExceptionsReturns;
        }
        #[doc = "Changes return value in top frame. Available only at return break position.\n[setReturnValue](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setReturnValue)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetReturnValueParams {
            #[doc = "New return value."]
            #[serde(rename = "newValue")]
            pub new_value: super::runtime::CallArgument,
        }
        impl SetReturnValueParams {
            pub fn new(new_value: impl Into<super::runtime::CallArgument>) -> Self {
                Self {
                    new_value: new_value.into(),
                }
            }
        }
        impl SetReturnValueParams {
            pub fn builder() -> SetReturnValueParamsBuilder {
                SetReturnValueParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetReturnValueParamsBuilder {
            new_value: Option<super::runtime::CallArgument>,
        }
        impl SetReturnValueParamsBuilder {
            pub fn new_value(mut self, new_value: impl Into<super::runtime::CallArgument>) -> Self {
                self.new_value = Some(new_value.into());
                self
            }
            pub fn build(self) -> Result<SetReturnValueParams, String> {
                Ok(SetReturnValueParams {
                    new_value: self.new_value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(new_value))
                    })?,
                })
            }
        }
        impl SetReturnValueParams {
            pub const IDENTIFIER: &'static str = "Debugger.setReturnValue";
        }
        impl chromiumoxide_types::Method for SetReturnValueParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetReturnValueParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Changes return value in top frame. Available only at return break position.\n[setReturnValue](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setReturnValue)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetReturnValueReturns {}
        impl chromiumoxide_types::Command for SetReturnValueParams {
            type Response = SetReturnValueReturns;
        }
        #[doc = "Edits JavaScript source live.\n\nIn general, functions that are currently on the stack can not be edited with\na single exception: If the edited function is the top-most stack frame and\nthat is the only activation of that function on the stack. In this case\nthe live edit will be successful and a `Debugger.restartFrame` for the\ntop-most function is automatically triggered.\n[setScriptSource](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setScriptSource)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetScriptSourceParams {
            #[doc = "Id of the script to edit."]
            #[serde(rename = "scriptId")]
            pub script_id: super::runtime::ScriptId,
            #[doc = "New content of the script."]
            #[serde(rename = "scriptSource")]
            pub script_source: String,
            #[doc = "If true the change will not actually be applied. Dry run may be used to get result\ndescription without actually modifying the code."]
            #[serde(rename = "dryRun")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub dry_run: Option<bool>,
            #[doc = "If true, then `scriptSource` is allowed to change the function on top of the stack\nas long as the top-most stack frame is the only activation of that function."]
            #[serde(rename = "allowTopFrameEditing")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub allow_top_frame_editing: Option<bool>,
        }
        impl SetScriptSourceParams {
            pub fn new(
                script_id: impl Into<super::runtime::ScriptId>,
                script_source: impl Into<String>,
            ) -> Self {
                Self {
                    script_id: script_id.into(),
                    script_source: script_source.into(),
                    dry_run: None,
                    allow_top_frame_editing: None,
                }
            }
        }
        impl SetScriptSourceParams {
            pub fn builder() -> SetScriptSourceParamsBuilder {
                SetScriptSourceParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetScriptSourceParamsBuilder {
            script_id: Option<super::runtime::ScriptId>,
            script_source: Option<String>,
            dry_run: Option<bool>,
            allow_top_frame_editing: Option<bool>,
        }
        impl SetScriptSourceParamsBuilder {
            pub fn script_id(mut self, script_id: impl Into<super::runtime::ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn script_source(mut self, script_source: impl Into<String>) -> Self {
                self.script_source = Some(script_source.into());
                self
            }
            pub fn dry_run(mut self, dry_run: impl Into<bool>) -> Self {
                self.dry_run = Some(dry_run.into());
                self
            }
            pub fn allow_top_frame_editing(
                mut self,
                allow_top_frame_editing: impl Into<bool>,
            ) -> Self {
                self.allow_top_frame_editing = Some(allow_top_frame_editing.into());
                self
            }
            pub fn build(self) -> Result<SetScriptSourceParams, String> {
                Ok(SetScriptSourceParams {
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                    script_source: self.script_source.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_source))
                    })?,
                    dry_run: self.dry_run,
                    allow_top_frame_editing: self.allow_top_frame_editing,
                })
            }
        }
        impl SetScriptSourceParams {
            pub const IDENTIFIER: &'static str = "Debugger.setScriptSource";
        }
        impl chromiumoxide_types::Method for SetScriptSourceParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetScriptSourceParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Edits JavaScript source live.\n\nIn general, functions that are currently on the stack can not be edited with\na single exception: If the edited function is the top-most stack frame and\nthat is the only activation of that function on the stack. In this case\nthe live edit will be successful and a `Debugger.restartFrame` for the\ntop-most function is automatically triggered.\n[setScriptSource](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setScriptSource)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetScriptSourceReturns {
            #[doc = "Whether the operation was successful or not. Only `Ok` denotes a\nsuccessful live edit while the other enum variants denote why\nthe live edit failed."]
            #[serde(rename = "status")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub status: SetScriptSourceStatus,
            #[doc = "Exception details if any. Only present when `status` is `CompileError`."]
            #[serde(rename = "exceptionDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub exception_details: Option<super::runtime::ExceptionDetails>,
        }
        #[doc = "Whether the operation was successful or not. Only `Ok` denotes a\nsuccessful live edit while the other enum variants denote why\nthe live edit failed."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SetScriptSourceStatus {
            #[serde(rename = "Ok")]
            Ok,
            #[serde(rename = "CompileError")]
            CompileError,
            #[serde(rename = "BlockedByActiveGenerator")]
            BlockedByActiveGenerator,
            #[serde(rename = "BlockedByActiveFunction")]
            BlockedByActiveFunction,
        }
        impl AsRef<str> for SetScriptSourceStatus {
            fn as_ref(&self) -> &str {
                match self {
                    SetScriptSourceStatus::Ok => "Ok",
                    SetScriptSourceStatus::CompileError => "CompileError",
                    SetScriptSourceStatus::BlockedByActiveGenerator => "BlockedByActiveGenerator",
                    SetScriptSourceStatus::BlockedByActiveFunction => "BlockedByActiveFunction",
                }
            }
        }
        impl ::std::str::FromStr for SetScriptSourceStatus {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Ok" | "ok" => Ok(SetScriptSourceStatus::Ok),
                    "CompileError" | "compileerror" => Ok(SetScriptSourceStatus::CompileError),
                    "BlockedByActiveGenerator" | "blockedbyactivegenerator" => {
                        Ok(SetScriptSourceStatus::BlockedByActiveGenerator)
                    }
                    "BlockedByActiveFunction" | "blockedbyactivefunction" => {
                        Ok(SetScriptSourceStatus::BlockedByActiveFunction)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl SetScriptSourceReturns {
            pub fn new(status: impl Into<SetScriptSourceStatus>) -> Self {
                Self {
                    status: status.into(),
                    exception_details: None,
                }
            }
        }
        impl SetScriptSourceReturns {
            pub fn builder() -> SetScriptSourceReturnsBuilder {
                SetScriptSourceReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetScriptSourceReturnsBuilder {
            status: Option<SetScriptSourceStatus>,
            exception_details: Option<super::runtime::ExceptionDetails>,
        }
        impl SetScriptSourceReturnsBuilder {
            pub fn status(mut self, status: impl Into<SetScriptSourceStatus>) -> Self {
                self.status = Some(status.into());
                self
            }
            pub fn exception_details(
                mut self,
                exception_details: impl Into<super::runtime::ExceptionDetails>,
            ) -> Self {
                self.exception_details = Some(exception_details.into());
                self
            }
            pub fn build(self) -> Result<SetScriptSourceReturns, String> {
                Ok(SetScriptSourceReturns {
                    status: self.status.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(status))
                    })?,
                    exception_details: self.exception_details,
                })
            }
        }
        impl chromiumoxide_types::Command for SetScriptSourceParams {
            type Response = SetScriptSourceReturns;
        }
        #[doc = "Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).\n[setSkipAllPauses](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setSkipAllPauses)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetSkipAllPausesParams {
            #[doc = "New value for skip pauses state."]
            #[serde(rename = "skip")]
            pub skip: bool,
        }
        impl SetSkipAllPausesParams {
            pub fn new(skip: impl Into<bool>) -> Self {
                Self { skip: skip.into() }
            }
        }
        impl SetSkipAllPausesParams {
            pub fn builder() -> SetSkipAllPausesParamsBuilder {
                SetSkipAllPausesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetSkipAllPausesParamsBuilder {
            skip: Option<bool>,
        }
        impl SetSkipAllPausesParamsBuilder {
            pub fn skip(mut self, skip: impl Into<bool>) -> Self {
                self.skip = Some(skip.into());
                self
            }
            pub fn build(self) -> Result<SetSkipAllPausesParams, String> {
                Ok(SetSkipAllPausesParams {
                    skip: self.skip.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(skip))
                    })?,
                })
            }
        }
        impl SetSkipAllPausesParams {
            pub const IDENTIFIER: &'static str = "Debugger.setSkipAllPauses";
        }
        impl chromiumoxide_types::Method for SetSkipAllPausesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetSkipAllPausesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).\n[setSkipAllPauses](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setSkipAllPauses)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetSkipAllPausesReturns {}
        impl chromiumoxide_types::Command for SetSkipAllPausesParams {
            type Response = SetSkipAllPausesReturns;
        }
        #[doc = "Changes value of variable in a callframe. Object-based scopes are not supported and must be\nmutated manually.\n[setVariableValue](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setVariableValue)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetVariableValueParams {
            #[doc = "0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'\nscope types are allowed. Other scopes could be manipulated manually."]
            #[serde(rename = "scopeNumber")]
            pub scope_number: i64,
            #[doc = "Variable name."]
            #[serde(rename = "variableName")]
            pub variable_name: String,
            #[doc = "New variable value."]
            #[serde(rename = "newValue")]
            pub new_value: super::runtime::CallArgument,
            #[doc = "Id of callframe that holds variable."]
            #[serde(rename = "callFrameId")]
            pub call_frame_id: CallFrameId,
        }
        impl SetVariableValueParams {
            pub fn new(
                scope_number: impl Into<i64>,
                variable_name: impl Into<String>,
                new_value: impl Into<super::runtime::CallArgument>,
                call_frame_id: impl Into<CallFrameId>,
            ) -> Self {
                Self {
                    scope_number: scope_number.into(),
                    variable_name: variable_name.into(),
                    new_value: new_value.into(),
                    call_frame_id: call_frame_id.into(),
                }
            }
        }
        impl SetVariableValueParams {
            pub fn builder() -> SetVariableValueParamsBuilder {
                SetVariableValueParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetVariableValueParamsBuilder {
            scope_number: Option<i64>,
            variable_name: Option<String>,
            new_value: Option<super::runtime::CallArgument>,
            call_frame_id: Option<CallFrameId>,
        }
        impl SetVariableValueParamsBuilder {
            pub fn scope_number(mut self, scope_number: impl Into<i64>) -> Self {
                self.scope_number = Some(scope_number.into());
                self
            }
            pub fn variable_name(mut self, variable_name: impl Into<String>) -> Self {
                self.variable_name = Some(variable_name.into());
                self
            }
            pub fn new_value(mut self, new_value: impl Into<super::runtime::CallArgument>) -> Self {
                self.new_value = Some(new_value.into());
                self
            }
            pub fn call_frame_id(mut self, call_frame_id: impl Into<CallFrameId>) -> Self {
                self.call_frame_id = Some(call_frame_id.into());
                self
            }
            pub fn build(self) -> Result<SetVariableValueParams, String> {
                Ok(SetVariableValueParams {
                    scope_number: self.scope_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scope_number))
                    })?,
                    variable_name: self.variable_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(variable_name))
                    })?,
                    new_value: self.new_value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(new_value))
                    })?,
                    call_frame_id: self.call_frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(call_frame_id))
                    })?,
                })
            }
        }
        impl SetVariableValueParams {
            pub const IDENTIFIER: &'static str = "Debugger.setVariableValue";
        }
        impl chromiumoxide_types::Method for SetVariableValueParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetVariableValueParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Changes value of variable in a callframe. Object-based scopes are not supported and must be\nmutated manually.\n[setVariableValue](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setVariableValue)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetVariableValueReturns {}
        impl chromiumoxide_types::Command for SetVariableValueParams {
            type Response = SetVariableValueReturns;
        }
        #[doc = "Steps into the function call.\n[stepInto](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-stepInto)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StepIntoParams {
            #[doc = "Debugger will pause on the execution of the first async task which was scheduled\nbefore next pause."]
            #[serde(rename = "breakOnAsyncCall")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub break_on_async_call: Option<bool>,
            #[doc = "The skipList specifies location ranges that should be skipped on step into."]
            #[serde(rename = "skipList")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub skip_list: Option<Vec<LocationRange>>,
        }
        impl StepIntoParams {
            pub fn builder() -> StepIntoParamsBuilder {
                StepIntoParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StepIntoParamsBuilder {
            break_on_async_call: Option<bool>,
            skip_list: Option<Vec<LocationRange>>,
        }
        impl StepIntoParamsBuilder {
            pub fn break_on_async_call(mut self, break_on_async_call: impl Into<bool>) -> Self {
                self.break_on_async_call = Some(break_on_async_call.into());
                self
            }
            pub fn skip_list(mut self, skip_list: impl Into<LocationRange>) -> Self {
                let v = self.skip_list.get_or_insert(Vec::new());
                v.push(skip_list.into());
                self
            }
            pub fn skip_lists<I, S>(mut self, skip_lists: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<LocationRange>,
            {
                let v = self.skip_list.get_or_insert(Vec::new());
                for val in skip_lists {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> StepIntoParams {
                StepIntoParams {
                    break_on_async_call: self.break_on_async_call,
                    skip_list: self.skip_list,
                }
            }
        }
        impl StepIntoParams {
            pub const IDENTIFIER: &'static str = "Debugger.stepInto";
        }
        impl chromiumoxide_types::Method for StepIntoParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StepIntoParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Steps into the function call.\n[stepInto](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-stepInto)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StepIntoReturns {}
        impl chromiumoxide_types::Command for StepIntoParams {
            type Response = StepIntoReturns;
        }
        #[doc = "Steps out of the function call.\n[stepOut](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-stepOut)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StepOutParams {}
        impl StepOutParams {
            pub const IDENTIFIER: &'static str = "Debugger.stepOut";
        }
        impl chromiumoxide_types::Method for StepOutParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StepOutParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Steps out of the function call.\n[stepOut](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-stepOut)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StepOutReturns {}
        impl chromiumoxide_types::Command for StepOutParams {
            type Response = StepOutReturns;
        }
        #[doc = "Steps over the statement.\n[stepOver](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-stepOver)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StepOverParams {
            #[doc = "The skipList specifies location ranges that should be skipped on step over."]
            #[serde(rename = "skipList")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub skip_list: Option<Vec<LocationRange>>,
        }
        impl StepOverParams {
            pub fn builder() -> StepOverParamsBuilder {
                StepOverParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StepOverParamsBuilder {
            skip_list: Option<Vec<LocationRange>>,
        }
        impl StepOverParamsBuilder {
            pub fn skip_list(mut self, skip_list: impl Into<LocationRange>) -> Self {
                let v = self.skip_list.get_or_insert(Vec::new());
                v.push(skip_list.into());
                self
            }
            pub fn skip_lists<I, S>(mut self, skip_lists: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<LocationRange>,
            {
                let v = self.skip_list.get_or_insert(Vec::new());
                for val in skip_lists {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> StepOverParams {
                StepOverParams {
                    skip_list: self.skip_list,
                }
            }
        }
        impl StepOverParams {
            pub const IDENTIFIER: &'static str = "Debugger.stepOver";
        }
        impl chromiumoxide_types::Method for StepOverParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StepOverParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Steps over the statement.\n[stepOver](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-stepOver)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StepOverReturns {}
        impl chromiumoxide_types::Command for StepOverParams {
            type Response = StepOverReturns;
        }
        #[doc = "Fired when breakpoint is resolved to an actual script and location.\n[breakpointResolved](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#event-breakpointResolved)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventBreakpointResolved {
            #[doc = "Breakpoint unique identifier."]
            #[serde(rename = "breakpointId")]
            pub breakpoint_id: BreakpointId,
            #[doc = "Actual breakpoint location."]
            #[serde(rename = "location")]
            pub location: Location,
        }
        impl EventBreakpointResolved {
            pub const IDENTIFIER: &'static str = "Debugger.breakpointResolved";
        }
        impl chromiumoxide_types::Method for EventBreakpointResolved {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventBreakpointResolved {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.\n[paused](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#event-paused)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventPaused {
            #[doc = "Call stack the virtual machine stopped on."]
            #[serde(rename = "callFrames")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub call_frames: Vec<CallFrame>,
            #[doc = "Pause reason."]
            #[serde(rename = "reason")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub reason: PausedReason,
            #[doc = "Object containing break-specific auxiliary properties."]
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub data: Option<serde_json::Value>,
            #[doc = "Hit breakpoints IDs"]
            #[serde(rename = "hitBreakpoints")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub hit_breakpoints: Option<Vec<String>>,
            #[doc = "Async stack trace, if any."]
            #[serde(rename = "asyncStackTrace")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub async_stack_trace: Option<super::runtime::StackTrace>,
            #[doc = "Async stack trace, if any."]
            #[serde(rename = "asyncStackTraceId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub async_stack_trace_id: Option<super::runtime::StackTraceId>,
        }
        #[doc = "Pause reason."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PausedReason {
            #[serde(rename = "ambiguous")]
            Ambiguous,
            #[serde(rename = "assert")]
            Assert,
            #[serde(rename = "CSPViolation")]
            CspViolation,
            #[serde(rename = "debugCommand")]
            DebugCommand,
            #[serde(rename = "DOM")]
            Dom,
            #[serde(rename = "EventListener")]
            EventListener,
            #[serde(rename = "exception")]
            Exception,
            #[serde(rename = "instrumentation")]
            Instrumentation,
            #[serde(rename = "OOM")]
            Oom,
            #[serde(rename = "other")]
            Other,
            #[serde(rename = "promiseRejection")]
            PromiseRejection,
            #[serde(rename = "XHR")]
            Xhr,
        }
        impl AsRef<str> for PausedReason {
            fn as_ref(&self) -> &str {
                match self {
                    PausedReason::Ambiguous => "ambiguous",
                    PausedReason::Assert => "assert",
                    PausedReason::CspViolation => "CSPViolation",
                    PausedReason::DebugCommand => "debugCommand",
                    PausedReason::Dom => "DOM",
                    PausedReason::EventListener => "EventListener",
                    PausedReason::Exception => "exception",
                    PausedReason::Instrumentation => "instrumentation",
                    PausedReason::Oom => "OOM",
                    PausedReason::Other => "other",
                    PausedReason::PromiseRejection => "promiseRejection",
                    PausedReason::Xhr => "XHR",
                }
            }
        }
        impl ::std::str::FromStr for PausedReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "ambiguous" | "Ambiguous" => Ok(PausedReason::Ambiguous),
                    "assert" | "Assert" => Ok(PausedReason::Assert),
                    "CSPViolation" | "CspViolation" | "cspviolation" => {
                        Ok(PausedReason::CspViolation)
                    }
                    "debugCommand" | "DebugCommand" | "debugcommand" => {
                        Ok(PausedReason::DebugCommand)
                    }
                    "DOM" | "Dom" | "dom" => Ok(PausedReason::Dom),
                    "EventListener" | "eventlistener" => Ok(PausedReason::EventListener),
                    "exception" | "Exception" => Ok(PausedReason::Exception),
                    "instrumentation" | "Instrumentation" => Ok(PausedReason::Instrumentation),
                    "OOM" | "Oom" | "oom" => Ok(PausedReason::Oom),
                    "other" | "Other" => Ok(PausedReason::Other),
                    "promiseRejection" | "PromiseRejection" | "promiserejection" => {
                        Ok(PausedReason::PromiseRejection)
                    }
                    "XHR" | "Xhr" | "xhr" => Ok(PausedReason::Xhr),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl EventPaused {
            pub const IDENTIFIER: &'static str = "Debugger.paused";
        }
        impl chromiumoxide_types::Method for EventPaused {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventPaused {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when the virtual machine resumed execution.\n[resumed](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#event-resumed)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventResumed {}
        impl EventResumed {
            pub const IDENTIFIER: &'static str = "Debugger.resumed";
        }
        impl chromiumoxide_types::Method for EventResumed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventResumed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when virtual machine fails to parse the script.\n[scriptFailedToParse](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#event-scriptFailedToParse)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventScriptFailedToParse {
            #[doc = "Identifier of the script parsed."]
            #[serde(rename = "scriptId")]
            pub script_id: super::runtime::ScriptId,
            #[doc = "URL or name of the script parsed (if any)."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Line offset of the script within the resource with given URL (for script tags)."]
            #[serde(rename = "startLine")]
            pub start_line: i64,
            #[doc = "Column offset of the script within the resource with given URL."]
            #[serde(rename = "startColumn")]
            pub start_column: i64,
            #[doc = "Last line of the script."]
            #[serde(rename = "endLine")]
            pub end_line: i64,
            #[doc = "Length of the last line of the script."]
            #[serde(rename = "endColumn")]
            pub end_column: i64,
            #[doc = "Specifies script creation context."]
            #[serde(rename = "executionContextId")]
            pub execution_context_id: super::runtime::ExecutionContextId,
            #[doc = "Content hash of the script, SHA-256."]
            #[serde(rename = "hash")]
            pub hash: String,
            #[doc = "Embedder-specific auxiliary data."]
            #[serde(rename = "executionContextAuxData")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub execution_context_aux_data: Option<serde_json::Value>,
            #[doc = "URL of source map associated with script (if any)."]
            #[serde(rename = "sourceMapURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub source_map_url: Option<String>,
            #[doc = "True, if this script has sourceURL."]
            #[serde(rename = "hasSourceURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub has_source_url: Option<bool>,
            #[doc = "True, if this script is ES6 module."]
            #[serde(rename = "isModule")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_module: Option<bool>,
            #[doc = "This script length."]
            #[serde(rename = "length")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub length: Option<i64>,
            #[doc = "JavaScript top stack frame of where the script parsed event was triggered if available."]
            #[serde(rename = "stackTrace")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub stack_trace: Option<super::runtime::StackTrace>,
            #[doc = "If the scriptLanguage is WebAssembly, the code section offset in the module."]
            #[serde(rename = "codeOffset")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub code_offset: Option<i64>,
            #[doc = "The language of the script."]
            #[serde(rename = "scriptLanguage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub script_language: Option<super::debugger::ScriptLanguage>,
            #[doc = "The name the embedder supplied for this script."]
            #[serde(rename = "embedderName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub embedder_name: Option<String>,
        }
        impl EventScriptFailedToParse {
            pub const IDENTIFIER: &'static str = "Debugger.scriptFailedToParse";
        }
        impl chromiumoxide_types::Method for EventScriptFailedToParse {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventScriptFailedToParse {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when virtual machine parses script. This event is also fired for all known and uncollected\nscripts upon enabling debugger.\n[scriptParsed](https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#event-scriptParsed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventScriptParsed {
            #[doc = "Identifier of the script parsed."]
            #[serde(rename = "scriptId")]
            pub script_id: super::runtime::ScriptId,
            #[doc = "URL or name of the script parsed (if any)."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Line offset of the script within the resource with given URL (for script tags)."]
            #[serde(rename = "startLine")]
            pub start_line: i64,
            #[doc = "Column offset of the script within the resource with given URL."]
            #[serde(rename = "startColumn")]
            pub start_column: i64,
            #[doc = "Last line of the script."]
            #[serde(rename = "endLine")]
            pub end_line: i64,
            #[doc = "Length of the last line of the script."]
            #[serde(rename = "endColumn")]
            pub end_column: i64,
            #[doc = "Specifies script creation context."]
            #[serde(rename = "executionContextId")]
            pub execution_context_id: super::runtime::ExecutionContextId,
            #[doc = "Content hash of the script, SHA-256."]
            #[serde(rename = "hash")]
            pub hash: String,
            #[doc = "Embedder-specific auxiliary data."]
            #[serde(rename = "executionContextAuxData")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub execution_context_aux_data: Option<serde_json::Value>,
            #[doc = "True, if this script is generated as a result of the live edit operation."]
            #[serde(rename = "isLiveEdit")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_live_edit: Option<bool>,
            #[doc = "URL of source map associated with script (if any)."]
            #[serde(rename = "sourceMapURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub source_map_url: Option<String>,
            #[doc = "True, if this script has sourceURL."]
            #[serde(rename = "hasSourceURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub has_source_url: Option<bool>,
            #[doc = "True, if this script is ES6 module."]
            #[serde(rename = "isModule")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_module: Option<bool>,
            #[doc = "This script length."]
            #[serde(rename = "length")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub length: Option<i64>,
            #[doc = "JavaScript top stack frame of where the script parsed event was triggered if available."]
            #[serde(rename = "stackTrace")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub stack_trace: Option<super::runtime::StackTrace>,
            #[doc = "If the scriptLanguage is WebAssembly, the code section offset in the module."]
            #[serde(rename = "codeOffset")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub code_offset: Option<i64>,
            #[doc = "The language of the script."]
            #[serde(rename = "scriptLanguage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub script_language: Option<super::debugger::ScriptLanguage>,
            #[doc = "If the scriptLanguage is WebASsembly, the source of debug symbols for the module."]
            #[serde(rename = "debugSymbols")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub debug_symbols: Option<super::debugger::DebugSymbols>,
            #[doc = "The name the embedder supplied for this script."]
            #[serde(rename = "embedderName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub embedder_name: Option<String>,
        }
        impl EventScriptParsed {
            pub const IDENTIFIER: &'static str = "Debugger.scriptParsed";
        }
        impl chromiumoxide_types::Method for EventScriptParsed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventScriptParsed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    pub mod heap_profiler {
        use serde::{Deserialize, Serialize};
        #[doc = "Heap snapshot object id.\n[HeapSnapshotObjectId](https://chromedevtools.github.io/devtools-protocol/tot/HeapProfiler/#type-HeapSnapshotObjectId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct HeapSnapshotObjectId(String);
        impl HeapSnapshotObjectId {
            pub fn new(val: impl Into<String>) -> Self {
                HeapSnapshotObjectId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for HeapSnapshotObjectId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<HeapSnapshotObjectId> for String {
            fn from(el: HeapSnapshotObjectId) -> String {
                el.0
            }
        }
        impl From<String> for HeapSnapshotObjectId {
            fn from(expr: String) -> Self {
                HeapSnapshotObjectId(expr)
            }
        }
        impl std::borrow::Borrow<str> for HeapSnapshotObjectId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl HeapSnapshotObjectId {
            pub const IDENTIFIER: &'static str = "HeapProfiler.HeapSnapshotObjectId";
        }
        #[doc = "Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.\n[SamplingHeapProfileNode](https://chromedevtools.github.io/devtools-protocol/tot/HeapProfiler/#type-SamplingHeapProfileNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SamplingHeapProfileNode {
            #[doc = "Function location."]
            #[serde(rename = "callFrame")]
            pub call_frame: super::runtime::CallFrame,
            #[doc = "Allocations size in bytes for the node excluding children."]
            #[serde(rename = "selfSize")]
            pub self_size: f64,
            #[doc = "Node id. Ids are unique across all profiles collected between startSampling and stopSampling."]
            #[serde(rename = "id")]
            pub id: i64,
            #[doc = "Child nodes."]
            #[serde(rename = "children")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub children: Vec<SamplingHeapProfileNode>,
        }
        impl SamplingHeapProfileNode {
            pub fn new(
                call_frame: impl Into<super::runtime::CallFrame>,
                self_size: impl Into<f64>,
                id: impl Into<i64>,
                children: Vec<SamplingHeapProfileNode>,
            ) -> Self {
                Self {
                    call_frame: call_frame.into(),
                    self_size: self_size.into(),
                    id: id.into(),
                    children,
                }
            }
        }
        impl SamplingHeapProfileNode {
            pub fn builder() -> SamplingHeapProfileNodeBuilder {
                SamplingHeapProfileNodeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SamplingHeapProfileNodeBuilder {
            call_frame: Option<super::runtime::CallFrame>,
            self_size: Option<f64>,
            id: Option<i64>,
            children: Option<Vec<SamplingHeapProfileNode>>,
        }
        impl SamplingHeapProfileNodeBuilder {
            pub fn call_frame(mut self, call_frame: impl Into<super::runtime::CallFrame>) -> Self {
                self.call_frame = Some(call_frame.into());
                self
            }
            pub fn self_size(mut self, self_size: impl Into<f64>) -> Self {
                self.self_size = Some(self_size.into());
                self
            }
            pub fn id(mut self, id: impl Into<i64>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn children(mut self, children: impl Into<SamplingHeapProfileNode>) -> Self {
                let v = self.children.get_or_insert(Vec::new());
                v.push(children.into());
                self
            }
            pub fn childrens<I, S>(mut self, childrens: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<SamplingHeapProfileNode>,
            {
                let v = self.children.get_or_insert(Vec::new());
                for val in childrens {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SamplingHeapProfileNode, String> {
                Ok(SamplingHeapProfileNode {
                    call_frame: self.call_frame.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(call_frame))
                    })?,
                    self_size: self.self_size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(self_size))
                    })?,
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                    children: self.children.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(children))
                    })?,
                })
            }
        }
        impl SamplingHeapProfileNode {
            pub const IDENTIFIER: &'static str = "HeapProfiler.SamplingHeapProfileNode";
        }
        #[doc = "A single sample from a sampling profile.\n[SamplingHeapProfileSample](https://chromedevtools.github.io/devtools-protocol/tot/HeapProfiler/#type-SamplingHeapProfileSample)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SamplingHeapProfileSample {
            #[doc = "Allocation size in bytes attributed to the sample."]
            #[serde(rename = "size")]
            pub size: f64,
            #[doc = "Id of the corresponding profile tree node."]
            #[serde(rename = "nodeId")]
            pub node_id: i64,
            #[doc = "Time-ordered sample ordinal number. It is unique across all profiles retrieved\nbetween startSampling and stopSampling."]
            #[serde(rename = "ordinal")]
            pub ordinal: f64,
        }
        impl SamplingHeapProfileSample {
            pub fn new(
                size: impl Into<f64>,
                node_id: impl Into<i64>,
                ordinal: impl Into<f64>,
            ) -> Self {
                Self {
                    size: size.into(),
                    node_id: node_id.into(),
                    ordinal: ordinal.into(),
                }
            }
        }
        impl SamplingHeapProfileSample {
            pub fn builder() -> SamplingHeapProfileSampleBuilder {
                SamplingHeapProfileSampleBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SamplingHeapProfileSampleBuilder {
            size: Option<f64>,
            node_id: Option<i64>,
            ordinal: Option<f64>,
        }
        impl SamplingHeapProfileSampleBuilder {
            pub fn size(mut self, size: impl Into<f64>) -> Self {
                self.size = Some(size.into());
                self
            }
            pub fn node_id(mut self, node_id: impl Into<i64>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn ordinal(mut self, ordinal: impl Into<f64>) -> Self {
                self.ordinal = Some(ordinal.into());
                self
            }
            pub fn build(self) -> Result<SamplingHeapProfileSample, String> {
                Ok(SamplingHeapProfileSample {
                    size: self.size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(size))
                    })?,
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    ordinal: self.ordinal.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(ordinal))
                    })?,
                })
            }
        }
        impl SamplingHeapProfileSample {
            pub const IDENTIFIER: &'static str = "HeapProfiler.SamplingHeapProfileSample";
        }
        #[doc = "Sampling profile.\n[SamplingHeapProfile](https://chromedevtools.github.io/devtools-protocol/tot/HeapProfiler/#type-SamplingHeapProfile)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SamplingHeapProfile {
            #[serde(rename = "head")]
            pub head: SamplingHeapProfileNode,
            #[serde(rename = "samples")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub samples: Vec<SamplingHeapProfileSample>,
        }
        impl SamplingHeapProfile {
            pub fn new(
                head: impl Into<SamplingHeapProfileNode>,
                samples: Vec<SamplingHeapProfileSample>,
            ) -> Self {
                Self {
                    head: head.into(),
                    samples,
                }
            }
        }
        impl SamplingHeapProfile {
            pub fn builder() -> SamplingHeapProfileBuilder {
                SamplingHeapProfileBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SamplingHeapProfileBuilder {
            head: Option<SamplingHeapProfileNode>,
            samples: Option<Vec<SamplingHeapProfileSample>>,
        }
        impl SamplingHeapProfileBuilder {
            pub fn head(mut self, head: impl Into<SamplingHeapProfileNode>) -> Self {
                self.head = Some(head.into());
                self
            }
            pub fn sample(mut self, sample: impl Into<SamplingHeapProfileSample>) -> Self {
                let v = self.samples.get_or_insert(Vec::new());
                v.push(sample.into());
                self
            }
            pub fn samples<I, S>(mut self, samples: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<SamplingHeapProfileSample>,
            {
                let v = self.samples.get_or_insert(Vec::new());
                for val in samples {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SamplingHeapProfile, String> {
                Ok(SamplingHeapProfile {
                    head: self.head.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(head))
                    })?,
                    samples: self.samples.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(samples))
                    })?,
                })
            }
        }
        impl SamplingHeapProfile {
            pub const IDENTIFIER: &'static str = "HeapProfiler.SamplingHeapProfile";
        }
        #[doc = "Enables console to refer to the node with given id via $x (see Command Line API for more details\n$x functions).\n[addInspectedHeapObject](https://chromedevtools.github.io/devtools-protocol/tot/HeapProfiler/#method-addInspectedHeapObject)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AddInspectedHeapObjectParams {
            #[doc = "Heap snapshot object id to be accessible by means of $x command line API."]
            #[serde(rename = "heapObjectId")]
            pub heap_object_id: HeapSnapshotObjectId,
        }
        impl AddInspectedHeapObjectParams {
            pub fn new(heap_object_id: impl Into<HeapSnapshotObjectId>) -> Self {
                Self {
                    heap_object_id: heap_object_id.into(),
                }
            }
        }
        impl AddInspectedHeapObjectParams {
            pub fn builder() -> AddInspectedHeapObjectParamsBuilder {
                AddInspectedHeapObjectParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AddInspectedHeapObjectParamsBuilder {
            heap_object_id: Option<HeapSnapshotObjectId>,
        }
        impl AddInspectedHeapObjectParamsBuilder {
            pub fn heap_object_id(
                mut self,
                heap_object_id: impl Into<HeapSnapshotObjectId>,
            ) -> Self {
                self.heap_object_id = Some(heap_object_id.into());
                self
            }
            pub fn build(self) -> Result<AddInspectedHeapObjectParams, String> {
                Ok(AddInspectedHeapObjectParams {
                    heap_object_id: self.heap_object_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(heap_object_id))
                    })?,
                })
            }
        }
        impl AddInspectedHeapObjectParams {
            pub const IDENTIFIER: &'static str = "HeapProfiler.addInspectedHeapObject";
        }
        impl chromiumoxide_types::Method for AddInspectedHeapObjectParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for AddInspectedHeapObjectParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables console to refer to the node with given id via $x (see Command Line API for more details\n$x functions).\n[addInspectedHeapObject](https://chromedevtools.github.io/devtools-protocol/tot/HeapProfiler/#method-addInspectedHeapObject)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct AddInspectedHeapObjectReturns {}
        impl chromiumoxide_types::Command for AddInspectedHeapObjectParams {
            type Response = AddInspectedHeapObjectReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CollectGarbageParams {}
        impl CollectGarbageParams {
            pub const IDENTIFIER: &'static str = "HeapProfiler.collectGarbage";
        }
        impl chromiumoxide_types::Method for CollectGarbageParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CollectGarbageParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CollectGarbageReturns {}
        impl chromiumoxide_types::Command for CollectGarbageParams {
            type Response = CollectGarbageReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "HeapProfiler.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "HeapProfiler.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetHeapObjectIdParams {
            #[doc = "Identifier of the object to get heap object id for."]
            #[serde(rename = "objectId")]
            pub object_id: super::runtime::RemoteObjectId,
        }
        impl GetHeapObjectIdParams {
            pub fn new(object_id: impl Into<super::runtime::RemoteObjectId>) -> Self {
                Self {
                    object_id: object_id.into(),
                }
            }
        }
        impl GetHeapObjectIdParams {
            pub fn builder() -> GetHeapObjectIdParamsBuilder {
                GetHeapObjectIdParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetHeapObjectIdParamsBuilder {
            object_id: Option<super::runtime::RemoteObjectId>,
        }
        impl GetHeapObjectIdParamsBuilder {
            pub fn object_id(
                mut self,
                object_id: impl Into<super::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> Result<GetHeapObjectIdParams, String> {
                Ok(GetHeapObjectIdParams {
                    object_id: self.object_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(object_id))
                    })?,
                })
            }
        }
        impl GetHeapObjectIdParams {
            pub const IDENTIFIER: &'static str = "HeapProfiler.getHeapObjectId";
        }
        impl chromiumoxide_types::Method for GetHeapObjectIdParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetHeapObjectIdParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetHeapObjectIdReturns {
            #[doc = "Id of the heap snapshot object corresponding to the passed remote object id."]
            #[serde(rename = "heapSnapshotObjectId")]
            pub heap_snapshot_object_id: HeapSnapshotObjectId,
        }
        impl GetHeapObjectIdReturns {
            pub fn new(heap_snapshot_object_id: impl Into<HeapSnapshotObjectId>) -> Self {
                Self {
                    heap_snapshot_object_id: heap_snapshot_object_id.into(),
                }
            }
        }
        impl GetHeapObjectIdReturns {
            pub fn builder() -> GetHeapObjectIdReturnsBuilder {
                GetHeapObjectIdReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetHeapObjectIdReturnsBuilder {
            heap_snapshot_object_id: Option<HeapSnapshotObjectId>,
        }
        impl GetHeapObjectIdReturnsBuilder {
            pub fn heap_snapshot_object_id(
                mut self,
                heap_snapshot_object_id: impl Into<HeapSnapshotObjectId>,
            ) -> Self {
                self.heap_snapshot_object_id = Some(heap_snapshot_object_id.into());
                self
            }
            pub fn build(self) -> Result<GetHeapObjectIdReturns, String> {
                Ok(GetHeapObjectIdReturns {
                    heap_snapshot_object_id: self.heap_snapshot_object_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(heap_snapshot_object_id)
                        )
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetHeapObjectIdParams {
            type Response = GetHeapObjectIdReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetObjectByHeapObjectIdParams {
            #[serde(rename = "objectId")]
            pub object_id: HeapSnapshotObjectId,
            #[doc = "Symbolic group name that can be used to release multiple objects."]
            #[serde(rename = "objectGroup")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_group: Option<String>,
        }
        impl GetObjectByHeapObjectIdParams {
            pub fn new(object_id: impl Into<HeapSnapshotObjectId>) -> Self {
                Self {
                    object_id: object_id.into(),
                    object_group: None,
                }
            }
        }
        impl GetObjectByHeapObjectIdParams {
            pub fn builder() -> GetObjectByHeapObjectIdParamsBuilder {
                GetObjectByHeapObjectIdParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetObjectByHeapObjectIdParamsBuilder {
            object_id: Option<HeapSnapshotObjectId>,
            object_group: Option<String>,
        }
        impl GetObjectByHeapObjectIdParamsBuilder {
            pub fn object_id(mut self, object_id: impl Into<HeapSnapshotObjectId>) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn object_group(mut self, object_group: impl Into<String>) -> Self {
                self.object_group = Some(object_group.into());
                self
            }
            pub fn build(self) -> Result<GetObjectByHeapObjectIdParams, String> {
                Ok(GetObjectByHeapObjectIdParams {
                    object_id: self.object_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(object_id))
                    })?,
                    object_group: self.object_group,
                })
            }
        }
        impl GetObjectByHeapObjectIdParams {
            pub const IDENTIFIER: &'static str = "HeapProfiler.getObjectByHeapObjectId";
        }
        impl chromiumoxide_types::Method for GetObjectByHeapObjectIdParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetObjectByHeapObjectIdParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetObjectByHeapObjectIdReturns {
            #[doc = "Evaluation result."]
            #[serde(rename = "result")]
            pub result: super::runtime::RemoteObject,
        }
        impl GetObjectByHeapObjectIdReturns {
            pub fn new(result: impl Into<super::runtime::RemoteObject>) -> Self {
                Self {
                    result: result.into(),
                }
            }
        }
        impl GetObjectByHeapObjectIdReturns {
            pub fn builder() -> GetObjectByHeapObjectIdReturnsBuilder {
                GetObjectByHeapObjectIdReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetObjectByHeapObjectIdReturnsBuilder {
            result: Option<super::runtime::RemoteObject>,
        }
        impl GetObjectByHeapObjectIdReturnsBuilder {
            pub fn result(mut self, result: impl Into<super::runtime::RemoteObject>) -> Self {
                self.result = Some(result.into());
                self
            }
            pub fn build(self) -> Result<GetObjectByHeapObjectIdReturns, String> {
                Ok(GetObjectByHeapObjectIdReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetObjectByHeapObjectIdParams {
            type Response = GetObjectByHeapObjectIdReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetSamplingProfileParams {}
        impl GetSamplingProfileParams {
            pub const IDENTIFIER: &'static str = "HeapProfiler.getSamplingProfile";
        }
        impl chromiumoxide_types::Method for GetSamplingProfileParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetSamplingProfileParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetSamplingProfileReturns {
            #[doc = "Return the sampling profile being collected."]
            #[serde(rename = "profile")]
            pub profile: SamplingHeapProfile,
        }
        impl GetSamplingProfileReturns {
            pub fn new(profile: impl Into<SamplingHeapProfile>) -> Self {
                Self {
                    profile: profile.into(),
                }
            }
        }
        impl GetSamplingProfileReturns {
            pub fn builder() -> GetSamplingProfileReturnsBuilder {
                GetSamplingProfileReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetSamplingProfileReturnsBuilder {
            profile: Option<SamplingHeapProfile>,
        }
        impl GetSamplingProfileReturnsBuilder {
            pub fn profile(mut self, profile: impl Into<SamplingHeapProfile>) -> Self {
                self.profile = Some(profile.into());
                self
            }
            pub fn build(self) -> Result<GetSamplingProfileReturns, String> {
                Ok(GetSamplingProfileReturns {
                    profile: self.profile.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(profile))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetSamplingProfileParams {
            type Response = GetSamplingProfileReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartSamplingParams {
            #[doc = "Average sample interval in bytes. Poisson distribution is used for the intervals. The\ndefault value is 32768 bytes."]
            #[serde(rename = "samplingInterval")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub sampling_interval: Option<f64>,
        }
        impl StartSamplingParams {
            pub fn builder() -> StartSamplingParamsBuilder {
                StartSamplingParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StartSamplingParamsBuilder {
            sampling_interval: Option<f64>,
        }
        impl StartSamplingParamsBuilder {
            pub fn sampling_interval(mut self, sampling_interval: impl Into<f64>) -> Self {
                self.sampling_interval = Some(sampling_interval.into());
                self
            }
            pub fn build(self) -> StartSamplingParams {
                StartSamplingParams {
                    sampling_interval: self.sampling_interval,
                }
            }
        }
        impl StartSamplingParams {
            pub const IDENTIFIER: &'static str = "HeapProfiler.startSampling";
        }
        impl chromiumoxide_types::Method for StartSamplingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartSamplingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartSamplingReturns {}
        impl chromiumoxide_types::Command for StartSamplingParams {
            type Response = StartSamplingReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartTrackingHeapObjectsParams {
            #[serde(rename = "trackAllocations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub track_allocations: Option<bool>,
        }
        impl StartTrackingHeapObjectsParams {
            pub fn builder() -> StartTrackingHeapObjectsParamsBuilder {
                StartTrackingHeapObjectsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StartTrackingHeapObjectsParamsBuilder {
            track_allocations: Option<bool>,
        }
        impl StartTrackingHeapObjectsParamsBuilder {
            pub fn track_allocations(mut self, track_allocations: impl Into<bool>) -> Self {
                self.track_allocations = Some(track_allocations.into());
                self
            }
            pub fn build(self) -> StartTrackingHeapObjectsParams {
                StartTrackingHeapObjectsParams {
                    track_allocations: self.track_allocations,
                }
            }
        }
        impl StartTrackingHeapObjectsParams {
            pub const IDENTIFIER: &'static str = "HeapProfiler.startTrackingHeapObjects";
        }
        impl chromiumoxide_types::Method for StartTrackingHeapObjectsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartTrackingHeapObjectsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartTrackingHeapObjectsReturns {}
        impl chromiumoxide_types::Command for StartTrackingHeapObjectsParams {
            type Response = StartTrackingHeapObjectsReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopSamplingParams {}
        impl StopSamplingParams {
            pub const IDENTIFIER: &'static str = "HeapProfiler.stopSampling";
        }
        impl chromiumoxide_types::Method for StopSamplingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopSamplingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StopSamplingReturns {
            #[doc = "Recorded sampling heap profile."]
            #[serde(rename = "profile")]
            pub profile: SamplingHeapProfile,
        }
        impl StopSamplingReturns {
            pub fn new(profile: impl Into<SamplingHeapProfile>) -> Self {
                Self {
                    profile: profile.into(),
                }
            }
        }
        impl StopSamplingReturns {
            pub fn builder() -> StopSamplingReturnsBuilder {
                StopSamplingReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StopSamplingReturnsBuilder {
            profile: Option<SamplingHeapProfile>,
        }
        impl StopSamplingReturnsBuilder {
            pub fn profile(mut self, profile: impl Into<SamplingHeapProfile>) -> Self {
                self.profile = Some(profile.into());
                self
            }
            pub fn build(self) -> Result<StopSamplingReturns, String> {
                Ok(StopSamplingReturns {
                    profile: self.profile.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(profile))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for StopSamplingParams {
            type Response = StopSamplingReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopTrackingHeapObjectsParams {
            #[doc = "If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken\nwhen the tracking is stopped."]
            #[serde(rename = "reportProgress")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub report_progress: Option<bool>,
            #[doc = "If true, numerical values are included in the snapshot"]
            #[serde(rename = "captureNumericValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub capture_numeric_value: Option<bool>,
            #[doc = "If true, exposes internals of the snapshot."]
            #[serde(rename = "exposeInternals")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub expose_internals: Option<bool>,
        }
        impl StopTrackingHeapObjectsParams {
            pub fn builder() -> StopTrackingHeapObjectsParamsBuilder {
                StopTrackingHeapObjectsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StopTrackingHeapObjectsParamsBuilder {
            report_progress: Option<bool>,
            capture_numeric_value: Option<bool>,
            expose_internals: Option<bool>,
        }
        impl StopTrackingHeapObjectsParamsBuilder {
            pub fn report_progress(mut self, report_progress: impl Into<bool>) -> Self {
                self.report_progress = Some(report_progress.into());
                self
            }
            pub fn capture_numeric_value(mut self, capture_numeric_value: impl Into<bool>) -> Self {
                self.capture_numeric_value = Some(capture_numeric_value.into());
                self
            }
            pub fn expose_internals(mut self, expose_internals: impl Into<bool>) -> Self {
                self.expose_internals = Some(expose_internals.into());
                self
            }
            pub fn build(self) -> StopTrackingHeapObjectsParams {
                StopTrackingHeapObjectsParams {
                    report_progress: self.report_progress,
                    capture_numeric_value: self.capture_numeric_value,
                    expose_internals: self.expose_internals,
                }
            }
        }
        impl StopTrackingHeapObjectsParams {
            pub const IDENTIFIER: &'static str = "HeapProfiler.stopTrackingHeapObjects";
        }
        impl chromiumoxide_types::Method for StopTrackingHeapObjectsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopTrackingHeapObjectsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopTrackingHeapObjectsReturns {}
        impl chromiumoxide_types::Command for StopTrackingHeapObjectsParams {
            type Response = StopTrackingHeapObjectsReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TakeHeapSnapshotParams {
            #[doc = "If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken."]
            #[serde(rename = "reportProgress")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub report_progress: Option<bool>,
            #[doc = "If true, numerical values are included in the snapshot"]
            #[serde(rename = "captureNumericValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub capture_numeric_value: Option<bool>,
            #[doc = "If true, exposes internals of the snapshot."]
            #[serde(rename = "exposeInternals")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub expose_internals: Option<bool>,
        }
        impl TakeHeapSnapshotParams {
            pub fn builder() -> TakeHeapSnapshotParamsBuilder {
                TakeHeapSnapshotParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TakeHeapSnapshotParamsBuilder {
            report_progress: Option<bool>,
            capture_numeric_value: Option<bool>,
            expose_internals: Option<bool>,
        }
        impl TakeHeapSnapshotParamsBuilder {
            pub fn report_progress(mut self, report_progress: impl Into<bool>) -> Self {
                self.report_progress = Some(report_progress.into());
                self
            }
            pub fn capture_numeric_value(mut self, capture_numeric_value: impl Into<bool>) -> Self {
                self.capture_numeric_value = Some(capture_numeric_value.into());
                self
            }
            pub fn expose_internals(mut self, expose_internals: impl Into<bool>) -> Self {
                self.expose_internals = Some(expose_internals.into());
                self
            }
            pub fn build(self) -> TakeHeapSnapshotParams {
                TakeHeapSnapshotParams {
                    report_progress: self.report_progress,
                    capture_numeric_value: self.capture_numeric_value,
                    expose_internals: self.expose_internals,
                }
            }
        }
        impl TakeHeapSnapshotParams {
            pub const IDENTIFIER: &'static str = "HeapProfiler.takeHeapSnapshot";
        }
        impl chromiumoxide_types::Method for TakeHeapSnapshotParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for TakeHeapSnapshotParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TakeHeapSnapshotReturns {}
        impl chromiumoxide_types::Command for TakeHeapSnapshotParams {
            type Response = TakeHeapSnapshotReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAddHeapSnapshotChunk {
            #[serde(rename = "chunk")]
            pub chunk: String,
        }
        impl EventAddHeapSnapshotChunk {
            pub const IDENTIFIER: &'static str = "HeapProfiler.addHeapSnapshotChunk";
        }
        impl chromiumoxide_types::Method for EventAddHeapSnapshotChunk {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAddHeapSnapshotChunk {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "If heap objects tracking has been started then backend may send update for one or more fragments\n[heapStatsUpdate](https://chromedevtools.github.io/devtools-protocol/tot/HeapProfiler/#event-heapStatsUpdate)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventHeapStatsUpdate {
            #[doc = "An array of triplets. Each triplet describes a fragment. The first integer is the fragment\nindex, the second integer is a total count of objects for the fragment, the third integer is\na total size of the objects for the fragment."]
            #[serde(rename = "statsUpdate")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub stats_update: Vec<i64>,
        }
        impl EventHeapStatsUpdate {
            pub const IDENTIFIER: &'static str = "HeapProfiler.heapStatsUpdate";
        }
        impl chromiumoxide_types::Method for EventHeapStatsUpdate {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventHeapStatsUpdate {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "If heap objects tracking has been started then backend regularly sends a current value for last\nseen object id and corresponding timestamp. If the were changes in the heap since last event\nthen one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.\n[lastSeenObjectId](https://chromedevtools.github.io/devtools-protocol/tot/HeapProfiler/#event-lastSeenObjectId)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventLastSeenObjectId {
            #[serde(rename = "lastSeenObjectId")]
            pub last_seen_object_id: i64,
            #[serde(rename = "timestamp")]
            pub timestamp: f64,
        }
        impl EventLastSeenObjectId {
            pub const IDENTIFIER: &'static str = "HeapProfiler.lastSeenObjectId";
        }
        impl chromiumoxide_types::Method for EventLastSeenObjectId {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventLastSeenObjectId {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventReportHeapSnapshotProgress {
            #[serde(rename = "done")]
            pub done: i64,
            #[serde(rename = "total")]
            pub total: i64,
            #[serde(rename = "finished")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub finished: Option<bool>,
        }
        impl EventReportHeapSnapshotProgress {
            pub const IDENTIFIER: &'static str = "HeapProfiler.reportHeapSnapshotProgress";
        }
        impl chromiumoxide_types::Method for EventReportHeapSnapshotProgress {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventReportHeapSnapshotProgress {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventResetProfiles {}
        impl EventResetProfiles {
            pub const IDENTIFIER: &'static str = "HeapProfiler.resetProfiles";
        }
        impl chromiumoxide_types::Method for EventResetProfiles {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventResetProfiles {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    pub mod profiler {
        use serde::{Deserialize, Serialize};
        #[doc = "Profile node. Holds callsite information, execution statistics and child nodes.\n[ProfileNode](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-ProfileNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ProfileNode {
            #[doc = "Unique id of the node."]
            #[serde(rename = "id")]
            pub id: i64,
            #[doc = "Function location."]
            #[serde(rename = "callFrame")]
            pub call_frame: super::runtime::CallFrame,
            #[doc = "Number of samples where this node was on top of the call stack."]
            #[serde(rename = "hitCount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub hit_count: Option<i64>,
            #[doc = "Child node ids."]
            #[serde(rename = "children")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub children: Option<Vec<i64>>,
            #[doc = "The reason of being not optimized. The function may be deoptimized or marked as don't\noptimize."]
            #[serde(rename = "deoptReason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub deopt_reason: Option<String>,
            #[doc = "An array of source position ticks."]
            #[serde(rename = "positionTicks")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub position_ticks: Option<Vec<PositionTickInfo>>,
        }
        impl ProfileNode {
            pub fn new(
                id: impl Into<i64>,
                call_frame: impl Into<super::runtime::CallFrame>,
            ) -> Self {
                Self {
                    id: id.into(),
                    call_frame: call_frame.into(),
                    hit_count: None,
                    children: None,
                    deopt_reason: None,
                    position_ticks: None,
                }
            }
        }
        impl ProfileNode {
            pub fn builder() -> ProfileNodeBuilder {
                ProfileNodeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ProfileNodeBuilder {
            id: Option<i64>,
            call_frame: Option<super::runtime::CallFrame>,
            hit_count: Option<i64>,
            children: Option<Vec<i64>>,
            deopt_reason: Option<String>,
            position_ticks: Option<Vec<PositionTickInfo>>,
        }
        impl ProfileNodeBuilder {
            pub fn id(mut self, id: impl Into<i64>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn call_frame(mut self, call_frame: impl Into<super::runtime::CallFrame>) -> Self {
                self.call_frame = Some(call_frame.into());
                self
            }
            pub fn hit_count(mut self, hit_count: impl Into<i64>) -> Self {
                self.hit_count = Some(hit_count.into());
                self
            }
            pub fn children(mut self, children: impl Into<i64>) -> Self {
                let v = self.children.get_or_insert(Vec::new());
                v.push(children.into());
                self
            }
            pub fn childrens<I, S>(mut self, childrens: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.children.get_or_insert(Vec::new());
                for val in childrens {
                    v.push(val.into());
                }
                self
            }
            pub fn deopt_reason(mut self, deopt_reason: impl Into<String>) -> Self {
                self.deopt_reason = Some(deopt_reason.into());
                self
            }
            pub fn position_tick(mut self, position_tick: impl Into<PositionTickInfo>) -> Self {
                let v = self.position_ticks.get_or_insert(Vec::new());
                v.push(position_tick.into());
                self
            }
            pub fn position_ticks<I, S>(mut self, position_ticks: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PositionTickInfo>,
            {
                let v = self.position_ticks.get_or_insert(Vec::new());
                for val in position_ticks {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<ProfileNode, String> {
                Ok(ProfileNode {
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                    call_frame: self.call_frame.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(call_frame))
                    })?,
                    hit_count: self.hit_count,
                    children: self.children,
                    deopt_reason: self.deopt_reason,
                    position_ticks: self.position_ticks,
                })
            }
        }
        impl ProfileNode {
            pub const IDENTIFIER: &'static str = "Profiler.ProfileNode";
        }
        #[doc = "Profile.\n[Profile](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-Profile)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Profile {
            #[doc = "The list of profile nodes. First item is the root node."]
            #[serde(rename = "nodes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub nodes: Vec<ProfileNode>,
            #[doc = "Profiling start timestamp in microseconds."]
            #[serde(rename = "startTime")]
            pub start_time: f64,
            #[doc = "Profiling end timestamp in microseconds."]
            #[serde(rename = "endTime")]
            pub end_time: f64,
            #[doc = "Ids of samples top nodes."]
            #[serde(rename = "samples")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub samples: Option<Vec<i64>>,
            #[doc = "Time intervals between adjacent samples in microseconds. The first delta is relative to the\nprofile startTime."]
            #[serde(rename = "timeDeltas")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub time_deltas: Option<Vec<i64>>,
        }
        impl Profile {
            pub fn new(
                nodes: Vec<ProfileNode>,
                start_time: impl Into<f64>,
                end_time: impl Into<f64>,
            ) -> Self {
                Self {
                    nodes,
                    start_time: start_time.into(),
                    end_time: end_time.into(),
                    samples: None,
                    time_deltas: None,
                }
            }
        }
        impl Profile {
            pub fn builder() -> ProfileBuilder {
                ProfileBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ProfileBuilder {
            nodes: Option<Vec<ProfileNode>>,
            start_time: Option<f64>,
            end_time: Option<f64>,
            samples: Option<Vec<i64>>,
            time_deltas: Option<Vec<i64>>,
        }
        impl ProfileBuilder {
            pub fn node(mut self, node: impl Into<ProfileNode>) -> Self {
                let v = self.nodes.get_or_insert(Vec::new());
                v.push(node.into());
                self
            }
            pub fn nodes<I, S>(mut self, nodes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ProfileNode>,
            {
                let v = self.nodes.get_or_insert(Vec::new());
                for val in nodes {
                    v.push(val.into());
                }
                self
            }
            pub fn start_time(mut self, start_time: impl Into<f64>) -> Self {
                self.start_time = Some(start_time.into());
                self
            }
            pub fn end_time(mut self, end_time: impl Into<f64>) -> Self {
                self.end_time = Some(end_time.into());
                self
            }
            pub fn sample(mut self, sample: impl Into<i64>) -> Self {
                let v = self.samples.get_or_insert(Vec::new());
                v.push(sample.into());
                self
            }
            pub fn samples<I, S>(mut self, samples: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.samples.get_or_insert(Vec::new());
                for val in samples {
                    v.push(val.into());
                }
                self
            }
            pub fn time_delta(mut self, time_delta: impl Into<i64>) -> Self {
                let v = self.time_deltas.get_or_insert(Vec::new());
                v.push(time_delta.into());
                self
            }
            pub fn time_deltas<I, S>(mut self, time_deltas: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.time_deltas.get_or_insert(Vec::new());
                for val in time_deltas {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<Profile, String> {
                Ok(Profile {
                    nodes: self.nodes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(nodes))
                    })?,
                    start_time: self.start_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(start_time))
                    })?,
                    end_time: self.end_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(end_time))
                    })?,
                    samples: self.samples,
                    time_deltas: self.time_deltas,
                })
            }
        }
        impl Profile {
            pub const IDENTIFIER: &'static str = "Profiler.Profile";
        }
        #[doc = "Specifies a number of samples attributed to a certain source position.\n[PositionTickInfo](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-PositionTickInfo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PositionTickInfo {
            #[doc = "Source line number (1-based)."]
            #[serde(rename = "line")]
            pub line: i64,
            #[doc = "Number of samples attributed to the source line."]
            #[serde(rename = "ticks")]
            pub ticks: i64,
        }
        impl PositionTickInfo {
            pub fn new(line: impl Into<i64>, ticks: impl Into<i64>) -> Self {
                Self {
                    line: line.into(),
                    ticks: ticks.into(),
                }
            }
        }
        impl PositionTickInfo {
            pub fn builder() -> PositionTickInfoBuilder {
                PositionTickInfoBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PositionTickInfoBuilder {
            line: Option<i64>,
            ticks: Option<i64>,
        }
        impl PositionTickInfoBuilder {
            pub fn line(mut self, line: impl Into<i64>) -> Self {
                self.line = Some(line.into());
                self
            }
            pub fn ticks(mut self, ticks: impl Into<i64>) -> Self {
                self.ticks = Some(ticks.into());
                self
            }
            pub fn build(self) -> Result<PositionTickInfo, String> {
                Ok(PositionTickInfo {
                    line: self.line.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line))
                    })?,
                    ticks: self.ticks.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(ticks))
                    })?,
                })
            }
        }
        impl PositionTickInfo {
            pub const IDENTIFIER: &'static str = "Profiler.PositionTickInfo";
        }
        #[doc = "Coverage data for a source range.\n[CoverageRange](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-CoverageRange)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CoverageRange {
            #[doc = "JavaScript script source offset for the range start."]
            #[serde(rename = "startOffset")]
            pub start_offset: i64,
            #[doc = "JavaScript script source offset for the range end."]
            #[serde(rename = "endOffset")]
            pub end_offset: i64,
            #[doc = "Collected execution count of the source range."]
            #[serde(rename = "count")]
            pub count: i64,
        }
        impl CoverageRange {
            pub fn new(
                start_offset: impl Into<i64>,
                end_offset: impl Into<i64>,
                count: impl Into<i64>,
            ) -> Self {
                Self {
                    start_offset: start_offset.into(),
                    end_offset: end_offset.into(),
                    count: count.into(),
                }
            }
        }
        impl CoverageRange {
            pub fn builder() -> CoverageRangeBuilder {
                CoverageRangeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CoverageRangeBuilder {
            start_offset: Option<i64>,
            end_offset: Option<i64>,
            count: Option<i64>,
        }
        impl CoverageRangeBuilder {
            pub fn start_offset(mut self, start_offset: impl Into<i64>) -> Self {
                self.start_offset = Some(start_offset.into());
                self
            }
            pub fn end_offset(mut self, end_offset: impl Into<i64>) -> Self {
                self.end_offset = Some(end_offset.into());
                self
            }
            pub fn count(mut self, count: impl Into<i64>) -> Self {
                self.count = Some(count.into());
                self
            }
            pub fn build(self) -> Result<CoverageRange, String> {
                Ok(CoverageRange {
                    start_offset: self.start_offset.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(start_offset))
                    })?,
                    end_offset: self.end_offset.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(end_offset))
                    })?,
                    count: self.count.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(count))
                    })?,
                })
            }
        }
        impl CoverageRange {
            pub const IDENTIFIER: &'static str = "Profiler.CoverageRange";
        }
        #[doc = "Coverage data for a JavaScript function.\n[FunctionCoverage](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-FunctionCoverage)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct FunctionCoverage {
            #[doc = "JavaScript function name."]
            #[serde(rename = "functionName")]
            pub function_name: String,
            #[doc = "Source ranges inside the function with coverage data."]
            #[serde(rename = "ranges")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub ranges: Vec<CoverageRange>,
            #[doc = "Whether coverage data for this function has block granularity."]
            #[serde(rename = "isBlockCoverage")]
            pub is_block_coverage: bool,
        }
        impl FunctionCoverage {
            pub fn new(
                function_name: impl Into<String>,
                ranges: Vec<CoverageRange>,
                is_block_coverage: impl Into<bool>,
            ) -> Self {
                Self {
                    function_name: function_name.into(),
                    ranges,
                    is_block_coverage: is_block_coverage.into(),
                }
            }
        }
        impl FunctionCoverage {
            pub fn builder() -> FunctionCoverageBuilder {
                FunctionCoverageBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FunctionCoverageBuilder {
            function_name: Option<String>,
            ranges: Option<Vec<CoverageRange>>,
            is_block_coverage: Option<bool>,
        }
        impl FunctionCoverageBuilder {
            pub fn function_name(mut self, function_name: impl Into<String>) -> Self {
                self.function_name = Some(function_name.into());
                self
            }
            pub fn range(mut self, range: impl Into<CoverageRange>) -> Self {
                let v = self.ranges.get_or_insert(Vec::new());
                v.push(range.into());
                self
            }
            pub fn ranges<I, S>(mut self, ranges: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CoverageRange>,
            {
                let v = self.ranges.get_or_insert(Vec::new());
                for val in ranges {
                    v.push(val.into());
                }
                self
            }
            pub fn is_block_coverage(mut self, is_block_coverage: impl Into<bool>) -> Self {
                self.is_block_coverage = Some(is_block_coverage.into());
                self
            }
            pub fn build(self) -> Result<FunctionCoverage, String> {
                Ok(FunctionCoverage {
                    function_name: self.function_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(function_name))
                    })?,
                    ranges: self.ranges.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(ranges))
                    })?,
                    is_block_coverage: self.is_block_coverage.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(is_block_coverage)
                        )
                    })?,
                })
            }
        }
        impl FunctionCoverage {
            pub const IDENTIFIER: &'static str = "Profiler.FunctionCoverage";
        }
        #[doc = "Coverage data for a JavaScript script.\n[ScriptCoverage](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-ScriptCoverage)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ScriptCoverage {
            #[doc = "JavaScript script id."]
            #[serde(rename = "scriptId")]
            pub script_id: super::runtime::ScriptId,
            #[doc = "JavaScript script name or url."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Functions contained in the script that has coverage data."]
            #[serde(rename = "functions")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub functions: Vec<FunctionCoverage>,
        }
        impl ScriptCoverage {
            pub fn new(
                script_id: impl Into<super::runtime::ScriptId>,
                url: impl Into<String>,
                functions: Vec<FunctionCoverage>,
            ) -> Self {
                Self {
                    script_id: script_id.into(),
                    url: url.into(),
                    functions,
                }
            }
        }
        impl ScriptCoverage {
            pub fn builder() -> ScriptCoverageBuilder {
                ScriptCoverageBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ScriptCoverageBuilder {
            script_id: Option<super::runtime::ScriptId>,
            url: Option<String>,
            functions: Option<Vec<FunctionCoverage>>,
        }
        impl ScriptCoverageBuilder {
            pub fn script_id(mut self, script_id: impl Into<super::runtime::ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn function(mut self, function: impl Into<FunctionCoverage>) -> Self {
                let v = self.functions.get_or_insert(Vec::new());
                v.push(function.into());
                self
            }
            pub fn functions<I, S>(mut self, functions: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<FunctionCoverage>,
            {
                let v = self.functions.get_or_insert(Vec::new());
                for val in functions {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<ScriptCoverage, String> {
                Ok(ScriptCoverage {
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    functions: self.functions.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(functions))
                    })?,
                })
            }
        }
        impl ScriptCoverage {
            pub const IDENTIFIER: &'static str = "Profiler.ScriptCoverage";
        }
        #[doc = "Describes a type collected during runtime.\n[TypeObject](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-TypeObject)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TypeObject {
            #[doc = "Name of a type collected with type profiling."]
            #[serde(rename = "name")]
            pub name: String,
        }
        impl TypeObject {
            pub fn new(name: impl Into<String>) -> Self {
                Self { name: name.into() }
            }
        }
        impl<T: Into<String>> From<T> for TypeObject {
            fn from(url: T) -> Self {
                TypeObject::new(url)
            }
        }
        impl TypeObject {
            pub fn builder() -> TypeObjectBuilder {
                TypeObjectBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TypeObjectBuilder {
            name: Option<String>,
        }
        impl TypeObjectBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn build(self) -> Result<TypeObject, String> {
                Ok(TypeObject {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                })
            }
        }
        impl TypeObject {
            pub const IDENTIFIER: &'static str = "Profiler.TypeObject";
        }
        #[doc = "Source offset and types for a parameter or return value.\n[TypeProfileEntry](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-TypeProfileEntry)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TypeProfileEntry {
            #[doc = "Source offset of the parameter or end of function for return values."]
            #[serde(rename = "offset")]
            pub offset: i64,
            #[doc = "The types for this parameter or return value."]
            #[serde(rename = "types")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub types: Vec<TypeObject>,
        }
        impl TypeProfileEntry {
            pub fn new(offset: impl Into<i64>, types: Vec<TypeObject>) -> Self {
                Self {
                    offset: offset.into(),
                    types,
                }
            }
        }
        impl TypeProfileEntry {
            pub fn builder() -> TypeProfileEntryBuilder {
                TypeProfileEntryBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TypeProfileEntryBuilder {
            offset: Option<i64>,
            types: Option<Vec<TypeObject>>,
        }
        impl TypeProfileEntryBuilder {
            pub fn offset(mut self, offset: impl Into<i64>) -> Self {
                self.offset = Some(offset.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<TypeObject>) -> Self {
                let v = self.types.get_or_insert(Vec::new());
                v.push(r#type.into());
                self
            }
            pub fn types<I, S>(mut self, types: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<TypeObject>,
            {
                let v = self.types.get_or_insert(Vec::new());
                for val in types {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<TypeProfileEntry, String> {
                Ok(TypeProfileEntry {
                    offset: self.offset.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(offset))
                    })?,
                    types: self.types.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(types))
                    })?,
                })
            }
        }
        impl TypeProfileEntry {
            pub const IDENTIFIER: &'static str = "Profiler.TypeProfileEntry";
        }
        #[doc = "Type profile data collected during runtime for a JavaScript script.\n[ScriptTypeProfile](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-ScriptTypeProfile)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ScriptTypeProfile {
            #[doc = "JavaScript script id."]
            #[serde(rename = "scriptId")]
            pub script_id: super::runtime::ScriptId,
            #[doc = "JavaScript script name or url."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Type profile entries for parameters and return values of the functions in the script."]
            #[serde(rename = "entries")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub entries: Vec<TypeProfileEntry>,
        }
        impl ScriptTypeProfile {
            pub fn new(
                script_id: impl Into<super::runtime::ScriptId>,
                url: impl Into<String>,
                entries: Vec<TypeProfileEntry>,
            ) -> Self {
                Self {
                    script_id: script_id.into(),
                    url: url.into(),
                    entries,
                }
            }
        }
        impl ScriptTypeProfile {
            pub fn builder() -> ScriptTypeProfileBuilder {
                ScriptTypeProfileBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ScriptTypeProfileBuilder {
            script_id: Option<super::runtime::ScriptId>,
            url: Option<String>,
            entries: Option<Vec<TypeProfileEntry>>,
        }
        impl ScriptTypeProfileBuilder {
            pub fn script_id(mut self, script_id: impl Into<super::runtime::ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn entrie(mut self, entrie: impl Into<TypeProfileEntry>) -> Self {
                let v = self.entries.get_or_insert(Vec::new());
                v.push(entrie.into());
                self
            }
            pub fn entries<I, S>(mut self, entries: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<TypeProfileEntry>,
            {
                let v = self.entries.get_or_insert(Vec::new());
                for val in entries {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<ScriptTypeProfile, String> {
                Ok(ScriptTypeProfile {
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    entries: self.entries.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(entries))
                    })?,
                })
            }
        }
        impl ScriptTypeProfile {
            pub const IDENTIFIER: &'static str = "Profiler.ScriptTypeProfile";
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Profiler.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Profiler.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Collect coverage data for the current isolate. The coverage data may be incomplete due to\ngarbage collection.\n[getBestEffortCoverage](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-getBestEffortCoverage)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetBestEffortCoverageParams {}
        impl GetBestEffortCoverageParams {
            pub const IDENTIFIER: &'static str = "Profiler.getBestEffortCoverage";
        }
        impl chromiumoxide_types::Method for GetBestEffortCoverageParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetBestEffortCoverageParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Collect coverage data for the current isolate. The coverage data may be incomplete due to\ngarbage collection.\n[getBestEffortCoverage](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-getBestEffortCoverage)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetBestEffortCoverageReturns {
            #[doc = "Coverage data for the current isolate."]
            #[serde(rename = "result")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub result: Vec<ScriptCoverage>,
        }
        impl GetBestEffortCoverageReturns {
            pub fn new(result: Vec<ScriptCoverage>) -> Self {
                Self { result }
            }
        }
        impl GetBestEffortCoverageReturns {
            pub fn builder() -> GetBestEffortCoverageReturnsBuilder {
                GetBestEffortCoverageReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetBestEffortCoverageReturnsBuilder {
            result: Option<Vec<ScriptCoverage>>,
        }
        impl GetBestEffortCoverageReturnsBuilder {
            pub fn result(mut self, result: impl Into<ScriptCoverage>) -> Self {
                let v = self.result.get_or_insert(Vec::new());
                v.push(result.into());
                self
            }
            pub fn results<I, S>(mut self, results: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ScriptCoverage>,
            {
                let v = self.result.get_or_insert(Vec::new());
                for val in results {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetBestEffortCoverageReturns, String> {
                Ok(GetBestEffortCoverageReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetBestEffortCoverageParams {
            type Response = GetBestEffortCoverageReturns;
        }
        #[doc = "Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.\n[setSamplingInterval](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-setSamplingInterval)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetSamplingIntervalParams {
            #[doc = "New sampling interval in microseconds."]
            #[serde(rename = "interval")]
            pub interval: i64,
        }
        impl SetSamplingIntervalParams {
            pub fn new(interval: impl Into<i64>) -> Self {
                Self {
                    interval: interval.into(),
                }
            }
        }
        impl SetSamplingIntervalParams {
            pub fn builder() -> SetSamplingIntervalParamsBuilder {
                SetSamplingIntervalParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetSamplingIntervalParamsBuilder {
            interval: Option<i64>,
        }
        impl SetSamplingIntervalParamsBuilder {
            pub fn interval(mut self, interval: impl Into<i64>) -> Self {
                self.interval = Some(interval.into());
                self
            }
            pub fn build(self) -> Result<SetSamplingIntervalParams, String> {
                Ok(SetSamplingIntervalParams {
                    interval: self.interval.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(interval))
                    })?,
                })
            }
        }
        impl SetSamplingIntervalParams {
            pub const IDENTIFIER: &'static str = "Profiler.setSamplingInterval";
        }
        impl chromiumoxide_types::Method for SetSamplingIntervalParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetSamplingIntervalParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.\n[setSamplingInterval](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-setSamplingInterval)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetSamplingIntervalReturns {}
        impl chromiumoxide_types::Command for SetSamplingIntervalParams {
            type Response = SetSamplingIntervalReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartParams {}
        impl StartParams {
            pub const IDENTIFIER: &'static str = "Profiler.start";
        }
        impl chromiumoxide_types::Method for StartParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartReturns {}
        impl chromiumoxide_types::Command for StartParams {
            type Response = StartReturns;
        }
        #[doc = "Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code\ncoverage may be incomplete. Enabling prevents running optimized code and resets execution\ncounters.\n[startPreciseCoverage](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-startPreciseCoverage)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartPreciseCoverageParams {
            #[doc = "Collect accurate call counts beyond simple 'covered' or 'not covered'."]
            #[serde(rename = "callCount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub call_count: Option<bool>,
            #[doc = "Collect block-based coverage."]
            #[serde(rename = "detailed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub detailed: Option<bool>,
            #[doc = "Allow the backend to send updates on its own initiative"]
            #[serde(rename = "allowTriggeredUpdates")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub allow_triggered_updates: Option<bool>,
        }
        impl StartPreciseCoverageParams {
            pub fn builder() -> StartPreciseCoverageParamsBuilder {
                StartPreciseCoverageParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StartPreciseCoverageParamsBuilder {
            call_count: Option<bool>,
            detailed: Option<bool>,
            allow_triggered_updates: Option<bool>,
        }
        impl StartPreciseCoverageParamsBuilder {
            pub fn call_count(mut self, call_count: impl Into<bool>) -> Self {
                self.call_count = Some(call_count.into());
                self
            }
            pub fn detailed(mut self, detailed: impl Into<bool>) -> Self {
                self.detailed = Some(detailed.into());
                self
            }
            pub fn allow_triggered_updates(
                mut self,
                allow_triggered_updates: impl Into<bool>,
            ) -> Self {
                self.allow_triggered_updates = Some(allow_triggered_updates.into());
                self
            }
            pub fn build(self) -> StartPreciseCoverageParams {
                StartPreciseCoverageParams {
                    call_count: self.call_count,
                    detailed: self.detailed,
                    allow_triggered_updates: self.allow_triggered_updates,
                }
            }
        }
        impl StartPreciseCoverageParams {
            pub const IDENTIFIER: &'static str = "Profiler.startPreciseCoverage";
        }
        impl chromiumoxide_types::Method for StartPreciseCoverageParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartPreciseCoverageParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code\ncoverage may be incomplete. Enabling prevents running optimized code and resets execution\ncounters.\n[startPreciseCoverage](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-startPreciseCoverage)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StartPreciseCoverageReturns {
            #[doc = "Monotonically increasing time (in seconds) when the coverage update was taken in the backend."]
            #[serde(rename = "timestamp")]
            pub timestamp: f64,
        }
        impl StartPreciseCoverageReturns {
            pub fn new(timestamp: impl Into<f64>) -> Self {
                Self {
                    timestamp: timestamp.into(),
                }
            }
        }
        impl StartPreciseCoverageReturns {
            pub fn builder() -> StartPreciseCoverageReturnsBuilder {
                StartPreciseCoverageReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StartPreciseCoverageReturnsBuilder {
            timestamp: Option<f64>,
        }
        impl StartPreciseCoverageReturnsBuilder {
            pub fn timestamp(mut self, timestamp: impl Into<f64>) -> Self {
                self.timestamp = Some(timestamp.into());
                self
            }
            pub fn build(self) -> Result<StartPreciseCoverageReturns, String> {
                Ok(StartPreciseCoverageReturns {
                    timestamp: self.timestamp.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(timestamp))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for StartPreciseCoverageParams {
            type Response = StartPreciseCoverageReturns;
        }
        #[doc = "Enable type profile.\n[startTypeProfile](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-startTypeProfile)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartTypeProfileParams {}
        impl StartTypeProfileParams {
            pub const IDENTIFIER: &'static str = "Profiler.startTypeProfile";
        }
        impl chromiumoxide_types::Method for StartTypeProfileParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartTypeProfileParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enable type profile.\n[startTypeProfile](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-startTypeProfile)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartTypeProfileReturns {}
        impl chromiumoxide_types::Command for StartTypeProfileParams {
            type Response = StartTypeProfileReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopParams {}
        impl StopParams {
            pub const IDENTIFIER: &'static str = "Profiler.stop";
        }
        impl chromiumoxide_types::Method for StopParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StopReturns {
            #[doc = "Recorded profile."]
            #[serde(rename = "profile")]
            pub profile: Profile,
        }
        impl StopReturns {
            pub fn new(profile: impl Into<Profile>) -> Self {
                Self {
                    profile: profile.into(),
                }
            }
        }
        impl StopReturns {
            pub fn builder() -> StopReturnsBuilder {
                StopReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StopReturnsBuilder {
            profile: Option<Profile>,
        }
        impl StopReturnsBuilder {
            pub fn profile(mut self, profile: impl Into<Profile>) -> Self {
                self.profile = Some(profile.into());
                self
            }
            pub fn build(self) -> Result<StopReturns, String> {
                Ok(StopReturns {
                    profile: self.profile.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(profile))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for StopParams {
            type Response = StopReturns;
        }
        #[doc = "Disable precise code coverage. Disabling releases unnecessary execution count records and allows\nexecuting optimized code.\n[stopPreciseCoverage](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-stopPreciseCoverage)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopPreciseCoverageParams {}
        impl StopPreciseCoverageParams {
            pub const IDENTIFIER: &'static str = "Profiler.stopPreciseCoverage";
        }
        impl chromiumoxide_types::Method for StopPreciseCoverageParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopPreciseCoverageParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disable precise code coverage. Disabling releases unnecessary execution count records and allows\nexecuting optimized code.\n[stopPreciseCoverage](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-stopPreciseCoverage)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopPreciseCoverageReturns {}
        impl chromiumoxide_types::Command for StopPreciseCoverageParams {
            type Response = StopPreciseCoverageReturns;
        }
        #[doc = "Disable type profile. Disabling releases type profile data collected so far.\n[stopTypeProfile](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-stopTypeProfile)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopTypeProfileParams {}
        impl StopTypeProfileParams {
            pub const IDENTIFIER: &'static str = "Profiler.stopTypeProfile";
        }
        impl chromiumoxide_types::Method for StopTypeProfileParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopTypeProfileParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disable type profile. Disabling releases type profile data collected so far.\n[stopTypeProfile](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-stopTypeProfile)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopTypeProfileReturns {}
        impl chromiumoxide_types::Command for StopTypeProfileParams {
            type Response = StopTypeProfileReturns;
        }
        #[doc = "Collect coverage data for the current isolate, and resets execution counters. Precise code\ncoverage needs to have started.\n[takePreciseCoverage](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-takePreciseCoverage)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TakePreciseCoverageParams {}
        impl TakePreciseCoverageParams {
            pub const IDENTIFIER: &'static str = "Profiler.takePreciseCoverage";
        }
        impl chromiumoxide_types::Method for TakePreciseCoverageParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for TakePreciseCoverageParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Collect coverage data for the current isolate, and resets execution counters. Precise code\ncoverage needs to have started.\n[takePreciseCoverage](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-takePreciseCoverage)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TakePreciseCoverageReturns {
            #[doc = "Coverage data for the current isolate."]
            #[serde(rename = "result")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub result: Vec<ScriptCoverage>,
            #[doc = "Monotonically increasing time (in seconds) when the coverage update was taken in the backend."]
            #[serde(rename = "timestamp")]
            pub timestamp: f64,
        }
        impl TakePreciseCoverageReturns {
            pub fn new(result: Vec<ScriptCoverage>, timestamp: impl Into<f64>) -> Self {
                Self {
                    result,
                    timestamp: timestamp.into(),
                }
            }
        }
        impl TakePreciseCoverageReturns {
            pub fn builder() -> TakePreciseCoverageReturnsBuilder {
                TakePreciseCoverageReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TakePreciseCoverageReturnsBuilder {
            result: Option<Vec<ScriptCoverage>>,
            timestamp: Option<f64>,
        }
        impl TakePreciseCoverageReturnsBuilder {
            pub fn result(mut self, result: impl Into<ScriptCoverage>) -> Self {
                let v = self.result.get_or_insert(Vec::new());
                v.push(result.into());
                self
            }
            pub fn results<I, S>(mut self, results: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ScriptCoverage>,
            {
                let v = self.result.get_or_insert(Vec::new());
                for val in results {
                    v.push(val.into());
                }
                self
            }
            pub fn timestamp(mut self, timestamp: impl Into<f64>) -> Self {
                self.timestamp = Some(timestamp.into());
                self
            }
            pub fn build(self) -> Result<TakePreciseCoverageReturns, String> {
                Ok(TakePreciseCoverageReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                    timestamp: self.timestamp.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(timestamp))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for TakePreciseCoverageParams {
            type Response = TakePreciseCoverageReturns;
        }
        #[doc = "Collect type profile.\n[takeTypeProfile](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-takeTypeProfile)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TakeTypeProfileParams {}
        impl TakeTypeProfileParams {
            pub const IDENTIFIER: &'static str = "Profiler.takeTypeProfile";
        }
        impl chromiumoxide_types::Method for TakeTypeProfileParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for TakeTypeProfileParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Collect type profile.\n[takeTypeProfile](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-takeTypeProfile)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TakeTypeProfileReturns {
            #[doc = "Type profile for all scripts since startTypeProfile() was turned on."]
            #[serde(rename = "result")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub result: Vec<ScriptTypeProfile>,
        }
        impl TakeTypeProfileReturns {
            pub fn new(result: Vec<ScriptTypeProfile>) -> Self {
                Self { result }
            }
        }
        impl TakeTypeProfileReturns {
            pub fn builder() -> TakeTypeProfileReturnsBuilder {
                TakeTypeProfileReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TakeTypeProfileReturnsBuilder {
            result: Option<Vec<ScriptTypeProfile>>,
        }
        impl TakeTypeProfileReturnsBuilder {
            pub fn result(mut self, result: impl Into<ScriptTypeProfile>) -> Self {
                let v = self.result.get_or_insert(Vec::new());
                v.push(result.into());
                self
            }
            pub fn results<I, S>(mut self, results: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ScriptTypeProfile>,
            {
                let v = self.result.get_or_insert(Vec::new());
                for val in results {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<TakeTypeProfileReturns, String> {
                Ok(TakeTypeProfileReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for TakeTypeProfileParams {
            type Response = TakeTypeProfileReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventConsoleProfileFinished {
            #[serde(rename = "id")]
            pub id: String,
            #[doc = "Location of console.profileEnd()."]
            #[serde(rename = "location")]
            pub location: super::debugger::Location,
            #[serde(rename = "profile")]
            pub profile: Profile,
            #[doc = "Profile title passed as an argument to console.profile()."]
            #[serde(rename = "title")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub title: Option<String>,
        }
        impl EventConsoleProfileFinished {
            pub const IDENTIFIER: &'static str = "Profiler.consoleProfileFinished";
        }
        impl chromiumoxide_types::Method for EventConsoleProfileFinished {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventConsoleProfileFinished {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sent when new profile recording is started using console.profile() call.\n[consoleProfileStarted](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#event-consoleProfileStarted)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventConsoleProfileStarted {
            #[serde(rename = "id")]
            pub id: String,
            #[doc = "Location of console.profile()."]
            #[serde(rename = "location")]
            pub location: super::debugger::Location,
            #[doc = "Profile title passed as an argument to console.profile()."]
            #[serde(rename = "title")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub title: Option<String>,
        }
        impl EventConsoleProfileStarted {
            pub const IDENTIFIER: &'static str = "Profiler.consoleProfileStarted";
        }
        impl chromiumoxide_types::Method for EventConsoleProfileStarted {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventConsoleProfileStarted {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Reports coverage delta since the last poll (either from an event like this, or from\n`takePreciseCoverage` for the current isolate. May only be sent if precise code\ncoverage has been started. This event can be trigged by the embedder to, for example,\ntrigger collection of coverage data immediately at a certain point in time.\n[preciseCoverageDeltaUpdate](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#event-preciseCoverageDeltaUpdate)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventPreciseCoverageDeltaUpdate {
            #[doc = "Monotonically increasing time (in seconds) when the coverage update was taken in the backend."]
            #[serde(rename = "timestamp")]
            pub timestamp: f64,
            #[doc = "Identifier for distinguishing coverage events."]
            #[serde(rename = "occasion")]
            pub occasion: String,
            #[doc = "Coverage data for the current isolate."]
            #[serde(rename = "result")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub result: Vec<ScriptCoverage>,
        }
        impl EventPreciseCoverageDeltaUpdate {
            pub const IDENTIFIER: &'static str = "Profiler.preciseCoverageDeltaUpdate";
        }
        impl chromiumoxide_types::Method for EventPreciseCoverageDeltaUpdate {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventPreciseCoverageDeltaUpdate {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.\nEvaluation results are returned as mirror object that expose object type, string representation\nand unique identifier that can be used for further object reference. Original objects are\nmaintained in memory unless they are either explicitly released or are released along with the\nother objects in their object group."]
    pub mod runtime {
        use serde::{Deserialize, Serialize};
        #[doc = "Unique script identifier.\n[ScriptId](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-ScriptId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct ScriptId(String);
        impl ScriptId {
            pub fn new(val: impl Into<String>) -> Self {
                ScriptId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for ScriptId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<ScriptId> for String {
            fn from(el: ScriptId) -> String {
                el.0
            }
        }
        impl From<String> for ScriptId {
            fn from(expr: String) -> Self {
                ScriptId(expr)
            }
        }
        impl std::borrow::Borrow<str> for ScriptId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl ScriptId {
            pub const IDENTIFIER: &'static str = "Runtime.ScriptId";
        }
        #[doc = "Represents the value serialiazed by the WebDriver BiDi specification\nhttps://w3c.github.io/webdriver-bidi.\n[WebDriverValue](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-WebDriverValue)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct WebDriverValue {
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: WebDriverValueType,
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value: Option<serde_json::Value>,
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<String>,
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum WebDriverValueType {
            #[serde(rename = "undefined")]
            Undefined,
            #[serde(rename = "null")]
            Null,
            #[serde(rename = "string")]
            String,
            #[serde(rename = "number")]
            Number,
            #[serde(rename = "boolean")]
            Boolean,
            #[serde(rename = "bigint")]
            Bigint,
            #[serde(rename = "regexp")]
            Regexp,
            #[serde(rename = "date")]
            Date,
            #[serde(rename = "symbol")]
            Symbol,
            #[serde(rename = "array")]
            Array,
            #[serde(rename = "object")]
            Object,
            #[serde(rename = "function")]
            Function,
            #[serde(rename = "map")]
            Map,
            #[serde(rename = "set")]
            Set,
            #[serde(rename = "weakmap")]
            Weakmap,
            #[serde(rename = "weakset")]
            Weakset,
            #[serde(rename = "error")]
            Error,
            #[serde(rename = "proxy")]
            Proxy,
            #[serde(rename = "promise")]
            Promise,
            #[serde(rename = "typedarray")]
            Typedarray,
            #[serde(rename = "arraybuffer")]
            Arraybuffer,
            #[serde(rename = "node")]
            Node,
            #[serde(rename = "window")]
            Window,
        }
        impl AsRef<str> for WebDriverValueType {
            fn as_ref(&self) -> &str {
                match self {
                    WebDriverValueType::Undefined => "undefined",
                    WebDriverValueType::Null => "null",
                    WebDriverValueType::String => "string",
                    WebDriverValueType::Number => "number",
                    WebDriverValueType::Boolean => "boolean",
                    WebDriverValueType::Bigint => "bigint",
                    WebDriverValueType::Regexp => "regexp",
                    WebDriverValueType::Date => "date",
                    WebDriverValueType::Symbol => "symbol",
                    WebDriverValueType::Array => "array",
                    WebDriverValueType::Object => "object",
                    WebDriverValueType::Function => "function",
                    WebDriverValueType::Map => "map",
                    WebDriverValueType::Set => "set",
                    WebDriverValueType::Weakmap => "weakmap",
                    WebDriverValueType::Weakset => "weakset",
                    WebDriverValueType::Error => "error",
                    WebDriverValueType::Proxy => "proxy",
                    WebDriverValueType::Promise => "promise",
                    WebDriverValueType::Typedarray => "typedarray",
                    WebDriverValueType::Arraybuffer => "arraybuffer",
                    WebDriverValueType::Node => "node",
                    WebDriverValueType::Window => "window",
                }
            }
        }
        impl ::std::str::FromStr for WebDriverValueType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "undefined" | "Undefined" => Ok(WebDriverValueType::Undefined),
                    "null" | "Null" => Ok(WebDriverValueType::Null),
                    "string" | "String" => Ok(WebDriverValueType::String),
                    "number" | "Number" => Ok(WebDriverValueType::Number),
                    "boolean" | "Boolean" => Ok(WebDriverValueType::Boolean),
                    "bigint" | "Bigint" => Ok(WebDriverValueType::Bigint),
                    "regexp" | "Regexp" => Ok(WebDriverValueType::Regexp),
                    "date" | "Date" => Ok(WebDriverValueType::Date),
                    "symbol" | "Symbol" => Ok(WebDriverValueType::Symbol),
                    "array" | "Array" => Ok(WebDriverValueType::Array),
                    "object" | "Object" => Ok(WebDriverValueType::Object),
                    "function" | "Function" => Ok(WebDriverValueType::Function),
                    "map" | "Map" => Ok(WebDriverValueType::Map),
                    "set" | "Set" => Ok(WebDriverValueType::Set),
                    "weakmap" | "Weakmap" => Ok(WebDriverValueType::Weakmap),
                    "weakset" | "Weakset" => Ok(WebDriverValueType::Weakset),
                    "error" | "Error" => Ok(WebDriverValueType::Error),
                    "proxy" | "Proxy" => Ok(WebDriverValueType::Proxy),
                    "promise" | "Promise" => Ok(WebDriverValueType::Promise),
                    "typedarray" | "Typedarray" => Ok(WebDriverValueType::Typedarray),
                    "arraybuffer" | "Arraybuffer" => Ok(WebDriverValueType::Arraybuffer),
                    "node" | "Node" => Ok(WebDriverValueType::Node),
                    "window" | "Window" => Ok(WebDriverValueType::Window),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl WebDriverValue {
            pub fn new(r#type: impl Into<WebDriverValueType>) -> Self {
                Self {
                    r#type: r#type.into(),
                    value: None,
                    object_id: None,
                }
            }
        }
        impl WebDriverValue {
            pub fn builder() -> WebDriverValueBuilder {
                WebDriverValueBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct WebDriverValueBuilder {
            r#type: Option<WebDriverValueType>,
            value: Option<serde_json::Value>,
            object_id: Option<String>,
        }
        impl WebDriverValueBuilder {
            pub fn r#type(mut self, r#type: impl Into<WebDriverValueType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn value(mut self, value: impl Into<serde_json::Value>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn object_id(mut self, object_id: impl Into<String>) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> Result<WebDriverValue, String> {
                Ok(WebDriverValue {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    value: self.value,
                    object_id: self.object_id,
                })
            }
        }
        impl WebDriverValue {
            pub const IDENTIFIER: &'static str = "Runtime.WebDriverValue";
        }
        #[doc = "Unique object identifier.\n[RemoteObjectId](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-RemoteObjectId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct RemoteObjectId(String);
        impl RemoteObjectId {
            pub fn new(val: impl Into<String>) -> Self {
                RemoteObjectId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for RemoteObjectId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<RemoteObjectId> for String {
            fn from(el: RemoteObjectId) -> String {
                el.0
            }
        }
        impl From<String> for RemoteObjectId {
            fn from(expr: String) -> Self {
                RemoteObjectId(expr)
            }
        }
        impl std::borrow::Borrow<str> for RemoteObjectId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl RemoteObjectId {
            pub const IDENTIFIER: &'static str = "Runtime.RemoteObjectId";
        }
        #[doc = "Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,\n`-Infinity`, and bigint literals.\n[UnserializableValue](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-UnserializableValue)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct UnserializableValue(String);
        impl UnserializableValue {
            pub fn new(val: impl Into<String>) -> Self {
                UnserializableValue(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for UnserializableValue {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<UnserializableValue> for String {
            fn from(el: UnserializableValue) -> String {
                el.0
            }
        }
        impl From<String> for UnserializableValue {
            fn from(expr: String) -> Self {
                UnserializableValue(expr)
            }
        }
        impl UnserializableValue {
            pub const IDENTIFIER: &'static str = "Runtime.UnserializableValue";
        }
        #[doc = "Mirror object referencing original JavaScript object.\n[RemoteObject](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-RemoteObject)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoteObject {
            #[doc = "Object type."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: RemoteObjectType,
            #[doc = "Object subtype hint. Specified for `object` type values only.\nNOTE: If you change anything here, make sure to also update\n`subtype` in `ObjectPreview` and `PropertyPreview` below."]
            #[serde(rename = "subtype")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub subtype: Option<RemoteObjectSubtype>,
            #[doc = "Object class (constructor) name. Specified for `object` type values only."]
            #[serde(rename = "className")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub class_name: Option<String>,
            #[doc = "Remote object value in case of primitive values or JSON values (if it was requested)."]
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value: Option<serde_json::Value>,
            #[doc = "Primitive value which can not be JSON-stringified does not have `value`, but gets this\nproperty."]
            #[serde(rename = "unserializableValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub unserializable_value: Option<UnserializableValue>,
            #[doc = "String representation of the object."]
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub description: Option<String>,
            #[doc = "WebDriver BiDi representation of the value."]
            #[serde(rename = "webDriverValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub web_driver_value: Option<WebDriverValue>,
            #[doc = "Unique object identifier (for non-primitive values)."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<RemoteObjectId>,
            #[doc = "Preview containing abbreviated property values. Specified for `object` type values only."]
            #[serde(rename = "preview")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub preview: Option<ObjectPreview>,
            #[serde(rename = "customPreview")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub custom_preview: Option<CustomPreview>,
        }
        #[doc = "Object type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum RemoteObjectType {
            #[serde(rename = "object")]
            Object,
            #[serde(rename = "function")]
            Function,
            #[serde(rename = "undefined")]
            Undefined,
            #[serde(rename = "string")]
            String,
            #[serde(rename = "number")]
            Number,
            #[serde(rename = "boolean")]
            Boolean,
            #[serde(rename = "symbol")]
            Symbol,
            #[serde(rename = "bigint")]
            Bigint,
        }
        impl AsRef<str> for RemoteObjectType {
            fn as_ref(&self) -> &str {
                match self {
                    RemoteObjectType::Object => "object",
                    RemoteObjectType::Function => "function",
                    RemoteObjectType::Undefined => "undefined",
                    RemoteObjectType::String => "string",
                    RemoteObjectType::Number => "number",
                    RemoteObjectType::Boolean => "boolean",
                    RemoteObjectType::Symbol => "symbol",
                    RemoteObjectType::Bigint => "bigint",
                }
            }
        }
        impl ::std::str::FromStr for RemoteObjectType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "object" | "Object" => Ok(RemoteObjectType::Object),
                    "function" | "Function" => Ok(RemoteObjectType::Function),
                    "undefined" | "Undefined" => Ok(RemoteObjectType::Undefined),
                    "string" | "String" => Ok(RemoteObjectType::String),
                    "number" | "Number" => Ok(RemoteObjectType::Number),
                    "boolean" | "Boolean" => Ok(RemoteObjectType::Boolean),
                    "symbol" | "Symbol" => Ok(RemoteObjectType::Symbol),
                    "bigint" | "Bigint" => Ok(RemoteObjectType::Bigint),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Object subtype hint. Specified for `object` type values only.\nNOTE: If you change anything here, make sure to also update\n`subtype` in `ObjectPreview` and `PropertyPreview` below."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum RemoteObjectSubtype {
            #[serde(rename = "array")]
            Array,
            #[serde(rename = "null")]
            Null,
            #[serde(rename = "node")]
            Node,
            #[serde(rename = "regexp")]
            Regexp,
            #[serde(rename = "date")]
            Date,
            #[serde(rename = "map")]
            Map,
            #[serde(rename = "set")]
            Set,
            #[serde(rename = "weakmap")]
            Weakmap,
            #[serde(rename = "weakset")]
            Weakset,
            #[serde(rename = "iterator")]
            Iterator,
            #[serde(rename = "generator")]
            Generator,
            #[serde(rename = "error")]
            Error,
            #[serde(rename = "proxy")]
            Proxy,
            #[serde(rename = "promise")]
            Promise,
            #[serde(rename = "typedarray")]
            Typedarray,
            #[serde(rename = "arraybuffer")]
            Arraybuffer,
            #[serde(rename = "dataview")]
            Dataview,
            #[serde(rename = "webassemblymemory")]
            Webassemblymemory,
            #[serde(rename = "wasmvalue")]
            Wasmvalue,
        }
        impl AsRef<str> for RemoteObjectSubtype {
            fn as_ref(&self) -> &str {
                match self {
                    RemoteObjectSubtype::Array => "array",
                    RemoteObjectSubtype::Null => "null",
                    RemoteObjectSubtype::Node => "node",
                    RemoteObjectSubtype::Regexp => "regexp",
                    RemoteObjectSubtype::Date => "date",
                    RemoteObjectSubtype::Map => "map",
                    RemoteObjectSubtype::Set => "set",
                    RemoteObjectSubtype::Weakmap => "weakmap",
                    RemoteObjectSubtype::Weakset => "weakset",
                    RemoteObjectSubtype::Iterator => "iterator",
                    RemoteObjectSubtype::Generator => "generator",
                    RemoteObjectSubtype::Error => "error",
                    RemoteObjectSubtype::Proxy => "proxy",
                    RemoteObjectSubtype::Promise => "promise",
                    RemoteObjectSubtype::Typedarray => "typedarray",
                    RemoteObjectSubtype::Arraybuffer => "arraybuffer",
                    RemoteObjectSubtype::Dataview => "dataview",
                    RemoteObjectSubtype::Webassemblymemory => "webassemblymemory",
                    RemoteObjectSubtype::Wasmvalue => "wasmvalue",
                }
            }
        }
        impl ::std::str::FromStr for RemoteObjectSubtype {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "array" | "Array" => Ok(RemoteObjectSubtype::Array),
                    "null" | "Null" => Ok(RemoteObjectSubtype::Null),
                    "node" | "Node" => Ok(RemoteObjectSubtype::Node),
                    "regexp" | "Regexp" => Ok(RemoteObjectSubtype::Regexp),
                    "date" | "Date" => Ok(RemoteObjectSubtype::Date),
                    "map" | "Map" => Ok(RemoteObjectSubtype::Map),
                    "set" | "Set" => Ok(RemoteObjectSubtype::Set),
                    "weakmap" | "Weakmap" => Ok(RemoteObjectSubtype::Weakmap),
                    "weakset" | "Weakset" => Ok(RemoteObjectSubtype::Weakset),
                    "iterator" | "Iterator" => Ok(RemoteObjectSubtype::Iterator),
                    "generator" | "Generator" => Ok(RemoteObjectSubtype::Generator),
                    "error" | "Error" => Ok(RemoteObjectSubtype::Error),
                    "proxy" | "Proxy" => Ok(RemoteObjectSubtype::Proxy),
                    "promise" | "Promise" => Ok(RemoteObjectSubtype::Promise),
                    "typedarray" | "Typedarray" => Ok(RemoteObjectSubtype::Typedarray),
                    "arraybuffer" | "Arraybuffer" => Ok(RemoteObjectSubtype::Arraybuffer),
                    "dataview" | "Dataview" => Ok(RemoteObjectSubtype::Dataview),
                    "webassemblymemory" | "Webassemblymemory" => {
                        Ok(RemoteObjectSubtype::Webassemblymemory)
                    }
                    "wasmvalue" | "Wasmvalue" => Ok(RemoteObjectSubtype::Wasmvalue),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl RemoteObject {
            pub fn new(r#type: impl Into<RemoteObjectType>) -> Self {
                Self {
                    r#type: r#type.into(),
                    subtype: None,
                    class_name: None,
                    value: None,
                    unserializable_value: None,
                    description: None,
                    web_driver_value: None,
                    object_id: None,
                    preview: None,
                    custom_preview: None,
                }
            }
        }
        impl RemoteObject {
            pub fn builder() -> RemoteObjectBuilder {
                RemoteObjectBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoteObjectBuilder {
            r#type: Option<RemoteObjectType>,
            subtype: Option<RemoteObjectSubtype>,
            class_name: Option<String>,
            value: Option<serde_json::Value>,
            unserializable_value: Option<UnserializableValue>,
            description: Option<String>,
            web_driver_value: Option<WebDriverValue>,
            object_id: Option<RemoteObjectId>,
            preview: Option<ObjectPreview>,
            custom_preview: Option<CustomPreview>,
        }
        impl RemoteObjectBuilder {
            pub fn r#type(mut self, r#type: impl Into<RemoteObjectType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn subtype(mut self, subtype: impl Into<RemoteObjectSubtype>) -> Self {
                self.subtype = Some(subtype.into());
                self
            }
            pub fn class_name(mut self, class_name: impl Into<String>) -> Self {
                self.class_name = Some(class_name.into());
                self
            }
            pub fn value(mut self, value: impl Into<serde_json::Value>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn unserializable_value(
                mut self,
                unserializable_value: impl Into<UnserializableValue>,
            ) -> Self {
                self.unserializable_value = Some(unserializable_value.into());
                self
            }
            pub fn description(mut self, description: impl Into<String>) -> Self {
                self.description = Some(description.into());
                self
            }
            pub fn web_driver_value(mut self, web_driver_value: impl Into<WebDriverValue>) -> Self {
                self.web_driver_value = Some(web_driver_value.into());
                self
            }
            pub fn object_id(mut self, object_id: impl Into<RemoteObjectId>) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn preview(mut self, preview: impl Into<ObjectPreview>) -> Self {
                self.preview = Some(preview.into());
                self
            }
            pub fn custom_preview(mut self, custom_preview: impl Into<CustomPreview>) -> Self {
                self.custom_preview = Some(custom_preview.into());
                self
            }
            pub fn build(self) -> Result<RemoteObject, String> {
                Ok(RemoteObject {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    subtype: self.subtype,
                    class_name: self.class_name,
                    value: self.value,
                    unserializable_value: self.unserializable_value,
                    description: self.description,
                    web_driver_value: self.web_driver_value,
                    object_id: self.object_id,
                    preview: self.preview,
                    custom_preview: self.custom_preview,
                })
            }
        }
        impl RemoteObject {
            pub const IDENTIFIER: &'static str = "Runtime.RemoteObject";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CustomPreview {
            #[doc = "The JSON-stringified result of formatter.header(object, config) call.\nIt contains json ML array that represents RemoteObject."]
            #[serde(rename = "header")]
            pub header: String,
            #[doc = "If formatter returns true as a result of formatter.hasBody call then bodyGetterId will\ncontain RemoteObjectId for the function that returns result of formatter.body(object, config) call.\nThe result value is json ML array."]
            #[serde(rename = "bodyGetterId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub body_getter_id: Option<RemoteObjectId>,
        }
        impl CustomPreview {
            pub fn new(header: impl Into<String>) -> Self {
                Self {
                    header: header.into(),
                    body_getter_id: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for CustomPreview {
            fn from(url: T) -> Self {
                CustomPreview::new(url)
            }
        }
        impl CustomPreview {
            pub fn builder() -> CustomPreviewBuilder {
                CustomPreviewBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CustomPreviewBuilder {
            header: Option<String>,
            body_getter_id: Option<RemoteObjectId>,
        }
        impl CustomPreviewBuilder {
            pub fn header(mut self, header: impl Into<String>) -> Self {
                self.header = Some(header.into());
                self
            }
            pub fn body_getter_id(mut self, body_getter_id: impl Into<RemoteObjectId>) -> Self {
                self.body_getter_id = Some(body_getter_id.into());
                self
            }
            pub fn build(self) -> Result<CustomPreview, String> {
                Ok(CustomPreview {
                    header: self.header.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(header))
                    })?,
                    body_getter_id: self.body_getter_id,
                })
            }
        }
        impl CustomPreview {
            pub const IDENTIFIER: &'static str = "Runtime.CustomPreview";
        }
        #[doc = "Object containing abbreviated remote object value.\n[ObjectPreview](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-ObjectPreview)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ObjectPreview {
            #[doc = "Object type."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: ObjectPreviewType,
            #[doc = "Object subtype hint. Specified for `object` type values only."]
            #[serde(rename = "subtype")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub subtype: Option<ObjectPreviewSubtype>,
            #[doc = "String representation of the object."]
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub description: Option<String>,
            #[doc = "True iff some of the properties or entries of the original object did not fit."]
            #[serde(rename = "overflow")]
            pub overflow: bool,
            #[doc = "List of the properties."]
            #[serde(rename = "properties")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub properties: Vec<PropertyPreview>,
            #[doc = "List of the entries. Specified for `map` and `set` subtype values only."]
            #[serde(rename = "entries")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub entries: Option<Vec<EntryPreview>>,
        }
        #[doc = "Object type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ObjectPreviewType {
            #[serde(rename = "object")]
            Object,
            #[serde(rename = "function")]
            Function,
            #[serde(rename = "undefined")]
            Undefined,
            #[serde(rename = "string")]
            String,
            #[serde(rename = "number")]
            Number,
            #[serde(rename = "boolean")]
            Boolean,
            #[serde(rename = "symbol")]
            Symbol,
            #[serde(rename = "bigint")]
            Bigint,
        }
        impl AsRef<str> for ObjectPreviewType {
            fn as_ref(&self) -> &str {
                match self {
                    ObjectPreviewType::Object => "object",
                    ObjectPreviewType::Function => "function",
                    ObjectPreviewType::Undefined => "undefined",
                    ObjectPreviewType::String => "string",
                    ObjectPreviewType::Number => "number",
                    ObjectPreviewType::Boolean => "boolean",
                    ObjectPreviewType::Symbol => "symbol",
                    ObjectPreviewType::Bigint => "bigint",
                }
            }
        }
        impl ::std::str::FromStr for ObjectPreviewType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "object" | "Object" => Ok(ObjectPreviewType::Object),
                    "function" | "Function" => Ok(ObjectPreviewType::Function),
                    "undefined" | "Undefined" => Ok(ObjectPreviewType::Undefined),
                    "string" | "String" => Ok(ObjectPreviewType::String),
                    "number" | "Number" => Ok(ObjectPreviewType::Number),
                    "boolean" | "Boolean" => Ok(ObjectPreviewType::Boolean),
                    "symbol" | "Symbol" => Ok(ObjectPreviewType::Symbol),
                    "bigint" | "Bigint" => Ok(ObjectPreviewType::Bigint),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Object subtype hint. Specified for `object` type values only."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ObjectPreviewSubtype {
            #[serde(rename = "array")]
            Array,
            #[serde(rename = "null")]
            Null,
            #[serde(rename = "node")]
            Node,
            #[serde(rename = "regexp")]
            Regexp,
            #[serde(rename = "date")]
            Date,
            #[serde(rename = "map")]
            Map,
            #[serde(rename = "set")]
            Set,
            #[serde(rename = "weakmap")]
            Weakmap,
            #[serde(rename = "weakset")]
            Weakset,
            #[serde(rename = "iterator")]
            Iterator,
            #[serde(rename = "generator")]
            Generator,
            #[serde(rename = "error")]
            Error,
            #[serde(rename = "proxy")]
            Proxy,
            #[serde(rename = "promise")]
            Promise,
            #[serde(rename = "typedarray")]
            Typedarray,
            #[serde(rename = "arraybuffer")]
            Arraybuffer,
            #[serde(rename = "dataview")]
            Dataview,
            #[serde(rename = "webassemblymemory")]
            Webassemblymemory,
            #[serde(rename = "wasmvalue")]
            Wasmvalue,
        }
        impl AsRef<str> for ObjectPreviewSubtype {
            fn as_ref(&self) -> &str {
                match self {
                    ObjectPreviewSubtype::Array => "array",
                    ObjectPreviewSubtype::Null => "null",
                    ObjectPreviewSubtype::Node => "node",
                    ObjectPreviewSubtype::Regexp => "regexp",
                    ObjectPreviewSubtype::Date => "date",
                    ObjectPreviewSubtype::Map => "map",
                    ObjectPreviewSubtype::Set => "set",
                    ObjectPreviewSubtype::Weakmap => "weakmap",
                    ObjectPreviewSubtype::Weakset => "weakset",
                    ObjectPreviewSubtype::Iterator => "iterator",
                    ObjectPreviewSubtype::Generator => "generator",
                    ObjectPreviewSubtype::Error => "error",
                    ObjectPreviewSubtype::Proxy => "proxy",
                    ObjectPreviewSubtype::Promise => "promise",
                    ObjectPreviewSubtype::Typedarray => "typedarray",
                    ObjectPreviewSubtype::Arraybuffer => "arraybuffer",
                    ObjectPreviewSubtype::Dataview => "dataview",
                    ObjectPreviewSubtype::Webassemblymemory => "webassemblymemory",
                    ObjectPreviewSubtype::Wasmvalue => "wasmvalue",
                }
            }
        }
        impl ::std::str::FromStr for ObjectPreviewSubtype {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "array" | "Array" => Ok(ObjectPreviewSubtype::Array),
                    "null" | "Null" => Ok(ObjectPreviewSubtype::Null),
                    "node" | "Node" => Ok(ObjectPreviewSubtype::Node),
                    "regexp" | "Regexp" => Ok(ObjectPreviewSubtype::Regexp),
                    "date" | "Date" => Ok(ObjectPreviewSubtype::Date),
                    "map" | "Map" => Ok(ObjectPreviewSubtype::Map),
                    "set" | "Set" => Ok(ObjectPreviewSubtype::Set),
                    "weakmap" | "Weakmap" => Ok(ObjectPreviewSubtype::Weakmap),
                    "weakset" | "Weakset" => Ok(ObjectPreviewSubtype::Weakset),
                    "iterator" | "Iterator" => Ok(ObjectPreviewSubtype::Iterator),
                    "generator" | "Generator" => Ok(ObjectPreviewSubtype::Generator),
                    "error" | "Error" => Ok(ObjectPreviewSubtype::Error),
                    "proxy" | "Proxy" => Ok(ObjectPreviewSubtype::Proxy),
                    "promise" | "Promise" => Ok(ObjectPreviewSubtype::Promise),
                    "typedarray" | "Typedarray" => Ok(ObjectPreviewSubtype::Typedarray),
                    "arraybuffer" | "Arraybuffer" => Ok(ObjectPreviewSubtype::Arraybuffer),
                    "dataview" | "Dataview" => Ok(ObjectPreviewSubtype::Dataview),
                    "webassemblymemory" | "Webassemblymemory" => {
                        Ok(ObjectPreviewSubtype::Webassemblymemory)
                    }
                    "wasmvalue" | "Wasmvalue" => Ok(ObjectPreviewSubtype::Wasmvalue),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl ObjectPreview {
            pub fn new(
                r#type: impl Into<ObjectPreviewType>,
                overflow: impl Into<bool>,
                properties: Vec<PropertyPreview>,
            ) -> Self {
                Self {
                    r#type: r#type.into(),
                    overflow: overflow.into(),
                    properties,
                    subtype: None,
                    description: None,
                    entries: None,
                }
            }
        }
        impl ObjectPreview {
            pub fn builder() -> ObjectPreviewBuilder {
                ObjectPreviewBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ObjectPreviewBuilder {
            r#type: Option<ObjectPreviewType>,
            subtype: Option<ObjectPreviewSubtype>,
            description: Option<String>,
            overflow: Option<bool>,
            properties: Option<Vec<PropertyPreview>>,
            entries: Option<Vec<EntryPreview>>,
        }
        impl ObjectPreviewBuilder {
            pub fn r#type(mut self, r#type: impl Into<ObjectPreviewType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn subtype(mut self, subtype: impl Into<ObjectPreviewSubtype>) -> Self {
                self.subtype = Some(subtype.into());
                self
            }
            pub fn description(mut self, description: impl Into<String>) -> Self {
                self.description = Some(description.into());
                self
            }
            pub fn overflow(mut self, overflow: impl Into<bool>) -> Self {
                self.overflow = Some(overflow.into());
                self
            }
            pub fn propertie(mut self, propertie: impl Into<PropertyPreview>) -> Self {
                let v = self.properties.get_or_insert(Vec::new());
                v.push(propertie.into());
                self
            }
            pub fn properties<I, S>(mut self, properties: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PropertyPreview>,
            {
                let v = self.properties.get_or_insert(Vec::new());
                for val in properties {
                    v.push(val.into());
                }
                self
            }
            pub fn entrie(mut self, entrie: impl Into<EntryPreview>) -> Self {
                let v = self.entries.get_or_insert(Vec::new());
                v.push(entrie.into());
                self
            }
            pub fn entries<I, S>(mut self, entries: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<EntryPreview>,
            {
                let v = self.entries.get_or_insert(Vec::new());
                for val in entries {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<ObjectPreview, String> {
                Ok(ObjectPreview {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    subtype: self.subtype,
                    description: self.description,
                    overflow: self.overflow.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(overflow))
                    })?,
                    properties: self.properties.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(properties))
                    })?,
                    entries: self.entries,
                })
            }
        }
        impl ObjectPreview {
            pub const IDENTIFIER: &'static str = "Runtime.ObjectPreview";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PropertyPreview {
            #[doc = "Property name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Object type. Accessor means that the property itself is an accessor property."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: PropertyPreviewType,
            #[doc = "User-friendly property value string."]
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value: Option<String>,
            #[doc = "Nested value preview."]
            #[serde(rename = "valuePreview")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value_preview: Option<ObjectPreview>,
            #[doc = "Object subtype hint. Specified for `object` type values only."]
            #[serde(rename = "subtype")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub subtype: Option<PropertyPreviewSubtype>,
        }
        #[doc = "Object type. Accessor means that the property itself is an accessor property."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PropertyPreviewType {
            #[serde(rename = "object")]
            Object,
            #[serde(rename = "function")]
            Function,
            #[serde(rename = "undefined")]
            Undefined,
            #[serde(rename = "string")]
            String,
            #[serde(rename = "number")]
            Number,
            #[serde(rename = "boolean")]
            Boolean,
            #[serde(rename = "symbol")]
            Symbol,
            #[serde(rename = "accessor")]
            Accessor,
            #[serde(rename = "bigint")]
            Bigint,
        }
        impl AsRef<str> for PropertyPreviewType {
            fn as_ref(&self) -> &str {
                match self {
                    PropertyPreviewType::Object => "object",
                    PropertyPreviewType::Function => "function",
                    PropertyPreviewType::Undefined => "undefined",
                    PropertyPreviewType::String => "string",
                    PropertyPreviewType::Number => "number",
                    PropertyPreviewType::Boolean => "boolean",
                    PropertyPreviewType::Symbol => "symbol",
                    PropertyPreviewType::Accessor => "accessor",
                    PropertyPreviewType::Bigint => "bigint",
                }
            }
        }
        impl ::std::str::FromStr for PropertyPreviewType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "object" | "Object" => Ok(PropertyPreviewType::Object),
                    "function" | "Function" => Ok(PropertyPreviewType::Function),
                    "undefined" | "Undefined" => Ok(PropertyPreviewType::Undefined),
                    "string" | "String" => Ok(PropertyPreviewType::String),
                    "number" | "Number" => Ok(PropertyPreviewType::Number),
                    "boolean" | "Boolean" => Ok(PropertyPreviewType::Boolean),
                    "symbol" | "Symbol" => Ok(PropertyPreviewType::Symbol),
                    "accessor" | "Accessor" => Ok(PropertyPreviewType::Accessor),
                    "bigint" | "Bigint" => Ok(PropertyPreviewType::Bigint),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Object subtype hint. Specified for `object` type values only."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PropertyPreviewSubtype {
            #[serde(rename = "array")]
            Array,
            #[serde(rename = "null")]
            Null,
            #[serde(rename = "node")]
            Node,
            #[serde(rename = "regexp")]
            Regexp,
            #[serde(rename = "date")]
            Date,
            #[serde(rename = "map")]
            Map,
            #[serde(rename = "set")]
            Set,
            #[serde(rename = "weakmap")]
            Weakmap,
            #[serde(rename = "weakset")]
            Weakset,
            #[serde(rename = "iterator")]
            Iterator,
            #[serde(rename = "generator")]
            Generator,
            #[serde(rename = "error")]
            Error,
            #[serde(rename = "proxy")]
            Proxy,
            #[serde(rename = "promise")]
            Promise,
            #[serde(rename = "typedarray")]
            Typedarray,
            #[serde(rename = "arraybuffer")]
            Arraybuffer,
            #[serde(rename = "dataview")]
            Dataview,
            #[serde(rename = "webassemblymemory")]
            Webassemblymemory,
            #[serde(rename = "wasmvalue")]
            Wasmvalue,
        }
        impl AsRef<str> for PropertyPreviewSubtype {
            fn as_ref(&self) -> &str {
                match self {
                    PropertyPreviewSubtype::Array => "array",
                    PropertyPreviewSubtype::Null => "null",
                    PropertyPreviewSubtype::Node => "node",
                    PropertyPreviewSubtype::Regexp => "regexp",
                    PropertyPreviewSubtype::Date => "date",
                    PropertyPreviewSubtype::Map => "map",
                    PropertyPreviewSubtype::Set => "set",
                    PropertyPreviewSubtype::Weakmap => "weakmap",
                    PropertyPreviewSubtype::Weakset => "weakset",
                    PropertyPreviewSubtype::Iterator => "iterator",
                    PropertyPreviewSubtype::Generator => "generator",
                    PropertyPreviewSubtype::Error => "error",
                    PropertyPreviewSubtype::Proxy => "proxy",
                    PropertyPreviewSubtype::Promise => "promise",
                    PropertyPreviewSubtype::Typedarray => "typedarray",
                    PropertyPreviewSubtype::Arraybuffer => "arraybuffer",
                    PropertyPreviewSubtype::Dataview => "dataview",
                    PropertyPreviewSubtype::Webassemblymemory => "webassemblymemory",
                    PropertyPreviewSubtype::Wasmvalue => "wasmvalue",
                }
            }
        }
        impl ::std::str::FromStr for PropertyPreviewSubtype {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "array" | "Array" => Ok(PropertyPreviewSubtype::Array),
                    "null" | "Null" => Ok(PropertyPreviewSubtype::Null),
                    "node" | "Node" => Ok(PropertyPreviewSubtype::Node),
                    "regexp" | "Regexp" => Ok(PropertyPreviewSubtype::Regexp),
                    "date" | "Date" => Ok(PropertyPreviewSubtype::Date),
                    "map" | "Map" => Ok(PropertyPreviewSubtype::Map),
                    "set" | "Set" => Ok(PropertyPreviewSubtype::Set),
                    "weakmap" | "Weakmap" => Ok(PropertyPreviewSubtype::Weakmap),
                    "weakset" | "Weakset" => Ok(PropertyPreviewSubtype::Weakset),
                    "iterator" | "Iterator" => Ok(PropertyPreviewSubtype::Iterator),
                    "generator" | "Generator" => Ok(PropertyPreviewSubtype::Generator),
                    "error" | "Error" => Ok(PropertyPreviewSubtype::Error),
                    "proxy" | "Proxy" => Ok(PropertyPreviewSubtype::Proxy),
                    "promise" | "Promise" => Ok(PropertyPreviewSubtype::Promise),
                    "typedarray" | "Typedarray" => Ok(PropertyPreviewSubtype::Typedarray),
                    "arraybuffer" | "Arraybuffer" => Ok(PropertyPreviewSubtype::Arraybuffer),
                    "dataview" | "Dataview" => Ok(PropertyPreviewSubtype::Dataview),
                    "webassemblymemory" | "Webassemblymemory" => {
                        Ok(PropertyPreviewSubtype::Webassemblymemory)
                    }
                    "wasmvalue" | "Wasmvalue" => Ok(PropertyPreviewSubtype::Wasmvalue),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl PropertyPreview {
            pub fn new(name: impl Into<String>, r#type: impl Into<PropertyPreviewType>) -> Self {
                Self {
                    name: name.into(),
                    r#type: r#type.into(),
                    value: None,
                    value_preview: None,
                    subtype: None,
                }
            }
        }
        impl PropertyPreview {
            pub fn builder() -> PropertyPreviewBuilder {
                PropertyPreviewBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PropertyPreviewBuilder {
            name: Option<String>,
            r#type: Option<PropertyPreviewType>,
            value: Option<String>,
            value_preview: Option<ObjectPreview>,
            subtype: Option<PropertyPreviewSubtype>,
        }
        impl PropertyPreviewBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<PropertyPreviewType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn value_preview(mut self, value_preview: impl Into<ObjectPreview>) -> Self {
                self.value_preview = Some(value_preview.into());
                self
            }
            pub fn subtype(mut self, subtype: impl Into<PropertyPreviewSubtype>) -> Self {
                self.subtype = Some(subtype.into());
                self
            }
            pub fn build(self) -> Result<PropertyPreview, String> {
                Ok(PropertyPreview {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    value: self.value,
                    value_preview: self.value_preview,
                    subtype: self.subtype,
                })
            }
        }
        impl PropertyPreview {
            pub const IDENTIFIER: &'static str = "Runtime.PropertyPreview";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EntryPreview {
            #[doc = "Preview of the key. Specified for map-like collection entries."]
            #[serde(rename = "key")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub key: Option<ObjectPreview>,
            #[doc = "Preview of the value."]
            #[serde(rename = "value")]
            pub value: ObjectPreview,
        }
        impl EntryPreview {
            pub fn new(value: impl Into<ObjectPreview>) -> Self {
                Self {
                    value: value.into(),
                    key: None,
                }
            }
        }
        impl EntryPreview {
            pub fn builder() -> EntryPreviewBuilder {
                EntryPreviewBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EntryPreviewBuilder {
            key: Option<ObjectPreview>,
            value: Option<ObjectPreview>,
        }
        impl EntryPreviewBuilder {
            pub fn key(mut self, key: impl Into<ObjectPreview>) -> Self {
                self.key = Some(key.into());
                self
            }
            pub fn value(mut self, value: impl Into<ObjectPreview>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<EntryPreview, String> {
                Ok(EntryPreview {
                    key: self.key,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl EntryPreview {
            pub const IDENTIFIER: &'static str = "Runtime.EntryPreview";
        }
        #[doc = "Object property descriptor.\n[PropertyDescriptor](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-PropertyDescriptor)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PropertyDescriptor {
            #[doc = "Property name or symbol description."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "The value associated with the property."]
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value: Option<RemoteObject>,
            #[doc = "True if the value associated with the property may be changed (data descriptors only)."]
            #[serde(rename = "writable")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub writable: Option<bool>,
            #[doc = "A function which serves as a getter for the property, or `undefined` if there is no getter\n(accessor descriptors only)."]
            #[serde(rename = "get")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub get: Option<RemoteObject>,
            #[doc = "A function which serves as a setter for the property, or `undefined` if there is no setter\n(accessor descriptors only)."]
            #[serde(rename = "set")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub set: Option<RemoteObject>,
            #[doc = "True if the type of this property descriptor may be changed and if the property may be\ndeleted from the corresponding object."]
            #[serde(rename = "configurable")]
            pub configurable: bool,
            #[doc = "True if this property shows up during enumeration of the properties on the corresponding\nobject."]
            #[serde(rename = "enumerable")]
            pub enumerable: bool,
            #[doc = "True if the result was thrown during the evaluation."]
            #[serde(rename = "wasThrown")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub was_thrown: Option<bool>,
            #[doc = "True if the property is owned for the object."]
            #[serde(rename = "isOwn")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_own: Option<bool>,
            #[doc = "Property symbol object, if the property is of the `symbol` type."]
            #[serde(rename = "symbol")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub symbol: Option<RemoteObject>,
        }
        impl PropertyDescriptor {
            pub fn new(
                name: impl Into<String>,
                configurable: impl Into<bool>,
                enumerable: impl Into<bool>,
            ) -> Self {
                Self {
                    name: name.into(),
                    configurable: configurable.into(),
                    enumerable: enumerable.into(),
                    value: None,
                    writable: None,
                    get: None,
                    set: None,
                    was_thrown: None,
                    is_own: None,
                    symbol: None,
                }
            }
        }
        impl PropertyDescriptor {
            pub fn builder() -> PropertyDescriptorBuilder {
                PropertyDescriptorBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PropertyDescriptorBuilder {
            name: Option<String>,
            value: Option<RemoteObject>,
            writable: Option<bool>,
            get: Option<RemoteObject>,
            set: Option<RemoteObject>,
            configurable: Option<bool>,
            enumerable: Option<bool>,
            was_thrown: Option<bool>,
            is_own: Option<bool>,
            symbol: Option<RemoteObject>,
        }
        impl PropertyDescriptorBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<RemoteObject>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn writable(mut self, writable: impl Into<bool>) -> Self {
                self.writable = Some(writable.into());
                self
            }
            pub fn get(mut self, get: impl Into<RemoteObject>) -> Self {
                self.get = Some(get.into());
                self
            }
            pub fn set(mut self, set: impl Into<RemoteObject>) -> Self {
                self.set = Some(set.into());
                self
            }
            pub fn configurable(mut self, configurable: impl Into<bool>) -> Self {
                self.configurable = Some(configurable.into());
                self
            }
            pub fn enumerable(mut self, enumerable: impl Into<bool>) -> Self {
                self.enumerable = Some(enumerable.into());
                self
            }
            pub fn was_thrown(mut self, was_thrown: impl Into<bool>) -> Self {
                self.was_thrown = Some(was_thrown.into());
                self
            }
            pub fn is_own(mut self, is_own: impl Into<bool>) -> Self {
                self.is_own = Some(is_own.into());
                self
            }
            pub fn symbol(mut self, symbol: impl Into<RemoteObject>) -> Self {
                self.symbol = Some(symbol.into());
                self
            }
            pub fn build(self) -> Result<PropertyDescriptor, String> {
                Ok(PropertyDescriptor {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value,
                    writable: self.writable,
                    get: self.get,
                    set: self.set,
                    configurable: self.configurable.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(configurable))
                    })?,
                    enumerable: self.enumerable.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enumerable))
                    })?,
                    was_thrown: self.was_thrown,
                    is_own: self.is_own,
                    symbol: self.symbol,
                })
            }
        }
        impl PropertyDescriptor {
            pub const IDENTIFIER: &'static str = "Runtime.PropertyDescriptor";
        }
        #[doc = "Object internal property descriptor. This property isn't normally visible in JavaScript code.\n[InternalPropertyDescriptor](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-InternalPropertyDescriptor)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InternalPropertyDescriptor {
            #[doc = "Conventional property name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "The value associated with the property."]
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value: Option<RemoteObject>,
        }
        impl InternalPropertyDescriptor {
            pub fn new(name: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for InternalPropertyDescriptor {
            fn from(url: T) -> Self {
                InternalPropertyDescriptor::new(url)
            }
        }
        impl InternalPropertyDescriptor {
            pub fn builder() -> InternalPropertyDescriptorBuilder {
                InternalPropertyDescriptorBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct InternalPropertyDescriptorBuilder {
            name: Option<String>,
            value: Option<RemoteObject>,
        }
        impl InternalPropertyDescriptorBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<RemoteObject>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<InternalPropertyDescriptor, String> {
                Ok(InternalPropertyDescriptor {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value,
                })
            }
        }
        impl InternalPropertyDescriptor {
            pub const IDENTIFIER: &'static str = "Runtime.InternalPropertyDescriptor";
        }
        #[doc = "Object private field descriptor.\n[PrivatePropertyDescriptor](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-PrivatePropertyDescriptor)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PrivatePropertyDescriptor {
            #[doc = "Private property name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "The value associated with the private property."]
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value: Option<RemoteObject>,
            #[doc = "A function which serves as a getter for the private property,\nor `undefined` if there is no getter (accessor descriptors only)."]
            #[serde(rename = "get")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub get: Option<RemoteObject>,
            #[doc = "A function which serves as a setter for the private property,\nor `undefined` if there is no setter (accessor descriptors only)."]
            #[serde(rename = "set")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub set: Option<RemoteObject>,
        }
        impl PrivatePropertyDescriptor {
            pub fn new(name: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: None,
                    get: None,
                    set: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for PrivatePropertyDescriptor {
            fn from(url: T) -> Self {
                PrivatePropertyDescriptor::new(url)
            }
        }
        impl PrivatePropertyDescriptor {
            pub fn builder() -> PrivatePropertyDescriptorBuilder {
                PrivatePropertyDescriptorBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PrivatePropertyDescriptorBuilder {
            name: Option<String>,
            value: Option<RemoteObject>,
            get: Option<RemoteObject>,
            set: Option<RemoteObject>,
        }
        impl PrivatePropertyDescriptorBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<RemoteObject>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn get(mut self, get: impl Into<RemoteObject>) -> Self {
                self.get = Some(get.into());
                self
            }
            pub fn set(mut self, set: impl Into<RemoteObject>) -> Self {
                self.set = Some(set.into());
                self
            }
            pub fn build(self) -> Result<PrivatePropertyDescriptor, String> {
                Ok(PrivatePropertyDescriptor {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value,
                    get: self.get,
                    set: self.set,
                })
            }
        }
        impl PrivatePropertyDescriptor {
            pub const IDENTIFIER: &'static str = "Runtime.PrivatePropertyDescriptor";
        }
        #[doc = "Represents function call argument. Either remote object id `objectId`, primitive `value`,\nunserializable primitive value or neither of (for undefined) them should be specified.\n[CallArgument](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-CallArgument)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CallArgument {
            #[doc = "Primitive value or serializable javascript object."]
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value: Option<serde_json::Value>,
            #[doc = "Primitive value which can not be JSON-stringified."]
            #[serde(rename = "unserializableValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub unserializable_value: Option<UnserializableValue>,
            #[doc = "Remote object handle."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<RemoteObjectId>,
        }
        impl CallArgument {
            pub fn builder() -> CallArgumentBuilder {
                CallArgumentBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CallArgumentBuilder {
            value: Option<serde_json::Value>,
            unserializable_value: Option<UnserializableValue>,
            object_id: Option<RemoteObjectId>,
        }
        impl CallArgumentBuilder {
            pub fn value(mut self, value: impl Into<serde_json::Value>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn unserializable_value(
                mut self,
                unserializable_value: impl Into<UnserializableValue>,
            ) -> Self {
                self.unserializable_value = Some(unserializable_value.into());
                self
            }
            pub fn object_id(mut self, object_id: impl Into<RemoteObjectId>) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> CallArgument {
                CallArgument {
                    value: self.value,
                    unserializable_value: self.unserializable_value,
                    object_id: self.object_id,
                }
            }
        }
        impl CallArgument {
            pub const IDENTIFIER: &'static str = "Runtime.CallArgument";
        }
        #[doc = "Id of an execution context.\n[ExecutionContextId](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-ExecutionContextId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Copy, Hash)]
        pub struct ExecutionContextId(i64);
        impl ExecutionContextId {
            pub fn new(val: impl Into<i64>) -> Self {
                ExecutionContextId(val.into())
            }
            pub fn inner(&self) -> &i64 {
                &self.0
            }
        }
        impl ExecutionContextId {
            pub const IDENTIFIER: &'static str = "Runtime.ExecutionContextId";
        }
        #[doc = "Description of an isolated world.\n[ExecutionContextDescription](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-ExecutionContextDescription)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ExecutionContextDescription {
            #[doc = "Unique id of the execution context. It can be used to specify in which execution context\nscript evaluation should be performed."]
            #[serde(rename = "id")]
            pub id: ExecutionContextId,
            #[doc = "Execution context origin."]
            #[serde(rename = "origin")]
            pub origin: String,
            #[doc = "Human readable name describing given context."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "A system-unique execution context identifier. Unlike the id, this is unique across\nmultiple processes, so can be reliably used to identify specific context while backend\nperforms a cross-process navigation."]
            #[serde(rename = "uniqueId")]
            pub unique_id: String,
            #[doc = "Embedder-specific auxiliary data."]
            #[serde(rename = "auxData")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub aux_data: Option<serde_json::Value>,
        }
        impl ExecutionContextDescription {
            pub fn new(
                id: impl Into<ExecutionContextId>,
                origin: impl Into<String>,
                name: impl Into<String>,
                unique_id: impl Into<String>,
            ) -> Self {
                Self {
                    id: id.into(),
                    origin: origin.into(),
                    name: name.into(),
                    unique_id: unique_id.into(),
                    aux_data: None,
                }
            }
        }
        impl ExecutionContextDescription {
            pub fn builder() -> ExecutionContextDescriptionBuilder {
                ExecutionContextDescriptionBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ExecutionContextDescriptionBuilder {
            id: Option<ExecutionContextId>,
            origin: Option<String>,
            name: Option<String>,
            unique_id: Option<String>,
            aux_data: Option<serde_json::Value>,
        }
        impl ExecutionContextDescriptionBuilder {
            pub fn id(mut self, id: impl Into<ExecutionContextId>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn unique_id(mut self, unique_id: impl Into<String>) -> Self {
                self.unique_id = Some(unique_id.into());
                self
            }
            pub fn aux_data(mut self, aux_data: impl Into<serde_json::Value>) -> Self {
                self.aux_data = Some(aux_data.into());
                self
            }
            pub fn build(self) -> Result<ExecutionContextDescription, String> {
                Ok(ExecutionContextDescription {
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    unique_id: self.unique_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(unique_id))
                    })?,
                    aux_data: self.aux_data,
                })
            }
        }
        impl ExecutionContextDescription {
            pub const IDENTIFIER: &'static str = "Runtime.ExecutionContextDescription";
        }
        #[doc = "Detailed information about exception (or error) that was thrown during script compilation or\nexecution.\n[ExceptionDetails](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-ExceptionDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ExceptionDetails {
            #[doc = "Exception id."]
            #[serde(rename = "exceptionId")]
            pub exception_id: i64,
            #[doc = "Exception text, which should be used together with exception object when available."]
            #[serde(rename = "text")]
            pub text: String,
            #[doc = "Line number of the exception location (0-based)."]
            #[serde(rename = "lineNumber")]
            pub line_number: i64,
            #[doc = "Column number of the exception location (0-based)."]
            #[serde(rename = "columnNumber")]
            pub column_number: i64,
            #[doc = "Script ID of the exception location."]
            #[serde(rename = "scriptId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub script_id: Option<ScriptId>,
            #[doc = "URL of the exception location, to be used when the script was not reported."]
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url: Option<String>,
            #[doc = "JavaScript stack trace if available."]
            #[serde(rename = "stackTrace")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub stack_trace: Option<StackTrace>,
            #[doc = "Exception object if available."]
            #[serde(rename = "exception")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub exception: Option<RemoteObject>,
            #[doc = "Identifier of the context where exception happened."]
            #[serde(rename = "executionContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub execution_context_id: Option<ExecutionContextId>,
            #[doc = "Dictionary with entries of meta data that the client associated\nwith this exception, such as information about associated network\nrequests, etc."]
            #[serde(rename = "exceptionMetaData")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub exception_meta_data: Option<serde_json::Value>,
        }
        impl ExceptionDetails {
            pub fn new(
                exception_id: impl Into<i64>,
                text: impl Into<String>,
                line_number: impl Into<i64>,
                column_number: impl Into<i64>,
            ) -> Self {
                Self {
                    exception_id: exception_id.into(),
                    text: text.into(),
                    line_number: line_number.into(),
                    column_number: column_number.into(),
                    script_id: None,
                    url: None,
                    stack_trace: None,
                    exception: None,
                    execution_context_id: None,
                    exception_meta_data: None,
                }
            }
        }
        impl ExceptionDetails {
            pub fn builder() -> ExceptionDetailsBuilder {
                ExceptionDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ExceptionDetailsBuilder {
            exception_id: Option<i64>,
            text: Option<String>,
            line_number: Option<i64>,
            column_number: Option<i64>,
            script_id: Option<ScriptId>,
            url: Option<String>,
            stack_trace: Option<StackTrace>,
            exception: Option<RemoteObject>,
            execution_context_id: Option<ExecutionContextId>,
            exception_meta_data: Option<serde_json::Value>,
        }
        impl ExceptionDetailsBuilder {
            pub fn exception_id(mut self, exception_id: impl Into<i64>) -> Self {
                self.exception_id = Some(exception_id.into());
                self
            }
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn line_number(mut self, line_number: impl Into<i64>) -> Self {
                self.line_number = Some(line_number.into());
                self
            }
            pub fn column_number(mut self, column_number: impl Into<i64>) -> Self {
                self.column_number = Some(column_number.into());
                self
            }
            pub fn script_id(mut self, script_id: impl Into<ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn stack_trace(mut self, stack_trace: impl Into<StackTrace>) -> Self {
                self.stack_trace = Some(stack_trace.into());
                self
            }
            pub fn exception(mut self, exception: impl Into<RemoteObject>) -> Self {
                self.exception = Some(exception.into());
                self
            }
            pub fn execution_context_id(
                mut self,
                execution_context_id: impl Into<ExecutionContextId>,
            ) -> Self {
                self.execution_context_id = Some(execution_context_id.into());
                self
            }
            pub fn exception_meta_data(
                mut self,
                exception_meta_data: impl Into<serde_json::Value>,
            ) -> Self {
                self.exception_meta_data = Some(exception_meta_data.into());
                self
            }
            pub fn build(self) -> Result<ExceptionDetails, String> {
                Ok(ExceptionDetails {
                    exception_id: self.exception_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(exception_id))
                    })?,
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                    line_number: self.line_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line_number))
                    })?,
                    column_number: self.column_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(column_number))
                    })?,
                    script_id: self.script_id,
                    url: self.url,
                    stack_trace: self.stack_trace,
                    exception: self.exception,
                    execution_context_id: self.execution_context_id,
                    exception_meta_data: self.exception_meta_data,
                })
            }
        }
        impl ExceptionDetails {
            pub const IDENTIFIER: &'static str = "Runtime.ExceptionDetails";
        }
        #[doc = "Number of milliseconds since epoch.\n[Timestamp](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-Timestamp)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct Timestamp(f64);
        impl Timestamp {
            pub fn new(val: impl Into<f64>) -> Self {
                Timestamp(val.into())
            }
            pub fn inner(&self) -> &f64 {
                &self.0
            }
        }
        impl Timestamp {
            pub const IDENTIFIER: &'static str = "Runtime.Timestamp";
        }
        #[doc = "Number of milliseconds.\n[TimeDelta](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-TimeDelta)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TimeDelta(f64);
        impl TimeDelta {
            pub fn new(val: impl Into<f64>) -> Self {
                TimeDelta(val.into())
            }
            pub fn inner(&self) -> &f64 {
                &self.0
            }
        }
        impl TimeDelta {
            pub const IDENTIFIER: &'static str = "Runtime.TimeDelta";
        }
        #[doc = "Stack entry for runtime errors and assertions.\n[CallFrame](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-CallFrame)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CallFrame {
            #[doc = "JavaScript function name."]
            #[serde(rename = "functionName")]
            pub function_name: String,
            #[doc = "JavaScript script id."]
            #[serde(rename = "scriptId")]
            pub script_id: ScriptId,
            #[doc = "JavaScript script name or url."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "JavaScript script line number (0-based)."]
            #[serde(rename = "lineNumber")]
            pub line_number: i64,
            #[doc = "JavaScript script column number (0-based)."]
            #[serde(rename = "columnNumber")]
            pub column_number: i64,
        }
        impl CallFrame {
            pub fn builder() -> CallFrameBuilder {
                CallFrameBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CallFrameBuilder {
            function_name: Option<String>,
            script_id: Option<ScriptId>,
            url: Option<String>,
            line_number: Option<i64>,
            column_number: Option<i64>,
        }
        impl CallFrameBuilder {
            pub fn function_name(mut self, function_name: impl Into<String>) -> Self {
                self.function_name = Some(function_name.into());
                self
            }
            pub fn script_id(mut self, script_id: impl Into<ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn line_number(mut self, line_number: impl Into<i64>) -> Self {
                self.line_number = Some(line_number.into());
                self
            }
            pub fn column_number(mut self, column_number: impl Into<i64>) -> Self {
                self.column_number = Some(column_number.into());
                self
            }
            pub fn build(self) -> Result<CallFrame, String> {
                Ok(CallFrame {
                    function_name: self.function_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(function_name))
                    })?,
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    line_number: self.line_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line_number))
                    })?,
                    column_number: self.column_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(column_number))
                    })?,
                })
            }
        }
        impl CallFrame {
            pub const IDENTIFIER: &'static str = "Runtime.CallFrame";
        }
        #[doc = "Call frames for assertions or error messages.\n[StackTrace](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-StackTrace)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StackTrace {
            #[doc = "String label of this stack trace. For async traces this may be a name of the function that\ninitiated the async call."]
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub description: Option<String>,
            #[doc = "JavaScript function name."]
            #[serde(rename = "callFrames")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub call_frames: Vec<CallFrame>,
            #[doc = "Asynchronous JavaScript stack trace that preceded this stack, if available."]
            #[serde(rename = "parent")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub parent: Option<Box<StackTrace>>,
            #[doc = "Asynchronous JavaScript stack trace that preceded this stack, if available."]
            #[serde(rename = "parentId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub parent_id: Option<StackTraceId>,
        }
        impl StackTrace {
            pub fn new(call_frames: Vec<CallFrame>) -> Self {
                Self {
                    call_frames,
                    description: None,
                    parent: None,
                    parent_id: None,
                }
            }
        }
        impl StackTrace {
            pub fn builder() -> StackTraceBuilder {
                StackTraceBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StackTraceBuilder {
            description: Option<String>,
            call_frames: Option<Vec<CallFrame>>,
            parent: Option<StackTrace>,
            parent_id: Option<StackTraceId>,
        }
        impl StackTraceBuilder {
            pub fn description(mut self, description: impl Into<String>) -> Self {
                self.description = Some(description.into());
                self
            }
            pub fn call_frame(mut self, call_frame: impl Into<CallFrame>) -> Self {
                let v = self.call_frames.get_or_insert(Vec::new());
                v.push(call_frame.into());
                self
            }
            pub fn call_frames<I, S>(mut self, call_frames: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CallFrame>,
            {
                let v = self.call_frames.get_or_insert(Vec::new());
                for val in call_frames {
                    v.push(val.into());
                }
                self
            }
            pub fn parent(mut self, parent: impl Into<StackTrace>) -> Self {
                self.parent = Some(parent.into());
                self
            }
            pub fn parent_id(mut self, parent_id: impl Into<StackTraceId>) -> Self {
                self.parent_id = Some(parent_id.into());
                self
            }
            pub fn build(self) -> Result<StackTrace, String> {
                Ok(StackTrace {
                    description: self.description,
                    call_frames: self.call_frames.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(call_frames))
                    })?,
                    parent: self.parent.map(Box::new),
                    parent_id: self.parent_id,
                })
            }
        }
        impl StackTrace {
            pub const IDENTIFIER: &'static str = "Runtime.StackTrace";
        }
        #[doc = "Unique identifier of current debugger.\n[UniqueDebuggerId](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-UniqueDebuggerId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct UniqueDebuggerId(String);
        impl UniqueDebuggerId {
            pub fn new(val: impl Into<String>) -> Self {
                UniqueDebuggerId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for UniqueDebuggerId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<UniqueDebuggerId> for String {
            fn from(el: UniqueDebuggerId) -> String {
                el.0
            }
        }
        impl From<String> for UniqueDebuggerId {
            fn from(expr: String) -> Self {
                UniqueDebuggerId(expr)
            }
        }
        impl std::borrow::Borrow<str> for UniqueDebuggerId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl UniqueDebuggerId {
            pub const IDENTIFIER: &'static str = "Runtime.UniqueDebuggerId";
        }
        #[doc = "If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This\nallows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.\n[StackTraceId](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-StackTraceId)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StackTraceId {
            #[serde(rename = "id")]
            pub id: String,
            #[serde(rename = "debuggerId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub debugger_id: Option<UniqueDebuggerId>,
        }
        impl StackTraceId {
            pub fn new(id: impl Into<String>) -> Self {
                Self {
                    id: id.into(),
                    debugger_id: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for StackTraceId {
            fn from(url: T) -> Self {
                StackTraceId::new(url)
            }
        }
        impl StackTraceId {
            pub fn builder() -> StackTraceIdBuilder {
                StackTraceIdBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StackTraceIdBuilder {
            id: Option<String>,
            debugger_id: Option<UniqueDebuggerId>,
        }
        impl StackTraceIdBuilder {
            pub fn id(mut self, id: impl Into<String>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn debugger_id(mut self, debugger_id: impl Into<UniqueDebuggerId>) -> Self {
                self.debugger_id = Some(debugger_id.into());
                self
            }
            pub fn build(self) -> Result<StackTraceId, String> {
                Ok(StackTraceId {
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                    debugger_id: self.debugger_id,
                })
            }
        }
        impl StackTraceId {
            pub const IDENTIFIER: &'static str = "Runtime.StackTraceId";
        }
        #[doc = "Add handler to promise with given promise object id.\n[awaitPromise](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-awaitPromise)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AwaitPromiseParams {
            #[doc = "Identifier of the promise."]
            #[serde(rename = "promiseObjectId")]
            pub promise_object_id: RemoteObjectId,
            #[doc = "Whether the result is expected to be a JSON object that should be sent by value."]
            #[serde(rename = "returnByValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub return_by_value: Option<bool>,
            #[doc = "Whether preview should be generated for the result."]
            #[serde(rename = "generatePreview")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub generate_preview: Option<bool>,
        }
        impl AwaitPromiseParams {
            pub fn new(promise_object_id: impl Into<RemoteObjectId>) -> Self {
                Self {
                    promise_object_id: promise_object_id.into(),
                    return_by_value: None,
                    generate_preview: None,
                }
            }
        }
        impl AwaitPromiseParams {
            pub fn builder() -> AwaitPromiseParamsBuilder {
                AwaitPromiseParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AwaitPromiseParamsBuilder {
            promise_object_id: Option<RemoteObjectId>,
            return_by_value: Option<bool>,
            generate_preview: Option<bool>,
        }
        impl AwaitPromiseParamsBuilder {
            pub fn promise_object_id(
                mut self,
                promise_object_id: impl Into<RemoteObjectId>,
            ) -> Self {
                self.promise_object_id = Some(promise_object_id.into());
                self
            }
            pub fn return_by_value(mut self, return_by_value: impl Into<bool>) -> Self {
                self.return_by_value = Some(return_by_value.into());
                self
            }
            pub fn generate_preview(mut self, generate_preview: impl Into<bool>) -> Self {
                self.generate_preview = Some(generate_preview.into());
                self
            }
            pub fn build(self) -> Result<AwaitPromiseParams, String> {
                Ok(AwaitPromiseParams {
                    promise_object_id: self.promise_object_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(promise_object_id)
                        )
                    })?,
                    return_by_value: self.return_by_value,
                    generate_preview: self.generate_preview,
                })
            }
        }
        impl AwaitPromiseParams {
            pub const IDENTIFIER: &'static str = "Runtime.awaitPromise";
        }
        impl chromiumoxide_types::Method for AwaitPromiseParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for AwaitPromiseParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Add handler to promise with given promise object id.\n[awaitPromise](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-awaitPromise)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AwaitPromiseReturns {
            #[doc = "Promise result. Will contain rejected value if promise was rejected."]
            #[serde(rename = "result")]
            pub result: RemoteObject,
            #[doc = "Exception details if stack strace is available."]
            #[serde(rename = "exceptionDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub exception_details: Option<ExceptionDetails>,
        }
        impl AwaitPromiseReturns {
            pub fn new(result: impl Into<RemoteObject>) -> Self {
                Self {
                    result: result.into(),
                    exception_details: None,
                }
            }
        }
        impl AwaitPromiseReturns {
            pub fn builder() -> AwaitPromiseReturnsBuilder {
                AwaitPromiseReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AwaitPromiseReturnsBuilder {
            result: Option<RemoteObject>,
            exception_details: Option<ExceptionDetails>,
        }
        impl AwaitPromiseReturnsBuilder {
            pub fn result(mut self, result: impl Into<RemoteObject>) -> Self {
                self.result = Some(result.into());
                self
            }
            pub fn exception_details(
                mut self,
                exception_details: impl Into<ExceptionDetails>,
            ) -> Self {
                self.exception_details = Some(exception_details.into());
                self
            }
            pub fn build(self) -> Result<AwaitPromiseReturns, String> {
                Ok(AwaitPromiseReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                    exception_details: self.exception_details,
                })
            }
        }
        impl chromiumoxide_types::Command for AwaitPromiseParams {
            type Response = AwaitPromiseReturns;
        }
        #[doc = "Calls function with given declaration on the given object. Object group of the result is\ninherited from the target object.\n[callFunctionOn](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-callFunctionOn)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CallFunctionOnParams {
            #[doc = "Declaration of the function to call."]
            #[serde(rename = "functionDeclaration")]
            pub function_declaration: String,
            #[doc = "Identifier of the object to call function on. Either objectId or executionContextId should\nbe specified."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<RemoteObjectId>,
            #[doc = "Call arguments. All call arguments must belong to the same JavaScript world as the target\nobject."]
            #[serde(rename = "arguments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub arguments: Option<Vec<CallArgument>>,
            #[doc = "In silent mode exceptions thrown during evaluation are not reported and do not pause\nexecution. Overrides `setPauseOnException` state."]
            #[serde(rename = "silent")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub silent: Option<bool>,
            #[doc = "Whether the result is expected to be a JSON object which should be sent by value."]
            #[serde(rename = "returnByValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub return_by_value: Option<bool>,
            #[doc = "Whether preview should be generated for the result."]
            #[serde(rename = "generatePreview")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub generate_preview: Option<bool>,
            #[doc = "Whether execution should be treated as initiated by user in the UI."]
            #[serde(rename = "userGesture")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub user_gesture: Option<bool>,
            #[doc = "Whether execution should `await` for resulting value and return once awaited promise is\nresolved."]
            #[serde(rename = "awaitPromise")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub await_promise: Option<bool>,
            #[doc = "Specifies execution context which global object will be used to call function on. Either\nexecutionContextId or objectId should be specified."]
            #[serde(rename = "executionContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub execution_context_id: Option<ExecutionContextId>,
            #[doc = "Symbolic group name that can be used to release multiple objects. If objectGroup is not\nspecified and objectId is, objectGroup will be inherited from object."]
            #[serde(rename = "objectGroup")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_group: Option<String>,
            #[doc = "Whether to throw an exception if side effect cannot be ruled out during evaluation."]
            #[serde(rename = "throwOnSideEffect")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub throw_on_side_effect: Option<bool>,
            #[doc = "Whether the result should contain `webDriverValue`, serialized according to\nhttps://w3c.github.io/webdriver-bidi. This is mutually exclusive with `returnByValue`, but\nresulting `objectId` is still provided."]
            #[serde(rename = "generateWebDriverValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub generate_web_driver_value: Option<bool>,
        }
        impl CallFunctionOnParams {
            pub fn new(function_declaration: impl Into<String>) -> Self {
                Self {
                    function_declaration: function_declaration.into(),
                    object_id: None,
                    arguments: None,
                    silent: None,
                    return_by_value: None,
                    generate_preview: None,
                    user_gesture: None,
                    await_promise: None,
                    execution_context_id: None,
                    object_group: None,
                    throw_on_side_effect: None,
                    generate_web_driver_value: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for CallFunctionOnParams {
            fn from(url: T) -> Self {
                CallFunctionOnParams::new(url)
            }
        }
        impl CallFunctionOnParams {
            pub fn builder() -> CallFunctionOnParamsBuilder {
                CallFunctionOnParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CallFunctionOnParamsBuilder {
            function_declaration: Option<String>,
            object_id: Option<RemoteObjectId>,
            arguments: Option<Vec<CallArgument>>,
            silent: Option<bool>,
            return_by_value: Option<bool>,
            generate_preview: Option<bool>,
            user_gesture: Option<bool>,
            await_promise: Option<bool>,
            execution_context_id: Option<ExecutionContextId>,
            object_group: Option<String>,
            throw_on_side_effect: Option<bool>,
            generate_web_driver_value: Option<bool>,
        }
        impl CallFunctionOnParamsBuilder {
            pub fn function_declaration(mut self, function_declaration: impl Into<String>) -> Self {
                self.function_declaration = Some(function_declaration.into());
                self
            }
            pub fn object_id(mut self, object_id: impl Into<RemoteObjectId>) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn argument(mut self, argument: impl Into<CallArgument>) -> Self {
                let v = self.arguments.get_or_insert(Vec::new());
                v.push(argument.into());
                self
            }
            pub fn arguments<I, S>(mut self, arguments: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CallArgument>,
            {
                let v = self.arguments.get_or_insert(Vec::new());
                for val in arguments {
                    v.push(val.into());
                }
                self
            }
            pub fn silent(mut self, silent: impl Into<bool>) -> Self {
                self.silent = Some(silent.into());
                self
            }
            pub fn return_by_value(mut self, return_by_value: impl Into<bool>) -> Self {
                self.return_by_value = Some(return_by_value.into());
                self
            }
            pub fn generate_preview(mut self, generate_preview: impl Into<bool>) -> Self {
                self.generate_preview = Some(generate_preview.into());
                self
            }
            pub fn user_gesture(mut self, user_gesture: impl Into<bool>) -> Self {
                self.user_gesture = Some(user_gesture.into());
                self
            }
            pub fn await_promise(mut self, await_promise: impl Into<bool>) -> Self {
                self.await_promise = Some(await_promise.into());
                self
            }
            pub fn execution_context_id(
                mut self,
                execution_context_id: impl Into<ExecutionContextId>,
            ) -> Self {
                self.execution_context_id = Some(execution_context_id.into());
                self
            }
            pub fn object_group(mut self, object_group: impl Into<String>) -> Self {
                self.object_group = Some(object_group.into());
                self
            }
            pub fn throw_on_side_effect(mut self, throw_on_side_effect: impl Into<bool>) -> Self {
                self.throw_on_side_effect = Some(throw_on_side_effect.into());
                self
            }
            pub fn generate_web_driver_value(
                mut self,
                generate_web_driver_value: impl Into<bool>,
            ) -> Self {
                self.generate_web_driver_value = Some(generate_web_driver_value.into());
                self
            }
            pub fn build(self) -> Result<CallFunctionOnParams, String> {
                Ok(CallFunctionOnParams {
                    function_declaration: self.function_declaration.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(function_declaration)
                        )
                    })?,
                    object_id: self.object_id,
                    arguments: self.arguments,
                    silent: self.silent,
                    return_by_value: self.return_by_value,
                    generate_preview: self.generate_preview,
                    user_gesture: self.user_gesture,
                    await_promise: self.await_promise,
                    execution_context_id: self.execution_context_id,
                    object_group: self.object_group,
                    throw_on_side_effect: self.throw_on_side_effect,
                    generate_web_driver_value: self.generate_web_driver_value,
                })
            }
        }
        impl CallFunctionOnParams {
            pub const IDENTIFIER: &'static str = "Runtime.callFunctionOn";
        }
        impl chromiumoxide_types::Method for CallFunctionOnParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CallFunctionOnParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Calls function with given declaration on the given object. Object group of the result is\ninherited from the target object.\n[callFunctionOn](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-callFunctionOn)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CallFunctionOnReturns {
            #[doc = "Call result."]
            #[serde(rename = "result")]
            pub result: RemoteObject,
            #[doc = "Exception details."]
            #[serde(rename = "exceptionDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub exception_details: Option<ExceptionDetails>,
        }
        impl CallFunctionOnReturns {
            pub fn new(result: impl Into<RemoteObject>) -> Self {
                Self {
                    result: result.into(),
                    exception_details: None,
                }
            }
        }
        impl CallFunctionOnReturns {
            pub fn builder() -> CallFunctionOnReturnsBuilder {
                CallFunctionOnReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CallFunctionOnReturnsBuilder {
            result: Option<RemoteObject>,
            exception_details: Option<ExceptionDetails>,
        }
        impl CallFunctionOnReturnsBuilder {
            pub fn result(mut self, result: impl Into<RemoteObject>) -> Self {
                self.result = Some(result.into());
                self
            }
            pub fn exception_details(
                mut self,
                exception_details: impl Into<ExceptionDetails>,
            ) -> Self {
                self.exception_details = Some(exception_details.into());
                self
            }
            pub fn build(self) -> Result<CallFunctionOnReturns, String> {
                Ok(CallFunctionOnReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                    exception_details: self.exception_details,
                })
            }
        }
        impl chromiumoxide_types::Command for CallFunctionOnParams {
            type Response = CallFunctionOnReturns;
        }
        #[doc = "Compiles expression.\n[compileScript](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-compileScript)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CompileScriptParams {
            #[doc = "Expression to compile."]
            #[serde(rename = "expression")]
            pub expression: String,
            #[doc = "Source url to be set for the script."]
            #[serde(rename = "sourceURL")]
            pub source_url: String,
            #[doc = "Specifies whether the compiled script should be persisted."]
            #[serde(rename = "persistScript")]
            pub persist_script: bool,
            #[doc = "Specifies in which execution context to perform script run. If the parameter is omitted the\nevaluation will be performed in the context of the inspected page."]
            #[serde(rename = "executionContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub execution_context_id: Option<ExecutionContextId>,
        }
        impl CompileScriptParams {
            pub fn new(
                expression: impl Into<String>,
                source_url: impl Into<String>,
                persist_script: impl Into<bool>,
            ) -> Self {
                Self {
                    expression: expression.into(),
                    source_url: source_url.into(),
                    persist_script: persist_script.into(),
                    execution_context_id: None,
                }
            }
        }
        impl CompileScriptParams {
            pub fn builder() -> CompileScriptParamsBuilder {
                CompileScriptParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CompileScriptParamsBuilder {
            expression: Option<String>,
            source_url: Option<String>,
            persist_script: Option<bool>,
            execution_context_id: Option<ExecutionContextId>,
        }
        impl CompileScriptParamsBuilder {
            pub fn expression(mut self, expression: impl Into<String>) -> Self {
                self.expression = Some(expression.into());
                self
            }
            pub fn source_url(mut self, source_url: impl Into<String>) -> Self {
                self.source_url = Some(source_url.into());
                self
            }
            pub fn persist_script(mut self, persist_script: impl Into<bool>) -> Self {
                self.persist_script = Some(persist_script.into());
                self
            }
            pub fn execution_context_id(
                mut self,
                execution_context_id: impl Into<ExecutionContextId>,
            ) -> Self {
                self.execution_context_id = Some(execution_context_id.into());
                self
            }
            pub fn build(self) -> Result<CompileScriptParams, String> {
                Ok(CompileScriptParams {
                    expression: self.expression.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(expression))
                    })?,
                    source_url: self.source_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(source_url))
                    })?,
                    persist_script: self.persist_script.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(persist_script))
                    })?,
                    execution_context_id: self.execution_context_id,
                })
            }
        }
        impl CompileScriptParams {
            pub const IDENTIFIER: &'static str = "Runtime.compileScript";
        }
        impl chromiumoxide_types::Method for CompileScriptParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CompileScriptParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Compiles expression.\n[compileScript](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-compileScript)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CompileScriptReturns {
            #[doc = "Id of the script."]
            #[serde(rename = "scriptId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub script_id: Option<ScriptId>,
            #[doc = "Exception details."]
            #[serde(rename = "exceptionDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub exception_details: Option<ExceptionDetails>,
        }
        impl CompileScriptReturns {
            pub fn builder() -> CompileScriptReturnsBuilder {
                CompileScriptReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CompileScriptReturnsBuilder {
            script_id: Option<ScriptId>,
            exception_details: Option<ExceptionDetails>,
        }
        impl CompileScriptReturnsBuilder {
            pub fn script_id(mut self, script_id: impl Into<ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn exception_details(
                mut self,
                exception_details: impl Into<ExceptionDetails>,
            ) -> Self {
                self.exception_details = Some(exception_details.into());
                self
            }
            pub fn build(self) -> CompileScriptReturns {
                CompileScriptReturns {
                    script_id: self.script_id,
                    exception_details: self.exception_details,
                }
            }
        }
        impl chromiumoxide_types::Command for CompileScriptParams {
            type Response = CompileScriptReturns;
        }
        #[doc = "Disables reporting of execution contexts creation.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Runtime.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables reporting of execution contexts creation.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Discards collected exceptions and console API calls.\n[discardConsoleEntries](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-discardConsoleEntries)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DiscardConsoleEntriesParams {}
        impl DiscardConsoleEntriesParams {
            pub const IDENTIFIER: &'static str = "Runtime.discardConsoleEntries";
        }
        impl chromiumoxide_types::Method for DiscardConsoleEntriesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DiscardConsoleEntriesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Discards collected exceptions and console API calls.\n[discardConsoleEntries](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-discardConsoleEntries)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DiscardConsoleEntriesReturns {}
        impl chromiumoxide_types::Command for DiscardConsoleEntriesParams {
            type Response = DiscardConsoleEntriesReturns;
        }
        #[doc = "Enables reporting of execution contexts creation by means of `executionContextCreated` event.\nWhen the reporting gets enabled the event will be sent immediately for each existing execution\ncontext.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Runtime.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables reporting of execution contexts creation by means of `executionContextCreated` event.\nWhen the reporting gets enabled the event will be sent immediately for each existing execution\ncontext.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Evaluates expression on global object.\n[evaluate](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-evaluate)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EvaluateParams {
            #[doc = "Expression to evaluate."]
            #[serde(rename = "expression")]
            pub expression: String,
            #[doc = "Symbolic group name that can be used to release multiple objects."]
            #[serde(rename = "objectGroup")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_group: Option<String>,
            #[doc = "Determines whether Command Line API should be available during the evaluation."]
            #[serde(rename = "includeCommandLineAPI")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub include_command_line_api: Option<bool>,
            #[doc = "In silent mode exceptions thrown during evaluation are not reported and do not pause\nexecution. Overrides `setPauseOnException` state."]
            #[serde(rename = "silent")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub silent: Option<bool>,
            #[doc = "Specifies in which execution context to perform evaluation. If the parameter is omitted the\nevaluation will be performed in the context of the inspected page.\nThis is mutually exclusive with `uniqueContextId`, which offers an\nalternative way to identify the execution context that is more reliable\nin a multi-process environment."]
            #[serde(rename = "contextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub context_id: Option<ExecutionContextId>,
            #[doc = "Whether the result is expected to be a JSON object that should be sent by value."]
            #[serde(rename = "returnByValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub return_by_value: Option<bool>,
            #[doc = "Whether preview should be generated for the result."]
            #[serde(rename = "generatePreview")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub generate_preview: Option<bool>,
            #[doc = "Whether execution should be treated as initiated by user in the UI."]
            #[serde(rename = "userGesture")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub user_gesture: Option<bool>,
            #[doc = "Whether execution should `await` for resulting value and return once awaited promise is\nresolved."]
            #[serde(rename = "awaitPromise")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub await_promise: Option<bool>,
            #[doc = "Whether to throw an exception if side effect cannot be ruled out during evaluation.\nThis implies `disableBreaks` below."]
            #[serde(rename = "throwOnSideEffect")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub throw_on_side_effect: Option<bool>,
            #[doc = "Terminate execution after timing out (number of milliseconds)."]
            #[serde(rename = "timeout")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub timeout: Option<TimeDelta>,
            #[doc = "Disable breakpoints during execution."]
            #[serde(rename = "disableBreaks")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub disable_breaks: Option<bool>,
            #[doc = "Setting this flag to true enables `let` re-declaration and top-level `await`.\nNote that `let` variables can only be re-declared if they originate from\n`replMode` themselves."]
            #[serde(rename = "replMode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub repl_mode: Option<bool>,
            #[doc = "The Content Security Policy (CSP) for the target might block 'unsafe-eval'\nwhich includes eval(), Function(), setTimeout() and setInterval()\nwhen called with non-callable arguments. This flag bypasses CSP for this\nevaluation and allows unsafe-eval. Defaults to true."]
            #[serde(rename = "allowUnsafeEvalBlockedByCSP")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub allow_unsafe_eval_blocked_by_csp: Option<bool>,
            #[doc = "An alternative way to specify the execution context to evaluate in.\nCompared to contextId that may be reused across processes, this is guaranteed to be\nsystem-unique, so it can be used to prevent accidental evaluation of the expression\nin context different than intended (e.g. as a result of navigation across process\nboundaries).\nThis is mutually exclusive with `contextId`."]
            #[serde(rename = "uniqueContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub unique_context_id: Option<String>,
            #[doc = "Whether the result should be serialized according to https://w3c.github.io/webdriver-bidi."]
            #[serde(rename = "generateWebDriverValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub generate_web_driver_value: Option<bool>,
            #[doc = r" This is a manually added field that is not part of the protocol definition, hence ignored during serde operations."]
            #[doc = r""]
            #[doc = r" If set to true, this field indicates, that if the command resulted in a response value of type `function` this, `EvaluateParams` command should be executed as a `CallFunctionOnParams` instead."]
            #[serde(skip)]
            pub eval_as_function_fallback: Option<bool>,
        }
        impl EvaluateParams {
            pub fn new(expression: impl Into<String>) -> Self {
                Self {
                    expression: expression.into(),
                    object_group: None,
                    include_command_line_api: None,
                    silent: None,
                    context_id: None,
                    return_by_value: None,
                    generate_preview: None,
                    user_gesture: None,
                    await_promise: None,
                    throw_on_side_effect: None,
                    timeout: None,
                    disable_breaks: None,
                    repl_mode: None,
                    allow_unsafe_eval_blocked_by_csp: None,
                    unique_context_id: None,
                    generate_web_driver_value: None,
                    eval_as_function_fallback: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for EvaluateParams {
            fn from(url: T) -> Self {
                EvaluateParams::new(url)
            }
        }
        impl EvaluateParams {
            pub fn builder() -> EvaluateParamsBuilder {
                EvaluateParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EvaluateParamsBuilder {
            expression: Option<String>,
            object_group: Option<String>,
            include_command_line_api: Option<bool>,
            silent: Option<bool>,
            context_id: Option<ExecutionContextId>,
            return_by_value: Option<bool>,
            generate_preview: Option<bool>,
            user_gesture: Option<bool>,
            await_promise: Option<bool>,
            throw_on_side_effect: Option<bool>,
            timeout: Option<TimeDelta>,
            disable_breaks: Option<bool>,
            repl_mode: Option<bool>,
            allow_unsafe_eval_blocked_by_csp: Option<bool>,
            unique_context_id: Option<String>,
            generate_web_driver_value: Option<bool>,
            eval_as_function_fallback: Option<bool>,
        }
        impl EvaluateParamsBuilder {
            pub fn expression(mut self, expression: impl Into<String>) -> Self {
                self.expression = Some(expression.into());
                self
            }
            pub fn object_group(mut self, object_group: impl Into<String>) -> Self {
                self.object_group = Some(object_group.into());
                self
            }
            pub fn include_command_line_api(
                mut self,
                include_command_line_api: impl Into<bool>,
            ) -> Self {
                self.include_command_line_api = Some(include_command_line_api.into());
                self
            }
            pub fn silent(mut self, silent: impl Into<bool>) -> Self {
                self.silent = Some(silent.into());
                self
            }
            pub fn context_id(mut self, context_id: impl Into<ExecutionContextId>) -> Self {
                self.context_id = Some(context_id.into());
                self
            }
            pub fn return_by_value(mut self, return_by_value: impl Into<bool>) -> Self {
                self.return_by_value = Some(return_by_value.into());
                self
            }
            pub fn generate_preview(mut self, generate_preview: impl Into<bool>) -> Self {
                self.generate_preview = Some(generate_preview.into());
                self
            }
            pub fn user_gesture(mut self, user_gesture: impl Into<bool>) -> Self {
                self.user_gesture = Some(user_gesture.into());
                self
            }
            pub fn await_promise(mut self, await_promise: impl Into<bool>) -> Self {
                self.await_promise = Some(await_promise.into());
                self
            }
            pub fn throw_on_side_effect(mut self, throw_on_side_effect: impl Into<bool>) -> Self {
                self.throw_on_side_effect = Some(throw_on_side_effect.into());
                self
            }
            pub fn timeout(mut self, timeout: impl Into<TimeDelta>) -> Self {
                self.timeout = Some(timeout.into());
                self
            }
            pub fn disable_breaks(mut self, disable_breaks: impl Into<bool>) -> Self {
                self.disable_breaks = Some(disable_breaks.into());
                self
            }
            pub fn repl_mode(mut self, repl_mode: impl Into<bool>) -> Self {
                self.repl_mode = Some(repl_mode.into());
                self
            }
            pub fn allow_unsafe_eval_blocked_by_csp(
                mut self,
                allow_unsafe_eval_blocked_by_csp: impl Into<bool>,
            ) -> Self {
                self.allow_unsafe_eval_blocked_by_csp =
                    Some(allow_unsafe_eval_blocked_by_csp.into());
                self
            }
            pub fn unique_context_id(mut self, unique_context_id: impl Into<String>) -> Self {
                self.unique_context_id = Some(unique_context_id.into());
                self
            }
            pub fn generate_web_driver_value(
                mut self,
                generate_web_driver_value: impl Into<bool>,
            ) -> Self {
                self.generate_web_driver_value = Some(generate_web_driver_value.into());
                self
            }
            pub fn eval_as_function_fallback(
                mut self,
                eval_as_function_fallback: impl Into<bool>,
            ) -> Self {
                self.eval_as_function_fallback = Some(eval_as_function_fallback.into());
                self
            }
            pub fn build(self) -> Result<EvaluateParams, String> {
                Ok(EvaluateParams {
                    expression: self.expression.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(expression))
                    })?,
                    object_group: self.object_group,
                    include_command_line_api: self.include_command_line_api,
                    silent: self.silent,
                    context_id: self.context_id,
                    return_by_value: self.return_by_value,
                    generate_preview: self.generate_preview,
                    user_gesture: self.user_gesture,
                    await_promise: self.await_promise,
                    throw_on_side_effect: self.throw_on_side_effect,
                    timeout: self.timeout,
                    disable_breaks: self.disable_breaks,
                    repl_mode: self.repl_mode,
                    allow_unsafe_eval_blocked_by_csp: self.allow_unsafe_eval_blocked_by_csp,
                    unique_context_id: self.unique_context_id,
                    generate_web_driver_value: self.generate_web_driver_value,
                    eval_as_function_fallback: self.eval_as_function_fallback,
                })
            }
        }
        impl EvaluateParams {
            pub const IDENTIFIER: &'static str = "Runtime.evaluate";
        }
        impl chromiumoxide_types::Method for EvaluateParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EvaluateParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Evaluates expression on global object.\n[evaluate](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-evaluate)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EvaluateReturns {
            #[doc = "Evaluation result."]
            #[serde(rename = "result")]
            pub result: RemoteObject,
            #[doc = "Exception details."]
            #[serde(rename = "exceptionDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub exception_details: Option<ExceptionDetails>,
            #[doc = r" This is a manually added field that is not part of the protocol definition, hence ignored during serde operations."]
            #[doc = r""]
            #[doc = r" If set to true, this field indicates, that if the command resulted in a response value of type `function` this, `EvaluateParams` command should be executed as a `CallFunctionOnParams` instead."]
            #[serde(skip)]
            pub eval_as_function_fallback: Option<bool>,
        }
        impl EvaluateReturns {
            pub fn new(result: impl Into<RemoteObject>) -> Self {
                Self {
                    result: result.into(),
                    exception_details: None,
                    eval_as_function_fallback: None,
                }
            }
        }
        impl EvaluateReturns {
            pub fn builder() -> EvaluateReturnsBuilder {
                EvaluateReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EvaluateReturnsBuilder {
            result: Option<RemoteObject>,
            exception_details: Option<ExceptionDetails>,
            eval_as_function_fallback: Option<bool>,
        }
        impl EvaluateReturnsBuilder {
            pub fn result(mut self, result: impl Into<RemoteObject>) -> Self {
                self.result = Some(result.into());
                self
            }
            pub fn exception_details(
                mut self,
                exception_details: impl Into<ExceptionDetails>,
            ) -> Self {
                self.exception_details = Some(exception_details.into());
                self
            }
            pub fn eval_as_function_fallback(
                mut self,
                eval_as_function_fallback: impl Into<bool>,
            ) -> Self {
                self.eval_as_function_fallback = Some(eval_as_function_fallback.into());
                self
            }
            pub fn build(self) -> Result<EvaluateReturns, String> {
                Ok(EvaluateReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                    exception_details: self.exception_details,
                    eval_as_function_fallback: self.eval_as_function_fallback,
                })
            }
        }
        impl chromiumoxide_types::Command for EvaluateParams {
            type Response = EvaluateReturns;
        }
        #[doc = "Returns the isolate id.\n[getIsolateId](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-getIsolateId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetIsolateIdParams {}
        impl GetIsolateIdParams {
            pub const IDENTIFIER: &'static str = "Runtime.getIsolateId";
        }
        impl chromiumoxide_types::Method for GetIsolateIdParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetIsolateIdParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the isolate id.\n[getIsolateId](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-getIsolateId)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetIsolateIdReturns {
            #[doc = "The isolate id."]
            #[serde(rename = "id")]
            pub id: String,
        }
        impl GetIsolateIdReturns {
            pub fn new(id: impl Into<String>) -> Self {
                Self { id: id.into() }
            }
        }
        impl<T: Into<String>> From<T> for GetIsolateIdReturns {
            fn from(url: T) -> Self {
                GetIsolateIdReturns::new(url)
            }
        }
        impl GetIsolateIdReturns {
            pub fn builder() -> GetIsolateIdReturnsBuilder {
                GetIsolateIdReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetIsolateIdReturnsBuilder {
            id: Option<String>,
        }
        impl GetIsolateIdReturnsBuilder {
            pub fn id(mut self, id: impl Into<String>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn build(self) -> Result<GetIsolateIdReturns, String> {
                Ok(GetIsolateIdReturns {
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetIsolateIdParams {
            type Response = GetIsolateIdReturns;
        }
        #[doc = "Returns the JavaScript heap usage.\nIt is the total usage of the corresponding isolate not scoped to a particular Runtime.\n[getHeapUsage](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-getHeapUsage)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetHeapUsageParams {}
        impl GetHeapUsageParams {
            pub const IDENTIFIER: &'static str = "Runtime.getHeapUsage";
        }
        impl chromiumoxide_types::Method for GetHeapUsageParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetHeapUsageParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the JavaScript heap usage.\nIt is the total usage of the corresponding isolate not scoped to a particular Runtime.\n[getHeapUsage](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-getHeapUsage)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetHeapUsageReturns {
            #[doc = "Used heap size in bytes."]
            #[serde(rename = "usedSize")]
            pub used_size: f64,
            #[doc = "Allocated heap size in bytes."]
            #[serde(rename = "totalSize")]
            pub total_size: f64,
        }
        impl GetHeapUsageReturns {
            pub fn new(used_size: impl Into<f64>, total_size: impl Into<f64>) -> Self {
                Self {
                    used_size: used_size.into(),
                    total_size: total_size.into(),
                }
            }
        }
        impl GetHeapUsageReturns {
            pub fn builder() -> GetHeapUsageReturnsBuilder {
                GetHeapUsageReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetHeapUsageReturnsBuilder {
            used_size: Option<f64>,
            total_size: Option<f64>,
        }
        impl GetHeapUsageReturnsBuilder {
            pub fn used_size(mut self, used_size: impl Into<f64>) -> Self {
                self.used_size = Some(used_size.into());
                self
            }
            pub fn total_size(mut self, total_size: impl Into<f64>) -> Self {
                self.total_size = Some(total_size.into());
                self
            }
            pub fn build(self) -> Result<GetHeapUsageReturns, String> {
                Ok(GetHeapUsageReturns {
                    used_size: self.used_size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(used_size))
                    })?,
                    total_size: self.total_size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(total_size))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetHeapUsageParams {
            type Response = GetHeapUsageReturns;
        }
        #[doc = "Returns properties of a given object. Object group of the result is inherited from the target\nobject.\n[getProperties](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-getProperties)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetPropertiesParams {
            #[doc = "Identifier of the object to return properties for."]
            #[serde(rename = "objectId")]
            pub object_id: RemoteObjectId,
            #[doc = "If true, returns properties belonging only to the element itself, not to its prototype\nchain."]
            #[serde(rename = "ownProperties")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub own_properties: Option<bool>,
            #[doc = "If true, returns accessor properties (with getter/setter) only; internal properties are not\nreturned either."]
            #[serde(rename = "accessorPropertiesOnly")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub accessor_properties_only: Option<bool>,
            #[doc = "Whether preview should be generated for the results."]
            #[serde(rename = "generatePreview")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub generate_preview: Option<bool>,
            #[doc = "If true, returns non-indexed properties only."]
            #[serde(rename = "nonIndexedPropertiesOnly")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub non_indexed_properties_only: Option<bool>,
        }
        impl GetPropertiesParams {
            pub fn new(object_id: impl Into<RemoteObjectId>) -> Self {
                Self {
                    object_id: object_id.into(),
                    own_properties: None,
                    accessor_properties_only: None,
                    generate_preview: None,
                    non_indexed_properties_only: None,
                }
            }
        }
        impl GetPropertiesParams {
            pub fn builder() -> GetPropertiesParamsBuilder {
                GetPropertiesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetPropertiesParamsBuilder {
            object_id: Option<RemoteObjectId>,
            own_properties: Option<bool>,
            accessor_properties_only: Option<bool>,
            generate_preview: Option<bool>,
            non_indexed_properties_only: Option<bool>,
        }
        impl GetPropertiesParamsBuilder {
            pub fn object_id(mut self, object_id: impl Into<RemoteObjectId>) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn own_properties(mut self, own_properties: impl Into<bool>) -> Self {
                self.own_properties = Some(own_properties.into());
                self
            }
            pub fn accessor_properties_only(
                mut self,
                accessor_properties_only: impl Into<bool>,
            ) -> Self {
                self.accessor_properties_only = Some(accessor_properties_only.into());
                self
            }
            pub fn generate_preview(mut self, generate_preview: impl Into<bool>) -> Self {
                self.generate_preview = Some(generate_preview.into());
                self
            }
            pub fn non_indexed_properties_only(
                mut self,
                non_indexed_properties_only: impl Into<bool>,
            ) -> Self {
                self.non_indexed_properties_only = Some(non_indexed_properties_only.into());
                self
            }
            pub fn build(self) -> Result<GetPropertiesParams, String> {
                Ok(GetPropertiesParams {
                    object_id: self.object_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(object_id))
                    })?,
                    own_properties: self.own_properties,
                    accessor_properties_only: self.accessor_properties_only,
                    generate_preview: self.generate_preview,
                    non_indexed_properties_only: self.non_indexed_properties_only,
                })
            }
        }
        impl GetPropertiesParams {
            pub const IDENTIFIER: &'static str = "Runtime.getProperties";
        }
        impl chromiumoxide_types::Method for GetPropertiesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetPropertiesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns properties of a given object. Object group of the result is inherited from the target\nobject.\n[getProperties](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-getProperties)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetPropertiesReturns {
            #[doc = "Object properties."]
            #[serde(rename = "result")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub result: Vec<PropertyDescriptor>,
            #[doc = "Internal object properties (only of the element itself)."]
            #[serde(rename = "internalProperties")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub internal_properties: Option<Vec<InternalPropertyDescriptor>>,
            #[doc = "Object private properties."]
            #[serde(rename = "privateProperties")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub private_properties: Option<Vec<PrivatePropertyDescriptor>>,
            #[doc = "Exception details."]
            #[serde(rename = "exceptionDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub exception_details: Option<ExceptionDetails>,
        }
        impl GetPropertiesReturns {
            pub fn new(result: Vec<PropertyDescriptor>) -> Self {
                Self {
                    result,
                    internal_properties: None,
                    private_properties: None,
                    exception_details: None,
                }
            }
        }
        impl GetPropertiesReturns {
            pub fn builder() -> GetPropertiesReturnsBuilder {
                GetPropertiesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetPropertiesReturnsBuilder {
            result: Option<Vec<PropertyDescriptor>>,
            internal_properties: Option<Vec<InternalPropertyDescriptor>>,
            private_properties: Option<Vec<PrivatePropertyDescriptor>>,
            exception_details: Option<ExceptionDetails>,
        }
        impl GetPropertiesReturnsBuilder {
            pub fn result(mut self, result: impl Into<PropertyDescriptor>) -> Self {
                let v = self.result.get_or_insert(Vec::new());
                v.push(result.into());
                self
            }
            pub fn results<I, S>(mut self, results: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PropertyDescriptor>,
            {
                let v = self.result.get_or_insert(Vec::new());
                for val in results {
                    v.push(val.into());
                }
                self
            }
            pub fn internal_propertie(
                mut self,
                internal_propertie: impl Into<InternalPropertyDescriptor>,
            ) -> Self {
                let v = self.internal_properties.get_or_insert(Vec::new());
                v.push(internal_propertie.into());
                self
            }
            pub fn internal_properties<I, S>(mut self, internal_properties: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<InternalPropertyDescriptor>,
            {
                let v = self.internal_properties.get_or_insert(Vec::new());
                for val in internal_properties {
                    v.push(val.into());
                }
                self
            }
            pub fn private_propertie(
                mut self,
                private_propertie: impl Into<PrivatePropertyDescriptor>,
            ) -> Self {
                let v = self.private_properties.get_or_insert(Vec::new());
                v.push(private_propertie.into());
                self
            }
            pub fn private_properties<I, S>(mut self, private_properties: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PrivatePropertyDescriptor>,
            {
                let v = self.private_properties.get_or_insert(Vec::new());
                for val in private_properties {
                    v.push(val.into());
                }
                self
            }
            pub fn exception_details(
                mut self,
                exception_details: impl Into<ExceptionDetails>,
            ) -> Self {
                self.exception_details = Some(exception_details.into());
                self
            }
            pub fn build(self) -> Result<GetPropertiesReturns, String> {
                Ok(GetPropertiesReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                    internal_properties: self.internal_properties,
                    private_properties: self.private_properties,
                    exception_details: self.exception_details,
                })
            }
        }
        impl chromiumoxide_types::Command for GetPropertiesParams {
            type Response = GetPropertiesReturns;
        }
        #[doc = "Returns all let, const and class variables from global scope.\n[globalLexicalScopeNames](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-globalLexicalScopeNames)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GlobalLexicalScopeNamesParams {
            #[doc = "Specifies in which execution context to lookup global scope variables."]
            #[serde(rename = "executionContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub execution_context_id: Option<ExecutionContextId>,
        }
        impl GlobalLexicalScopeNamesParams {
            pub fn builder() -> GlobalLexicalScopeNamesParamsBuilder {
                GlobalLexicalScopeNamesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GlobalLexicalScopeNamesParamsBuilder {
            execution_context_id: Option<ExecutionContextId>,
        }
        impl GlobalLexicalScopeNamesParamsBuilder {
            pub fn execution_context_id(
                mut self,
                execution_context_id: impl Into<ExecutionContextId>,
            ) -> Self {
                self.execution_context_id = Some(execution_context_id.into());
                self
            }
            pub fn build(self) -> GlobalLexicalScopeNamesParams {
                GlobalLexicalScopeNamesParams {
                    execution_context_id: self.execution_context_id,
                }
            }
        }
        impl GlobalLexicalScopeNamesParams {
            pub const IDENTIFIER: &'static str = "Runtime.globalLexicalScopeNames";
        }
        impl chromiumoxide_types::Method for GlobalLexicalScopeNamesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GlobalLexicalScopeNamesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns all let, const and class variables from global scope.\n[globalLexicalScopeNames](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-globalLexicalScopeNames)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GlobalLexicalScopeNamesReturns {
            #[serde(rename = "names")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub names: Vec<String>,
        }
        impl GlobalLexicalScopeNamesReturns {
            pub fn new(names: Vec<String>) -> Self {
                Self { names }
            }
        }
        impl GlobalLexicalScopeNamesReturns {
            pub fn builder() -> GlobalLexicalScopeNamesReturnsBuilder {
                GlobalLexicalScopeNamesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GlobalLexicalScopeNamesReturnsBuilder {
            names: Option<Vec<String>>,
        }
        impl GlobalLexicalScopeNamesReturnsBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                let v = self.names.get_or_insert(Vec::new());
                v.push(name.into());
                self
            }
            pub fn names<I, S>(mut self, names: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.names.get_or_insert(Vec::new());
                for val in names {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GlobalLexicalScopeNamesReturns, String> {
                Ok(GlobalLexicalScopeNamesReturns {
                    names: self.names.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(names))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GlobalLexicalScopeNamesParams {
            type Response = GlobalLexicalScopeNamesReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct QueryObjectsParams {
            #[doc = "Identifier of the prototype to return objects for."]
            #[serde(rename = "prototypeObjectId")]
            pub prototype_object_id: RemoteObjectId,
            #[doc = "Symbolic group name that can be used to release the results."]
            #[serde(rename = "objectGroup")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_group: Option<String>,
        }
        impl QueryObjectsParams {
            pub fn new(prototype_object_id: impl Into<RemoteObjectId>) -> Self {
                Self {
                    prototype_object_id: prototype_object_id.into(),
                    object_group: None,
                }
            }
        }
        impl QueryObjectsParams {
            pub fn builder() -> QueryObjectsParamsBuilder {
                QueryObjectsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct QueryObjectsParamsBuilder {
            prototype_object_id: Option<RemoteObjectId>,
            object_group: Option<String>,
        }
        impl QueryObjectsParamsBuilder {
            pub fn prototype_object_id(
                mut self,
                prototype_object_id: impl Into<RemoteObjectId>,
            ) -> Self {
                self.prototype_object_id = Some(prototype_object_id.into());
                self
            }
            pub fn object_group(mut self, object_group: impl Into<String>) -> Self {
                self.object_group = Some(object_group.into());
                self
            }
            pub fn build(self) -> Result<QueryObjectsParams, String> {
                Ok(QueryObjectsParams {
                    prototype_object_id: self.prototype_object_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(prototype_object_id)
                        )
                    })?,
                    object_group: self.object_group,
                })
            }
        }
        impl QueryObjectsParams {
            pub const IDENTIFIER: &'static str = "Runtime.queryObjects";
        }
        impl chromiumoxide_types::Method for QueryObjectsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for QueryObjectsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct QueryObjectsReturns {
            #[doc = "Array with objects."]
            #[serde(rename = "objects")]
            pub objects: RemoteObject,
        }
        impl QueryObjectsReturns {
            pub fn new(objects: impl Into<RemoteObject>) -> Self {
                Self {
                    objects: objects.into(),
                }
            }
        }
        impl QueryObjectsReturns {
            pub fn builder() -> QueryObjectsReturnsBuilder {
                QueryObjectsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct QueryObjectsReturnsBuilder {
            objects: Option<RemoteObject>,
        }
        impl QueryObjectsReturnsBuilder {
            pub fn objects(mut self, objects: impl Into<RemoteObject>) -> Self {
                self.objects = Some(objects.into());
                self
            }
            pub fn build(self) -> Result<QueryObjectsReturns, String> {
                Ok(QueryObjectsReturns {
                    objects: self.objects.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(objects))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for QueryObjectsParams {
            type Response = QueryObjectsReturns;
        }
        #[doc = "Releases remote object with given id.\n[releaseObject](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-releaseObject)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ReleaseObjectParams {
            #[doc = "Identifier of the object to release."]
            #[serde(rename = "objectId")]
            pub object_id: RemoteObjectId,
        }
        impl ReleaseObjectParams {
            pub fn new(object_id: impl Into<RemoteObjectId>) -> Self {
                Self {
                    object_id: object_id.into(),
                }
            }
        }
        impl ReleaseObjectParams {
            pub fn builder() -> ReleaseObjectParamsBuilder {
                ReleaseObjectParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ReleaseObjectParamsBuilder {
            object_id: Option<RemoteObjectId>,
        }
        impl ReleaseObjectParamsBuilder {
            pub fn object_id(mut self, object_id: impl Into<RemoteObjectId>) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> Result<ReleaseObjectParams, String> {
                Ok(ReleaseObjectParams {
                    object_id: self.object_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(object_id))
                    })?,
                })
            }
        }
        impl ReleaseObjectParams {
            pub const IDENTIFIER: &'static str = "Runtime.releaseObject";
        }
        impl chromiumoxide_types::Method for ReleaseObjectParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ReleaseObjectParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Releases remote object with given id.\n[releaseObject](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-releaseObject)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ReleaseObjectReturns {}
        impl chromiumoxide_types::Command for ReleaseObjectParams {
            type Response = ReleaseObjectReturns;
        }
        #[doc = "Releases all remote objects that belong to a given group.\n[releaseObjectGroup](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-releaseObjectGroup)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ReleaseObjectGroupParams {
            #[doc = "Symbolic object group name."]
            #[serde(rename = "objectGroup")]
            pub object_group: String,
        }
        impl ReleaseObjectGroupParams {
            pub fn new(object_group: impl Into<String>) -> Self {
                Self {
                    object_group: object_group.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for ReleaseObjectGroupParams {
            fn from(url: T) -> Self {
                ReleaseObjectGroupParams::new(url)
            }
        }
        impl ReleaseObjectGroupParams {
            pub fn builder() -> ReleaseObjectGroupParamsBuilder {
                ReleaseObjectGroupParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ReleaseObjectGroupParamsBuilder {
            object_group: Option<String>,
        }
        impl ReleaseObjectGroupParamsBuilder {
            pub fn object_group(mut self, object_group: impl Into<String>) -> Self {
                self.object_group = Some(object_group.into());
                self
            }
            pub fn build(self) -> Result<ReleaseObjectGroupParams, String> {
                Ok(ReleaseObjectGroupParams {
                    object_group: self.object_group.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(object_group))
                    })?,
                })
            }
        }
        impl ReleaseObjectGroupParams {
            pub const IDENTIFIER: &'static str = "Runtime.releaseObjectGroup";
        }
        impl chromiumoxide_types::Method for ReleaseObjectGroupParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ReleaseObjectGroupParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Releases all remote objects that belong to a given group.\n[releaseObjectGroup](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-releaseObjectGroup)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ReleaseObjectGroupReturns {}
        impl chromiumoxide_types::Command for ReleaseObjectGroupParams {
            type Response = ReleaseObjectGroupReturns;
        }
        #[doc = "Tells inspected instance to run if it was waiting for debugger to attach.\n[runIfWaitingForDebugger](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-runIfWaitingForDebugger)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RunIfWaitingForDebuggerParams {}
        impl RunIfWaitingForDebuggerParams {
            pub const IDENTIFIER: &'static str = "Runtime.runIfWaitingForDebugger";
        }
        impl chromiumoxide_types::Method for RunIfWaitingForDebuggerParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RunIfWaitingForDebuggerParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Tells inspected instance to run if it was waiting for debugger to attach.\n[runIfWaitingForDebugger](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-runIfWaitingForDebugger)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RunIfWaitingForDebuggerReturns {}
        impl chromiumoxide_types::Command for RunIfWaitingForDebuggerParams {
            type Response = RunIfWaitingForDebuggerReturns;
        }
        #[doc = "Runs script with given id in a given context.\n[runScript](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-runScript)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RunScriptParams {
            #[doc = "Id of the script to run."]
            #[serde(rename = "scriptId")]
            pub script_id: ScriptId,
            #[doc = "Specifies in which execution context to perform script run. If the parameter is omitted the\nevaluation will be performed in the context of the inspected page."]
            #[serde(rename = "executionContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub execution_context_id: Option<ExecutionContextId>,
            #[doc = "Symbolic group name that can be used to release multiple objects."]
            #[serde(rename = "objectGroup")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_group: Option<String>,
            #[doc = "In silent mode exceptions thrown during evaluation are not reported and do not pause\nexecution. Overrides `setPauseOnException` state."]
            #[serde(rename = "silent")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub silent: Option<bool>,
            #[doc = "Determines whether Command Line API should be available during the evaluation."]
            #[serde(rename = "includeCommandLineAPI")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub include_command_line_api: Option<bool>,
            #[doc = "Whether the result is expected to be a JSON object which should be sent by value."]
            #[serde(rename = "returnByValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub return_by_value: Option<bool>,
            #[doc = "Whether preview should be generated for the result."]
            #[serde(rename = "generatePreview")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub generate_preview: Option<bool>,
            #[doc = "Whether execution should `await` for resulting value and return once awaited promise is\nresolved."]
            #[serde(rename = "awaitPromise")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub await_promise: Option<bool>,
        }
        impl RunScriptParams {
            pub fn new(script_id: impl Into<ScriptId>) -> Self {
                Self {
                    script_id: script_id.into(),
                    execution_context_id: None,
                    object_group: None,
                    silent: None,
                    include_command_line_api: None,
                    return_by_value: None,
                    generate_preview: None,
                    await_promise: None,
                }
            }
        }
        impl RunScriptParams {
            pub fn builder() -> RunScriptParamsBuilder {
                RunScriptParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RunScriptParamsBuilder {
            script_id: Option<ScriptId>,
            execution_context_id: Option<ExecutionContextId>,
            object_group: Option<String>,
            silent: Option<bool>,
            include_command_line_api: Option<bool>,
            return_by_value: Option<bool>,
            generate_preview: Option<bool>,
            await_promise: Option<bool>,
        }
        impl RunScriptParamsBuilder {
            pub fn script_id(mut self, script_id: impl Into<ScriptId>) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn execution_context_id(
                mut self,
                execution_context_id: impl Into<ExecutionContextId>,
            ) -> Self {
                self.execution_context_id = Some(execution_context_id.into());
                self
            }
            pub fn object_group(mut self, object_group: impl Into<String>) -> Self {
                self.object_group = Some(object_group.into());
                self
            }
            pub fn silent(mut self, silent: impl Into<bool>) -> Self {
                self.silent = Some(silent.into());
                self
            }
            pub fn include_command_line_api(
                mut self,
                include_command_line_api: impl Into<bool>,
            ) -> Self {
                self.include_command_line_api = Some(include_command_line_api.into());
                self
            }
            pub fn return_by_value(mut self, return_by_value: impl Into<bool>) -> Self {
                self.return_by_value = Some(return_by_value.into());
                self
            }
            pub fn generate_preview(mut self, generate_preview: impl Into<bool>) -> Self {
                self.generate_preview = Some(generate_preview.into());
                self
            }
            pub fn await_promise(mut self, await_promise: impl Into<bool>) -> Self {
                self.await_promise = Some(await_promise.into());
                self
            }
            pub fn build(self) -> Result<RunScriptParams, String> {
                Ok(RunScriptParams {
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                    execution_context_id: self.execution_context_id,
                    object_group: self.object_group,
                    silent: self.silent,
                    include_command_line_api: self.include_command_line_api,
                    return_by_value: self.return_by_value,
                    generate_preview: self.generate_preview,
                    await_promise: self.await_promise,
                })
            }
        }
        impl RunScriptParams {
            pub const IDENTIFIER: &'static str = "Runtime.runScript";
        }
        impl chromiumoxide_types::Method for RunScriptParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RunScriptParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Runs script with given id in a given context.\n[runScript](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-runScript)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RunScriptReturns {
            #[doc = "Run result."]
            #[serde(rename = "result")]
            pub result: RemoteObject,
            #[doc = "Exception details."]
            #[serde(rename = "exceptionDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub exception_details: Option<ExceptionDetails>,
        }
        impl RunScriptReturns {
            pub fn new(result: impl Into<RemoteObject>) -> Self {
                Self {
                    result: result.into(),
                    exception_details: None,
                }
            }
        }
        impl RunScriptReturns {
            pub fn builder() -> RunScriptReturnsBuilder {
                RunScriptReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RunScriptReturnsBuilder {
            result: Option<RemoteObject>,
            exception_details: Option<ExceptionDetails>,
        }
        impl RunScriptReturnsBuilder {
            pub fn result(mut self, result: impl Into<RemoteObject>) -> Self {
                self.result = Some(result.into());
                self
            }
            pub fn exception_details(
                mut self,
                exception_details: impl Into<ExceptionDetails>,
            ) -> Self {
                self.exception_details = Some(exception_details.into());
                self
            }
            pub fn build(self) -> Result<RunScriptReturns, String> {
                Ok(RunScriptReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                    exception_details: self.exception_details,
                })
            }
        }
        impl chromiumoxide_types::Command for RunScriptParams {
            type Response = RunScriptReturns;
        }
        #[doc = "Enables or disables async call stacks tracking.\n[setAsyncCallStackDepth](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-setAsyncCallStackDepth)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetAsyncCallStackDepthParams {
            #[doc = "Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async\ncall stacks (default)."]
            #[serde(rename = "maxDepth")]
            pub max_depth: i64,
        }
        impl SetAsyncCallStackDepthParams {
            pub fn new(max_depth: impl Into<i64>) -> Self {
                Self {
                    max_depth: max_depth.into(),
                }
            }
        }
        impl SetAsyncCallStackDepthParams {
            pub fn builder() -> SetAsyncCallStackDepthParamsBuilder {
                SetAsyncCallStackDepthParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetAsyncCallStackDepthParamsBuilder {
            max_depth: Option<i64>,
        }
        impl SetAsyncCallStackDepthParamsBuilder {
            pub fn max_depth(mut self, max_depth: impl Into<i64>) -> Self {
                self.max_depth = Some(max_depth.into());
                self
            }
            pub fn build(self) -> Result<SetAsyncCallStackDepthParams, String> {
                Ok(SetAsyncCallStackDepthParams {
                    max_depth: self.max_depth.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(max_depth))
                    })?,
                })
            }
        }
        impl SetAsyncCallStackDepthParams {
            pub const IDENTIFIER: &'static str = "Runtime.setAsyncCallStackDepth";
        }
        impl chromiumoxide_types::Method for SetAsyncCallStackDepthParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetAsyncCallStackDepthParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables or disables async call stacks tracking.\n[setAsyncCallStackDepth](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-setAsyncCallStackDepth)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetAsyncCallStackDepthReturns {}
        impl chromiumoxide_types::Command for SetAsyncCallStackDepthParams {
            type Response = SetAsyncCallStackDepthReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetCustomObjectFormatterEnabledParams {
            #[serde(rename = "enabled")]
            pub enabled: bool,
        }
        impl SetCustomObjectFormatterEnabledParams {
            pub fn new(enabled: impl Into<bool>) -> Self {
                Self {
                    enabled: enabled.into(),
                }
            }
        }
        impl SetCustomObjectFormatterEnabledParams {
            pub fn builder() -> SetCustomObjectFormatterEnabledParamsBuilder {
                SetCustomObjectFormatterEnabledParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetCustomObjectFormatterEnabledParamsBuilder {
            enabled: Option<bool>,
        }
        impl SetCustomObjectFormatterEnabledParamsBuilder {
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn build(self) -> Result<SetCustomObjectFormatterEnabledParams, String> {
                Ok(SetCustomObjectFormatterEnabledParams {
                    enabled: self.enabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enabled))
                    })?,
                })
            }
        }
        impl SetCustomObjectFormatterEnabledParams {
            pub const IDENTIFIER: &'static str = "Runtime.setCustomObjectFormatterEnabled";
        }
        impl chromiumoxide_types::Method for SetCustomObjectFormatterEnabledParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetCustomObjectFormatterEnabledParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetCustomObjectFormatterEnabledReturns {}
        impl chromiumoxide_types::Command for SetCustomObjectFormatterEnabledParams {
            type Response = SetCustomObjectFormatterEnabledReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetMaxCallStackSizeToCaptureParams {
            #[serde(rename = "size")]
            pub size: i64,
        }
        impl SetMaxCallStackSizeToCaptureParams {
            pub fn new(size: impl Into<i64>) -> Self {
                Self { size: size.into() }
            }
        }
        impl SetMaxCallStackSizeToCaptureParams {
            pub fn builder() -> SetMaxCallStackSizeToCaptureParamsBuilder {
                SetMaxCallStackSizeToCaptureParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetMaxCallStackSizeToCaptureParamsBuilder {
            size: Option<i64>,
        }
        impl SetMaxCallStackSizeToCaptureParamsBuilder {
            pub fn size(mut self, size: impl Into<i64>) -> Self {
                self.size = Some(size.into());
                self
            }
            pub fn build(self) -> Result<SetMaxCallStackSizeToCaptureParams, String> {
                Ok(SetMaxCallStackSizeToCaptureParams {
                    size: self.size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(size))
                    })?,
                })
            }
        }
        impl SetMaxCallStackSizeToCaptureParams {
            pub const IDENTIFIER: &'static str = "Runtime.setMaxCallStackSizeToCapture";
        }
        impl chromiumoxide_types::Method for SetMaxCallStackSizeToCaptureParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetMaxCallStackSizeToCaptureParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetMaxCallStackSizeToCaptureReturns {}
        impl chromiumoxide_types::Command for SetMaxCallStackSizeToCaptureParams {
            type Response = SetMaxCallStackSizeToCaptureReturns;
        }
        #[doc = "Terminate current or next JavaScript execution.\nWill cancel the termination when the outer-most script execution ends.\n[terminateExecution](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-terminateExecution)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TerminateExecutionParams {}
        impl TerminateExecutionParams {
            pub const IDENTIFIER: &'static str = "Runtime.terminateExecution";
        }
        impl chromiumoxide_types::Method for TerminateExecutionParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for TerminateExecutionParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Terminate current or next JavaScript execution.\nWill cancel the termination when the outer-most script execution ends.\n[terminateExecution](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-terminateExecution)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TerminateExecutionReturns {}
        impl chromiumoxide_types::Command for TerminateExecutionParams {
            type Response = TerminateExecutionReturns;
        }
        #[doc = "If executionContextId is empty, adds binding with the given name on the\nglobal objects of all inspected contexts, including those created later,\nbindings survive reloads.\nBinding function takes exactly one argument, this argument should be string,\nin case of any other input, function throws an exception.\nEach binding function call produces Runtime.bindingCalled notification.\n[addBinding](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-addBinding)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AddBindingParams {
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "If specified, the binding is exposed to the executionContext with\nmatching name, even for contexts created after the binding is added.\nSee also `ExecutionContext.name` and `worldName` parameter to\n`Page.addScriptToEvaluateOnNewDocument`.\nThis parameter is mutually exclusive with `executionContextId`."]
            #[serde(rename = "executionContextName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub execution_context_name: Option<String>,
        }
        impl AddBindingParams {
            pub fn new(name: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    execution_context_name: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for AddBindingParams {
            fn from(url: T) -> Self {
                AddBindingParams::new(url)
            }
        }
        impl AddBindingParams {
            pub fn builder() -> AddBindingParamsBuilder {
                AddBindingParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AddBindingParamsBuilder {
            name: Option<String>,
            execution_context_name: Option<String>,
        }
        impl AddBindingParamsBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn execution_context_name(
                mut self,
                execution_context_name: impl Into<String>,
            ) -> Self {
                self.execution_context_name = Some(execution_context_name.into());
                self
            }
            pub fn build(self) -> Result<AddBindingParams, String> {
                Ok(AddBindingParams {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    execution_context_name: self.execution_context_name,
                })
            }
        }
        impl AddBindingParams {
            pub const IDENTIFIER: &'static str = "Runtime.addBinding";
        }
        impl chromiumoxide_types::Method for AddBindingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for AddBindingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "If executionContextId is empty, adds binding with the given name on the\nglobal objects of all inspected contexts, including those created later,\nbindings survive reloads.\nBinding function takes exactly one argument, this argument should be string,\nin case of any other input, function throws an exception.\nEach binding function call produces Runtime.bindingCalled notification.\n[addBinding](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-addBinding)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct AddBindingReturns {}
        impl chromiumoxide_types::Command for AddBindingParams {
            type Response = AddBindingReturns;
        }
        #[doc = "This method does not remove binding function from global object but\nunsubscribes current runtime agent from Runtime.bindingCalled notifications.\n[removeBinding](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-removeBinding)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoveBindingParams {
            #[serde(rename = "name")]
            pub name: String,
        }
        impl RemoveBindingParams {
            pub fn new(name: impl Into<String>) -> Self {
                Self { name: name.into() }
            }
        }
        impl<T: Into<String>> From<T> for RemoveBindingParams {
            fn from(url: T) -> Self {
                RemoveBindingParams::new(url)
            }
        }
        impl RemoveBindingParams {
            pub fn builder() -> RemoveBindingParamsBuilder {
                RemoveBindingParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoveBindingParamsBuilder {
            name: Option<String>,
        }
        impl RemoveBindingParamsBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn build(self) -> Result<RemoveBindingParams, String> {
                Ok(RemoveBindingParams {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                })
            }
        }
        impl RemoveBindingParams {
            pub const IDENTIFIER: &'static str = "Runtime.removeBinding";
        }
        impl chromiumoxide_types::Method for RemoveBindingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RemoveBindingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "This method does not remove binding function from global object but\nunsubscribes current runtime agent from Runtime.bindingCalled notifications.\n[removeBinding](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-removeBinding)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RemoveBindingReturns {}
        impl chromiumoxide_types::Command for RemoveBindingParams {
            type Response = RemoveBindingReturns;
        }
        #[doc = "This method tries to lookup and populate exception details for a\nJavaScript Error object.\nNote that the stackTrace portion of the resulting exceptionDetails will\nonly be populated if the Runtime domain was enabled at the time when the\nError was thrown.\n[getExceptionDetails](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-getExceptionDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetExceptionDetailsParams {
            #[doc = "The error object for which to resolve the exception details."]
            #[serde(rename = "errorObjectId")]
            pub error_object_id: RemoteObjectId,
        }
        impl GetExceptionDetailsParams {
            pub fn new(error_object_id: impl Into<RemoteObjectId>) -> Self {
                Self {
                    error_object_id: error_object_id.into(),
                }
            }
        }
        impl GetExceptionDetailsParams {
            pub fn builder() -> GetExceptionDetailsParamsBuilder {
                GetExceptionDetailsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetExceptionDetailsParamsBuilder {
            error_object_id: Option<RemoteObjectId>,
        }
        impl GetExceptionDetailsParamsBuilder {
            pub fn error_object_id(mut self, error_object_id: impl Into<RemoteObjectId>) -> Self {
                self.error_object_id = Some(error_object_id.into());
                self
            }
            pub fn build(self) -> Result<GetExceptionDetailsParams, String> {
                Ok(GetExceptionDetailsParams {
                    error_object_id: self.error_object_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(error_object_id))
                    })?,
                })
            }
        }
        impl GetExceptionDetailsParams {
            pub const IDENTIFIER: &'static str = "Runtime.getExceptionDetails";
        }
        impl chromiumoxide_types::Method for GetExceptionDetailsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetExceptionDetailsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "This method tries to lookup and populate exception details for a\nJavaScript Error object.\nNote that the stackTrace portion of the resulting exceptionDetails will\nonly be populated if the Runtime domain was enabled at the time when the\nError was thrown.\n[getExceptionDetails](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-getExceptionDetails)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetExceptionDetailsReturns {
            #[serde(rename = "exceptionDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub exception_details: Option<ExceptionDetails>,
        }
        impl GetExceptionDetailsReturns {
            pub fn builder() -> GetExceptionDetailsReturnsBuilder {
                GetExceptionDetailsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetExceptionDetailsReturnsBuilder {
            exception_details: Option<ExceptionDetails>,
        }
        impl GetExceptionDetailsReturnsBuilder {
            pub fn exception_details(
                mut self,
                exception_details: impl Into<ExceptionDetails>,
            ) -> Self {
                self.exception_details = Some(exception_details.into());
                self
            }
            pub fn build(self) -> GetExceptionDetailsReturns {
                GetExceptionDetailsReturns {
                    exception_details: self.exception_details,
                }
            }
        }
        impl chromiumoxide_types::Command for GetExceptionDetailsParams {
            type Response = GetExceptionDetailsReturns;
        }
        #[doc = "Notification is issued every time when binding is called.\n[bindingCalled](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-bindingCalled)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventBindingCalled {
            #[serde(rename = "name")]
            pub name: String,
            #[serde(rename = "payload")]
            pub payload: String,
            #[doc = "Identifier of the context where the call was made."]
            #[serde(rename = "executionContextId")]
            pub execution_context_id: ExecutionContextId,
        }
        impl EventBindingCalled {
            pub const IDENTIFIER: &'static str = "Runtime.bindingCalled";
        }
        impl chromiumoxide_types::Method for EventBindingCalled {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventBindingCalled {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued when console API was called.\n[consoleAPICalled](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-consoleAPICalled)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventConsoleApiCalled {
            #[doc = "Type of the call."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: ConsoleApiCalledType,
            #[doc = "Call arguments."]
            #[serde(rename = "args")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub args: Vec<RemoteObject>,
            #[doc = "Identifier of the context where the call was made."]
            #[serde(rename = "executionContextId")]
            pub execution_context_id: ExecutionContextId,
            #[doc = "Call timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: Timestamp,
            #[doc = "Stack trace captured when the call was made. The async stack chain is automatically reported for\nthe following call types: `assert`, `error`, `trace`, `warning`. For other types the async call\nchain can be retrieved using `Debugger.getStackTrace` and `stackTrace.parentId` field."]
            #[serde(rename = "stackTrace")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub stack_trace: Option<StackTrace>,
            #[doc = "Console context descriptor for calls on non-default console context (not console.*):\n'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call\non named context."]
            #[serde(rename = "context")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub context: Option<String>,
        }
        #[doc = "Type of the call."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ConsoleApiCalledType {
            #[serde(rename = "log")]
            Log,
            #[serde(rename = "debug")]
            Debug,
            #[serde(rename = "info")]
            Info,
            #[serde(rename = "error")]
            Error,
            #[serde(rename = "warning")]
            Warning,
            #[serde(rename = "dir")]
            Dir,
            #[serde(rename = "dirxml")]
            Dirxml,
            #[serde(rename = "table")]
            Table,
            #[serde(rename = "trace")]
            Trace,
            #[serde(rename = "clear")]
            Clear,
            #[serde(rename = "startGroup")]
            StartGroup,
            #[serde(rename = "startGroupCollapsed")]
            StartGroupCollapsed,
            #[serde(rename = "endGroup")]
            EndGroup,
            #[serde(rename = "assert")]
            Assert,
            #[serde(rename = "profile")]
            Profile,
            #[serde(rename = "profileEnd")]
            ProfileEnd,
            #[serde(rename = "count")]
            Count,
            #[serde(rename = "timeEnd")]
            TimeEnd,
        }
        impl AsRef<str> for ConsoleApiCalledType {
            fn as_ref(&self) -> &str {
                match self {
                    ConsoleApiCalledType::Log => "log",
                    ConsoleApiCalledType::Debug => "debug",
                    ConsoleApiCalledType::Info => "info",
                    ConsoleApiCalledType::Error => "error",
                    ConsoleApiCalledType::Warning => "warning",
                    ConsoleApiCalledType::Dir => "dir",
                    ConsoleApiCalledType::Dirxml => "dirxml",
                    ConsoleApiCalledType::Table => "table",
                    ConsoleApiCalledType::Trace => "trace",
                    ConsoleApiCalledType::Clear => "clear",
                    ConsoleApiCalledType::StartGroup => "startGroup",
                    ConsoleApiCalledType::StartGroupCollapsed => "startGroupCollapsed",
                    ConsoleApiCalledType::EndGroup => "endGroup",
                    ConsoleApiCalledType::Assert => "assert",
                    ConsoleApiCalledType::Profile => "profile",
                    ConsoleApiCalledType::ProfileEnd => "profileEnd",
                    ConsoleApiCalledType::Count => "count",
                    ConsoleApiCalledType::TimeEnd => "timeEnd",
                }
            }
        }
        impl ::std::str::FromStr for ConsoleApiCalledType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "log" | "Log" => Ok(ConsoleApiCalledType::Log),
                    "debug" | "Debug" => Ok(ConsoleApiCalledType::Debug),
                    "info" | "Info" => Ok(ConsoleApiCalledType::Info),
                    "error" | "Error" => Ok(ConsoleApiCalledType::Error),
                    "warning" | "Warning" => Ok(ConsoleApiCalledType::Warning),
                    "dir" | "Dir" => Ok(ConsoleApiCalledType::Dir),
                    "dirxml" | "Dirxml" => Ok(ConsoleApiCalledType::Dirxml),
                    "table" | "Table" => Ok(ConsoleApiCalledType::Table),
                    "trace" | "Trace" => Ok(ConsoleApiCalledType::Trace),
                    "clear" | "Clear" => Ok(ConsoleApiCalledType::Clear),
                    "startGroup" | "StartGroup" | "startgroup" => {
                        Ok(ConsoleApiCalledType::StartGroup)
                    }
                    "startGroupCollapsed" | "StartGroupCollapsed" | "startgroupcollapsed" => {
                        Ok(ConsoleApiCalledType::StartGroupCollapsed)
                    }
                    "endGroup" | "EndGroup" | "endgroup" => Ok(ConsoleApiCalledType::EndGroup),
                    "assert" | "Assert" => Ok(ConsoleApiCalledType::Assert),
                    "profile" | "Profile" => Ok(ConsoleApiCalledType::Profile),
                    "profileEnd" | "ProfileEnd" | "profileend" => {
                        Ok(ConsoleApiCalledType::ProfileEnd)
                    }
                    "count" | "Count" => Ok(ConsoleApiCalledType::Count),
                    "timeEnd" | "TimeEnd" | "timeend" => Ok(ConsoleApiCalledType::TimeEnd),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl EventConsoleApiCalled {
            pub const IDENTIFIER: &'static str = "Runtime.consoleAPICalled";
        }
        impl chromiumoxide_types::Method for EventConsoleApiCalled {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventConsoleApiCalled {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued when unhandled exception was revoked.\n[exceptionRevoked](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-exceptionRevoked)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventExceptionRevoked {
            #[doc = "Reason describing why exception was revoked."]
            #[serde(rename = "reason")]
            pub reason: String,
            #[doc = "The id of revoked exception, as reported in `exceptionThrown`."]
            #[serde(rename = "exceptionId")]
            pub exception_id: i64,
        }
        impl EventExceptionRevoked {
            pub const IDENTIFIER: &'static str = "Runtime.exceptionRevoked";
        }
        impl chromiumoxide_types::Method for EventExceptionRevoked {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventExceptionRevoked {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued when exception was thrown and unhandled.\n[exceptionThrown](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-exceptionThrown)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventExceptionThrown {
            #[doc = "Timestamp of the exception."]
            #[serde(rename = "timestamp")]
            pub timestamp: Timestamp,
            #[serde(rename = "exceptionDetails")]
            pub exception_details: ExceptionDetails,
        }
        impl EventExceptionThrown {
            pub const IDENTIFIER: &'static str = "Runtime.exceptionThrown";
        }
        impl chromiumoxide_types::Method for EventExceptionThrown {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventExceptionThrown {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued when new execution context is created.\n[executionContextCreated](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-executionContextCreated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventExecutionContextCreated {
            #[doc = "A newly created execution context."]
            #[serde(rename = "context")]
            pub context: ExecutionContextDescription,
        }
        impl EventExecutionContextCreated {
            pub const IDENTIFIER: &'static str = "Runtime.executionContextCreated";
        }
        impl chromiumoxide_types::Method for EventExecutionContextCreated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventExecutionContextCreated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued when execution context is destroyed.\n[executionContextDestroyed](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-executionContextDestroyed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventExecutionContextDestroyed {
            #[doc = "Id of the destroyed context"]
            #[serde(rename = "executionContextId")]
            pub execution_context_id: ExecutionContextId,
        }
        impl EventExecutionContextDestroyed {
            pub const IDENTIFIER: &'static str = "Runtime.executionContextDestroyed";
        }
        impl chromiumoxide_types::Method for EventExecutionContextDestroyed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventExecutionContextDestroyed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued when all executionContexts were cleared in browser\n[executionContextsCleared](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-executionContextsCleared)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventExecutionContextsCleared {}
        impl EventExecutionContextsCleared {
            pub const IDENTIFIER: &'static str = "Runtime.executionContextsCleared";
        }
        impl chromiumoxide_types::Method for EventExecutionContextsCleared {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventExecutionContextsCleared {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued when object should be inspected (for example, as a result of inspect() command line API\ncall).\n[inspectRequested](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-inspectRequested)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventInspectRequested {
            #[serde(rename = "object")]
            pub object: RemoteObject,
            #[serde(rename = "hints")]
            pub hints: serde_json::Value,
            #[doc = "Identifier of the context where the call was made."]
            #[serde(rename = "executionContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub execution_context_id: Option<ExecutionContextId>,
        }
        impl EventInspectRequested {
            pub const IDENTIFIER: &'static str = "Runtime.inspectRequested";
        }
        impl chromiumoxide_types::Method for EventInspectRequested {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventInspectRequested {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
}
#[allow(clippy::wrong_self_convention)]
pub mod browser_protocol {
    #[doc = r" The version of this protocol definition"]
    pub const VERSION: &str = "1.3";
    pub mod accessibility {
        use serde::{Deserialize, Serialize};
        #[doc = "Unique accessibility node identifier.\n[AXNodeId](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#type-AXNodeId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct AxNodeId(String);
        impl AxNodeId {
            pub fn new(val: impl Into<String>) -> Self {
                AxNodeId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for AxNodeId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<AxNodeId> for String {
            fn from(el: AxNodeId) -> String {
                el.0
            }
        }
        impl From<String> for AxNodeId {
            fn from(expr: String) -> Self {
                AxNodeId(expr)
            }
        }
        impl std::borrow::Borrow<str> for AxNodeId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl AxNodeId {
            pub const IDENTIFIER: &'static str = "Accessibility.AXNodeId";
        }
        #[doc = "Enum of possible property types."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AxValueType {
            #[serde(rename = "boolean")]
            Boolean,
            #[serde(rename = "tristate")]
            Tristate,
            #[serde(rename = "booleanOrUndefined")]
            BooleanOrUndefined,
            #[serde(rename = "idref")]
            Idref,
            #[serde(rename = "idrefList")]
            IdrefList,
            #[serde(rename = "integer")]
            Integer,
            #[serde(rename = "node")]
            Node,
            #[serde(rename = "nodeList")]
            NodeList,
            #[serde(rename = "number")]
            Number,
            #[serde(rename = "string")]
            String,
            #[serde(rename = "computedString")]
            ComputedString,
            #[serde(rename = "token")]
            Token,
            #[serde(rename = "tokenList")]
            TokenList,
            #[serde(rename = "domRelation")]
            DomRelation,
            #[serde(rename = "role")]
            Role,
            #[serde(rename = "internalRole")]
            InternalRole,
            #[serde(rename = "valueUndefined")]
            ValueUndefined,
        }
        impl AsRef<str> for AxValueType {
            fn as_ref(&self) -> &str {
                match self {
                    AxValueType::Boolean => "boolean",
                    AxValueType::Tristate => "tristate",
                    AxValueType::BooleanOrUndefined => "booleanOrUndefined",
                    AxValueType::Idref => "idref",
                    AxValueType::IdrefList => "idrefList",
                    AxValueType::Integer => "integer",
                    AxValueType::Node => "node",
                    AxValueType::NodeList => "nodeList",
                    AxValueType::Number => "number",
                    AxValueType::String => "string",
                    AxValueType::ComputedString => "computedString",
                    AxValueType::Token => "token",
                    AxValueType::TokenList => "tokenList",
                    AxValueType::DomRelation => "domRelation",
                    AxValueType::Role => "role",
                    AxValueType::InternalRole => "internalRole",
                    AxValueType::ValueUndefined => "valueUndefined",
                }
            }
        }
        impl ::std::str::FromStr for AxValueType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "boolean" | "Boolean" => Ok(AxValueType::Boolean),
                    "tristate" | "Tristate" => Ok(AxValueType::Tristate),
                    "booleanOrUndefined" | "BooleanOrUndefined" | "booleanorundefined" => {
                        Ok(AxValueType::BooleanOrUndefined)
                    }
                    "idref" | "Idref" => Ok(AxValueType::Idref),
                    "idrefList" | "IdrefList" | "idreflist" => Ok(AxValueType::IdrefList),
                    "integer" | "Integer" => Ok(AxValueType::Integer),
                    "node" | "Node" => Ok(AxValueType::Node),
                    "nodeList" | "NodeList" | "nodelist" => Ok(AxValueType::NodeList),
                    "number" | "Number" => Ok(AxValueType::Number),
                    "string" | "String" => Ok(AxValueType::String),
                    "computedString" | "ComputedString" | "computedstring" => {
                        Ok(AxValueType::ComputedString)
                    }
                    "token" | "Token" => Ok(AxValueType::Token),
                    "tokenList" | "TokenList" | "tokenlist" => Ok(AxValueType::TokenList),
                    "domRelation" | "DomRelation" | "domrelation" => Ok(AxValueType::DomRelation),
                    "role" | "Role" => Ok(AxValueType::Role),
                    "internalRole" | "InternalRole" | "internalrole" => {
                        Ok(AxValueType::InternalRole)
                    }
                    "valueUndefined" | "ValueUndefined" | "valueundefined" => {
                        Ok(AxValueType::ValueUndefined)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Enum of possible property sources."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AxValueSourceType {
            #[serde(rename = "attribute")]
            Attribute,
            #[serde(rename = "implicit")]
            Implicit,
            #[serde(rename = "style")]
            Style,
            #[serde(rename = "contents")]
            Contents,
            #[serde(rename = "placeholder")]
            Placeholder,
            #[serde(rename = "relatedElement")]
            RelatedElement,
        }
        impl AsRef<str> for AxValueSourceType {
            fn as_ref(&self) -> &str {
                match self {
                    AxValueSourceType::Attribute => "attribute",
                    AxValueSourceType::Implicit => "implicit",
                    AxValueSourceType::Style => "style",
                    AxValueSourceType::Contents => "contents",
                    AxValueSourceType::Placeholder => "placeholder",
                    AxValueSourceType::RelatedElement => "relatedElement",
                }
            }
        }
        impl ::std::str::FromStr for AxValueSourceType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "attribute" | "Attribute" => Ok(AxValueSourceType::Attribute),
                    "implicit" | "Implicit" => Ok(AxValueSourceType::Implicit),
                    "style" | "Style" => Ok(AxValueSourceType::Style),
                    "contents" | "Contents" => Ok(AxValueSourceType::Contents),
                    "placeholder" | "Placeholder" => Ok(AxValueSourceType::Placeholder),
                    "relatedElement" | "RelatedElement" | "relatedelement" => {
                        Ok(AxValueSourceType::RelatedElement)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Enum of possible native property sources (as a subtype of a particular AXValueSourceType)."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AxValueNativeSourceType {
            #[serde(rename = "description")]
            Description,
            #[serde(rename = "figcaption")]
            Figcaption,
            #[serde(rename = "label")]
            Label,
            #[serde(rename = "labelfor")]
            Labelfor,
            #[serde(rename = "labelwrapped")]
            Labelwrapped,
            #[serde(rename = "legend")]
            Legend,
            #[serde(rename = "rubyannotation")]
            Rubyannotation,
            #[serde(rename = "tablecaption")]
            Tablecaption,
            #[serde(rename = "title")]
            Title,
            #[serde(rename = "other")]
            Other,
        }
        impl AsRef<str> for AxValueNativeSourceType {
            fn as_ref(&self) -> &str {
                match self {
                    AxValueNativeSourceType::Description => "description",
                    AxValueNativeSourceType::Figcaption => "figcaption",
                    AxValueNativeSourceType::Label => "label",
                    AxValueNativeSourceType::Labelfor => "labelfor",
                    AxValueNativeSourceType::Labelwrapped => "labelwrapped",
                    AxValueNativeSourceType::Legend => "legend",
                    AxValueNativeSourceType::Rubyannotation => "rubyannotation",
                    AxValueNativeSourceType::Tablecaption => "tablecaption",
                    AxValueNativeSourceType::Title => "title",
                    AxValueNativeSourceType::Other => "other",
                }
            }
        }
        impl ::std::str::FromStr for AxValueNativeSourceType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "description" | "Description" => Ok(AxValueNativeSourceType::Description),
                    "figcaption" | "Figcaption" => Ok(AxValueNativeSourceType::Figcaption),
                    "label" | "Label" => Ok(AxValueNativeSourceType::Label),
                    "labelfor" | "Labelfor" => Ok(AxValueNativeSourceType::Labelfor),
                    "labelwrapped" | "Labelwrapped" => Ok(AxValueNativeSourceType::Labelwrapped),
                    "legend" | "Legend" => Ok(AxValueNativeSourceType::Legend),
                    "rubyannotation" | "Rubyannotation" => {
                        Ok(AxValueNativeSourceType::Rubyannotation)
                    }
                    "tablecaption" | "Tablecaption" => Ok(AxValueNativeSourceType::Tablecaption),
                    "title" | "Title" => Ok(AxValueNativeSourceType::Title),
                    "other" | "Other" => Ok(AxValueNativeSourceType::Other),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "A single source for a computed AX property.\n[AXValueSource](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#type-AXValueSource)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AxValueSource {
            #[doc = "What type of source this is."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: AxValueSourceType,
            #[doc = "The value of this property source."]
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value: Option<AxValue>,
            #[doc = "The name of the relevant attribute, if any."]
            #[serde(rename = "attribute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub attribute: Option<String>,
            #[doc = "The value of the relevant attribute, if any."]
            #[serde(rename = "attributeValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub attribute_value: Option<AxValue>,
            #[doc = "Whether this source is superseded by a higher priority source."]
            #[serde(rename = "superseded")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub superseded: Option<bool>,
            #[doc = "The native markup source for this value, e.g. a <label> element."]
            #[serde(rename = "nativeSource")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub native_source: Option<AxValueNativeSourceType>,
            #[doc = "The value, such as a node or node list, of the native source."]
            #[serde(rename = "nativeSourceValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub native_source_value: Option<AxValue>,
            #[doc = "Whether the value for this property is invalid."]
            #[serde(rename = "invalid")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub invalid: Option<bool>,
            #[doc = "Reason for the value being invalid, if it is."]
            #[serde(rename = "invalidReason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub invalid_reason: Option<String>,
        }
        impl AxValueSource {
            pub fn new(r#type: impl Into<AxValueSourceType>) -> Self {
                Self {
                    r#type: r#type.into(),
                    value: None,
                    attribute: None,
                    attribute_value: None,
                    superseded: None,
                    native_source: None,
                    native_source_value: None,
                    invalid: None,
                    invalid_reason: None,
                }
            }
        }
        impl AxValueSource {
            pub fn builder() -> AxValueSourceBuilder {
                AxValueSourceBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AxValueSourceBuilder {
            r#type: Option<AxValueSourceType>,
            value: Option<AxValue>,
            attribute: Option<String>,
            attribute_value: Option<AxValue>,
            superseded: Option<bool>,
            native_source: Option<AxValueNativeSourceType>,
            native_source_value: Option<AxValue>,
            invalid: Option<bool>,
            invalid_reason: Option<String>,
        }
        impl AxValueSourceBuilder {
            pub fn r#type(mut self, r#type: impl Into<AxValueSourceType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn value(mut self, value: impl Into<AxValue>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn attribute(mut self, attribute: impl Into<String>) -> Self {
                self.attribute = Some(attribute.into());
                self
            }
            pub fn attribute_value(mut self, attribute_value: impl Into<AxValue>) -> Self {
                self.attribute_value = Some(attribute_value.into());
                self
            }
            pub fn superseded(mut self, superseded: impl Into<bool>) -> Self {
                self.superseded = Some(superseded.into());
                self
            }
            pub fn native_source(
                mut self,
                native_source: impl Into<AxValueNativeSourceType>,
            ) -> Self {
                self.native_source = Some(native_source.into());
                self
            }
            pub fn native_source_value(mut self, native_source_value: impl Into<AxValue>) -> Self {
                self.native_source_value = Some(native_source_value.into());
                self
            }
            pub fn invalid(mut self, invalid: impl Into<bool>) -> Self {
                self.invalid = Some(invalid.into());
                self
            }
            pub fn invalid_reason(mut self, invalid_reason: impl Into<String>) -> Self {
                self.invalid_reason = Some(invalid_reason.into());
                self
            }
            pub fn build(self) -> Result<AxValueSource, String> {
                Ok(AxValueSource {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    value: self.value,
                    attribute: self.attribute,
                    attribute_value: self.attribute_value,
                    superseded: self.superseded,
                    native_source: self.native_source,
                    native_source_value: self.native_source_value,
                    invalid: self.invalid,
                    invalid_reason: self.invalid_reason,
                })
            }
        }
        impl AxValueSource {
            pub const IDENTIFIER: &'static str = "Accessibility.AXValueSource";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AxRelatedNode {
            #[doc = "The BackendNodeId of the related DOM node."]
            #[serde(rename = "backendDOMNodeId")]
            pub backend_dom_node_id: super::dom::BackendNodeId,
            #[doc = "The IDRef value provided, if any."]
            #[serde(rename = "idref")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub idref: Option<String>,
            #[doc = "The text alternative of this node in the current context."]
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub text: Option<String>,
        }
        impl AxRelatedNode {
            pub fn new(backend_dom_node_id: impl Into<super::dom::BackendNodeId>) -> Self {
                Self {
                    backend_dom_node_id: backend_dom_node_id.into(),
                    idref: None,
                    text: None,
                }
            }
        }
        impl AxRelatedNode {
            pub fn builder() -> AxRelatedNodeBuilder {
                AxRelatedNodeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AxRelatedNodeBuilder {
            backend_dom_node_id: Option<super::dom::BackendNodeId>,
            idref: Option<String>,
            text: Option<String>,
        }
        impl AxRelatedNodeBuilder {
            pub fn backend_dom_node_id(
                mut self,
                backend_dom_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.backend_dom_node_id = Some(backend_dom_node_id.into());
                self
            }
            pub fn idref(mut self, idref: impl Into<String>) -> Self {
                self.idref = Some(idref.into());
                self
            }
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn build(self) -> Result<AxRelatedNode, String> {
                Ok(AxRelatedNode {
                    backend_dom_node_id: self.backend_dom_node_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(backend_dom_node_id)
                        )
                    })?,
                    idref: self.idref,
                    text: self.text,
                })
            }
        }
        impl AxRelatedNode {
            pub const IDENTIFIER: &'static str = "Accessibility.AXRelatedNode";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AxProperty {
            #[doc = "The name of this property."]
            #[serde(rename = "name")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub name: AxPropertyName,
            #[doc = "The value of this property."]
            #[serde(rename = "value")]
            pub value: AxValue,
        }
        impl AxProperty {
            pub fn new(name: impl Into<AxPropertyName>, value: impl Into<AxValue>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                }
            }
        }
        impl AxProperty {
            pub fn builder() -> AxPropertyBuilder {
                AxPropertyBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AxPropertyBuilder {
            name: Option<AxPropertyName>,
            value: Option<AxValue>,
        }
        impl AxPropertyBuilder {
            pub fn name(mut self, name: impl Into<AxPropertyName>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<AxValue>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<AxProperty, String> {
                Ok(AxProperty {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl AxProperty {
            pub const IDENTIFIER: &'static str = "Accessibility.AXProperty";
        }
        #[doc = "A single computed AX property.\n[AXValue](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#type-AXValue)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AxValue {
            #[doc = "The type of this value."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: AxValueType,
            #[doc = "The computed value of this property."]
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value: Option<serde_json::Value>,
            #[doc = "One or more related nodes, if applicable."]
            #[serde(rename = "relatedNodes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub related_nodes: Option<Vec<AxRelatedNode>>,
            #[doc = "The sources which contributed to the computation of this property."]
            #[serde(rename = "sources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub sources: Option<Vec<AxValueSource>>,
        }
        impl AxValue {
            pub fn new(r#type: impl Into<AxValueType>) -> Self {
                Self {
                    r#type: r#type.into(),
                    value: None,
                    related_nodes: None,
                    sources: None,
                }
            }
        }
        impl AxValue {
            pub fn builder() -> AxValueBuilder {
                AxValueBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AxValueBuilder {
            r#type: Option<AxValueType>,
            value: Option<serde_json::Value>,
            related_nodes: Option<Vec<AxRelatedNode>>,
            sources: Option<Vec<AxValueSource>>,
        }
        impl AxValueBuilder {
            pub fn r#type(mut self, r#type: impl Into<AxValueType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn value(mut self, value: impl Into<serde_json::Value>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn related_node(mut self, related_node: impl Into<AxRelatedNode>) -> Self {
                let v = self.related_nodes.get_or_insert(Vec::new());
                v.push(related_node.into());
                self
            }
            pub fn related_nodes<I, S>(mut self, related_nodes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<AxRelatedNode>,
            {
                let v = self.related_nodes.get_or_insert(Vec::new());
                for val in related_nodes {
                    v.push(val.into());
                }
                self
            }
            pub fn source(mut self, source: impl Into<AxValueSource>) -> Self {
                let v = self.sources.get_or_insert(Vec::new());
                v.push(source.into());
                self
            }
            pub fn sources<I, S>(mut self, sources: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<AxValueSource>,
            {
                let v = self.sources.get_or_insert(Vec::new());
                for val in sources {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<AxValue, String> {
                Ok(AxValue {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    value: self.value,
                    related_nodes: self.related_nodes,
                    sources: self.sources,
                })
            }
        }
        impl AxValue {
            pub const IDENTIFIER: &'static str = "Accessibility.AXValue";
        }
        #[doc = "Values of AXProperty name:\n- from 'busy' to 'roledescription': states which apply to every AX node\n- from 'live' to 'root': attributes which apply to nodes in live regions\n- from 'autocomplete' to 'valuetext': attributes which apply to widgets\n- from 'checked' to 'selected': states which apply to widgets\n- from 'activedescendant' to 'owns' - relationships between elements other than parent/child/sibling."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AxPropertyName {
            #[serde(rename = "busy")]
            Busy,
            #[serde(rename = "disabled")]
            Disabled,
            #[serde(rename = "editable")]
            Editable,
            #[serde(rename = "focusable")]
            Focusable,
            #[serde(rename = "focused")]
            Focused,
            #[serde(rename = "hidden")]
            Hidden,
            #[serde(rename = "hiddenRoot")]
            HiddenRoot,
            #[serde(rename = "invalid")]
            Invalid,
            #[serde(rename = "keyshortcuts")]
            Keyshortcuts,
            #[serde(rename = "settable")]
            Settable,
            #[serde(rename = "roledescription")]
            Roledescription,
            #[serde(rename = "live")]
            Live,
            #[serde(rename = "atomic")]
            Atomic,
            #[serde(rename = "relevant")]
            Relevant,
            #[serde(rename = "root")]
            Root,
            #[serde(rename = "autocomplete")]
            Autocomplete,
            #[serde(rename = "hasPopup")]
            HasPopup,
            #[serde(rename = "level")]
            Level,
            #[serde(rename = "multiselectable")]
            Multiselectable,
            #[serde(rename = "orientation")]
            Orientation,
            #[serde(rename = "multiline")]
            Multiline,
            #[serde(rename = "readonly")]
            Readonly,
            #[serde(rename = "required")]
            Required,
            #[serde(rename = "valuemin")]
            Valuemin,
            #[serde(rename = "valuemax")]
            Valuemax,
            #[serde(rename = "valuetext")]
            Valuetext,
            #[serde(rename = "checked")]
            Checked,
            #[serde(rename = "expanded")]
            Expanded,
            #[serde(rename = "modal")]
            Modal,
            #[serde(rename = "pressed")]
            Pressed,
            #[serde(rename = "selected")]
            Selected,
            #[serde(rename = "activedescendant")]
            Activedescendant,
            #[serde(rename = "controls")]
            Controls,
            #[serde(rename = "describedby")]
            Describedby,
            #[serde(rename = "details")]
            Details,
            #[serde(rename = "errormessage")]
            Errormessage,
            #[serde(rename = "flowto")]
            Flowto,
            #[serde(rename = "labelledby")]
            Labelledby,
            #[serde(rename = "owns")]
            Owns,
        }
        impl AsRef<str> for AxPropertyName {
            fn as_ref(&self) -> &str {
                match self {
                    AxPropertyName::Busy => "busy",
                    AxPropertyName::Disabled => "disabled",
                    AxPropertyName::Editable => "editable",
                    AxPropertyName::Focusable => "focusable",
                    AxPropertyName::Focused => "focused",
                    AxPropertyName::Hidden => "hidden",
                    AxPropertyName::HiddenRoot => "hiddenRoot",
                    AxPropertyName::Invalid => "invalid",
                    AxPropertyName::Keyshortcuts => "keyshortcuts",
                    AxPropertyName::Settable => "settable",
                    AxPropertyName::Roledescription => "roledescription",
                    AxPropertyName::Live => "live",
                    AxPropertyName::Atomic => "atomic",
                    AxPropertyName::Relevant => "relevant",
                    AxPropertyName::Root => "root",
                    AxPropertyName::Autocomplete => "autocomplete",
                    AxPropertyName::HasPopup => "hasPopup",
                    AxPropertyName::Level => "level",
                    AxPropertyName::Multiselectable => "multiselectable",
                    AxPropertyName::Orientation => "orientation",
                    AxPropertyName::Multiline => "multiline",
                    AxPropertyName::Readonly => "readonly",
                    AxPropertyName::Required => "required",
                    AxPropertyName::Valuemin => "valuemin",
                    AxPropertyName::Valuemax => "valuemax",
                    AxPropertyName::Valuetext => "valuetext",
                    AxPropertyName::Checked => "checked",
                    AxPropertyName::Expanded => "expanded",
                    AxPropertyName::Modal => "modal",
                    AxPropertyName::Pressed => "pressed",
                    AxPropertyName::Selected => "selected",
                    AxPropertyName::Activedescendant => "activedescendant",
                    AxPropertyName::Controls => "controls",
                    AxPropertyName::Describedby => "describedby",
                    AxPropertyName::Details => "details",
                    AxPropertyName::Errormessage => "errormessage",
                    AxPropertyName::Flowto => "flowto",
                    AxPropertyName::Labelledby => "labelledby",
                    AxPropertyName::Owns => "owns",
                }
            }
        }
        impl ::std::str::FromStr for AxPropertyName {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "busy" | "Busy" => Ok(AxPropertyName::Busy),
                    "disabled" | "Disabled" => Ok(AxPropertyName::Disabled),
                    "editable" | "Editable" => Ok(AxPropertyName::Editable),
                    "focusable" | "Focusable" => Ok(AxPropertyName::Focusable),
                    "focused" | "Focused" => Ok(AxPropertyName::Focused),
                    "hidden" | "Hidden" => Ok(AxPropertyName::Hidden),
                    "hiddenRoot" | "HiddenRoot" | "hiddenroot" => Ok(AxPropertyName::HiddenRoot),
                    "invalid" | "Invalid" => Ok(AxPropertyName::Invalid),
                    "keyshortcuts" | "Keyshortcuts" => Ok(AxPropertyName::Keyshortcuts),
                    "settable" | "Settable" => Ok(AxPropertyName::Settable),
                    "roledescription" | "Roledescription" => Ok(AxPropertyName::Roledescription),
                    "live" | "Live" => Ok(AxPropertyName::Live),
                    "atomic" | "Atomic" => Ok(AxPropertyName::Atomic),
                    "relevant" | "Relevant" => Ok(AxPropertyName::Relevant),
                    "root" | "Root" => Ok(AxPropertyName::Root),
                    "autocomplete" | "Autocomplete" => Ok(AxPropertyName::Autocomplete),
                    "hasPopup" | "HasPopup" | "haspopup" => Ok(AxPropertyName::HasPopup),
                    "level" | "Level" => Ok(AxPropertyName::Level),
                    "multiselectable" | "Multiselectable" => Ok(AxPropertyName::Multiselectable),
                    "orientation" | "Orientation" => Ok(AxPropertyName::Orientation),
                    "multiline" | "Multiline" => Ok(AxPropertyName::Multiline),
                    "readonly" | "Readonly" => Ok(AxPropertyName::Readonly),
                    "required" | "Required" => Ok(AxPropertyName::Required),
                    "valuemin" | "Valuemin" => Ok(AxPropertyName::Valuemin),
                    "valuemax" | "Valuemax" => Ok(AxPropertyName::Valuemax),
                    "valuetext" | "Valuetext" => Ok(AxPropertyName::Valuetext),
                    "checked" | "Checked" => Ok(AxPropertyName::Checked),
                    "expanded" | "Expanded" => Ok(AxPropertyName::Expanded),
                    "modal" | "Modal" => Ok(AxPropertyName::Modal),
                    "pressed" | "Pressed" => Ok(AxPropertyName::Pressed),
                    "selected" | "Selected" => Ok(AxPropertyName::Selected),
                    "activedescendant" | "Activedescendant" => Ok(AxPropertyName::Activedescendant),
                    "controls" | "Controls" => Ok(AxPropertyName::Controls),
                    "describedby" | "Describedby" => Ok(AxPropertyName::Describedby),
                    "details" | "Details" => Ok(AxPropertyName::Details),
                    "errormessage" | "Errormessage" => Ok(AxPropertyName::Errormessage),
                    "flowto" | "Flowto" => Ok(AxPropertyName::Flowto),
                    "labelledby" | "Labelledby" => Ok(AxPropertyName::Labelledby),
                    "owns" | "Owns" => Ok(AxPropertyName::Owns),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "A node in the accessibility tree.\n[AXNode](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#type-AXNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AxNode {
            #[doc = "Unique identifier for this node."]
            #[serde(rename = "nodeId")]
            pub node_id: AxNodeId,
            #[doc = "Whether this node is ignored for accessibility"]
            #[serde(rename = "ignored")]
            pub ignored: bool,
            #[doc = "Collection of reasons why this node is hidden."]
            #[serde(rename = "ignoredReasons")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub ignored_reasons: Option<Vec<AxProperty>>,
            #[doc = "This `Node`'s role, whether explicit or implicit."]
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub role: Option<AxValue>,
            #[doc = "This `Node`'s Chrome raw role."]
            #[serde(rename = "chromeRole")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub chrome_role: Option<AxValue>,
            #[doc = "The accessible name for this `Node`."]
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub name: Option<AxValue>,
            #[doc = "The accessible description for this `Node`."]
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub description: Option<AxValue>,
            #[doc = "The value for this `Node`."]
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value: Option<AxValue>,
            #[doc = "All other properties"]
            #[serde(rename = "properties")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub properties: Option<Vec<AxProperty>>,
            #[doc = "ID for this node's parent."]
            #[serde(rename = "parentId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub parent_id: Option<AxNodeId>,
            #[doc = "IDs for each of this node's child nodes."]
            #[serde(rename = "childIds")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub child_ids: Option<Vec<AxNodeId>>,
            #[doc = "The backend ID for the associated DOM node, if any."]
            #[serde(rename = "backendDOMNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_dom_node_id: Option<super::dom::BackendNodeId>,
            #[doc = "The frame ID for the frame associated with this nodes document."]
            #[serde(rename = "frameId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_id: Option<super::page::FrameId>,
        }
        impl AxNode {
            pub fn new(node_id: impl Into<AxNodeId>, ignored: impl Into<bool>) -> Self {
                Self {
                    node_id: node_id.into(),
                    ignored: ignored.into(),
                    ignored_reasons: None,
                    role: None,
                    chrome_role: None,
                    name: None,
                    description: None,
                    value: None,
                    properties: None,
                    parent_id: None,
                    child_ids: None,
                    backend_dom_node_id: None,
                    frame_id: None,
                }
            }
        }
        impl AxNode {
            pub fn builder() -> AxNodeBuilder {
                AxNodeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AxNodeBuilder {
            node_id: Option<AxNodeId>,
            ignored: Option<bool>,
            ignored_reasons: Option<Vec<AxProperty>>,
            role: Option<AxValue>,
            chrome_role: Option<AxValue>,
            name: Option<AxValue>,
            description: Option<AxValue>,
            value: Option<AxValue>,
            properties: Option<Vec<AxProperty>>,
            parent_id: Option<AxNodeId>,
            child_ids: Option<Vec<AxNodeId>>,
            backend_dom_node_id: Option<super::dom::BackendNodeId>,
            frame_id: Option<super::page::FrameId>,
        }
        impl AxNodeBuilder {
            pub fn node_id(mut self, node_id: impl Into<AxNodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn ignored(mut self, ignored: impl Into<bool>) -> Self {
                self.ignored = Some(ignored.into());
                self
            }
            pub fn ignored_reason(mut self, ignored_reason: impl Into<AxProperty>) -> Self {
                let v = self.ignored_reasons.get_or_insert(Vec::new());
                v.push(ignored_reason.into());
                self
            }
            pub fn ignored_reasons<I, S>(mut self, ignored_reasons: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<AxProperty>,
            {
                let v = self.ignored_reasons.get_or_insert(Vec::new());
                for val in ignored_reasons {
                    v.push(val.into());
                }
                self
            }
            pub fn role(mut self, role: impl Into<AxValue>) -> Self {
                self.role = Some(role.into());
                self
            }
            pub fn chrome_role(mut self, chrome_role: impl Into<AxValue>) -> Self {
                self.chrome_role = Some(chrome_role.into());
                self
            }
            pub fn name(mut self, name: impl Into<AxValue>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn description(mut self, description: impl Into<AxValue>) -> Self {
                self.description = Some(description.into());
                self
            }
            pub fn value(mut self, value: impl Into<AxValue>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn propertie(mut self, propertie: impl Into<AxProperty>) -> Self {
                let v = self.properties.get_or_insert(Vec::new());
                v.push(propertie.into());
                self
            }
            pub fn properties<I, S>(mut self, properties: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<AxProperty>,
            {
                let v = self.properties.get_or_insert(Vec::new());
                for val in properties {
                    v.push(val.into());
                }
                self
            }
            pub fn parent_id(mut self, parent_id: impl Into<AxNodeId>) -> Self {
                self.parent_id = Some(parent_id.into());
                self
            }
            pub fn child_id(mut self, child_id: impl Into<AxNodeId>) -> Self {
                let v = self.child_ids.get_or_insert(Vec::new());
                v.push(child_id.into());
                self
            }
            pub fn child_ids<I, S>(mut self, child_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<AxNodeId>,
            {
                let v = self.child_ids.get_or_insert(Vec::new());
                for val in child_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn backend_dom_node_id(
                mut self,
                backend_dom_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.backend_dom_node_id = Some(backend_dom_node_id.into());
                self
            }
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn build(self) -> Result<AxNode, String> {
                Ok(AxNode {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    ignored: self.ignored.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(ignored))
                    })?,
                    ignored_reasons: self.ignored_reasons,
                    role: self.role,
                    chrome_role: self.chrome_role,
                    name: self.name,
                    description: self.description,
                    value: self.value,
                    properties: self.properties,
                    parent_id: self.parent_id,
                    child_ids: self.child_ids,
                    backend_dom_node_id: self.backend_dom_node_id,
                    frame_id: self.frame_id,
                })
            }
        }
        impl AxNode {
            pub const IDENTIFIER: &'static str = "Accessibility.AXNode";
        }
        #[doc = "Disables the accessibility domain.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Accessibility.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables the accessibility domain.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.\nThis turns on accessibility for the page, which can impact performance until accessibility is disabled.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Accessibility.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.\nThis turns on accessibility for the page, which can impact performance until accessibility is disabled.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.\n[getPartialAXTree](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getPartialAXTree)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetPartialAxTreeParams {
            #[doc = "Identifier of the node to get the partial accessibility tree for."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<super::dom::NodeId>,
            #[doc = "Identifier of the backend node to get the partial accessibility tree for."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<super::dom::BackendNodeId>,
            #[doc = "JavaScript object id of the node wrapper to get the partial accessibility tree for."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
            #[doc = "Whether to fetch this nodes ancestors, siblings and children. Defaults to true."]
            #[serde(rename = "fetchRelatives")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub fetch_relatives: Option<bool>,
        }
        impl GetPartialAxTreeParams {
            pub fn builder() -> GetPartialAxTreeParamsBuilder {
                GetPartialAxTreeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetPartialAxTreeParamsBuilder {
            node_id: Option<super::dom::NodeId>,
            backend_node_id: Option<super::dom::BackendNodeId>,
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
            fetch_relatives: Option<bool>,
        }
        impl GetPartialAxTreeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn backend_node_id(
                mut self,
                backend_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn fetch_relatives(mut self, fetch_relatives: impl Into<bool>) -> Self {
                self.fetch_relatives = Some(fetch_relatives.into());
                self
            }
            pub fn build(self) -> GetPartialAxTreeParams {
                GetPartialAxTreeParams {
                    node_id: self.node_id,
                    backend_node_id: self.backend_node_id,
                    object_id: self.object_id,
                    fetch_relatives: self.fetch_relatives,
                }
            }
        }
        impl GetPartialAxTreeParams {
            pub const IDENTIFIER: &'static str = "Accessibility.getPartialAXTree";
        }
        impl chromiumoxide_types::Method for GetPartialAxTreeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetPartialAxTreeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.\n[getPartialAXTree](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getPartialAXTree)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetPartialAxTreeReturns {
            #[doc = "The `Accessibility.AXNode` for this DOM node, if it exists, plus its ancestors, siblings and\nchildren, if requested."]
            #[serde(rename = "nodes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub nodes: Vec<AxNode>,
        }
        impl GetPartialAxTreeReturns {
            pub fn new(nodes: Vec<AxNode>) -> Self {
                Self { nodes }
            }
        }
        impl GetPartialAxTreeReturns {
            pub fn builder() -> GetPartialAxTreeReturnsBuilder {
                GetPartialAxTreeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetPartialAxTreeReturnsBuilder {
            nodes: Option<Vec<AxNode>>,
        }
        impl GetPartialAxTreeReturnsBuilder {
            pub fn node(mut self, node: impl Into<AxNode>) -> Self {
                let v = self.nodes.get_or_insert(Vec::new());
                v.push(node.into());
                self
            }
            pub fn nodes<I, S>(mut self, nodes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<AxNode>,
            {
                let v = self.nodes.get_or_insert(Vec::new());
                for val in nodes {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetPartialAxTreeReturns, String> {
                Ok(GetPartialAxTreeReturns {
                    nodes: self.nodes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(nodes))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetPartialAxTreeParams {
            type Response = GetPartialAxTreeReturns;
        }
        #[doc = "Fetches the entire accessibility tree for the root Document\n[getFullAXTree](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getFullAXTree)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetFullAxTreeParams {
            #[doc = "The maximum depth at which descendants of the root node should be retrieved.\nIf omitted, the full tree is returned."]
            #[serde(rename = "depth")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub depth: Option<i64>,
            #[doc = "The frame for whose document the AX tree should be retrieved.\nIf omited, the root frame is used."]
            #[serde(rename = "frameId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_id: Option<super::page::FrameId>,
        }
        impl GetFullAxTreeParams {
            pub fn builder() -> GetFullAxTreeParamsBuilder {
                GetFullAxTreeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetFullAxTreeParamsBuilder {
            depth: Option<i64>,
            frame_id: Option<super::page::FrameId>,
        }
        impl GetFullAxTreeParamsBuilder {
            pub fn depth(mut self, depth: impl Into<i64>) -> Self {
                self.depth = Some(depth.into());
                self
            }
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn build(self) -> GetFullAxTreeParams {
                GetFullAxTreeParams {
                    depth: self.depth,
                    frame_id: self.frame_id,
                }
            }
        }
        impl GetFullAxTreeParams {
            pub const IDENTIFIER: &'static str = "Accessibility.getFullAXTree";
        }
        impl chromiumoxide_types::Method for GetFullAxTreeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetFullAxTreeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fetches the entire accessibility tree for the root Document\n[getFullAXTree](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getFullAXTree)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetFullAxTreeReturns {
            #[serde(rename = "nodes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub nodes: Vec<AxNode>,
        }
        impl GetFullAxTreeReturns {
            pub fn new(nodes: Vec<AxNode>) -> Self {
                Self { nodes }
            }
        }
        impl GetFullAxTreeReturns {
            pub fn builder() -> GetFullAxTreeReturnsBuilder {
                GetFullAxTreeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetFullAxTreeReturnsBuilder {
            nodes: Option<Vec<AxNode>>,
        }
        impl GetFullAxTreeReturnsBuilder {
            pub fn node(mut self, node: impl Into<AxNode>) -> Self {
                let v = self.nodes.get_or_insert(Vec::new());
                v.push(node.into());
                self
            }
            pub fn nodes<I, S>(mut self, nodes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<AxNode>,
            {
                let v = self.nodes.get_or_insert(Vec::new());
                for val in nodes {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetFullAxTreeReturns, String> {
                Ok(GetFullAxTreeReturns {
                    nodes: self.nodes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(nodes))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetFullAxTreeParams {
            type Response = GetFullAxTreeReturns;
        }
        #[doc = "Fetches the root node.\nRequires `enable()` to have been called previously.\n[getRootAXNode](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getRootAXNode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetRootAxNodeParams {
            #[doc = "The frame in whose document the node resides.\nIf omitted, the root frame is used."]
            #[serde(rename = "frameId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_id: Option<super::page::FrameId>,
        }
        impl GetRootAxNodeParams {
            pub fn builder() -> GetRootAxNodeParamsBuilder {
                GetRootAxNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetRootAxNodeParamsBuilder {
            frame_id: Option<super::page::FrameId>,
        }
        impl GetRootAxNodeParamsBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn build(self) -> GetRootAxNodeParams {
                GetRootAxNodeParams {
                    frame_id: self.frame_id,
                }
            }
        }
        impl GetRootAxNodeParams {
            pub const IDENTIFIER: &'static str = "Accessibility.getRootAXNode";
        }
        impl chromiumoxide_types::Method for GetRootAxNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetRootAxNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fetches the root node.\nRequires `enable()` to have been called previously.\n[getRootAXNode](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getRootAXNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetRootAxNodeReturns {
            #[serde(rename = "node")]
            pub node: AxNode,
        }
        impl GetRootAxNodeReturns {
            pub fn new(node: impl Into<AxNode>) -> Self {
                Self { node: node.into() }
            }
        }
        impl GetRootAxNodeReturns {
            pub fn builder() -> GetRootAxNodeReturnsBuilder {
                GetRootAxNodeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetRootAxNodeReturnsBuilder {
            node: Option<AxNode>,
        }
        impl GetRootAxNodeReturnsBuilder {
            pub fn node(mut self, node: impl Into<AxNode>) -> Self {
                self.node = Some(node.into());
                self
            }
            pub fn build(self) -> Result<GetRootAxNodeReturns, String> {
                Ok(GetRootAxNodeReturns {
                    node: self.node.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetRootAxNodeParams {
            type Response = GetRootAxNodeReturns;
        }
        #[doc = "Fetches a node and all ancestors up to and including the root.\nRequires `enable()` to have been called previously.\n[getAXNodeAndAncestors](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getAXNodeAndAncestors)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetAxNodeAndAncestorsParams {
            #[doc = "Identifier of the node to get."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<super::dom::NodeId>,
            #[doc = "Identifier of the backend node to get."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<super::dom::BackendNodeId>,
            #[doc = "JavaScript object id of the node wrapper to get."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl GetAxNodeAndAncestorsParams {
            pub fn builder() -> GetAxNodeAndAncestorsParamsBuilder {
                GetAxNodeAndAncestorsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetAxNodeAndAncestorsParamsBuilder {
            node_id: Option<super::dom::NodeId>,
            backend_node_id: Option<super::dom::BackendNodeId>,
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl GetAxNodeAndAncestorsParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn backend_node_id(
                mut self,
                backend_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> GetAxNodeAndAncestorsParams {
                GetAxNodeAndAncestorsParams {
                    node_id: self.node_id,
                    backend_node_id: self.backend_node_id,
                    object_id: self.object_id,
                }
            }
        }
        impl GetAxNodeAndAncestorsParams {
            pub const IDENTIFIER: &'static str = "Accessibility.getAXNodeAndAncestors";
        }
        impl chromiumoxide_types::Method for GetAxNodeAndAncestorsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetAxNodeAndAncestorsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fetches a node and all ancestors up to and including the root.\nRequires `enable()` to have been called previously.\n[getAXNodeAndAncestors](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getAXNodeAndAncestors)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetAxNodeAndAncestorsReturns {
            #[serde(rename = "nodes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub nodes: Vec<AxNode>,
        }
        impl GetAxNodeAndAncestorsReturns {
            pub fn new(nodes: Vec<AxNode>) -> Self {
                Self { nodes }
            }
        }
        impl GetAxNodeAndAncestorsReturns {
            pub fn builder() -> GetAxNodeAndAncestorsReturnsBuilder {
                GetAxNodeAndAncestorsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetAxNodeAndAncestorsReturnsBuilder {
            nodes: Option<Vec<AxNode>>,
        }
        impl GetAxNodeAndAncestorsReturnsBuilder {
            pub fn node(mut self, node: impl Into<AxNode>) -> Self {
                let v = self.nodes.get_or_insert(Vec::new());
                v.push(node.into());
                self
            }
            pub fn nodes<I, S>(mut self, nodes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<AxNode>,
            {
                let v = self.nodes.get_or_insert(Vec::new());
                for val in nodes {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetAxNodeAndAncestorsReturns, String> {
                Ok(GetAxNodeAndAncestorsReturns {
                    nodes: self.nodes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(nodes))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetAxNodeAndAncestorsParams {
            type Response = GetAxNodeAndAncestorsReturns;
        }
        #[doc = "Fetches a particular accessibility node by AXNodeId.\nRequires `enable()` to have been called previously.\n[getChildAXNodes](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getChildAXNodes)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetChildAxNodesParams {
            #[serde(rename = "id")]
            pub id: AxNodeId,
            #[doc = "The frame in whose document the node resides.\nIf omitted, the root frame is used."]
            #[serde(rename = "frameId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_id: Option<super::page::FrameId>,
        }
        impl GetChildAxNodesParams {
            pub fn new(id: impl Into<AxNodeId>) -> Self {
                Self {
                    id: id.into(),
                    frame_id: None,
                }
            }
        }
        impl GetChildAxNodesParams {
            pub fn builder() -> GetChildAxNodesParamsBuilder {
                GetChildAxNodesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetChildAxNodesParamsBuilder {
            id: Option<AxNodeId>,
            frame_id: Option<super::page::FrameId>,
        }
        impl GetChildAxNodesParamsBuilder {
            pub fn id(mut self, id: impl Into<AxNodeId>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn build(self) -> Result<GetChildAxNodesParams, String> {
                Ok(GetChildAxNodesParams {
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                    frame_id: self.frame_id,
                })
            }
        }
        impl GetChildAxNodesParams {
            pub const IDENTIFIER: &'static str = "Accessibility.getChildAXNodes";
        }
        impl chromiumoxide_types::Method for GetChildAxNodesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetChildAxNodesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fetches a particular accessibility node by AXNodeId.\nRequires `enable()` to have been called previously.\n[getChildAXNodes](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getChildAXNodes)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetChildAxNodesReturns {
            #[serde(rename = "nodes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub nodes: Vec<AxNode>,
        }
        impl GetChildAxNodesReturns {
            pub fn new(nodes: Vec<AxNode>) -> Self {
                Self { nodes }
            }
        }
        impl GetChildAxNodesReturns {
            pub fn builder() -> GetChildAxNodesReturnsBuilder {
                GetChildAxNodesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetChildAxNodesReturnsBuilder {
            nodes: Option<Vec<AxNode>>,
        }
        impl GetChildAxNodesReturnsBuilder {
            pub fn node(mut self, node: impl Into<AxNode>) -> Self {
                let v = self.nodes.get_or_insert(Vec::new());
                v.push(node.into());
                self
            }
            pub fn nodes<I, S>(mut self, nodes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<AxNode>,
            {
                let v = self.nodes.get_or_insert(Vec::new());
                for val in nodes {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetChildAxNodesReturns, String> {
                Ok(GetChildAxNodesReturns {
                    nodes: self.nodes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(nodes))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetChildAxNodesParams {
            type Response = GetChildAxNodesReturns;
        }
        #[doc = "Query a DOM node's accessibility subtree for accessible name and role.\nThis command computes the name and role for all nodes in the subtree, including those that are\nignored for accessibility, and returns those that mactch the specified name and role. If no DOM\nnode is specified, or the DOM node does not exist, the command returns an error. If neither\n`accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.\n[queryAXTree](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-queryAXTree)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct QueryAxTreeParams {
            #[doc = "Identifier of the node for the root to query."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<super::dom::NodeId>,
            #[doc = "Identifier of the backend node for the root to query."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<super::dom::BackendNodeId>,
            #[doc = "JavaScript object id of the node wrapper for the root to query."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
            #[doc = "Find nodes with this computed name."]
            #[serde(rename = "accessibleName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub accessible_name: Option<String>,
            #[doc = "Find nodes with this computed role."]
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub role: Option<String>,
        }
        impl QueryAxTreeParams {
            pub fn builder() -> QueryAxTreeParamsBuilder {
                QueryAxTreeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct QueryAxTreeParamsBuilder {
            node_id: Option<super::dom::NodeId>,
            backend_node_id: Option<super::dom::BackendNodeId>,
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
            accessible_name: Option<String>,
            role: Option<String>,
        }
        impl QueryAxTreeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn backend_node_id(
                mut self,
                backend_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn accessible_name(mut self, accessible_name: impl Into<String>) -> Self {
                self.accessible_name = Some(accessible_name.into());
                self
            }
            pub fn role(mut self, role: impl Into<String>) -> Self {
                self.role = Some(role.into());
                self
            }
            pub fn build(self) -> QueryAxTreeParams {
                QueryAxTreeParams {
                    node_id: self.node_id,
                    backend_node_id: self.backend_node_id,
                    object_id: self.object_id,
                    accessible_name: self.accessible_name,
                    role: self.role,
                }
            }
        }
        impl QueryAxTreeParams {
            pub const IDENTIFIER: &'static str = "Accessibility.queryAXTree";
        }
        impl chromiumoxide_types::Method for QueryAxTreeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for QueryAxTreeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Query a DOM node's accessibility subtree for accessible name and role.\nThis command computes the name and role for all nodes in the subtree, including those that are\nignored for accessibility, and returns those that mactch the specified name and role. If no DOM\nnode is specified, or the DOM node does not exist, the command returns an error. If neither\n`accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.\n[queryAXTree](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-queryAXTree)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct QueryAxTreeReturns {
            #[doc = "A list of `Accessibility.AXNode` matching the specified attributes,\nincluding nodes that are ignored for accessibility."]
            #[serde(rename = "nodes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub nodes: Vec<AxNode>,
        }
        impl QueryAxTreeReturns {
            pub fn new(nodes: Vec<AxNode>) -> Self {
                Self { nodes }
            }
        }
        impl QueryAxTreeReturns {
            pub fn builder() -> QueryAxTreeReturnsBuilder {
                QueryAxTreeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct QueryAxTreeReturnsBuilder {
            nodes: Option<Vec<AxNode>>,
        }
        impl QueryAxTreeReturnsBuilder {
            pub fn node(mut self, node: impl Into<AxNode>) -> Self {
                let v = self.nodes.get_or_insert(Vec::new());
                v.push(node.into());
                self
            }
            pub fn nodes<I, S>(mut self, nodes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<AxNode>,
            {
                let v = self.nodes.get_or_insert(Vec::new());
                for val in nodes {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<QueryAxTreeReturns, String> {
                Ok(QueryAxTreeReturns {
                    nodes: self.nodes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(nodes))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for QueryAxTreeParams {
            type Response = QueryAxTreeReturns;
        }
        #[doc = "The loadComplete event mirrors the load complete event sent by the browser to assistive\ntechnology when the web page has finished loading.\n[loadComplete](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#event-loadComplete)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventLoadComplete {
            #[doc = "New document root node."]
            #[serde(rename = "root")]
            pub root: AxNode,
        }
        impl EventLoadComplete {
            pub const IDENTIFIER: &'static str = "Accessibility.loadComplete";
        }
        impl chromiumoxide_types::Method for EventLoadComplete {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventLoadComplete {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "The nodesUpdated event is sent every time a previously requested node has changed the in tree.\n[nodesUpdated](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#event-nodesUpdated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventNodesUpdated {
            #[doc = "Updated node data."]
            #[serde(rename = "nodes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub nodes: Vec<AxNode>,
        }
        impl EventNodesUpdated {
            pub const IDENTIFIER: &'static str = "Accessibility.nodesUpdated";
        }
        impl chromiumoxide_types::Method for EventNodesUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventNodesUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    pub mod animation {
        use serde::{Deserialize, Serialize};
        #[doc = "Animation instance.\n[Animation](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#type-Animation)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Animation {
            #[doc = "`Animation`'s id."]
            #[serde(rename = "id")]
            pub id: String,
            #[doc = "`Animation`'s name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "`Animation`'s internal paused state."]
            #[serde(rename = "pausedState")]
            pub paused_state: bool,
            #[doc = "`Animation`'s play state."]
            #[serde(rename = "playState")]
            pub play_state: String,
            #[doc = "`Animation`'s playback rate."]
            #[serde(rename = "playbackRate")]
            pub playback_rate: f64,
            #[doc = "`Animation`'s start time."]
            #[serde(rename = "startTime")]
            pub start_time: f64,
            #[doc = "`Animation`'s current time."]
            #[serde(rename = "currentTime")]
            pub current_time: f64,
            #[doc = "Animation type of `Animation`."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: AnimationType,
            #[doc = "`Animation`'s source animation node."]
            #[serde(rename = "source")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub source: Option<AnimationEffect>,
            #[doc = "A unique ID for `Animation` representing the sources that triggered this CSS\nanimation/transition."]
            #[serde(rename = "cssId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub css_id: Option<String>,
        }
        #[doc = "Animation type of `Animation`."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AnimationType {
            #[serde(rename = "CSSTransition")]
            CssTransition,
            #[serde(rename = "CSSAnimation")]
            CssAnimation,
            #[serde(rename = "WebAnimation")]
            WebAnimation,
        }
        impl AsRef<str> for AnimationType {
            fn as_ref(&self) -> &str {
                match self {
                    AnimationType::CssTransition => "CSSTransition",
                    AnimationType::CssAnimation => "CSSAnimation",
                    AnimationType::WebAnimation => "WebAnimation",
                }
            }
        }
        impl ::std::str::FromStr for AnimationType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "CSSTransition" | "CssTransition" | "csstransition" => {
                        Ok(AnimationType::CssTransition)
                    }
                    "CSSAnimation" | "CssAnimation" | "cssanimation" => {
                        Ok(AnimationType::CssAnimation)
                    }
                    "WebAnimation" | "webanimation" => Ok(AnimationType::WebAnimation),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl Animation {
            pub fn builder() -> AnimationBuilder {
                AnimationBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AnimationBuilder {
            id: Option<String>,
            name: Option<String>,
            paused_state: Option<bool>,
            play_state: Option<String>,
            playback_rate: Option<f64>,
            start_time: Option<f64>,
            current_time: Option<f64>,
            r#type: Option<AnimationType>,
            source: Option<AnimationEffect>,
            css_id: Option<String>,
        }
        impl AnimationBuilder {
            pub fn id(mut self, id: impl Into<String>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn paused_state(mut self, paused_state: impl Into<bool>) -> Self {
                self.paused_state = Some(paused_state.into());
                self
            }
            pub fn play_state(mut self, play_state: impl Into<String>) -> Self {
                self.play_state = Some(play_state.into());
                self
            }
            pub fn playback_rate(mut self, playback_rate: impl Into<f64>) -> Self {
                self.playback_rate = Some(playback_rate.into());
                self
            }
            pub fn start_time(mut self, start_time: impl Into<f64>) -> Self {
                self.start_time = Some(start_time.into());
                self
            }
            pub fn current_time(mut self, current_time: impl Into<f64>) -> Self {
                self.current_time = Some(current_time.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<AnimationType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn source(mut self, source: impl Into<AnimationEffect>) -> Self {
                self.source = Some(source.into());
                self
            }
            pub fn css_id(mut self, css_id: impl Into<String>) -> Self {
                self.css_id = Some(css_id.into());
                self
            }
            pub fn build(self) -> Result<Animation, String> {
                Ok(Animation {
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    paused_state: self.paused_state.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(paused_state))
                    })?,
                    play_state: self.play_state.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(play_state))
                    })?,
                    playback_rate: self.playback_rate.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(playback_rate))
                    })?,
                    start_time: self.start_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(start_time))
                    })?,
                    current_time: self.current_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(current_time))
                    })?,
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    source: self.source,
                    css_id: self.css_id,
                })
            }
        }
        impl Animation {
            pub const IDENTIFIER: &'static str = "Animation.Animation";
        }
        #[doc = "AnimationEffect instance\n[AnimationEffect](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#type-AnimationEffect)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AnimationEffect {
            #[doc = "`AnimationEffect`'s delay."]
            #[serde(rename = "delay")]
            pub delay: f64,
            #[doc = "`AnimationEffect`'s end delay."]
            #[serde(rename = "endDelay")]
            pub end_delay: f64,
            #[doc = "`AnimationEffect`'s iteration start."]
            #[serde(rename = "iterationStart")]
            pub iteration_start: f64,
            #[doc = "`AnimationEffect`'s iterations."]
            #[serde(rename = "iterations")]
            pub iterations: f64,
            #[doc = "`AnimationEffect`'s iteration duration."]
            #[serde(rename = "duration")]
            pub duration: f64,
            #[doc = "`AnimationEffect`'s playback direction."]
            #[serde(rename = "direction")]
            pub direction: String,
            #[doc = "`AnimationEffect`'s fill mode."]
            #[serde(rename = "fill")]
            pub fill: String,
            #[doc = "`AnimationEffect`'s target node."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<super::dom::BackendNodeId>,
            #[doc = "`AnimationEffect`'s keyframes."]
            #[serde(rename = "keyframesRule")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub keyframes_rule: Option<KeyframesRule>,
            #[doc = "`AnimationEffect`'s timing function."]
            #[serde(rename = "easing")]
            pub easing: String,
        }
        impl AnimationEffect {
            pub fn builder() -> AnimationEffectBuilder {
                AnimationEffectBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AnimationEffectBuilder {
            delay: Option<f64>,
            end_delay: Option<f64>,
            iteration_start: Option<f64>,
            iterations: Option<f64>,
            duration: Option<f64>,
            direction: Option<String>,
            fill: Option<String>,
            backend_node_id: Option<super::dom::BackendNodeId>,
            keyframes_rule: Option<KeyframesRule>,
            easing: Option<String>,
        }
        impl AnimationEffectBuilder {
            pub fn delay(mut self, delay: impl Into<f64>) -> Self {
                self.delay = Some(delay.into());
                self
            }
            pub fn end_delay(mut self, end_delay: impl Into<f64>) -> Self {
                self.end_delay = Some(end_delay.into());
                self
            }
            pub fn iteration_start(mut self, iteration_start: impl Into<f64>) -> Self {
                self.iteration_start = Some(iteration_start.into());
                self
            }
            pub fn iterations(mut self, iterations: impl Into<f64>) -> Self {
                self.iterations = Some(iterations.into());
                self
            }
            pub fn duration(mut self, duration: impl Into<f64>) -> Self {
                self.duration = Some(duration.into());
                self
            }
            pub fn direction(mut self, direction: impl Into<String>) -> Self {
                self.direction = Some(direction.into());
                self
            }
            pub fn fill(mut self, fill: impl Into<String>) -> Self {
                self.fill = Some(fill.into());
                self
            }
            pub fn backend_node_id(
                mut self,
                backend_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn keyframes_rule(mut self, keyframes_rule: impl Into<KeyframesRule>) -> Self {
                self.keyframes_rule = Some(keyframes_rule.into());
                self
            }
            pub fn easing(mut self, easing: impl Into<String>) -> Self {
                self.easing = Some(easing.into());
                self
            }
            pub fn build(self) -> Result<AnimationEffect, String> {
                Ok(AnimationEffect {
                    delay: self.delay.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(delay))
                    })?,
                    end_delay: self.end_delay.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(end_delay))
                    })?,
                    iteration_start: self.iteration_start.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(iteration_start))
                    })?,
                    iterations: self.iterations.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(iterations))
                    })?,
                    duration: self.duration.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(duration))
                    })?,
                    direction: self.direction.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(direction))
                    })?,
                    fill: self.fill.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(fill))
                    })?,
                    backend_node_id: self.backend_node_id,
                    keyframes_rule: self.keyframes_rule,
                    easing: self.easing.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(easing))
                    })?,
                })
            }
        }
        impl AnimationEffect {
            pub const IDENTIFIER: &'static str = "Animation.AnimationEffect";
        }
        #[doc = "Keyframes Rule\n[KeyframesRule](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#type-KeyframesRule)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct KeyframesRule {
            #[doc = "CSS keyframed animation's name."]
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub name: Option<String>,
            #[doc = "List of animation keyframes."]
            #[serde(rename = "keyframes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub keyframes: Vec<KeyframeStyle>,
        }
        impl KeyframesRule {
            pub fn new(keyframes: Vec<KeyframeStyle>) -> Self {
                Self {
                    keyframes,
                    name: None,
                }
            }
        }
        impl KeyframesRule {
            pub fn builder() -> KeyframesRuleBuilder {
                KeyframesRuleBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct KeyframesRuleBuilder {
            name: Option<String>,
            keyframes: Option<Vec<KeyframeStyle>>,
        }
        impl KeyframesRuleBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn keyframe(mut self, keyframe: impl Into<KeyframeStyle>) -> Self {
                let v = self.keyframes.get_or_insert(Vec::new());
                v.push(keyframe.into());
                self
            }
            pub fn keyframes<I, S>(mut self, keyframes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<KeyframeStyle>,
            {
                let v = self.keyframes.get_or_insert(Vec::new());
                for val in keyframes {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<KeyframesRule, String> {
                Ok(KeyframesRule {
                    name: self.name,
                    keyframes: self.keyframes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(keyframes))
                    })?,
                })
            }
        }
        impl KeyframesRule {
            pub const IDENTIFIER: &'static str = "Animation.KeyframesRule";
        }
        #[doc = "Keyframe Style\n[KeyframeStyle](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#type-KeyframeStyle)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct KeyframeStyle {
            #[doc = "Keyframe's time offset."]
            #[serde(rename = "offset")]
            pub offset: String,
            #[doc = "`AnimationEffect`'s timing function."]
            #[serde(rename = "easing")]
            pub easing: String,
        }
        impl KeyframeStyle {
            pub fn new(offset: impl Into<String>, easing: impl Into<String>) -> Self {
                Self {
                    offset: offset.into(),
                    easing: easing.into(),
                }
            }
        }
        impl KeyframeStyle {
            pub fn builder() -> KeyframeStyleBuilder {
                KeyframeStyleBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct KeyframeStyleBuilder {
            offset: Option<String>,
            easing: Option<String>,
        }
        impl KeyframeStyleBuilder {
            pub fn offset(mut self, offset: impl Into<String>) -> Self {
                self.offset = Some(offset.into());
                self
            }
            pub fn easing(mut self, easing: impl Into<String>) -> Self {
                self.easing = Some(easing.into());
                self
            }
            pub fn build(self) -> Result<KeyframeStyle, String> {
                Ok(KeyframeStyle {
                    offset: self.offset.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(offset))
                    })?,
                    easing: self.easing.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(easing))
                    })?,
                })
            }
        }
        impl KeyframeStyle {
            pub const IDENTIFIER: &'static str = "Animation.KeyframeStyle";
        }
        #[doc = "Disables animation domain notifications.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Animation.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables animation domain notifications.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables animation domain notifications.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Animation.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables animation domain notifications.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Returns the current time of the an animation.\n[getCurrentTime](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-getCurrentTime)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetCurrentTimeParams {
            #[doc = "Id of animation."]
            #[serde(rename = "id")]
            pub id: String,
        }
        impl GetCurrentTimeParams {
            pub fn new(id: impl Into<String>) -> Self {
                Self { id: id.into() }
            }
        }
        impl<T: Into<String>> From<T> for GetCurrentTimeParams {
            fn from(url: T) -> Self {
                GetCurrentTimeParams::new(url)
            }
        }
        impl GetCurrentTimeParams {
            pub fn builder() -> GetCurrentTimeParamsBuilder {
                GetCurrentTimeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetCurrentTimeParamsBuilder {
            id: Option<String>,
        }
        impl GetCurrentTimeParamsBuilder {
            pub fn id(mut self, id: impl Into<String>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn build(self) -> Result<GetCurrentTimeParams, String> {
                Ok(GetCurrentTimeParams {
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                })
            }
        }
        impl GetCurrentTimeParams {
            pub const IDENTIFIER: &'static str = "Animation.getCurrentTime";
        }
        impl chromiumoxide_types::Method for GetCurrentTimeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetCurrentTimeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the current time of the an animation.\n[getCurrentTime](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-getCurrentTime)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetCurrentTimeReturns {
            #[doc = "Current time of the page."]
            #[serde(rename = "currentTime")]
            pub current_time: f64,
        }
        impl GetCurrentTimeReturns {
            pub fn new(current_time: impl Into<f64>) -> Self {
                Self {
                    current_time: current_time.into(),
                }
            }
        }
        impl GetCurrentTimeReturns {
            pub fn builder() -> GetCurrentTimeReturnsBuilder {
                GetCurrentTimeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetCurrentTimeReturnsBuilder {
            current_time: Option<f64>,
        }
        impl GetCurrentTimeReturnsBuilder {
            pub fn current_time(mut self, current_time: impl Into<f64>) -> Self {
                self.current_time = Some(current_time.into());
                self
            }
            pub fn build(self) -> Result<GetCurrentTimeReturns, String> {
                Ok(GetCurrentTimeReturns {
                    current_time: self.current_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(current_time))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetCurrentTimeParams {
            type Response = GetCurrentTimeReturns;
        }
        #[doc = "Gets the playback rate of the document timeline.\n[getPlaybackRate](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-getPlaybackRate)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetPlaybackRateParams {}
        impl GetPlaybackRateParams {
            pub const IDENTIFIER: &'static str = "Animation.getPlaybackRate";
        }
        impl chromiumoxide_types::Method for GetPlaybackRateParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetPlaybackRateParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Gets the playback rate of the document timeline.\n[getPlaybackRate](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-getPlaybackRate)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetPlaybackRateReturns {
            #[doc = "Playback rate for animations on page."]
            #[serde(rename = "playbackRate")]
            pub playback_rate: f64,
        }
        impl GetPlaybackRateReturns {
            pub fn new(playback_rate: impl Into<f64>) -> Self {
                Self {
                    playback_rate: playback_rate.into(),
                }
            }
        }
        impl GetPlaybackRateReturns {
            pub fn builder() -> GetPlaybackRateReturnsBuilder {
                GetPlaybackRateReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetPlaybackRateReturnsBuilder {
            playback_rate: Option<f64>,
        }
        impl GetPlaybackRateReturnsBuilder {
            pub fn playback_rate(mut self, playback_rate: impl Into<f64>) -> Self {
                self.playback_rate = Some(playback_rate.into());
                self
            }
            pub fn build(self) -> Result<GetPlaybackRateReturns, String> {
                Ok(GetPlaybackRateReturns {
                    playback_rate: self.playback_rate.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(playback_rate))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetPlaybackRateParams {
            type Response = GetPlaybackRateReturns;
        }
        #[doc = "Releases a set of animations to no longer be manipulated.\n[releaseAnimations](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-releaseAnimations)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ReleaseAnimationsParams {
            #[doc = "List of animation ids to seek."]
            #[serde(rename = "animations")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub animations: Vec<String>,
        }
        impl ReleaseAnimationsParams {
            pub fn new(animations: Vec<String>) -> Self {
                Self { animations }
            }
        }
        impl ReleaseAnimationsParams {
            pub fn builder() -> ReleaseAnimationsParamsBuilder {
                ReleaseAnimationsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ReleaseAnimationsParamsBuilder {
            animations: Option<Vec<String>>,
        }
        impl ReleaseAnimationsParamsBuilder {
            pub fn animation(mut self, animation: impl Into<String>) -> Self {
                let v = self.animations.get_or_insert(Vec::new());
                v.push(animation.into());
                self
            }
            pub fn animations<I, S>(mut self, animations: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.animations.get_or_insert(Vec::new());
                for val in animations {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<ReleaseAnimationsParams, String> {
                Ok(ReleaseAnimationsParams {
                    animations: self.animations.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(animations))
                    })?,
                })
            }
        }
        impl ReleaseAnimationsParams {
            pub const IDENTIFIER: &'static str = "Animation.releaseAnimations";
        }
        impl chromiumoxide_types::Method for ReleaseAnimationsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ReleaseAnimationsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Releases a set of animations to no longer be manipulated.\n[releaseAnimations](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-releaseAnimations)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ReleaseAnimationsReturns {}
        impl chromiumoxide_types::Command for ReleaseAnimationsParams {
            type Response = ReleaseAnimationsReturns;
        }
        #[doc = "Gets the remote object of the Animation.\n[resolveAnimation](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-resolveAnimation)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ResolveAnimationParams {
            #[doc = "Animation id."]
            #[serde(rename = "animationId")]
            pub animation_id: String,
        }
        impl ResolveAnimationParams {
            pub fn new(animation_id: impl Into<String>) -> Self {
                Self {
                    animation_id: animation_id.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for ResolveAnimationParams {
            fn from(url: T) -> Self {
                ResolveAnimationParams::new(url)
            }
        }
        impl ResolveAnimationParams {
            pub fn builder() -> ResolveAnimationParamsBuilder {
                ResolveAnimationParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ResolveAnimationParamsBuilder {
            animation_id: Option<String>,
        }
        impl ResolveAnimationParamsBuilder {
            pub fn animation_id(mut self, animation_id: impl Into<String>) -> Self {
                self.animation_id = Some(animation_id.into());
                self
            }
            pub fn build(self) -> Result<ResolveAnimationParams, String> {
                Ok(ResolveAnimationParams {
                    animation_id: self.animation_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(animation_id))
                    })?,
                })
            }
        }
        impl ResolveAnimationParams {
            pub const IDENTIFIER: &'static str = "Animation.resolveAnimation";
        }
        impl chromiumoxide_types::Method for ResolveAnimationParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ResolveAnimationParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Gets the remote object of the Animation.\n[resolveAnimation](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-resolveAnimation)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ResolveAnimationReturns {
            #[doc = "Corresponding remote object."]
            #[serde(rename = "remoteObject")]
            pub remote_object: super::super::js_protocol::runtime::RemoteObject,
        }
        impl ResolveAnimationReturns {
            pub fn new(
                remote_object: impl Into<super::super::js_protocol::runtime::RemoteObject>,
            ) -> Self {
                Self {
                    remote_object: remote_object.into(),
                }
            }
        }
        impl ResolveAnimationReturns {
            pub fn builder() -> ResolveAnimationReturnsBuilder {
                ResolveAnimationReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ResolveAnimationReturnsBuilder {
            remote_object: Option<super::super::js_protocol::runtime::RemoteObject>,
        }
        impl ResolveAnimationReturnsBuilder {
            pub fn remote_object(
                mut self,
                remote_object: impl Into<super::super::js_protocol::runtime::RemoteObject>,
            ) -> Self {
                self.remote_object = Some(remote_object.into());
                self
            }
            pub fn build(self) -> Result<ResolveAnimationReturns, String> {
                Ok(ResolveAnimationReturns {
                    remote_object: self.remote_object.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(remote_object))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for ResolveAnimationParams {
            type Response = ResolveAnimationReturns;
        }
        #[doc = "Seek a set of animations to a particular time within each animation.\n[seekAnimations](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-seekAnimations)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SeekAnimationsParams {
            #[doc = "List of animation ids to seek."]
            #[serde(rename = "animations")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub animations: Vec<String>,
            #[doc = "Set the current time of each animation."]
            #[serde(rename = "currentTime")]
            pub current_time: f64,
        }
        impl SeekAnimationsParams {
            pub fn new(animations: Vec<String>, current_time: impl Into<f64>) -> Self {
                Self {
                    animations,
                    current_time: current_time.into(),
                }
            }
        }
        impl SeekAnimationsParams {
            pub fn builder() -> SeekAnimationsParamsBuilder {
                SeekAnimationsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SeekAnimationsParamsBuilder {
            animations: Option<Vec<String>>,
            current_time: Option<f64>,
        }
        impl SeekAnimationsParamsBuilder {
            pub fn animation(mut self, animation: impl Into<String>) -> Self {
                let v = self.animations.get_or_insert(Vec::new());
                v.push(animation.into());
                self
            }
            pub fn animations<I, S>(mut self, animations: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.animations.get_or_insert(Vec::new());
                for val in animations {
                    v.push(val.into());
                }
                self
            }
            pub fn current_time(mut self, current_time: impl Into<f64>) -> Self {
                self.current_time = Some(current_time.into());
                self
            }
            pub fn build(self) -> Result<SeekAnimationsParams, String> {
                Ok(SeekAnimationsParams {
                    animations: self.animations.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(animations))
                    })?,
                    current_time: self.current_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(current_time))
                    })?,
                })
            }
        }
        impl SeekAnimationsParams {
            pub const IDENTIFIER: &'static str = "Animation.seekAnimations";
        }
        impl chromiumoxide_types::Method for SeekAnimationsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SeekAnimationsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Seek a set of animations to a particular time within each animation.\n[seekAnimations](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-seekAnimations)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SeekAnimationsReturns {}
        impl chromiumoxide_types::Command for SeekAnimationsParams {
            type Response = SeekAnimationsReturns;
        }
        #[doc = "Sets the paused state of a set of animations.\n[setPaused](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-setPaused)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetPausedParams {
            #[doc = "Animations to set the pause state of."]
            #[serde(rename = "animations")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub animations: Vec<String>,
            #[doc = "Paused state to set to."]
            #[serde(rename = "paused")]
            pub paused: bool,
        }
        impl SetPausedParams {
            pub fn new(animations: Vec<String>, paused: impl Into<bool>) -> Self {
                Self {
                    animations,
                    paused: paused.into(),
                }
            }
        }
        impl SetPausedParams {
            pub fn builder() -> SetPausedParamsBuilder {
                SetPausedParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetPausedParamsBuilder {
            animations: Option<Vec<String>>,
            paused: Option<bool>,
        }
        impl SetPausedParamsBuilder {
            pub fn animation(mut self, animation: impl Into<String>) -> Self {
                let v = self.animations.get_or_insert(Vec::new());
                v.push(animation.into());
                self
            }
            pub fn animations<I, S>(mut self, animations: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.animations.get_or_insert(Vec::new());
                for val in animations {
                    v.push(val.into());
                }
                self
            }
            pub fn paused(mut self, paused: impl Into<bool>) -> Self {
                self.paused = Some(paused.into());
                self
            }
            pub fn build(self) -> Result<SetPausedParams, String> {
                Ok(SetPausedParams {
                    animations: self.animations.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(animations))
                    })?,
                    paused: self.paused.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(paused))
                    })?,
                })
            }
        }
        impl SetPausedParams {
            pub const IDENTIFIER: &'static str = "Animation.setPaused";
        }
        impl chromiumoxide_types::Method for SetPausedParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetPausedParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets the paused state of a set of animations.\n[setPaused](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-setPaused)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetPausedReturns {}
        impl chromiumoxide_types::Command for SetPausedParams {
            type Response = SetPausedReturns;
        }
        #[doc = "Sets the playback rate of the document timeline.\n[setPlaybackRate](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-setPlaybackRate)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetPlaybackRateParams {
            #[doc = "Playback rate for animations on page"]
            #[serde(rename = "playbackRate")]
            pub playback_rate: f64,
        }
        impl SetPlaybackRateParams {
            pub fn new(playback_rate: impl Into<f64>) -> Self {
                Self {
                    playback_rate: playback_rate.into(),
                }
            }
        }
        impl SetPlaybackRateParams {
            pub fn builder() -> SetPlaybackRateParamsBuilder {
                SetPlaybackRateParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetPlaybackRateParamsBuilder {
            playback_rate: Option<f64>,
        }
        impl SetPlaybackRateParamsBuilder {
            pub fn playback_rate(mut self, playback_rate: impl Into<f64>) -> Self {
                self.playback_rate = Some(playback_rate.into());
                self
            }
            pub fn build(self) -> Result<SetPlaybackRateParams, String> {
                Ok(SetPlaybackRateParams {
                    playback_rate: self.playback_rate.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(playback_rate))
                    })?,
                })
            }
        }
        impl SetPlaybackRateParams {
            pub const IDENTIFIER: &'static str = "Animation.setPlaybackRate";
        }
        impl chromiumoxide_types::Method for SetPlaybackRateParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetPlaybackRateParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets the playback rate of the document timeline.\n[setPlaybackRate](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-setPlaybackRate)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetPlaybackRateReturns {}
        impl chromiumoxide_types::Command for SetPlaybackRateParams {
            type Response = SetPlaybackRateReturns;
        }
        #[doc = "Sets the timing of an animation node.\n[setTiming](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-setTiming)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetTimingParams {
            #[doc = "Animation id."]
            #[serde(rename = "animationId")]
            pub animation_id: String,
            #[doc = "Duration of the animation."]
            #[serde(rename = "duration")]
            pub duration: f64,
            #[doc = "Delay of the animation."]
            #[serde(rename = "delay")]
            pub delay: f64,
        }
        impl SetTimingParams {
            pub fn new(
                animation_id: impl Into<String>,
                duration: impl Into<f64>,
                delay: impl Into<f64>,
            ) -> Self {
                Self {
                    animation_id: animation_id.into(),
                    duration: duration.into(),
                    delay: delay.into(),
                }
            }
        }
        impl SetTimingParams {
            pub fn builder() -> SetTimingParamsBuilder {
                SetTimingParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetTimingParamsBuilder {
            animation_id: Option<String>,
            duration: Option<f64>,
            delay: Option<f64>,
        }
        impl SetTimingParamsBuilder {
            pub fn animation_id(mut self, animation_id: impl Into<String>) -> Self {
                self.animation_id = Some(animation_id.into());
                self
            }
            pub fn duration(mut self, duration: impl Into<f64>) -> Self {
                self.duration = Some(duration.into());
                self
            }
            pub fn delay(mut self, delay: impl Into<f64>) -> Self {
                self.delay = Some(delay.into());
                self
            }
            pub fn build(self) -> Result<SetTimingParams, String> {
                Ok(SetTimingParams {
                    animation_id: self.animation_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(animation_id))
                    })?,
                    duration: self.duration.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(duration))
                    })?,
                    delay: self.delay.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(delay))
                    })?,
                })
            }
        }
        impl SetTimingParams {
            pub const IDENTIFIER: &'static str = "Animation.setTiming";
        }
        impl chromiumoxide_types::Method for SetTimingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetTimingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets the timing of an animation node.\n[setTiming](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-setTiming)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetTimingReturns {}
        impl chromiumoxide_types::Command for SetTimingParams {
            type Response = SetTimingReturns;
        }
        #[doc = "Event for when an animation has been cancelled.\n[animationCanceled](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#event-animationCanceled)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAnimationCanceled {
            #[doc = "Id of the animation that was cancelled."]
            #[serde(rename = "id")]
            pub id: String,
        }
        impl EventAnimationCanceled {
            pub const IDENTIFIER: &'static str = "Animation.animationCanceled";
        }
        impl chromiumoxide_types::Method for EventAnimationCanceled {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAnimationCanceled {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Event for each animation that has been created.\n[animationCreated](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#event-animationCreated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAnimationCreated {
            #[doc = "Id of the animation that was created."]
            #[serde(rename = "id")]
            pub id: String,
        }
        impl EventAnimationCreated {
            pub const IDENTIFIER: &'static str = "Animation.animationCreated";
        }
        impl chromiumoxide_types::Method for EventAnimationCreated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAnimationCreated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Event for animation that has been started.\n[animationStarted](https://chromedevtools.github.io/devtools-protocol/tot/Animation/#event-animationStarted)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAnimationStarted {
            #[doc = "Animation that was started."]
            #[serde(rename = "animation")]
            pub animation: Animation,
        }
        impl EventAnimationStarted {
            pub const IDENTIFIER: &'static str = "Animation.animationStarted";
        }
        impl chromiumoxide_types::Method for EventAnimationStarted {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAnimationStarted {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "Audits domain allows investigation of page violations and possible improvements."]
    pub mod audits {
        use serde::{Deserialize, Serialize};
        #[doc = "Information about a cookie that is affected by an inspector issue.\n[AffectedCookie](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-AffectedCookie)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AffectedCookie {
            #[doc = "The following three properties uniquely identify a cookie"]
            #[serde(rename = "name")]
            pub name: String,
            #[serde(rename = "path")]
            pub path: String,
            #[serde(rename = "domain")]
            pub domain: String,
        }
        impl AffectedCookie {
            pub fn new(
                name: impl Into<String>,
                path: impl Into<String>,
                domain: impl Into<String>,
            ) -> Self {
                Self {
                    name: name.into(),
                    path: path.into(),
                    domain: domain.into(),
                }
            }
        }
        impl AffectedCookie {
            pub fn builder() -> AffectedCookieBuilder {
                AffectedCookieBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AffectedCookieBuilder {
            name: Option<String>,
            path: Option<String>,
            domain: Option<String>,
        }
        impl AffectedCookieBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn path(mut self, path: impl Into<String>) -> Self {
                self.path = Some(path.into());
                self
            }
            pub fn domain(mut self, domain: impl Into<String>) -> Self {
                self.domain = Some(domain.into());
                self
            }
            pub fn build(self) -> Result<AffectedCookie, String> {
                Ok(AffectedCookie {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    path: self.path.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(path))
                    })?,
                    domain: self.domain.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(domain))
                    })?,
                })
            }
        }
        impl AffectedCookie {
            pub const IDENTIFIER: &'static str = "Audits.AffectedCookie";
        }
        #[doc = "Information about a request that is affected by an inspector issue.\n[AffectedRequest](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-AffectedRequest)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AffectedRequest {
            #[doc = "The unique request id."]
            #[serde(rename = "requestId")]
            pub request_id: super::network::RequestId,
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url: Option<String>,
        }
        impl AffectedRequest {
            pub fn new(request_id: impl Into<super::network::RequestId>) -> Self {
                Self {
                    request_id: request_id.into(),
                    url: None,
                }
            }
        }
        impl AffectedRequest {
            pub fn builder() -> AffectedRequestBuilder {
                AffectedRequestBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AffectedRequestBuilder {
            request_id: Option<super::network::RequestId>,
            url: Option<String>,
        }
        impl AffectedRequestBuilder {
            pub fn request_id(mut self, request_id: impl Into<super::network::RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn build(self) -> Result<AffectedRequest, String> {
                Ok(AffectedRequest {
                    request_id: self.request_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_id))
                    })?,
                    url: self.url,
                })
            }
        }
        impl AffectedRequest {
            pub const IDENTIFIER: &'static str = "Audits.AffectedRequest";
        }
        #[doc = "Information about the frame affected by an inspector issue.\n[AffectedFrame](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-AffectedFrame)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AffectedFrame {
            #[serde(rename = "frameId")]
            pub frame_id: super::page::FrameId,
        }
        impl AffectedFrame {
            pub fn new(frame_id: impl Into<super::page::FrameId>) -> Self {
                Self {
                    frame_id: frame_id.into(),
                }
            }
        }
        impl AffectedFrame {
            pub fn builder() -> AffectedFrameBuilder {
                AffectedFrameBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AffectedFrameBuilder {
            frame_id: Option<super::page::FrameId>,
        }
        impl AffectedFrameBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn build(self) -> Result<AffectedFrame, String> {
                Ok(AffectedFrame {
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                })
            }
        }
        impl AffectedFrame {
            pub const IDENTIFIER: &'static str = "Audits.AffectedFrame";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CookieExclusionReason {
            #[serde(rename = "ExcludeSameSiteUnspecifiedTreatedAsLax")]
            ExcludeSameSiteUnspecifiedTreatedAsLax,
            #[serde(rename = "ExcludeSameSiteNoneInsecure")]
            ExcludeSameSiteNoneInsecure,
            #[serde(rename = "ExcludeSameSiteLax")]
            ExcludeSameSiteLax,
            #[serde(rename = "ExcludeSameSiteStrict")]
            ExcludeSameSiteStrict,
            #[serde(rename = "ExcludeInvalidSameParty")]
            ExcludeInvalidSameParty,
            #[serde(rename = "ExcludeSamePartyCrossPartyContext")]
            ExcludeSamePartyCrossPartyContext,
            #[serde(rename = "ExcludeDomainNonASCII")]
            ExcludeDomainNonAscii,
        }
        impl AsRef<str> for CookieExclusionReason {
            fn as_ref(&self) -> &str {
                match self {
                    CookieExclusionReason::ExcludeSameSiteUnspecifiedTreatedAsLax => {
                        "ExcludeSameSiteUnspecifiedTreatedAsLax"
                    }
                    CookieExclusionReason::ExcludeSameSiteNoneInsecure => {
                        "ExcludeSameSiteNoneInsecure"
                    }
                    CookieExclusionReason::ExcludeSameSiteLax => "ExcludeSameSiteLax",
                    CookieExclusionReason::ExcludeSameSiteStrict => "ExcludeSameSiteStrict",
                    CookieExclusionReason::ExcludeInvalidSameParty => "ExcludeInvalidSameParty",
                    CookieExclusionReason::ExcludeSamePartyCrossPartyContext => {
                        "ExcludeSamePartyCrossPartyContext"
                    }
                    CookieExclusionReason::ExcludeDomainNonAscii => "ExcludeDomainNonASCII",
                }
            }
        }
        impl ::std::str::FromStr for CookieExclusionReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "ExcludeSameSiteUnspecifiedTreatedAsLax"
                    | "excludesamesiteunspecifiedtreatedaslax" => {
                        Ok(CookieExclusionReason::ExcludeSameSiteUnspecifiedTreatedAsLax)
                    }
                    "ExcludeSameSiteNoneInsecure" | "excludesamesitenoneinsecure" => {
                        Ok(CookieExclusionReason::ExcludeSameSiteNoneInsecure)
                    }
                    "ExcludeSameSiteLax" | "excludesamesitelax" => {
                        Ok(CookieExclusionReason::ExcludeSameSiteLax)
                    }
                    "ExcludeSameSiteStrict" | "excludesamesitestrict" => {
                        Ok(CookieExclusionReason::ExcludeSameSiteStrict)
                    }
                    "ExcludeInvalidSameParty" | "excludeinvalidsameparty" => {
                        Ok(CookieExclusionReason::ExcludeInvalidSameParty)
                    }
                    "ExcludeSamePartyCrossPartyContext" | "excludesamepartycrosspartycontext" => {
                        Ok(CookieExclusionReason::ExcludeSamePartyCrossPartyContext)
                    }
                    "ExcludeDomainNonASCII" | "ExcludeDomainNonAscii" | "excludedomainnonascii" => {
                        Ok(CookieExclusionReason::ExcludeDomainNonAscii)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CookieWarningReason {
            #[serde(rename = "WarnSameSiteUnspecifiedCrossSiteContext")]
            WarnSameSiteUnspecifiedCrossSiteContext,
            #[serde(rename = "WarnSameSiteNoneInsecure")]
            WarnSameSiteNoneInsecure,
            #[serde(rename = "WarnSameSiteUnspecifiedLaxAllowUnsafe")]
            WarnSameSiteUnspecifiedLaxAllowUnsafe,
            #[serde(rename = "WarnSameSiteStrictLaxDowngradeStrict")]
            WarnSameSiteStrictLaxDowngradeStrict,
            #[serde(rename = "WarnSameSiteStrictCrossDowngradeStrict")]
            WarnSameSiteStrictCrossDowngradeStrict,
            #[serde(rename = "WarnSameSiteStrictCrossDowngradeLax")]
            WarnSameSiteStrictCrossDowngradeLax,
            #[serde(rename = "WarnSameSiteLaxCrossDowngradeStrict")]
            WarnSameSiteLaxCrossDowngradeStrict,
            #[serde(rename = "WarnSameSiteLaxCrossDowngradeLax")]
            WarnSameSiteLaxCrossDowngradeLax,
            #[serde(rename = "WarnAttributeValueExceedsMaxSize")]
            WarnAttributeValueExceedsMaxSize,
            #[serde(rename = "WarnDomainNonASCII")]
            WarnDomainNonAscii,
        }
        impl AsRef<str> for CookieWarningReason {
            fn as_ref(&self) -> &str {
                match self {
                    CookieWarningReason::WarnSameSiteUnspecifiedCrossSiteContext => {
                        "WarnSameSiteUnspecifiedCrossSiteContext"
                    }
                    CookieWarningReason::WarnSameSiteNoneInsecure => "WarnSameSiteNoneInsecure",
                    CookieWarningReason::WarnSameSiteUnspecifiedLaxAllowUnsafe => {
                        "WarnSameSiteUnspecifiedLaxAllowUnsafe"
                    }
                    CookieWarningReason::WarnSameSiteStrictLaxDowngradeStrict => {
                        "WarnSameSiteStrictLaxDowngradeStrict"
                    }
                    CookieWarningReason::WarnSameSiteStrictCrossDowngradeStrict => {
                        "WarnSameSiteStrictCrossDowngradeStrict"
                    }
                    CookieWarningReason::WarnSameSiteStrictCrossDowngradeLax => {
                        "WarnSameSiteStrictCrossDowngradeLax"
                    }
                    CookieWarningReason::WarnSameSiteLaxCrossDowngradeStrict => {
                        "WarnSameSiteLaxCrossDowngradeStrict"
                    }
                    CookieWarningReason::WarnSameSiteLaxCrossDowngradeLax => {
                        "WarnSameSiteLaxCrossDowngradeLax"
                    }
                    CookieWarningReason::WarnAttributeValueExceedsMaxSize => {
                        "WarnAttributeValueExceedsMaxSize"
                    }
                    CookieWarningReason::WarnDomainNonAscii => "WarnDomainNonASCII",
                }
            }
        }
        impl ::std::str::FromStr for CookieWarningReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "WarnSameSiteUnspecifiedCrossSiteContext"
                    | "warnsamesiteunspecifiedcrosssitecontext" => {
                        Ok(CookieWarningReason::WarnSameSiteUnspecifiedCrossSiteContext)
                    }
                    "WarnSameSiteNoneInsecure" | "warnsamesitenoneinsecure" => {
                        Ok(CookieWarningReason::WarnSameSiteNoneInsecure)
                    }
                    "WarnSameSiteUnspecifiedLaxAllowUnsafe"
                    | "warnsamesiteunspecifiedlaxallowunsafe" => {
                        Ok(CookieWarningReason::WarnSameSiteUnspecifiedLaxAllowUnsafe)
                    }
                    "WarnSameSiteStrictLaxDowngradeStrict"
                    | "warnsamesitestrictlaxdowngradestrict" => {
                        Ok(CookieWarningReason::WarnSameSiteStrictLaxDowngradeStrict)
                    }
                    "WarnSameSiteStrictCrossDowngradeStrict"
                    | "warnsamesitestrictcrossdowngradestrict" => {
                        Ok(CookieWarningReason::WarnSameSiteStrictCrossDowngradeStrict)
                    }
                    "WarnSameSiteStrictCrossDowngradeLax"
                    | "warnsamesitestrictcrossdowngradelax" => {
                        Ok(CookieWarningReason::WarnSameSiteStrictCrossDowngradeLax)
                    }
                    "WarnSameSiteLaxCrossDowngradeStrict"
                    | "warnsamesitelaxcrossdowngradestrict" => {
                        Ok(CookieWarningReason::WarnSameSiteLaxCrossDowngradeStrict)
                    }
                    "WarnSameSiteLaxCrossDowngradeLax" | "warnsamesitelaxcrossdowngradelax" => {
                        Ok(CookieWarningReason::WarnSameSiteLaxCrossDowngradeLax)
                    }
                    "WarnAttributeValueExceedsMaxSize" | "warnattributevalueexceedsmaxsize" => {
                        Ok(CookieWarningReason::WarnAttributeValueExceedsMaxSize)
                    }
                    "WarnDomainNonASCII" | "WarnDomainNonAscii" | "warndomainnonascii" => {
                        Ok(CookieWarningReason::WarnDomainNonAscii)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CookieOperation {
            #[serde(rename = "SetCookie")]
            SetCookie,
            #[serde(rename = "ReadCookie")]
            ReadCookie,
        }
        impl AsRef<str> for CookieOperation {
            fn as_ref(&self) -> &str {
                match self {
                    CookieOperation::SetCookie => "SetCookie",
                    CookieOperation::ReadCookie => "ReadCookie",
                }
            }
        }
        impl ::std::str::FromStr for CookieOperation {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "SetCookie" | "setcookie" => Ok(CookieOperation::SetCookie),
                    "ReadCookie" | "readcookie" => Ok(CookieOperation::ReadCookie),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "This information is currently necessary, as the front-end has a difficult\ntime finding a specific cookie. With this, we can convey specific error\ninformation without the cookie.\n[CookieIssueDetails](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-CookieIssueDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CookieIssueDetails {
            #[doc = "If AffectedCookie is not set then rawCookieLine contains the raw\nSet-Cookie header string. This hints at a problem where the\ncookie line is syntactically or semantically malformed in a way\nthat no valid cookie could be created."]
            #[serde(rename = "cookie")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub cookie: Option<AffectedCookie>,
            #[serde(rename = "rawCookieLine")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub raw_cookie_line: Option<String>,
            #[serde(rename = "cookieWarningReasons")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub cookie_warning_reasons: Vec<CookieWarningReason>,
            #[serde(rename = "cookieExclusionReasons")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub cookie_exclusion_reasons: Vec<CookieExclusionReason>,
            #[doc = "Optionally identifies the site-for-cookies and the cookie url, which\nmay be used by the front-end as additional context."]
            #[serde(rename = "operation")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub operation: CookieOperation,
            #[serde(rename = "siteForCookies")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub site_for_cookies: Option<String>,
            #[serde(rename = "cookieUrl")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub cookie_url: Option<String>,
            #[serde(rename = "request")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub request: Option<AffectedRequest>,
        }
        impl CookieIssueDetails {
            pub fn new(
                cookie_warning_reasons: Vec<CookieWarningReason>,
                cookie_exclusion_reasons: Vec<CookieExclusionReason>,
                operation: impl Into<CookieOperation>,
            ) -> Self {
                Self {
                    cookie_warning_reasons,
                    cookie_exclusion_reasons,
                    operation: operation.into(),
                    cookie: None,
                    raw_cookie_line: None,
                    site_for_cookies: None,
                    cookie_url: None,
                    request: None,
                }
            }
        }
        impl CookieIssueDetails {
            pub fn builder() -> CookieIssueDetailsBuilder {
                CookieIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CookieIssueDetailsBuilder {
            cookie: Option<AffectedCookie>,
            raw_cookie_line: Option<String>,
            cookie_warning_reasons: Option<Vec<CookieWarningReason>>,
            cookie_exclusion_reasons: Option<Vec<CookieExclusionReason>>,
            operation: Option<CookieOperation>,
            site_for_cookies: Option<String>,
            cookie_url: Option<String>,
            request: Option<AffectedRequest>,
        }
        impl CookieIssueDetailsBuilder {
            pub fn cookie(mut self, cookie: impl Into<AffectedCookie>) -> Self {
                self.cookie = Some(cookie.into());
                self
            }
            pub fn raw_cookie_line(mut self, raw_cookie_line: impl Into<String>) -> Self {
                self.raw_cookie_line = Some(raw_cookie_line.into());
                self
            }
            pub fn cookie_warning_reason(
                mut self,
                cookie_warning_reason: impl Into<CookieWarningReason>,
            ) -> Self {
                let v = self.cookie_warning_reasons.get_or_insert(Vec::new());
                v.push(cookie_warning_reason.into());
                self
            }
            pub fn cookie_warning_reasons<I, S>(mut self, cookie_warning_reasons: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CookieWarningReason>,
            {
                let v = self.cookie_warning_reasons.get_or_insert(Vec::new());
                for val in cookie_warning_reasons {
                    v.push(val.into());
                }
                self
            }
            pub fn cookie_exclusion_reason(
                mut self,
                cookie_exclusion_reason: impl Into<CookieExclusionReason>,
            ) -> Self {
                let v = self.cookie_exclusion_reasons.get_or_insert(Vec::new());
                v.push(cookie_exclusion_reason.into());
                self
            }
            pub fn cookie_exclusion_reasons<I, S>(mut self, cookie_exclusion_reasons: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CookieExclusionReason>,
            {
                let v = self.cookie_exclusion_reasons.get_or_insert(Vec::new());
                for val in cookie_exclusion_reasons {
                    v.push(val.into());
                }
                self
            }
            pub fn operation(mut self, operation: impl Into<CookieOperation>) -> Self {
                self.operation = Some(operation.into());
                self
            }
            pub fn site_for_cookies(mut self, site_for_cookies: impl Into<String>) -> Self {
                self.site_for_cookies = Some(site_for_cookies.into());
                self
            }
            pub fn cookie_url(mut self, cookie_url: impl Into<String>) -> Self {
                self.cookie_url = Some(cookie_url.into());
                self
            }
            pub fn request(mut self, request: impl Into<AffectedRequest>) -> Self {
                self.request = Some(request.into());
                self
            }
            pub fn build(self) -> Result<CookieIssueDetails, String> {
                Ok(CookieIssueDetails {
                    cookie: self.cookie,
                    raw_cookie_line: self.raw_cookie_line,
                    cookie_warning_reasons: self.cookie_warning_reasons.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(cookie_warning_reasons)
                        )
                    })?,
                    cookie_exclusion_reasons: self.cookie_exclusion_reasons.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(cookie_exclusion_reasons)
                        )
                    })?,
                    operation: self.operation.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(operation))
                    })?,
                    site_for_cookies: self.site_for_cookies,
                    cookie_url: self.cookie_url,
                    request: self.request,
                })
            }
        }
        impl CookieIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.CookieIssueDetails";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum MixedContentResolutionStatus {
            #[serde(rename = "MixedContentBlocked")]
            MixedContentBlocked,
            #[serde(rename = "MixedContentAutomaticallyUpgraded")]
            MixedContentAutomaticallyUpgraded,
            #[serde(rename = "MixedContentWarning")]
            MixedContentWarning,
        }
        impl AsRef<str> for MixedContentResolutionStatus {
            fn as_ref(&self) -> &str {
                match self {
                    MixedContentResolutionStatus::MixedContentBlocked => "MixedContentBlocked",
                    MixedContentResolutionStatus::MixedContentAutomaticallyUpgraded => {
                        "MixedContentAutomaticallyUpgraded"
                    }
                    MixedContentResolutionStatus::MixedContentWarning => "MixedContentWarning",
                }
            }
        }
        impl ::std::str::FromStr for MixedContentResolutionStatus {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "MixedContentBlocked" | "mixedcontentblocked" => {
                        Ok(MixedContentResolutionStatus::MixedContentBlocked)
                    }
                    "MixedContentAutomaticallyUpgraded" | "mixedcontentautomaticallyupgraded" => {
                        Ok(MixedContentResolutionStatus::MixedContentAutomaticallyUpgraded)
                    }
                    "MixedContentWarning" | "mixedcontentwarning" => {
                        Ok(MixedContentResolutionStatus::MixedContentWarning)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum MixedContentResourceType {
            #[serde(rename = "AttributionSrc")]
            AttributionSrc,
            #[serde(rename = "Audio")]
            Audio,
            #[serde(rename = "Beacon")]
            Beacon,
            #[serde(rename = "CSPReport")]
            CspReport,
            #[serde(rename = "Download")]
            Download,
            #[serde(rename = "EventSource")]
            EventSource,
            #[serde(rename = "Favicon")]
            Favicon,
            #[serde(rename = "Font")]
            Font,
            #[serde(rename = "Form")]
            Form,
            #[serde(rename = "Frame")]
            Frame,
            #[serde(rename = "Image")]
            Image,
            #[serde(rename = "Import")]
            Import,
            #[serde(rename = "Manifest")]
            Manifest,
            #[serde(rename = "Ping")]
            Ping,
            #[serde(rename = "PluginData")]
            PluginData,
            #[serde(rename = "PluginResource")]
            PluginResource,
            #[serde(rename = "Prefetch")]
            Prefetch,
            #[serde(rename = "Resource")]
            Resource,
            #[serde(rename = "Script")]
            Script,
            #[serde(rename = "ServiceWorker")]
            ServiceWorker,
            #[serde(rename = "SharedWorker")]
            SharedWorker,
            #[serde(rename = "Stylesheet")]
            Stylesheet,
            #[serde(rename = "Track")]
            Track,
            #[serde(rename = "Video")]
            Video,
            #[serde(rename = "Worker")]
            Worker,
            #[serde(rename = "XMLHttpRequest")]
            XmlHttpRequest,
            #[serde(rename = "XSLT")]
            Xslt,
        }
        impl AsRef<str> for MixedContentResourceType {
            fn as_ref(&self) -> &str {
                match self {
                    MixedContentResourceType::AttributionSrc => "AttributionSrc",
                    MixedContentResourceType::Audio => "Audio",
                    MixedContentResourceType::Beacon => "Beacon",
                    MixedContentResourceType::CspReport => "CSPReport",
                    MixedContentResourceType::Download => "Download",
                    MixedContentResourceType::EventSource => "EventSource",
                    MixedContentResourceType::Favicon => "Favicon",
                    MixedContentResourceType::Font => "Font",
                    MixedContentResourceType::Form => "Form",
                    MixedContentResourceType::Frame => "Frame",
                    MixedContentResourceType::Image => "Image",
                    MixedContentResourceType::Import => "Import",
                    MixedContentResourceType::Manifest => "Manifest",
                    MixedContentResourceType::Ping => "Ping",
                    MixedContentResourceType::PluginData => "PluginData",
                    MixedContentResourceType::PluginResource => "PluginResource",
                    MixedContentResourceType::Prefetch => "Prefetch",
                    MixedContentResourceType::Resource => "Resource",
                    MixedContentResourceType::Script => "Script",
                    MixedContentResourceType::ServiceWorker => "ServiceWorker",
                    MixedContentResourceType::SharedWorker => "SharedWorker",
                    MixedContentResourceType::Stylesheet => "Stylesheet",
                    MixedContentResourceType::Track => "Track",
                    MixedContentResourceType::Video => "Video",
                    MixedContentResourceType::Worker => "Worker",
                    MixedContentResourceType::XmlHttpRequest => "XMLHttpRequest",
                    MixedContentResourceType::Xslt => "XSLT",
                }
            }
        }
        impl ::std::str::FromStr for MixedContentResourceType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "AttributionSrc" | "attributionsrc" => {
                        Ok(MixedContentResourceType::AttributionSrc)
                    }
                    "Audio" | "audio" => Ok(MixedContentResourceType::Audio),
                    "Beacon" | "beacon" => Ok(MixedContentResourceType::Beacon),
                    "CSPReport" | "CspReport" | "cspreport" => {
                        Ok(MixedContentResourceType::CspReport)
                    }
                    "Download" | "download" => Ok(MixedContentResourceType::Download),
                    "EventSource" | "eventsource" => Ok(MixedContentResourceType::EventSource),
                    "Favicon" | "favicon" => Ok(MixedContentResourceType::Favicon),
                    "Font" | "font" => Ok(MixedContentResourceType::Font),
                    "Form" | "form" => Ok(MixedContentResourceType::Form),
                    "Frame" | "frame" => Ok(MixedContentResourceType::Frame),
                    "Image" | "image" => Ok(MixedContentResourceType::Image),
                    "Import" | "import" => Ok(MixedContentResourceType::Import),
                    "Manifest" | "manifest" => Ok(MixedContentResourceType::Manifest),
                    "Ping" | "ping" => Ok(MixedContentResourceType::Ping),
                    "PluginData" | "plugindata" => Ok(MixedContentResourceType::PluginData),
                    "PluginResource" | "pluginresource" => {
                        Ok(MixedContentResourceType::PluginResource)
                    }
                    "Prefetch" | "prefetch" => Ok(MixedContentResourceType::Prefetch),
                    "Resource" | "resource" => Ok(MixedContentResourceType::Resource),
                    "Script" | "script" => Ok(MixedContentResourceType::Script),
                    "ServiceWorker" | "serviceworker" => {
                        Ok(MixedContentResourceType::ServiceWorker)
                    }
                    "SharedWorker" | "sharedworker" => Ok(MixedContentResourceType::SharedWorker),
                    "Stylesheet" | "stylesheet" => Ok(MixedContentResourceType::Stylesheet),
                    "Track" | "track" => Ok(MixedContentResourceType::Track),
                    "Video" | "video" => Ok(MixedContentResourceType::Video),
                    "Worker" | "worker" => Ok(MixedContentResourceType::Worker),
                    "XMLHttpRequest" | "XmlHttpRequest" | "xmlhttprequest" => {
                        Ok(MixedContentResourceType::XmlHttpRequest)
                    }
                    "XSLT" | "Xslt" | "xslt" => Ok(MixedContentResourceType::Xslt),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct MixedContentIssueDetails {
            #[doc = "The type of resource causing the mixed content issue (css, js, iframe,\nform,...). Marked as optional because it is mapped to from\nblink::mojom::RequestContextType, which will be replaced\nby network::mojom::RequestDestination"]
            #[serde(rename = "resourceType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub resource_type: Option<MixedContentResourceType>,
            #[doc = "The way the mixed content issue is being resolved."]
            #[serde(rename = "resolutionStatus")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub resolution_status: MixedContentResolutionStatus,
            #[doc = "The unsafe http url causing the mixed content issue."]
            #[serde(rename = "insecureURL")]
            pub insecure_url: String,
            #[doc = "The url responsible for the call to an unsafe url."]
            #[serde(rename = "mainResourceURL")]
            pub main_resource_url: String,
            #[doc = "The mixed content request.\nDoes not always exist (e.g. for unsafe form submission urls)."]
            #[serde(rename = "request")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub request: Option<AffectedRequest>,
            #[doc = "Optional because not every mixed content issue is necessarily linked to a frame."]
            #[serde(rename = "frame")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame: Option<AffectedFrame>,
        }
        impl MixedContentIssueDetails {
            pub fn new(
                resolution_status: impl Into<MixedContentResolutionStatus>,
                insecure_url: impl Into<String>,
                main_resource_url: impl Into<String>,
            ) -> Self {
                Self {
                    resolution_status: resolution_status.into(),
                    insecure_url: insecure_url.into(),
                    main_resource_url: main_resource_url.into(),
                    resource_type: None,
                    request: None,
                    frame: None,
                }
            }
        }
        impl MixedContentIssueDetails {
            pub fn builder() -> MixedContentIssueDetailsBuilder {
                MixedContentIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct MixedContentIssueDetailsBuilder {
            resource_type: Option<MixedContentResourceType>,
            resolution_status: Option<MixedContentResolutionStatus>,
            insecure_url: Option<String>,
            main_resource_url: Option<String>,
            request: Option<AffectedRequest>,
            frame: Option<AffectedFrame>,
        }
        impl MixedContentIssueDetailsBuilder {
            pub fn resource_type(
                mut self,
                resource_type: impl Into<MixedContentResourceType>,
            ) -> Self {
                self.resource_type = Some(resource_type.into());
                self
            }
            pub fn resolution_status(
                mut self,
                resolution_status: impl Into<MixedContentResolutionStatus>,
            ) -> Self {
                self.resolution_status = Some(resolution_status.into());
                self
            }
            pub fn insecure_url(mut self, insecure_url: impl Into<String>) -> Self {
                self.insecure_url = Some(insecure_url.into());
                self
            }
            pub fn main_resource_url(mut self, main_resource_url: impl Into<String>) -> Self {
                self.main_resource_url = Some(main_resource_url.into());
                self
            }
            pub fn request(mut self, request: impl Into<AffectedRequest>) -> Self {
                self.request = Some(request.into());
                self
            }
            pub fn frame(mut self, frame: impl Into<AffectedFrame>) -> Self {
                self.frame = Some(frame.into());
                self
            }
            pub fn build(self) -> Result<MixedContentIssueDetails, String> {
                Ok(MixedContentIssueDetails {
                    resource_type: self.resource_type,
                    resolution_status: self.resolution_status.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(resolution_status)
                        )
                    })?,
                    insecure_url: self.insecure_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(insecure_url))
                    })?,
                    main_resource_url: self.main_resource_url.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(main_resource_url)
                        )
                    })?,
                    request: self.request,
                    frame: self.frame,
                })
            }
        }
        impl MixedContentIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.MixedContentIssueDetails";
        }
        #[doc = "Enum indicating the reason a response has been blocked. These reasons are\nrefinements of the net error BLOCKED_BY_RESPONSE."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum BlockedByResponseReason {
            #[serde(rename = "CoepFrameResourceNeedsCoepHeader")]
            CoepFrameResourceNeedsCoepHeader,
            #[serde(rename = "CoopSandboxedIFrameCannotNavigateToCoopPage")]
            CoopSandboxedIFrameCannotNavigateToCoopPage,
            #[serde(rename = "CorpNotSameOrigin")]
            CorpNotSameOrigin,
            #[serde(rename = "CorpNotSameOriginAfterDefaultedToSameOriginByCoep")]
            CorpNotSameOriginAfterDefaultedToSameOriginByCoep,
            #[serde(rename = "CorpNotSameSite")]
            CorpNotSameSite,
        }
        impl AsRef<str> for BlockedByResponseReason {
            fn as_ref(&self) -> &str {
                match self {
                    BlockedByResponseReason::CoepFrameResourceNeedsCoepHeader => {
                        "CoepFrameResourceNeedsCoepHeader"
                    }
                    BlockedByResponseReason::CoopSandboxedIFrameCannotNavigateToCoopPage => {
                        "CoopSandboxedIFrameCannotNavigateToCoopPage"
                    }
                    BlockedByResponseReason::CorpNotSameOrigin => "CorpNotSameOrigin",
                    BlockedByResponseReason::CorpNotSameOriginAfterDefaultedToSameOriginByCoep => {
                        "CorpNotSameOriginAfterDefaultedToSameOriginByCoep"
                    }
                    BlockedByResponseReason::CorpNotSameSite => "CorpNotSameSite",
                }
            }
        }
        impl ::std::str::FromStr for BlockedByResponseReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "CoepFrameResourceNeedsCoepHeader" | "coepframeresourceneedscoepheader" => {
                        Ok(BlockedByResponseReason::CoepFrameResourceNeedsCoepHeader)
                    }
                    "CoopSandboxedIFrameCannotNavigateToCoopPage"
                    | "coopsandboxediframecannotnavigatetocooppage" => {
                        Ok(BlockedByResponseReason::CoopSandboxedIFrameCannotNavigateToCoopPage)
                    }
                    "CorpNotSameOrigin" | "corpnotsameorigin" => {
                        Ok(BlockedByResponseReason::CorpNotSameOrigin)
                    }
                    "CorpNotSameOriginAfterDefaultedToSameOriginByCoep"
                    | "corpnotsameoriginafterdefaultedtosameoriginbycoep" => Ok(
                        BlockedByResponseReason::CorpNotSameOriginAfterDefaultedToSameOriginByCoep,
                    ),
                    "CorpNotSameSite" | "corpnotsamesite" => {
                        Ok(BlockedByResponseReason::CorpNotSameSite)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Details for a request that has been blocked with the BLOCKED_BY_RESPONSE\ncode. Currently only used for COEP/COOP, but may be extended to include\nsome CSP errors in the future.\n[BlockedByResponseIssueDetails](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-BlockedByResponseIssueDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct BlockedByResponseIssueDetails {
            #[serde(rename = "request")]
            pub request: AffectedRequest,
            #[serde(rename = "parentFrame")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub parent_frame: Option<AffectedFrame>,
            #[serde(rename = "blockedFrame")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub blocked_frame: Option<AffectedFrame>,
            #[serde(rename = "reason")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub reason: BlockedByResponseReason,
        }
        impl BlockedByResponseIssueDetails {
            pub fn new(
                request: impl Into<AffectedRequest>,
                reason: impl Into<BlockedByResponseReason>,
            ) -> Self {
                Self {
                    request: request.into(),
                    reason: reason.into(),
                    parent_frame: None,
                    blocked_frame: None,
                }
            }
        }
        impl BlockedByResponseIssueDetails {
            pub fn builder() -> BlockedByResponseIssueDetailsBuilder {
                BlockedByResponseIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BlockedByResponseIssueDetailsBuilder {
            request: Option<AffectedRequest>,
            parent_frame: Option<AffectedFrame>,
            blocked_frame: Option<AffectedFrame>,
            reason: Option<BlockedByResponseReason>,
        }
        impl BlockedByResponseIssueDetailsBuilder {
            pub fn request(mut self, request: impl Into<AffectedRequest>) -> Self {
                self.request = Some(request.into());
                self
            }
            pub fn parent_frame(mut self, parent_frame: impl Into<AffectedFrame>) -> Self {
                self.parent_frame = Some(parent_frame.into());
                self
            }
            pub fn blocked_frame(mut self, blocked_frame: impl Into<AffectedFrame>) -> Self {
                self.blocked_frame = Some(blocked_frame.into());
                self
            }
            pub fn reason(mut self, reason: impl Into<BlockedByResponseReason>) -> Self {
                self.reason = Some(reason.into());
                self
            }
            pub fn build(self) -> Result<BlockedByResponseIssueDetails, String> {
                Ok(BlockedByResponseIssueDetails {
                    request: self.request.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request))
                    })?,
                    parent_frame: self.parent_frame,
                    blocked_frame: self.blocked_frame,
                    reason: self.reason.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(reason))
                    })?,
                })
            }
        }
        impl BlockedByResponseIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.BlockedByResponseIssueDetails";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum HeavyAdResolutionStatus {
            #[serde(rename = "HeavyAdBlocked")]
            HeavyAdBlocked,
            #[serde(rename = "HeavyAdWarning")]
            HeavyAdWarning,
        }
        impl AsRef<str> for HeavyAdResolutionStatus {
            fn as_ref(&self) -> &str {
                match self {
                    HeavyAdResolutionStatus::HeavyAdBlocked => "HeavyAdBlocked",
                    HeavyAdResolutionStatus::HeavyAdWarning => "HeavyAdWarning",
                }
            }
        }
        impl ::std::str::FromStr for HeavyAdResolutionStatus {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "HeavyAdBlocked" | "heavyadblocked" => {
                        Ok(HeavyAdResolutionStatus::HeavyAdBlocked)
                    }
                    "HeavyAdWarning" | "heavyadwarning" => {
                        Ok(HeavyAdResolutionStatus::HeavyAdWarning)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum HeavyAdReason {
            #[serde(rename = "NetworkTotalLimit")]
            NetworkTotalLimit,
            #[serde(rename = "CpuTotalLimit")]
            CpuTotalLimit,
            #[serde(rename = "CpuPeakLimit")]
            CpuPeakLimit,
        }
        impl AsRef<str> for HeavyAdReason {
            fn as_ref(&self) -> &str {
                match self {
                    HeavyAdReason::NetworkTotalLimit => "NetworkTotalLimit",
                    HeavyAdReason::CpuTotalLimit => "CpuTotalLimit",
                    HeavyAdReason::CpuPeakLimit => "CpuPeakLimit",
                }
            }
        }
        impl ::std::str::FromStr for HeavyAdReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "NetworkTotalLimit" | "networktotallimit" => {
                        Ok(HeavyAdReason::NetworkTotalLimit)
                    }
                    "CpuTotalLimit" | "cputotallimit" => Ok(HeavyAdReason::CpuTotalLimit),
                    "CpuPeakLimit" | "cpupeaklimit" => Ok(HeavyAdReason::CpuPeakLimit),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct HeavyAdIssueDetails {
            #[doc = "The resolution status, either blocking the content or warning."]
            #[serde(rename = "resolution")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub resolution: HeavyAdResolutionStatus,
            #[doc = "The reason the ad was blocked, total network or cpu or peak cpu."]
            #[serde(rename = "reason")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub reason: HeavyAdReason,
            #[doc = "The frame that was blocked."]
            #[serde(rename = "frame")]
            pub frame: AffectedFrame,
        }
        impl HeavyAdIssueDetails {
            pub fn new(
                resolution: impl Into<HeavyAdResolutionStatus>,
                reason: impl Into<HeavyAdReason>,
                frame: impl Into<AffectedFrame>,
            ) -> Self {
                Self {
                    resolution: resolution.into(),
                    reason: reason.into(),
                    frame: frame.into(),
                }
            }
        }
        impl HeavyAdIssueDetails {
            pub fn builder() -> HeavyAdIssueDetailsBuilder {
                HeavyAdIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct HeavyAdIssueDetailsBuilder {
            resolution: Option<HeavyAdResolutionStatus>,
            reason: Option<HeavyAdReason>,
            frame: Option<AffectedFrame>,
        }
        impl HeavyAdIssueDetailsBuilder {
            pub fn resolution(mut self, resolution: impl Into<HeavyAdResolutionStatus>) -> Self {
                self.resolution = Some(resolution.into());
                self
            }
            pub fn reason(mut self, reason: impl Into<HeavyAdReason>) -> Self {
                self.reason = Some(reason.into());
                self
            }
            pub fn frame(mut self, frame: impl Into<AffectedFrame>) -> Self {
                self.frame = Some(frame.into());
                self
            }
            pub fn build(self) -> Result<HeavyAdIssueDetails, String> {
                Ok(HeavyAdIssueDetails {
                    resolution: self.resolution.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(resolution))
                    })?,
                    reason: self.reason.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(reason))
                    })?,
                    frame: self.frame.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame))
                    })?,
                })
            }
        }
        impl HeavyAdIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.HeavyAdIssueDetails";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ContentSecurityPolicyViolationType {
            #[serde(rename = "kInlineViolation")]
            KInlineViolation,
            #[serde(rename = "kEvalViolation")]
            KEvalViolation,
            #[serde(rename = "kURLViolation")]
            KUrlViolation,
            #[serde(rename = "kTrustedTypesSinkViolation")]
            KTrustedTypesSinkViolation,
            #[serde(rename = "kTrustedTypesPolicyViolation")]
            KTrustedTypesPolicyViolation,
            #[serde(rename = "kWasmEvalViolation")]
            KWasmEvalViolation,
        }
        impl AsRef<str> for ContentSecurityPolicyViolationType {
            fn as_ref(&self) -> &str {
                match self {
                    ContentSecurityPolicyViolationType::KInlineViolation => "kInlineViolation",
                    ContentSecurityPolicyViolationType::KEvalViolation => "kEvalViolation",
                    ContentSecurityPolicyViolationType::KUrlViolation => "kURLViolation",
                    ContentSecurityPolicyViolationType::KTrustedTypesSinkViolation => {
                        "kTrustedTypesSinkViolation"
                    }
                    ContentSecurityPolicyViolationType::KTrustedTypesPolicyViolation => {
                        "kTrustedTypesPolicyViolation"
                    }
                    ContentSecurityPolicyViolationType::KWasmEvalViolation => "kWasmEvalViolation",
                }
            }
        }
        impl ::std::str::FromStr for ContentSecurityPolicyViolationType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "kInlineViolation" | "KInlineViolation" | "kinlineviolation" => {
                        Ok(ContentSecurityPolicyViolationType::KInlineViolation)
                    }
                    "kEvalViolation" | "KEvalViolation" | "kevalviolation" => {
                        Ok(ContentSecurityPolicyViolationType::KEvalViolation)
                    }
                    "kURLViolation" | "KUrlViolation" | "kurlviolation" => {
                        Ok(ContentSecurityPolicyViolationType::KUrlViolation)
                    }
                    "kTrustedTypesSinkViolation"
                    | "KTrustedTypesSinkViolation"
                    | "ktrustedtypessinkviolation" => {
                        Ok(ContentSecurityPolicyViolationType::KTrustedTypesSinkViolation)
                    }
                    "kTrustedTypesPolicyViolation"
                    | "KTrustedTypesPolicyViolation"
                    | "ktrustedtypespolicyviolation" => {
                        Ok(ContentSecurityPolicyViolationType::KTrustedTypesPolicyViolation)
                    }
                    "kWasmEvalViolation" | "KWasmEvalViolation" | "kwasmevalviolation" => {
                        Ok(ContentSecurityPolicyViolationType::KWasmEvalViolation)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SourceCodeLocation {
            #[serde(rename = "scriptId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub script_id: Option<super::super::js_protocol::runtime::ScriptId>,
            #[serde(rename = "url")]
            pub url: String,
            #[serde(rename = "lineNumber")]
            pub line_number: i64,
            #[serde(rename = "columnNumber")]
            pub column_number: i64,
        }
        impl SourceCodeLocation {
            pub fn new(
                url: impl Into<String>,
                line_number: impl Into<i64>,
                column_number: impl Into<i64>,
            ) -> Self {
                Self {
                    url: url.into(),
                    line_number: line_number.into(),
                    column_number: column_number.into(),
                    script_id: None,
                }
            }
        }
        impl SourceCodeLocation {
            pub fn builder() -> SourceCodeLocationBuilder {
                SourceCodeLocationBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SourceCodeLocationBuilder {
            script_id: Option<super::super::js_protocol::runtime::ScriptId>,
            url: Option<String>,
            line_number: Option<i64>,
            column_number: Option<i64>,
        }
        impl SourceCodeLocationBuilder {
            pub fn script_id(
                mut self,
                script_id: impl Into<super::super::js_protocol::runtime::ScriptId>,
            ) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn line_number(mut self, line_number: impl Into<i64>) -> Self {
                self.line_number = Some(line_number.into());
                self
            }
            pub fn column_number(mut self, column_number: impl Into<i64>) -> Self {
                self.column_number = Some(column_number.into());
                self
            }
            pub fn build(self) -> Result<SourceCodeLocation, String> {
                Ok(SourceCodeLocation {
                    script_id: self.script_id,
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    line_number: self.line_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line_number))
                    })?,
                    column_number: self.column_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(column_number))
                    })?,
                })
            }
        }
        impl SourceCodeLocation {
            pub const IDENTIFIER: &'static str = "Audits.SourceCodeLocation";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ContentSecurityPolicyIssueDetails {
            #[doc = "The url not included in allowed sources."]
            #[serde(rename = "blockedURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub blocked_url: Option<String>,
            #[doc = "Specific directive that is violated, causing the CSP issue."]
            #[serde(rename = "violatedDirective")]
            pub violated_directive: String,
            #[serde(rename = "isReportOnly")]
            pub is_report_only: bool,
            #[serde(rename = "contentSecurityPolicyViolationType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub content_security_policy_violation_type: ContentSecurityPolicyViolationType,
            #[serde(rename = "frameAncestor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_ancestor: Option<AffectedFrame>,
            #[serde(rename = "sourceCodeLocation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub source_code_location: Option<SourceCodeLocation>,
            #[serde(rename = "violatingNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub violating_node_id: Option<super::dom::BackendNodeId>,
        }
        impl ContentSecurityPolicyIssueDetails {
            pub fn new(
                violated_directive: impl Into<String>,
                is_report_only: impl Into<bool>,
                content_security_policy_violation_type: impl Into<ContentSecurityPolicyViolationType>,
            ) -> Self {
                Self {
                    violated_directive: violated_directive.into(),
                    is_report_only: is_report_only.into(),
                    content_security_policy_violation_type: content_security_policy_violation_type
                        .into(),
                    blocked_url: None,
                    frame_ancestor: None,
                    source_code_location: None,
                    violating_node_id: None,
                }
            }
        }
        impl ContentSecurityPolicyIssueDetails {
            pub fn builder() -> ContentSecurityPolicyIssueDetailsBuilder {
                ContentSecurityPolicyIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ContentSecurityPolicyIssueDetailsBuilder {
            blocked_url: Option<String>,
            violated_directive: Option<String>,
            is_report_only: Option<bool>,
            content_security_policy_violation_type: Option<ContentSecurityPolicyViolationType>,
            frame_ancestor: Option<AffectedFrame>,
            source_code_location: Option<SourceCodeLocation>,
            violating_node_id: Option<super::dom::BackendNodeId>,
        }
        impl ContentSecurityPolicyIssueDetailsBuilder {
            pub fn blocked_url(mut self, blocked_url: impl Into<String>) -> Self {
                self.blocked_url = Some(blocked_url.into());
                self
            }
            pub fn violated_directive(mut self, violated_directive: impl Into<String>) -> Self {
                self.violated_directive = Some(violated_directive.into());
                self
            }
            pub fn is_report_only(mut self, is_report_only: impl Into<bool>) -> Self {
                self.is_report_only = Some(is_report_only.into());
                self
            }
            pub fn content_security_policy_violation_type(
                mut self,
                content_security_policy_violation_type: impl Into<ContentSecurityPolicyViolationType>,
            ) -> Self {
                self.content_security_policy_violation_type =
                    Some(content_security_policy_violation_type.into());
                self
            }
            pub fn frame_ancestor(mut self, frame_ancestor: impl Into<AffectedFrame>) -> Self {
                self.frame_ancestor = Some(frame_ancestor.into());
                self
            }
            pub fn source_code_location(
                mut self,
                source_code_location: impl Into<SourceCodeLocation>,
            ) -> Self {
                self.source_code_location = Some(source_code_location.into());
                self
            }
            pub fn violating_node_id(
                mut self,
                violating_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.violating_node_id = Some(violating_node_id.into());
                self
            }
            pub fn build(self) -> Result<ContentSecurityPolicyIssueDetails, String> {
                Ok(ContentSecurityPolicyIssueDetails {
                    blocked_url: self.blocked_url,
                    violated_directive: self.violated_directive.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(violated_directive)
                        )
                    })?,
                    is_report_only: self.is_report_only.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(is_report_only))
                    })?,
                    content_security_policy_violation_type: self
                        .content_security_policy_violation_type
                        .ok_or_else(|| {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(content_security_policy_violation_type)
                            )
                        })?,
                    frame_ancestor: self.frame_ancestor,
                    source_code_location: self.source_code_location,
                    violating_node_id: self.violating_node_id,
                })
            }
        }
        impl ContentSecurityPolicyIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.ContentSecurityPolicyIssueDetails";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SharedArrayBufferIssueType {
            #[serde(rename = "TransferIssue")]
            TransferIssue,
            #[serde(rename = "CreationIssue")]
            CreationIssue,
        }
        impl AsRef<str> for SharedArrayBufferIssueType {
            fn as_ref(&self) -> &str {
                match self {
                    SharedArrayBufferIssueType::TransferIssue => "TransferIssue",
                    SharedArrayBufferIssueType::CreationIssue => "CreationIssue",
                }
            }
        }
        impl ::std::str::FromStr for SharedArrayBufferIssueType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "TransferIssue" | "transferissue" => {
                        Ok(SharedArrayBufferIssueType::TransferIssue)
                    }
                    "CreationIssue" | "creationissue" => {
                        Ok(SharedArrayBufferIssueType::CreationIssue)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Details for a issue arising from an SAB being instantiated in, or\ntransferred to a context that is not cross-origin isolated.\n[SharedArrayBufferIssueDetails](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-SharedArrayBufferIssueDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SharedArrayBufferIssueDetails {
            #[serde(rename = "sourceCodeLocation")]
            pub source_code_location: SourceCodeLocation,
            #[serde(rename = "isWarning")]
            pub is_warning: bool,
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: SharedArrayBufferIssueType,
        }
        impl SharedArrayBufferIssueDetails {
            pub fn new(
                source_code_location: impl Into<SourceCodeLocation>,
                is_warning: impl Into<bool>,
                r#type: impl Into<SharedArrayBufferIssueType>,
            ) -> Self {
                Self {
                    source_code_location: source_code_location.into(),
                    is_warning: is_warning.into(),
                    r#type: r#type.into(),
                }
            }
        }
        impl SharedArrayBufferIssueDetails {
            pub fn builder() -> SharedArrayBufferIssueDetailsBuilder {
                SharedArrayBufferIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SharedArrayBufferIssueDetailsBuilder {
            source_code_location: Option<SourceCodeLocation>,
            is_warning: Option<bool>,
            r#type: Option<SharedArrayBufferIssueType>,
        }
        impl SharedArrayBufferIssueDetailsBuilder {
            pub fn source_code_location(
                mut self,
                source_code_location: impl Into<SourceCodeLocation>,
            ) -> Self {
                self.source_code_location = Some(source_code_location.into());
                self
            }
            pub fn is_warning(mut self, is_warning: impl Into<bool>) -> Self {
                self.is_warning = Some(is_warning.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<SharedArrayBufferIssueType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn build(self) -> Result<SharedArrayBufferIssueDetails, String> {
                Ok(SharedArrayBufferIssueDetails {
                    source_code_location: self.source_code_location.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(source_code_location)
                        )
                    })?,
                    is_warning: self.is_warning.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(is_warning))
                    })?,
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                })
            }
        }
        impl SharedArrayBufferIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.SharedArrayBufferIssueDetails";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum TwaQualityEnforcementViolationType {
            #[serde(rename = "kHttpError")]
            KHttpError,
            #[serde(rename = "kUnavailableOffline")]
            KUnavailableOffline,
            #[serde(rename = "kDigitalAssetLinks")]
            KDigitalAssetLinks,
        }
        impl AsRef<str> for TwaQualityEnforcementViolationType {
            fn as_ref(&self) -> &str {
                match self {
                    TwaQualityEnforcementViolationType::KHttpError => "kHttpError",
                    TwaQualityEnforcementViolationType::KUnavailableOffline => {
                        "kUnavailableOffline"
                    }
                    TwaQualityEnforcementViolationType::KDigitalAssetLinks => "kDigitalAssetLinks",
                }
            }
        }
        impl ::std::str::FromStr for TwaQualityEnforcementViolationType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "kHttpError" | "KHttpError" | "khttperror" => {
                        Ok(TwaQualityEnforcementViolationType::KHttpError)
                    }
                    "kUnavailableOffline" | "KUnavailableOffline" | "kunavailableoffline" => {
                        Ok(TwaQualityEnforcementViolationType::KUnavailableOffline)
                    }
                    "kDigitalAssetLinks" | "KDigitalAssetLinks" | "kdigitalassetlinks" => {
                        Ok(TwaQualityEnforcementViolationType::KDigitalAssetLinks)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TrustedWebActivityIssueDetails {
            #[doc = "The url that triggers the violation."]
            #[serde(rename = "url")]
            pub url: String,
            #[serde(rename = "violationType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub violation_type: TwaQualityEnforcementViolationType,
            #[serde(rename = "httpStatusCode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub http_status_code: Option<i64>,
            #[doc = "The package name of the Trusted Web Activity client app. This field is\nonly used when violation type is kDigitalAssetLinks."]
            #[serde(rename = "packageName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub package_name: Option<String>,
            #[doc = "The signature of the Trusted Web Activity client app. This field is only\nused when violation type is kDigitalAssetLinks."]
            #[serde(rename = "signature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub signature: Option<String>,
        }
        impl TrustedWebActivityIssueDetails {
            pub fn new(
                url: impl Into<String>,
                violation_type: impl Into<TwaQualityEnforcementViolationType>,
            ) -> Self {
                Self {
                    url: url.into(),
                    violation_type: violation_type.into(),
                    http_status_code: None,
                    package_name: None,
                    signature: None,
                }
            }
        }
        impl TrustedWebActivityIssueDetails {
            pub fn builder() -> TrustedWebActivityIssueDetailsBuilder {
                TrustedWebActivityIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TrustedWebActivityIssueDetailsBuilder {
            url: Option<String>,
            violation_type: Option<TwaQualityEnforcementViolationType>,
            http_status_code: Option<i64>,
            package_name: Option<String>,
            signature: Option<String>,
        }
        impl TrustedWebActivityIssueDetailsBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn violation_type(
                mut self,
                violation_type: impl Into<TwaQualityEnforcementViolationType>,
            ) -> Self {
                self.violation_type = Some(violation_type.into());
                self
            }
            pub fn http_status_code(mut self, http_status_code: impl Into<i64>) -> Self {
                self.http_status_code = Some(http_status_code.into());
                self
            }
            pub fn package_name(mut self, package_name: impl Into<String>) -> Self {
                self.package_name = Some(package_name.into());
                self
            }
            pub fn signature(mut self, signature: impl Into<String>) -> Self {
                self.signature = Some(signature.into());
                self
            }
            pub fn build(self) -> Result<TrustedWebActivityIssueDetails, String> {
                Ok(TrustedWebActivityIssueDetails {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    violation_type: self.violation_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(violation_type))
                    })?,
                    http_status_code: self.http_status_code,
                    package_name: self.package_name,
                    signature: self.signature,
                })
            }
        }
        impl TrustedWebActivityIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.TrustedWebActivityIssueDetails";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LowTextContrastIssueDetails {
            #[serde(rename = "violatingNodeId")]
            pub violating_node_id: super::dom::BackendNodeId,
            #[serde(rename = "violatingNodeSelector")]
            pub violating_node_selector: String,
            #[serde(rename = "contrastRatio")]
            pub contrast_ratio: f64,
            #[serde(rename = "thresholdAA")]
            pub threshold_aa: f64,
            #[serde(rename = "thresholdAAA")]
            pub threshold_aaa: f64,
            #[serde(rename = "fontSize")]
            pub font_size: String,
            #[serde(rename = "fontWeight")]
            pub font_weight: String,
        }
        impl LowTextContrastIssueDetails {
            pub fn builder() -> LowTextContrastIssueDetailsBuilder {
                LowTextContrastIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LowTextContrastIssueDetailsBuilder {
            violating_node_id: Option<super::dom::BackendNodeId>,
            violating_node_selector: Option<String>,
            contrast_ratio: Option<f64>,
            threshold_aa: Option<f64>,
            threshold_aaa: Option<f64>,
            font_size: Option<String>,
            font_weight: Option<String>,
        }
        impl LowTextContrastIssueDetailsBuilder {
            pub fn violating_node_id(
                mut self,
                violating_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.violating_node_id = Some(violating_node_id.into());
                self
            }
            pub fn violating_node_selector(
                mut self,
                violating_node_selector: impl Into<String>,
            ) -> Self {
                self.violating_node_selector = Some(violating_node_selector.into());
                self
            }
            pub fn contrast_ratio(mut self, contrast_ratio: impl Into<f64>) -> Self {
                self.contrast_ratio = Some(contrast_ratio.into());
                self
            }
            pub fn threshold_aa(mut self, threshold_aa: impl Into<f64>) -> Self {
                self.threshold_aa = Some(threshold_aa.into());
                self
            }
            pub fn threshold_aaa(mut self, threshold_aaa: impl Into<f64>) -> Self {
                self.threshold_aaa = Some(threshold_aaa.into());
                self
            }
            pub fn font_size(mut self, font_size: impl Into<String>) -> Self {
                self.font_size = Some(font_size.into());
                self
            }
            pub fn font_weight(mut self, font_weight: impl Into<String>) -> Self {
                self.font_weight = Some(font_weight.into());
                self
            }
            pub fn build(self) -> Result<LowTextContrastIssueDetails, String> {
                Ok(LowTextContrastIssueDetails {
                    violating_node_id: self.violating_node_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(violating_node_id)
                        )
                    })?,
                    violating_node_selector: self.violating_node_selector.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(violating_node_selector)
                        )
                    })?,
                    contrast_ratio: self.contrast_ratio.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(contrast_ratio))
                    })?,
                    threshold_aa: self.threshold_aa.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(threshold_aa))
                    })?,
                    threshold_aaa: self.threshold_aaa.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(threshold_aaa))
                    })?,
                    font_size: self.font_size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(font_size))
                    })?,
                    font_weight: self.font_weight.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(font_weight))
                    })?,
                })
            }
        }
        impl LowTextContrastIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.LowTextContrastIssueDetails";
        }
        #[doc = "Details for a CORS related issue, e.g. a warning or error related to\nCORS RFC1918 enforcement.\n[CorsIssueDetails](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-CorsIssueDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CorsIssueDetails {
            #[serde(rename = "corsErrorStatus")]
            pub cors_error_status: super::network::CorsErrorStatus,
            #[serde(rename = "isWarning")]
            pub is_warning: bool,
            #[serde(rename = "request")]
            pub request: AffectedRequest,
            #[serde(rename = "location")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub location: Option<SourceCodeLocation>,
            #[serde(rename = "initiatorOrigin")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub initiator_origin: Option<String>,
            #[serde(rename = "resourceIPAddressSpace")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub resource_ip_address_space: Option<super::network::IpAddressSpace>,
            #[serde(rename = "clientSecurityState")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub client_security_state: Option<super::network::ClientSecurityState>,
        }
        impl CorsIssueDetails {
            pub fn new(
                cors_error_status: impl Into<super::network::CorsErrorStatus>,
                is_warning: impl Into<bool>,
                request: impl Into<AffectedRequest>,
            ) -> Self {
                Self {
                    cors_error_status: cors_error_status.into(),
                    is_warning: is_warning.into(),
                    request: request.into(),
                    location: None,
                    initiator_origin: None,
                    resource_ip_address_space: None,
                    client_security_state: None,
                }
            }
        }
        impl CorsIssueDetails {
            pub fn builder() -> CorsIssueDetailsBuilder {
                CorsIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CorsIssueDetailsBuilder {
            cors_error_status: Option<super::network::CorsErrorStatus>,
            is_warning: Option<bool>,
            request: Option<AffectedRequest>,
            location: Option<SourceCodeLocation>,
            initiator_origin: Option<String>,
            resource_ip_address_space: Option<super::network::IpAddressSpace>,
            client_security_state: Option<super::network::ClientSecurityState>,
        }
        impl CorsIssueDetailsBuilder {
            pub fn cors_error_status(
                mut self,
                cors_error_status: impl Into<super::network::CorsErrorStatus>,
            ) -> Self {
                self.cors_error_status = Some(cors_error_status.into());
                self
            }
            pub fn is_warning(mut self, is_warning: impl Into<bool>) -> Self {
                self.is_warning = Some(is_warning.into());
                self
            }
            pub fn request(mut self, request: impl Into<AffectedRequest>) -> Self {
                self.request = Some(request.into());
                self
            }
            pub fn location(mut self, location: impl Into<SourceCodeLocation>) -> Self {
                self.location = Some(location.into());
                self
            }
            pub fn initiator_origin(mut self, initiator_origin: impl Into<String>) -> Self {
                self.initiator_origin = Some(initiator_origin.into());
                self
            }
            pub fn resource_ip_address_space(
                mut self,
                resource_ip_address_space: impl Into<super::network::IpAddressSpace>,
            ) -> Self {
                self.resource_ip_address_space = Some(resource_ip_address_space.into());
                self
            }
            pub fn client_security_state(
                mut self,
                client_security_state: impl Into<super::network::ClientSecurityState>,
            ) -> Self {
                self.client_security_state = Some(client_security_state.into());
                self
            }
            pub fn build(self) -> Result<CorsIssueDetails, String> {
                Ok(CorsIssueDetails {
                    cors_error_status: self.cors_error_status.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(cors_error_status)
                        )
                    })?,
                    is_warning: self.is_warning.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(is_warning))
                    })?,
                    request: self.request.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request))
                    })?,
                    location: self.location,
                    initiator_origin: self.initiator_origin,
                    resource_ip_address_space: self.resource_ip_address_space,
                    client_security_state: self.client_security_state,
                })
            }
        }
        impl CorsIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.CorsIssueDetails";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AttributionReportingIssueType {
            #[serde(rename = "PermissionPolicyDisabled")]
            PermissionPolicyDisabled,
            #[serde(rename = "PermissionPolicyNotDelegated")]
            PermissionPolicyNotDelegated,
            #[serde(rename = "UntrustworthyReportingOrigin")]
            UntrustworthyReportingOrigin,
            #[serde(rename = "InsecureContext")]
            InsecureContext,
            #[doc = "TODO(apaseltiner): Rename this to InvalidRegisterSourceHeader"]
            #[serde(rename = "InvalidHeader")]
            InvalidHeader,
            #[serde(rename = "InvalidRegisterTriggerHeader")]
            InvalidRegisterTriggerHeader,
            #[serde(rename = "InvalidEligibleHeader")]
            InvalidEligibleHeader,
            #[serde(rename = "TooManyConcurrentRequests")]
            TooManyConcurrentRequests,
            #[serde(rename = "SourceAndTriggerHeaders")]
            SourceAndTriggerHeaders,
            #[serde(rename = "SourceIgnored")]
            SourceIgnored,
            #[serde(rename = "TriggerIgnored")]
            TriggerIgnored,
        }
        impl AsRef<str> for AttributionReportingIssueType {
            fn as_ref(&self) -> &str {
                match self {
                    AttributionReportingIssueType::PermissionPolicyDisabled => {
                        "PermissionPolicyDisabled"
                    }
                    AttributionReportingIssueType::PermissionPolicyNotDelegated => {
                        "PermissionPolicyNotDelegated"
                    }
                    AttributionReportingIssueType::UntrustworthyReportingOrigin => {
                        "UntrustworthyReportingOrigin"
                    }
                    AttributionReportingIssueType::InsecureContext => "InsecureContext",
                    AttributionReportingIssueType::InvalidHeader => "InvalidHeader",
                    AttributionReportingIssueType::InvalidRegisterTriggerHeader => {
                        "InvalidRegisterTriggerHeader"
                    }
                    AttributionReportingIssueType::InvalidEligibleHeader => "InvalidEligibleHeader",
                    AttributionReportingIssueType::TooManyConcurrentRequests => {
                        "TooManyConcurrentRequests"
                    }
                    AttributionReportingIssueType::SourceAndTriggerHeaders => {
                        "SourceAndTriggerHeaders"
                    }
                    AttributionReportingIssueType::SourceIgnored => "SourceIgnored",
                    AttributionReportingIssueType::TriggerIgnored => "TriggerIgnored",
                }
            }
        }
        impl ::std::str::FromStr for AttributionReportingIssueType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "PermissionPolicyDisabled" | "permissionpolicydisabled" => {
                        Ok(AttributionReportingIssueType::PermissionPolicyDisabled)
                    }
                    "PermissionPolicyNotDelegated" | "permissionpolicynotdelegated" => {
                        Ok(AttributionReportingIssueType::PermissionPolicyNotDelegated)
                    }
                    "UntrustworthyReportingOrigin" | "untrustworthyreportingorigin" => {
                        Ok(AttributionReportingIssueType::UntrustworthyReportingOrigin)
                    }
                    "InsecureContext" | "insecurecontext" => {
                        Ok(AttributionReportingIssueType::InsecureContext)
                    }
                    "InvalidHeader" | "invalidheader" => {
                        Ok(AttributionReportingIssueType::InvalidHeader)
                    }
                    "InvalidRegisterTriggerHeader" | "invalidregistertriggerheader" => {
                        Ok(AttributionReportingIssueType::InvalidRegisterTriggerHeader)
                    }
                    "InvalidEligibleHeader" | "invalideligibleheader" => {
                        Ok(AttributionReportingIssueType::InvalidEligibleHeader)
                    }
                    "TooManyConcurrentRequests" | "toomanyconcurrentrequests" => {
                        Ok(AttributionReportingIssueType::TooManyConcurrentRequests)
                    }
                    "SourceAndTriggerHeaders" | "sourceandtriggerheaders" => {
                        Ok(AttributionReportingIssueType::SourceAndTriggerHeaders)
                    }
                    "SourceIgnored" | "sourceignored" => {
                        Ok(AttributionReportingIssueType::SourceIgnored)
                    }
                    "TriggerIgnored" | "triggerignored" => {
                        Ok(AttributionReportingIssueType::TriggerIgnored)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Details for issues around \"Attribution Reporting API\" usage.\nExplainer: https://github.com/WICG/attribution-reporting-api\n[AttributionReportingIssueDetails](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-AttributionReportingIssueDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AttributionReportingIssueDetails {
            #[serde(rename = "violationType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub violation_type: AttributionReportingIssueType,
            #[serde(rename = "request")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub request: Option<AffectedRequest>,
            #[serde(rename = "violatingNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub violating_node_id: Option<super::dom::BackendNodeId>,
            #[serde(rename = "invalidParameter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub invalid_parameter: Option<String>,
        }
        impl AttributionReportingIssueDetails {
            pub fn new(violation_type: impl Into<AttributionReportingIssueType>) -> Self {
                Self {
                    violation_type: violation_type.into(),
                    request: None,
                    violating_node_id: None,
                    invalid_parameter: None,
                }
            }
        }
        impl AttributionReportingIssueDetails {
            pub fn builder() -> AttributionReportingIssueDetailsBuilder {
                AttributionReportingIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AttributionReportingIssueDetailsBuilder {
            violation_type: Option<AttributionReportingIssueType>,
            request: Option<AffectedRequest>,
            violating_node_id: Option<super::dom::BackendNodeId>,
            invalid_parameter: Option<String>,
        }
        impl AttributionReportingIssueDetailsBuilder {
            pub fn violation_type(
                mut self,
                violation_type: impl Into<AttributionReportingIssueType>,
            ) -> Self {
                self.violation_type = Some(violation_type.into());
                self
            }
            pub fn request(mut self, request: impl Into<AffectedRequest>) -> Self {
                self.request = Some(request.into());
                self
            }
            pub fn violating_node_id(
                mut self,
                violating_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.violating_node_id = Some(violating_node_id.into());
                self
            }
            pub fn invalid_parameter(mut self, invalid_parameter: impl Into<String>) -> Self {
                self.invalid_parameter = Some(invalid_parameter.into());
                self
            }
            pub fn build(self) -> Result<AttributionReportingIssueDetails, String> {
                Ok(AttributionReportingIssueDetails {
                    violation_type: self.violation_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(violation_type))
                    })?,
                    request: self.request,
                    violating_node_id: self.violating_node_id,
                    invalid_parameter: self.invalid_parameter,
                })
            }
        }
        impl AttributionReportingIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.AttributionReportingIssueDetails";
        }
        #[doc = "Details for issues about documents in Quirks Mode\nor Limited Quirks Mode that affects page layouting.\n[QuirksModeIssueDetails](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-QuirksModeIssueDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct QuirksModeIssueDetails {
            #[doc = "If false, it means the document's mode is \"quirks\"\ninstead of \"limited-quirks\"."]
            #[serde(rename = "isLimitedQuirksMode")]
            pub is_limited_quirks_mode: bool,
            #[serde(rename = "documentNodeId")]
            pub document_node_id: super::dom::BackendNodeId,
            #[serde(rename = "url")]
            pub url: String,
            #[serde(rename = "frameId")]
            pub frame_id: super::page::FrameId,
            #[serde(rename = "loaderId")]
            pub loader_id: super::network::LoaderId,
        }
        impl QuirksModeIssueDetails {
            pub fn builder() -> QuirksModeIssueDetailsBuilder {
                QuirksModeIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct QuirksModeIssueDetailsBuilder {
            is_limited_quirks_mode: Option<bool>,
            document_node_id: Option<super::dom::BackendNodeId>,
            url: Option<String>,
            frame_id: Option<super::page::FrameId>,
            loader_id: Option<super::network::LoaderId>,
        }
        impl QuirksModeIssueDetailsBuilder {
            pub fn is_limited_quirks_mode(
                mut self,
                is_limited_quirks_mode: impl Into<bool>,
            ) -> Self {
                self.is_limited_quirks_mode = Some(is_limited_quirks_mode.into());
                self
            }
            pub fn document_node_id(
                mut self,
                document_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.document_node_id = Some(document_node_id.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn loader_id(mut self, loader_id: impl Into<super::network::LoaderId>) -> Self {
                self.loader_id = Some(loader_id.into());
                self
            }
            pub fn build(self) -> Result<QuirksModeIssueDetails, String> {
                Ok(QuirksModeIssueDetails {
                    is_limited_quirks_mode: self.is_limited_quirks_mode.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(is_limited_quirks_mode)
                        )
                    })?,
                    document_node_id: self.document_node_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(document_node_id)
                        )
                    })?,
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                    loader_id: self.loader_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(loader_id))
                    })?,
                })
            }
        }
        impl QuirksModeIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.QuirksModeIssueDetails";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct NavigatorUserAgentIssueDetails {
            #[serde(rename = "url")]
            pub url: String,
            #[serde(rename = "location")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub location: Option<SourceCodeLocation>,
        }
        impl NavigatorUserAgentIssueDetails {
            pub fn new(url: impl Into<String>) -> Self {
                Self {
                    url: url.into(),
                    location: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for NavigatorUserAgentIssueDetails {
            fn from(url: T) -> Self {
                NavigatorUserAgentIssueDetails::new(url)
            }
        }
        impl NavigatorUserAgentIssueDetails {
            pub fn builder() -> NavigatorUserAgentIssueDetailsBuilder {
                NavigatorUserAgentIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct NavigatorUserAgentIssueDetailsBuilder {
            url: Option<String>,
            location: Option<SourceCodeLocation>,
        }
        impl NavigatorUserAgentIssueDetailsBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn location(mut self, location: impl Into<SourceCodeLocation>) -> Self {
                self.location = Some(location.into());
                self
            }
            pub fn build(self) -> Result<NavigatorUserAgentIssueDetails, String> {
                Ok(NavigatorUserAgentIssueDetails {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    location: self.location,
                })
            }
        }
        impl NavigatorUserAgentIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.NavigatorUserAgentIssueDetails";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum GenericIssueErrorType {
            #[serde(rename = "CrossOriginPortalPostMessageError")]
            CrossOriginPortalPostMessageError,
        }
        impl AsRef<str> for GenericIssueErrorType {
            fn as_ref(&self) -> &str {
                match self {
                    GenericIssueErrorType::CrossOriginPortalPostMessageError => {
                        "CrossOriginPortalPostMessageError"
                    }
                }
            }
        }
        impl ::std::str::FromStr for GenericIssueErrorType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "CrossOriginPortalPostMessageError" | "crossoriginportalpostmessageerror" => {
                        Ok(GenericIssueErrorType::CrossOriginPortalPostMessageError)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Depending on the concrete errorType, different properties are set.\n[GenericIssueDetails](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-GenericIssueDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GenericIssueDetails {
            #[doc = "Issues with the same errorType are aggregated in the frontend."]
            #[serde(rename = "errorType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub error_type: GenericIssueErrorType,
            #[serde(rename = "frameId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_id: Option<super::page::FrameId>,
        }
        impl GenericIssueDetails {
            pub fn new(error_type: impl Into<GenericIssueErrorType>) -> Self {
                Self {
                    error_type: error_type.into(),
                    frame_id: None,
                }
            }
        }
        impl GenericIssueDetails {
            pub fn builder() -> GenericIssueDetailsBuilder {
                GenericIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GenericIssueDetailsBuilder {
            error_type: Option<GenericIssueErrorType>,
            frame_id: Option<super::page::FrameId>,
        }
        impl GenericIssueDetailsBuilder {
            pub fn error_type(mut self, error_type: impl Into<GenericIssueErrorType>) -> Self {
                self.error_type = Some(error_type.into());
                self
            }
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn build(self) -> Result<GenericIssueDetails, String> {
                Ok(GenericIssueDetails {
                    error_type: self.error_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(error_type))
                    })?,
                    frame_id: self.frame_id,
                })
            }
        }
        impl GenericIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.GenericIssueDetails";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum DeprecationIssueType {
            #[serde(rename = "AuthorizationCoveredByWildcard")]
            AuthorizationCoveredByWildcard,
            #[serde(rename = "CanRequestURLHTTPContainingNewline")]
            CanRequestUrlhttpContainingNewline,
            #[serde(rename = "ChromeLoadTimesConnectionInfo")]
            ChromeLoadTimesConnectionInfo,
            #[serde(rename = "ChromeLoadTimesFirstPaintAfterLoadTime")]
            ChromeLoadTimesFirstPaintAfterLoadTime,
            #[serde(rename = "ChromeLoadTimesWasAlternateProtocolAvailable")]
            ChromeLoadTimesWasAlternateProtocolAvailable,
            #[serde(rename = "CookieWithTruncatingChar")]
            CookieWithTruncatingChar,
            #[serde(rename = "CrossOriginAccessBasedOnDocumentDomain")]
            CrossOriginAccessBasedOnDocumentDomain,
            #[serde(rename = "CrossOriginWindowAlert")]
            CrossOriginWindowAlert,
            #[serde(rename = "CrossOriginWindowConfirm")]
            CrossOriginWindowConfirm,
            #[serde(rename = "CSSSelectorInternalMediaControlsOverlayCastButton")]
            CssSelectorInternalMediaControlsOverlayCastButton,
            #[serde(rename = "DeprecationExample")]
            DeprecationExample,
            #[serde(rename = "DocumentDomainSettingWithoutOriginAgentClusterHeader")]
            DocumentDomainSettingWithoutOriginAgentClusterHeader,
            #[serde(rename = "EventPath")]
            EventPath,
            #[serde(rename = "ExpectCTHeader")]
            ExpectCtHeader,
            #[serde(rename = "GeolocationInsecureOrigin")]
            GeolocationInsecureOrigin,
            #[serde(rename = "GeolocationInsecureOriginDeprecatedNotRemoved")]
            GeolocationInsecureOriginDeprecatedNotRemoved,
            #[serde(rename = "GetUserMediaInsecureOrigin")]
            GetUserMediaInsecureOrigin,
            #[serde(rename = "HostCandidateAttributeGetter")]
            HostCandidateAttributeGetter,
            #[serde(rename = "IdentityInCanMakePaymentEvent")]
            IdentityInCanMakePaymentEvent,
            #[serde(rename = "InsecurePrivateNetworkSubresourceRequest")]
            InsecurePrivateNetworkSubresourceRequest,
            #[serde(rename = "LegacyConstraintGoogIPv6")]
            LegacyConstraintGoogIPv6,
            #[serde(rename = "LocalCSSFileExtensionRejected")]
            LocalCssFileExtensionRejected,
            #[serde(rename = "MediaSourceAbortRemove")]
            MediaSourceAbortRemove,
            #[serde(rename = "MediaSourceDurationTruncatingBuffered")]
            MediaSourceDurationTruncatingBuffered,
            #[serde(rename = "NavigateEventRestoreScroll")]
            NavigateEventRestoreScroll,
            #[serde(rename = "NavigateEventTransitionWhile")]
            NavigateEventTransitionWhile,
            #[serde(rename = "NoSysexWebMIDIWithoutPermission")]
            NoSysexWebMidiWithoutPermission,
            #[serde(rename = "NotificationInsecureOrigin")]
            NotificationInsecureOrigin,
            #[serde(rename = "NotificationPermissionRequestedIframe")]
            NotificationPermissionRequestedIframe,
            #[serde(rename = "ObsoleteWebRtcCipherSuite")]
            ObsoleteWebRtcCipherSuite,
            #[serde(rename = "OpenWebDatabaseInsecureContext")]
            OpenWebDatabaseInsecureContext,
            #[serde(rename = "OverflowVisibleOnReplacedElement")]
            OverflowVisibleOnReplacedElement,
            #[serde(rename = "PersistentQuotaType")]
            PersistentQuotaType,
            #[serde(rename = "PictureSourceSrc")]
            PictureSourceSrc,
            #[serde(rename = "PrefixedCancelAnimationFrame")]
            PrefixedCancelAnimationFrame,
            #[serde(rename = "PrefixedRequestAnimationFrame")]
            PrefixedRequestAnimationFrame,
            #[serde(rename = "PrefixedStorageInfo")]
            PrefixedStorageInfo,
            #[serde(rename = "PrefixedVideoDisplayingFullscreen")]
            PrefixedVideoDisplayingFullscreen,
            #[serde(rename = "PrefixedVideoEnterFullscreen")]
            PrefixedVideoEnterFullscreen,
            #[serde(rename = "PrefixedVideoEnterFullScreen")]
            PrefixedVideoEnterFullScreen,
            #[serde(rename = "PrefixedVideoExitFullscreen")]
            PrefixedVideoExitFullscreen,
            #[serde(rename = "PrefixedVideoExitFullScreen")]
            PrefixedVideoExitFullScreen,
            #[serde(rename = "PrefixedVideoSupportsFullscreen")]
            PrefixedVideoSupportsFullscreen,
            #[serde(rename = "RangeExpand")]
            RangeExpand,
            #[serde(rename = "RequestedSubresourceWithEmbeddedCredentials")]
            RequestedSubresourceWithEmbeddedCredentials,
            #[serde(rename = "RTCConstraintEnableDtlsSrtpFalse")]
            RtcConstraintEnableDtlsSrtpFalse,
            #[serde(rename = "RTCConstraintEnableDtlsSrtpTrue")]
            RtcConstraintEnableDtlsSrtpTrue,
            #[serde(rename = "RTCPeerConnectionComplexPlanBSdpUsingDefaultSdpSemantics")]
            RtcPeerConnectionComplexPlanBSdpUsingDefaultSdpSemantics,
            #[serde(rename = "RTCPeerConnectionSdpSemanticsPlanB")]
            RtcPeerConnectionSdpSemanticsPlanB,
            #[serde(rename = "RtcpMuxPolicyNegotiate")]
            RtcpMuxPolicyNegotiate,
            #[serde(rename = "SharedArrayBufferConstructedWithoutIsolation")]
            SharedArrayBufferConstructedWithoutIsolation,
            #[serde(rename = "TextToSpeech_DisallowedByAutoplay")]
            TextToSpeechDisallowedByAutoplay,
            #[serde(rename = "V8SharedArrayBufferConstructedInExtensionWithoutIsolation")]
            V8SharedArrayBufferConstructedInExtensionWithoutIsolation,
            #[serde(rename = "XHRJSONEncodingDetection")]
            XhrjsonEncodingDetection,
            #[serde(rename = "XMLHttpRequestSynchronousInNonWorkerOutsideBeforeUnload")]
            XmlHttpRequestSynchronousInNonWorkerOutsideBeforeUnload,
            #[serde(rename = "XRSupportsSession")]
            XrSupportsSession,
        }
        impl AsRef<str> for DeprecationIssueType {
            fn as_ref(&self) -> &str {
                match self { DeprecationIssueType :: AuthorizationCoveredByWildcard => "AuthorizationCoveredByWildcard" , DeprecationIssueType :: CanRequestUrlhttpContainingNewline => "CanRequestURLHTTPContainingNewline" , DeprecationIssueType :: ChromeLoadTimesConnectionInfo => "ChromeLoadTimesConnectionInfo" , DeprecationIssueType :: ChromeLoadTimesFirstPaintAfterLoadTime => "ChromeLoadTimesFirstPaintAfterLoadTime" , DeprecationIssueType :: ChromeLoadTimesWasAlternateProtocolAvailable => "ChromeLoadTimesWasAlternateProtocolAvailable" , DeprecationIssueType :: CookieWithTruncatingChar => "CookieWithTruncatingChar" , DeprecationIssueType :: CrossOriginAccessBasedOnDocumentDomain => "CrossOriginAccessBasedOnDocumentDomain" , DeprecationIssueType :: CrossOriginWindowAlert => "CrossOriginWindowAlert" , DeprecationIssueType :: CrossOriginWindowConfirm => "CrossOriginWindowConfirm" , DeprecationIssueType :: CssSelectorInternalMediaControlsOverlayCastButton => "CSSSelectorInternalMediaControlsOverlayCastButton" , DeprecationIssueType :: DeprecationExample => "DeprecationExample" , DeprecationIssueType :: DocumentDomainSettingWithoutOriginAgentClusterHeader => "DocumentDomainSettingWithoutOriginAgentClusterHeader" , DeprecationIssueType :: EventPath => "EventPath" , DeprecationIssueType :: ExpectCtHeader => "ExpectCTHeader" , DeprecationIssueType :: GeolocationInsecureOrigin => "GeolocationInsecureOrigin" , DeprecationIssueType :: GeolocationInsecureOriginDeprecatedNotRemoved => "GeolocationInsecureOriginDeprecatedNotRemoved" , DeprecationIssueType :: GetUserMediaInsecureOrigin => "GetUserMediaInsecureOrigin" , DeprecationIssueType :: HostCandidateAttributeGetter => "HostCandidateAttributeGetter" , DeprecationIssueType :: IdentityInCanMakePaymentEvent => "IdentityInCanMakePaymentEvent" , DeprecationIssueType :: InsecurePrivateNetworkSubresourceRequest => "InsecurePrivateNetworkSubresourceRequest" , DeprecationIssueType :: LegacyConstraintGoogIPv6 => "LegacyConstraintGoogIPv6" , DeprecationIssueType :: LocalCssFileExtensionRejected => "LocalCSSFileExtensionRejected" , DeprecationIssueType :: MediaSourceAbortRemove => "MediaSourceAbortRemove" , DeprecationIssueType :: MediaSourceDurationTruncatingBuffered => "MediaSourceDurationTruncatingBuffered" , DeprecationIssueType :: NavigateEventRestoreScroll => "NavigateEventRestoreScroll" , DeprecationIssueType :: NavigateEventTransitionWhile => "NavigateEventTransitionWhile" , DeprecationIssueType :: NoSysexWebMidiWithoutPermission => "NoSysexWebMIDIWithoutPermission" , DeprecationIssueType :: NotificationInsecureOrigin => "NotificationInsecureOrigin" , DeprecationIssueType :: NotificationPermissionRequestedIframe => "NotificationPermissionRequestedIframe" , DeprecationIssueType :: ObsoleteWebRtcCipherSuite => "ObsoleteWebRtcCipherSuite" , DeprecationIssueType :: OpenWebDatabaseInsecureContext => "OpenWebDatabaseInsecureContext" , DeprecationIssueType :: OverflowVisibleOnReplacedElement => "OverflowVisibleOnReplacedElement" , DeprecationIssueType :: PersistentQuotaType => "PersistentQuotaType" , DeprecationIssueType :: PictureSourceSrc => "PictureSourceSrc" , DeprecationIssueType :: PrefixedCancelAnimationFrame => "PrefixedCancelAnimationFrame" , DeprecationIssueType :: PrefixedRequestAnimationFrame => "PrefixedRequestAnimationFrame" , DeprecationIssueType :: PrefixedStorageInfo => "PrefixedStorageInfo" , DeprecationIssueType :: PrefixedVideoDisplayingFullscreen => "PrefixedVideoDisplayingFullscreen" , DeprecationIssueType :: PrefixedVideoEnterFullscreen => "PrefixedVideoEnterFullscreen" , DeprecationIssueType :: PrefixedVideoEnterFullScreen => "PrefixedVideoEnterFullScreen" , DeprecationIssueType :: PrefixedVideoExitFullscreen => "PrefixedVideoExitFullscreen" , DeprecationIssueType :: PrefixedVideoExitFullScreen => "PrefixedVideoExitFullScreen" , DeprecationIssueType :: PrefixedVideoSupportsFullscreen => "PrefixedVideoSupportsFullscreen" , DeprecationIssueType :: RangeExpand => "RangeExpand" , DeprecationIssueType :: RequestedSubresourceWithEmbeddedCredentials => "RequestedSubresourceWithEmbeddedCredentials" , DeprecationIssueType :: RtcConstraintEnableDtlsSrtpFalse => "RTCConstraintEnableDtlsSrtpFalse" , DeprecationIssueType :: RtcConstraintEnableDtlsSrtpTrue => "RTCConstraintEnableDtlsSrtpTrue" , DeprecationIssueType :: RtcPeerConnectionComplexPlanBSdpUsingDefaultSdpSemantics => "RTCPeerConnectionComplexPlanBSdpUsingDefaultSdpSemantics" , DeprecationIssueType :: RtcPeerConnectionSdpSemanticsPlanB => "RTCPeerConnectionSdpSemanticsPlanB" , DeprecationIssueType :: RtcpMuxPolicyNegotiate => "RtcpMuxPolicyNegotiate" , DeprecationIssueType :: SharedArrayBufferConstructedWithoutIsolation => "SharedArrayBufferConstructedWithoutIsolation" , DeprecationIssueType :: TextToSpeechDisallowedByAutoplay => "TextToSpeech_DisallowedByAutoplay" , DeprecationIssueType :: V8SharedArrayBufferConstructedInExtensionWithoutIsolation => "V8SharedArrayBufferConstructedInExtensionWithoutIsolation" , DeprecationIssueType :: XhrjsonEncodingDetection => "XHRJSONEncodingDetection" , DeprecationIssueType :: XmlHttpRequestSynchronousInNonWorkerOutsideBeforeUnload => "XMLHttpRequestSynchronousInNonWorkerOutsideBeforeUnload" , DeprecationIssueType :: XrSupportsSession => "XRSupportsSession" }
            }
        }
        impl ::std::str::FromStr for DeprecationIssueType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s { "AuthorizationCoveredByWildcard" | "authorizationcoveredbywildcard" => Ok (DeprecationIssueType :: AuthorizationCoveredByWildcard) , "CanRequestURLHTTPContainingNewline" | "CanRequestUrlhttpContainingNewline" | "canrequesturlhttpcontainingnewline" => Ok (DeprecationIssueType :: CanRequestUrlhttpContainingNewline) , "ChromeLoadTimesConnectionInfo" | "chromeloadtimesconnectioninfo" => Ok (DeprecationIssueType :: ChromeLoadTimesConnectionInfo) , "ChromeLoadTimesFirstPaintAfterLoadTime" | "chromeloadtimesfirstpaintafterloadtime" => Ok (DeprecationIssueType :: ChromeLoadTimesFirstPaintAfterLoadTime) , "ChromeLoadTimesWasAlternateProtocolAvailable" | "chromeloadtimeswasalternateprotocolavailable" => Ok (DeprecationIssueType :: ChromeLoadTimesWasAlternateProtocolAvailable) , "CookieWithTruncatingChar" | "cookiewithtruncatingchar" => Ok (DeprecationIssueType :: CookieWithTruncatingChar) , "CrossOriginAccessBasedOnDocumentDomain" | "crossoriginaccessbasedondocumentdomain" => Ok (DeprecationIssueType :: CrossOriginAccessBasedOnDocumentDomain) , "CrossOriginWindowAlert" | "crossoriginwindowalert" => Ok (DeprecationIssueType :: CrossOriginWindowAlert) , "CrossOriginWindowConfirm" | "crossoriginwindowconfirm" => Ok (DeprecationIssueType :: CrossOriginWindowConfirm) , "CSSSelectorInternalMediaControlsOverlayCastButton" | "CssSelectorInternalMediaControlsOverlayCastButton" | "cssselectorinternalmediacontrolsoverlaycastbutton" => Ok (DeprecationIssueType :: CssSelectorInternalMediaControlsOverlayCastButton) , "DeprecationExample" | "deprecationexample" => Ok (DeprecationIssueType :: DeprecationExample) , "DocumentDomainSettingWithoutOriginAgentClusterHeader" | "documentdomainsettingwithoutoriginagentclusterheader" => Ok (DeprecationIssueType :: DocumentDomainSettingWithoutOriginAgentClusterHeader) , "EventPath" | "eventpath" => Ok (DeprecationIssueType :: EventPath) , "ExpectCTHeader" | "ExpectCtHeader" | "expectctheader" => Ok (DeprecationIssueType :: ExpectCtHeader) , "GeolocationInsecureOrigin" | "geolocationinsecureorigin" => Ok (DeprecationIssueType :: GeolocationInsecureOrigin) , "GeolocationInsecureOriginDeprecatedNotRemoved" | "geolocationinsecureorigindeprecatednotremoved" => Ok (DeprecationIssueType :: GeolocationInsecureOriginDeprecatedNotRemoved) , "GetUserMediaInsecureOrigin" | "getusermediainsecureorigin" => Ok (DeprecationIssueType :: GetUserMediaInsecureOrigin) , "HostCandidateAttributeGetter" | "hostcandidateattributegetter" => Ok (DeprecationIssueType :: HostCandidateAttributeGetter) , "IdentityInCanMakePaymentEvent" | "identityincanmakepaymentevent" => Ok (DeprecationIssueType :: IdentityInCanMakePaymentEvent) , "InsecurePrivateNetworkSubresourceRequest" | "insecureprivatenetworksubresourcerequest" => Ok (DeprecationIssueType :: InsecurePrivateNetworkSubresourceRequest) , "LegacyConstraintGoogIPv6" | "legacyconstraintgoogipv6" => Ok (DeprecationIssueType :: LegacyConstraintGoogIPv6) , "LocalCSSFileExtensionRejected" | "LocalCssFileExtensionRejected" | "localcssfileextensionrejected" => Ok (DeprecationIssueType :: LocalCssFileExtensionRejected) , "MediaSourceAbortRemove" | "mediasourceabortremove" => Ok (DeprecationIssueType :: MediaSourceAbortRemove) , "MediaSourceDurationTruncatingBuffered" | "mediasourcedurationtruncatingbuffered" => Ok (DeprecationIssueType :: MediaSourceDurationTruncatingBuffered) , "NavigateEventRestoreScroll" | "navigateeventrestorescroll" => Ok (DeprecationIssueType :: NavigateEventRestoreScroll) , "NavigateEventTransitionWhile" | "navigateeventtransitionwhile" => Ok (DeprecationIssueType :: NavigateEventTransitionWhile) , "NoSysexWebMIDIWithoutPermission" | "NoSysexWebMidiWithoutPermission" | "nosysexwebmidiwithoutpermission" => Ok (DeprecationIssueType :: NoSysexWebMidiWithoutPermission) , "NotificationInsecureOrigin" | "notificationinsecureorigin" => Ok (DeprecationIssueType :: NotificationInsecureOrigin) , "NotificationPermissionRequestedIframe" | "notificationpermissionrequestediframe" => Ok (DeprecationIssueType :: NotificationPermissionRequestedIframe) , "ObsoleteWebRtcCipherSuite" | "obsoletewebrtcciphersuite" => Ok (DeprecationIssueType :: ObsoleteWebRtcCipherSuite) , "OpenWebDatabaseInsecureContext" | "openwebdatabaseinsecurecontext" => Ok (DeprecationIssueType :: OpenWebDatabaseInsecureContext) , "OverflowVisibleOnReplacedElement" | "overflowvisibleonreplacedelement" => Ok (DeprecationIssueType :: OverflowVisibleOnReplacedElement) , "PersistentQuotaType" | "persistentquotatype" => Ok (DeprecationIssueType :: PersistentQuotaType) , "PictureSourceSrc" | "picturesourcesrc" => Ok (DeprecationIssueType :: PictureSourceSrc) , "PrefixedCancelAnimationFrame" | "prefixedcancelanimationframe" => Ok (DeprecationIssueType :: PrefixedCancelAnimationFrame) , "PrefixedRequestAnimationFrame" | "prefixedrequestanimationframe" => Ok (DeprecationIssueType :: PrefixedRequestAnimationFrame) , "PrefixedStorageInfo" | "prefixedstorageinfo" => Ok (DeprecationIssueType :: PrefixedStorageInfo) , "PrefixedVideoDisplayingFullscreen" | "prefixedvideodisplayingfullscreen" => Ok (DeprecationIssueType :: PrefixedVideoDisplayingFullscreen) , "PrefixedVideoEnterFullscreen" | "prefixedvideoenterfullscreen" => Ok (DeprecationIssueType :: PrefixedVideoEnterFullscreen) , "PrefixedVideoEnterFullScreen" | "prefixedvideoenterfullscreen" => Ok (DeprecationIssueType :: PrefixedVideoEnterFullScreen) , "PrefixedVideoExitFullscreen" | "prefixedvideoexitfullscreen" => Ok (DeprecationIssueType :: PrefixedVideoExitFullscreen) , "PrefixedVideoExitFullScreen" | "prefixedvideoexitfullscreen" => Ok (DeprecationIssueType :: PrefixedVideoExitFullScreen) , "PrefixedVideoSupportsFullscreen" | "prefixedvideosupportsfullscreen" => Ok (DeprecationIssueType :: PrefixedVideoSupportsFullscreen) , "RangeExpand" | "rangeexpand" => Ok (DeprecationIssueType :: RangeExpand) , "RequestedSubresourceWithEmbeddedCredentials" | "requestedsubresourcewithembeddedcredentials" => Ok (DeprecationIssueType :: RequestedSubresourceWithEmbeddedCredentials) , "RTCConstraintEnableDtlsSrtpFalse" | "RtcConstraintEnableDtlsSrtpFalse" | "rtcconstraintenabledtlssrtpfalse" => Ok (DeprecationIssueType :: RtcConstraintEnableDtlsSrtpFalse) , "RTCConstraintEnableDtlsSrtpTrue" | "RtcConstraintEnableDtlsSrtpTrue" | "rtcconstraintenabledtlssrtptrue" => Ok (DeprecationIssueType :: RtcConstraintEnableDtlsSrtpTrue) , "RTCPeerConnectionComplexPlanBSdpUsingDefaultSdpSemantics" | "RtcPeerConnectionComplexPlanBSdpUsingDefaultSdpSemantics" | "rtcpeerconnectioncomplexplanbsdpusingdefaultsdpsemantics" => Ok (DeprecationIssueType :: RtcPeerConnectionComplexPlanBSdpUsingDefaultSdpSemantics) , "RTCPeerConnectionSdpSemanticsPlanB" | "RtcPeerConnectionSdpSemanticsPlanB" | "rtcpeerconnectionsdpsemanticsplanb" => Ok (DeprecationIssueType :: RtcPeerConnectionSdpSemanticsPlanB) , "RtcpMuxPolicyNegotiate" | "rtcpmuxpolicynegotiate" => Ok (DeprecationIssueType :: RtcpMuxPolicyNegotiate) , "SharedArrayBufferConstructedWithoutIsolation" | "sharedarraybufferconstructedwithoutisolation" => Ok (DeprecationIssueType :: SharedArrayBufferConstructedWithoutIsolation) , "TextToSpeech_DisallowedByAutoplay" | "TextToSpeechDisallowedByAutoplay" | "texttospeech_disallowedbyautoplay" => Ok (DeprecationIssueType :: TextToSpeechDisallowedByAutoplay) , "V8SharedArrayBufferConstructedInExtensionWithoutIsolation" | "v8sharedarraybufferconstructedinextensionwithoutisolation" => Ok (DeprecationIssueType :: V8SharedArrayBufferConstructedInExtensionWithoutIsolation) , "XHRJSONEncodingDetection" | "XhrjsonEncodingDetection" | "xhrjsonencodingdetection" => Ok (DeprecationIssueType :: XhrjsonEncodingDetection) , "XMLHttpRequestSynchronousInNonWorkerOutsideBeforeUnload" | "XmlHttpRequestSynchronousInNonWorkerOutsideBeforeUnload" | "xmlhttprequestsynchronousinnonworkeroutsidebeforeunload" => Ok (DeprecationIssueType :: XmlHttpRequestSynchronousInNonWorkerOutsideBeforeUnload) , "XRSupportsSession" | "XrSupportsSession" | "xrsupportssession" => Ok (DeprecationIssueType :: XrSupportsSession) , _ => Err (s . to_string ()) }
            }
        }
        #[doc = "This issue tracks information needed to print a deprecation message.\nhttps://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/frame/third_party/blink/renderer/core/frame/deprecation/README.md\n[DeprecationIssueDetails](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-DeprecationIssueDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DeprecationIssueDetails {
            #[serde(rename = "affectedFrame")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub affected_frame: Option<AffectedFrame>,
            #[serde(rename = "sourceCodeLocation")]
            pub source_code_location: SourceCodeLocation,
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: DeprecationIssueType,
        }
        impl DeprecationIssueDetails {
            pub fn new(
                source_code_location: impl Into<SourceCodeLocation>,
                r#type: impl Into<DeprecationIssueType>,
            ) -> Self {
                Self {
                    source_code_location: source_code_location.into(),
                    r#type: r#type.into(),
                    affected_frame: None,
                }
            }
        }
        impl DeprecationIssueDetails {
            pub fn builder() -> DeprecationIssueDetailsBuilder {
                DeprecationIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DeprecationIssueDetailsBuilder {
            affected_frame: Option<AffectedFrame>,
            source_code_location: Option<SourceCodeLocation>,
            r#type: Option<DeprecationIssueType>,
        }
        impl DeprecationIssueDetailsBuilder {
            pub fn affected_frame(mut self, affected_frame: impl Into<AffectedFrame>) -> Self {
                self.affected_frame = Some(affected_frame.into());
                self
            }
            pub fn source_code_location(
                mut self,
                source_code_location: impl Into<SourceCodeLocation>,
            ) -> Self {
                self.source_code_location = Some(source_code_location.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<DeprecationIssueType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn build(self) -> Result<DeprecationIssueDetails, String> {
                Ok(DeprecationIssueDetails {
                    affected_frame: self.affected_frame,
                    source_code_location: self.source_code_location.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(source_code_location)
                        )
                    })?,
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                })
            }
        }
        impl DeprecationIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.DeprecationIssueDetails";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ClientHintIssueReason {
            #[doc = "Items in the accept-ch meta tag allow list must be valid origins.\nNo special values (e.g. self, none, and *) are permitted."]
            #[serde(rename = "MetaTagAllowListInvalidOrigin")]
            MetaTagAllowListInvalidOrigin,
            #[doc = "Only accept-ch meta tags in the original HTML sent from the server\nare respected. Any injected via javascript (or other means) are ignored."]
            #[serde(rename = "MetaTagModifiedHTML")]
            MetaTagModifiedHtml,
        }
        impl AsRef<str> for ClientHintIssueReason {
            fn as_ref(&self) -> &str {
                match self {
                    ClientHintIssueReason::MetaTagAllowListInvalidOrigin => {
                        "MetaTagAllowListInvalidOrigin"
                    }
                    ClientHintIssueReason::MetaTagModifiedHtml => "MetaTagModifiedHTML",
                }
            }
        }
        impl ::std::str::FromStr for ClientHintIssueReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "MetaTagAllowListInvalidOrigin" | "metatagallowlistinvalidorigin" => {
                        Ok(ClientHintIssueReason::MetaTagAllowListInvalidOrigin)
                    }
                    "MetaTagModifiedHTML" | "MetaTagModifiedHtml" | "metatagmodifiedhtml" => {
                        Ok(ClientHintIssueReason::MetaTagModifiedHtml)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct FederatedAuthRequestIssueDetails {
            #[serde(rename = "federatedAuthRequestIssueReason")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub federated_auth_request_issue_reason: FederatedAuthRequestIssueReason,
        }
        impl FederatedAuthRequestIssueDetails {
            pub fn new(
                federated_auth_request_issue_reason: impl Into<FederatedAuthRequestIssueReason>,
            ) -> Self {
                Self {
                    federated_auth_request_issue_reason: federated_auth_request_issue_reason.into(),
                }
            }
        }
        impl FederatedAuthRequestIssueDetails {
            pub fn builder() -> FederatedAuthRequestIssueDetailsBuilder {
                FederatedAuthRequestIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FederatedAuthRequestIssueDetailsBuilder {
            federated_auth_request_issue_reason: Option<FederatedAuthRequestIssueReason>,
        }
        impl FederatedAuthRequestIssueDetailsBuilder {
            pub fn federated_auth_request_issue_reason(
                mut self,
                federated_auth_request_issue_reason: impl Into<FederatedAuthRequestIssueReason>,
            ) -> Self {
                self.federated_auth_request_issue_reason =
                    Some(federated_auth_request_issue_reason.into());
                self
            }
            pub fn build(self) -> Result<FederatedAuthRequestIssueDetails, String> {
                Ok(FederatedAuthRequestIssueDetails {
                    federated_auth_request_issue_reason: self
                        .federated_auth_request_issue_reason
                        .ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(federated_auth_request_issue_reason)
                        )
                    })?,
                })
            }
        }
        impl FederatedAuthRequestIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.FederatedAuthRequestIssueDetails";
        }
        #[doc = "Represents the failure reason when a federated authentication reason fails.\nShould be updated alongside RequestIdTokenStatus in\nthird_party/blink/public/mojom/devtools/inspector_issue.mojom to include\nall cases except for success."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum FederatedAuthRequestIssueReason {
            #[serde(rename = "ShouldEmbargo")]
            ShouldEmbargo,
            #[serde(rename = "TooManyRequests")]
            TooManyRequests,
            #[serde(rename = "ManifestListHttpNotFound")]
            ManifestListHttpNotFound,
            #[serde(rename = "ManifestListNoResponse")]
            ManifestListNoResponse,
            #[serde(rename = "ManifestListInvalidResponse")]
            ManifestListInvalidResponse,
            #[serde(rename = "ManifestNotInManifestList")]
            ManifestNotInManifestList,
            #[serde(rename = "ManifestListTooBig")]
            ManifestListTooBig,
            #[serde(rename = "ManifestHttpNotFound")]
            ManifestHttpNotFound,
            #[serde(rename = "ManifestNoResponse")]
            ManifestNoResponse,
            #[serde(rename = "ManifestInvalidResponse")]
            ManifestInvalidResponse,
            #[serde(rename = "ClientMetadataHttpNotFound")]
            ClientMetadataHttpNotFound,
            #[serde(rename = "ClientMetadataNoResponse")]
            ClientMetadataNoResponse,
            #[serde(rename = "ClientMetadataInvalidResponse")]
            ClientMetadataInvalidResponse,
            #[serde(rename = "DisabledInSettings")]
            DisabledInSettings,
            #[serde(rename = "ErrorFetchingSignin")]
            ErrorFetchingSignin,
            #[serde(rename = "InvalidSigninResponse")]
            InvalidSigninResponse,
            #[serde(rename = "AccountsHttpNotFound")]
            AccountsHttpNotFound,
            #[serde(rename = "AccountsNoResponse")]
            AccountsNoResponse,
            #[serde(rename = "AccountsInvalidResponse")]
            AccountsInvalidResponse,
            #[serde(rename = "IdTokenHttpNotFound")]
            IdTokenHttpNotFound,
            #[serde(rename = "IdTokenNoResponse")]
            IdTokenNoResponse,
            #[serde(rename = "IdTokenInvalidResponse")]
            IdTokenInvalidResponse,
            #[serde(rename = "IdTokenInvalidRequest")]
            IdTokenInvalidRequest,
            #[serde(rename = "ErrorIdToken")]
            ErrorIdToken,
            #[serde(rename = "Canceled")]
            Canceled,
            #[serde(rename = "RpPageNotVisible")]
            RpPageNotVisible,
        }
        impl AsRef<str> for FederatedAuthRequestIssueReason {
            fn as_ref(&self) -> &str {
                match self {
                    FederatedAuthRequestIssueReason::ShouldEmbargo => "ShouldEmbargo",
                    FederatedAuthRequestIssueReason::TooManyRequests => "TooManyRequests",
                    FederatedAuthRequestIssueReason::ManifestListHttpNotFound => {
                        "ManifestListHttpNotFound"
                    }
                    FederatedAuthRequestIssueReason::ManifestListNoResponse => {
                        "ManifestListNoResponse"
                    }
                    FederatedAuthRequestIssueReason::ManifestListInvalidResponse => {
                        "ManifestListInvalidResponse"
                    }
                    FederatedAuthRequestIssueReason::ManifestNotInManifestList => {
                        "ManifestNotInManifestList"
                    }
                    FederatedAuthRequestIssueReason::ManifestListTooBig => "ManifestListTooBig",
                    FederatedAuthRequestIssueReason::ManifestHttpNotFound => "ManifestHttpNotFound",
                    FederatedAuthRequestIssueReason::ManifestNoResponse => "ManifestNoResponse",
                    FederatedAuthRequestIssueReason::ManifestInvalidResponse => {
                        "ManifestInvalidResponse"
                    }
                    FederatedAuthRequestIssueReason::ClientMetadataHttpNotFound => {
                        "ClientMetadataHttpNotFound"
                    }
                    FederatedAuthRequestIssueReason::ClientMetadataNoResponse => {
                        "ClientMetadataNoResponse"
                    }
                    FederatedAuthRequestIssueReason::ClientMetadataInvalidResponse => {
                        "ClientMetadataInvalidResponse"
                    }
                    FederatedAuthRequestIssueReason::DisabledInSettings => "DisabledInSettings",
                    FederatedAuthRequestIssueReason::ErrorFetchingSignin => "ErrorFetchingSignin",
                    FederatedAuthRequestIssueReason::InvalidSigninResponse => {
                        "InvalidSigninResponse"
                    }
                    FederatedAuthRequestIssueReason::AccountsHttpNotFound => "AccountsHttpNotFound",
                    FederatedAuthRequestIssueReason::AccountsNoResponse => "AccountsNoResponse",
                    FederatedAuthRequestIssueReason::AccountsInvalidResponse => {
                        "AccountsInvalidResponse"
                    }
                    FederatedAuthRequestIssueReason::IdTokenHttpNotFound => "IdTokenHttpNotFound",
                    FederatedAuthRequestIssueReason::IdTokenNoResponse => "IdTokenNoResponse",
                    FederatedAuthRequestIssueReason::IdTokenInvalidResponse => {
                        "IdTokenInvalidResponse"
                    }
                    FederatedAuthRequestIssueReason::IdTokenInvalidRequest => {
                        "IdTokenInvalidRequest"
                    }
                    FederatedAuthRequestIssueReason::ErrorIdToken => "ErrorIdToken",
                    FederatedAuthRequestIssueReason::Canceled => "Canceled",
                    FederatedAuthRequestIssueReason::RpPageNotVisible => "RpPageNotVisible",
                }
            }
        }
        impl ::std::str::FromStr for FederatedAuthRequestIssueReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "ShouldEmbargo" | "shouldembargo" => {
                        Ok(FederatedAuthRequestIssueReason::ShouldEmbargo)
                    }
                    "TooManyRequests" | "toomanyrequests" => {
                        Ok(FederatedAuthRequestIssueReason::TooManyRequests)
                    }
                    "ManifestListHttpNotFound" | "manifestlisthttpnotfound" => {
                        Ok(FederatedAuthRequestIssueReason::ManifestListHttpNotFound)
                    }
                    "ManifestListNoResponse" | "manifestlistnoresponse" => {
                        Ok(FederatedAuthRequestIssueReason::ManifestListNoResponse)
                    }
                    "ManifestListInvalidResponse" | "manifestlistinvalidresponse" => {
                        Ok(FederatedAuthRequestIssueReason::ManifestListInvalidResponse)
                    }
                    "ManifestNotInManifestList" | "manifestnotinmanifestlist" => {
                        Ok(FederatedAuthRequestIssueReason::ManifestNotInManifestList)
                    }
                    "ManifestListTooBig" | "manifestlisttoobig" => {
                        Ok(FederatedAuthRequestIssueReason::ManifestListTooBig)
                    }
                    "ManifestHttpNotFound" | "manifesthttpnotfound" => {
                        Ok(FederatedAuthRequestIssueReason::ManifestHttpNotFound)
                    }
                    "ManifestNoResponse" | "manifestnoresponse" => {
                        Ok(FederatedAuthRequestIssueReason::ManifestNoResponse)
                    }
                    "ManifestInvalidResponse" | "manifestinvalidresponse" => {
                        Ok(FederatedAuthRequestIssueReason::ManifestInvalidResponse)
                    }
                    "ClientMetadataHttpNotFound" | "clientmetadatahttpnotfound" => {
                        Ok(FederatedAuthRequestIssueReason::ClientMetadataHttpNotFound)
                    }
                    "ClientMetadataNoResponse" | "clientmetadatanoresponse" => {
                        Ok(FederatedAuthRequestIssueReason::ClientMetadataNoResponse)
                    }
                    "ClientMetadataInvalidResponse" | "clientmetadatainvalidresponse" => {
                        Ok(FederatedAuthRequestIssueReason::ClientMetadataInvalidResponse)
                    }
                    "DisabledInSettings" | "disabledinsettings" => {
                        Ok(FederatedAuthRequestIssueReason::DisabledInSettings)
                    }
                    "ErrorFetchingSignin" | "errorfetchingsignin" => {
                        Ok(FederatedAuthRequestIssueReason::ErrorFetchingSignin)
                    }
                    "InvalidSigninResponse" | "invalidsigninresponse" => {
                        Ok(FederatedAuthRequestIssueReason::InvalidSigninResponse)
                    }
                    "AccountsHttpNotFound" | "accountshttpnotfound" => {
                        Ok(FederatedAuthRequestIssueReason::AccountsHttpNotFound)
                    }
                    "AccountsNoResponse" | "accountsnoresponse" => {
                        Ok(FederatedAuthRequestIssueReason::AccountsNoResponse)
                    }
                    "AccountsInvalidResponse" | "accountsinvalidresponse" => {
                        Ok(FederatedAuthRequestIssueReason::AccountsInvalidResponse)
                    }
                    "IdTokenHttpNotFound" | "idtokenhttpnotfound" => {
                        Ok(FederatedAuthRequestIssueReason::IdTokenHttpNotFound)
                    }
                    "IdTokenNoResponse" | "idtokennoresponse" => {
                        Ok(FederatedAuthRequestIssueReason::IdTokenNoResponse)
                    }
                    "IdTokenInvalidResponse" | "idtokeninvalidresponse" => {
                        Ok(FederatedAuthRequestIssueReason::IdTokenInvalidResponse)
                    }
                    "IdTokenInvalidRequest" | "idtokeninvalidrequest" => {
                        Ok(FederatedAuthRequestIssueReason::IdTokenInvalidRequest)
                    }
                    "ErrorIdToken" | "erroridtoken" => {
                        Ok(FederatedAuthRequestIssueReason::ErrorIdToken)
                    }
                    "Canceled" | "canceled" => Ok(FederatedAuthRequestIssueReason::Canceled),
                    "RpPageNotVisible" | "rppagenotvisible" => {
                        Ok(FederatedAuthRequestIssueReason::RpPageNotVisible)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "This issue tracks client hints related issues. It's used to deprecate old\nfeatures, encourage the use of new ones, and provide general guidance.\n[ClientHintIssueDetails](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-ClientHintIssueDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ClientHintIssueDetails {
            #[serde(rename = "sourceCodeLocation")]
            pub source_code_location: SourceCodeLocation,
            #[serde(rename = "clientHintIssueReason")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub client_hint_issue_reason: ClientHintIssueReason,
        }
        impl ClientHintIssueDetails {
            pub fn new(
                source_code_location: impl Into<SourceCodeLocation>,
                client_hint_issue_reason: impl Into<ClientHintIssueReason>,
            ) -> Self {
                Self {
                    source_code_location: source_code_location.into(),
                    client_hint_issue_reason: client_hint_issue_reason.into(),
                }
            }
        }
        impl ClientHintIssueDetails {
            pub fn builder() -> ClientHintIssueDetailsBuilder {
                ClientHintIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ClientHintIssueDetailsBuilder {
            source_code_location: Option<SourceCodeLocation>,
            client_hint_issue_reason: Option<ClientHintIssueReason>,
        }
        impl ClientHintIssueDetailsBuilder {
            pub fn source_code_location(
                mut self,
                source_code_location: impl Into<SourceCodeLocation>,
            ) -> Self {
                self.source_code_location = Some(source_code_location.into());
                self
            }
            pub fn client_hint_issue_reason(
                mut self,
                client_hint_issue_reason: impl Into<ClientHintIssueReason>,
            ) -> Self {
                self.client_hint_issue_reason = Some(client_hint_issue_reason.into());
                self
            }
            pub fn build(self) -> Result<ClientHintIssueDetails, String> {
                Ok(ClientHintIssueDetails {
                    source_code_location: self.source_code_location.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(source_code_location)
                        )
                    })?,
                    client_hint_issue_reason: self.client_hint_issue_reason.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(client_hint_issue_reason)
                        )
                    })?,
                })
            }
        }
        impl ClientHintIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.ClientHintIssueDetails";
        }
        #[doc = "A unique identifier for the type of issue. Each type may use one of the\noptional fields in InspectorIssueDetails to convey more specific\ninformation about the kind of issue."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum InspectorIssueCode {
            #[serde(rename = "CookieIssue")]
            CookieIssue,
            #[serde(rename = "MixedContentIssue")]
            MixedContentIssue,
            #[serde(rename = "BlockedByResponseIssue")]
            BlockedByResponseIssue,
            #[serde(rename = "HeavyAdIssue")]
            HeavyAdIssue,
            #[serde(rename = "ContentSecurityPolicyIssue")]
            ContentSecurityPolicyIssue,
            #[serde(rename = "SharedArrayBufferIssue")]
            SharedArrayBufferIssue,
            #[serde(rename = "TrustedWebActivityIssue")]
            TrustedWebActivityIssue,
            #[serde(rename = "LowTextContrastIssue")]
            LowTextContrastIssue,
            #[serde(rename = "CorsIssue")]
            CorsIssue,
            #[serde(rename = "AttributionReportingIssue")]
            AttributionReportingIssue,
            #[serde(rename = "QuirksModeIssue")]
            QuirksModeIssue,
            #[serde(rename = "NavigatorUserAgentIssue")]
            NavigatorUserAgentIssue,
            #[serde(rename = "GenericIssue")]
            GenericIssue,
            #[serde(rename = "DeprecationIssue")]
            DeprecationIssue,
            #[serde(rename = "ClientHintIssue")]
            ClientHintIssue,
            #[serde(rename = "FederatedAuthRequestIssue")]
            FederatedAuthRequestIssue,
        }
        impl AsRef<str> for InspectorIssueCode {
            fn as_ref(&self) -> &str {
                match self {
                    InspectorIssueCode::CookieIssue => "CookieIssue",
                    InspectorIssueCode::MixedContentIssue => "MixedContentIssue",
                    InspectorIssueCode::BlockedByResponseIssue => "BlockedByResponseIssue",
                    InspectorIssueCode::HeavyAdIssue => "HeavyAdIssue",
                    InspectorIssueCode::ContentSecurityPolicyIssue => "ContentSecurityPolicyIssue",
                    InspectorIssueCode::SharedArrayBufferIssue => "SharedArrayBufferIssue",
                    InspectorIssueCode::TrustedWebActivityIssue => "TrustedWebActivityIssue",
                    InspectorIssueCode::LowTextContrastIssue => "LowTextContrastIssue",
                    InspectorIssueCode::CorsIssue => "CorsIssue",
                    InspectorIssueCode::AttributionReportingIssue => "AttributionReportingIssue",
                    InspectorIssueCode::QuirksModeIssue => "QuirksModeIssue",
                    InspectorIssueCode::NavigatorUserAgentIssue => "NavigatorUserAgentIssue",
                    InspectorIssueCode::GenericIssue => "GenericIssue",
                    InspectorIssueCode::DeprecationIssue => "DeprecationIssue",
                    InspectorIssueCode::ClientHintIssue => "ClientHintIssue",
                    InspectorIssueCode::FederatedAuthRequestIssue => "FederatedAuthRequestIssue",
                }
            }
        }
        impl ::std::str::FromStr for InspectorIssueCode {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "CookieIssue" | "cookieissue" => Ok(InspectorIssueCode::CookieIssue),
                    "MixedContentIssue" | "mixedcontentissue" => {
                        Ok(InspectorIssueCode::MixedContentIssue)
                    }
                    "BlockedByResponseIssue" | "blockedbyresponseissue" => {
                        Ok(InspectorIssueCode::BlockedByResponseIssue)
                    }
                    "HeavyAdIssue" | "heavyadissue" => Ok(InspectorIssueCode::HeavyAdIssue),
                    "ContentSecurityPolicyIssue" | "contentsecuritypolicyissue" => {
                        Ok(InspectorIssueCode::ContentSecurityPolicyIssue)
                    }
                    "SharedArrayBufferIssue" | "sharedarraybufferissue" => {
                        Ok(InspectorIssueCode::SharedArrayBufferIssue)
                    }
                    "TrustedWebActivityIssue" | "trustedwebactivityissue" => {
                        Ok(InspectorIssueCode::TrustedWebActivityIssue)
                    }
                    "LowTextContrastIssue" | "lowtextcontrastissue" => {
                        Ok(InspectorIssueCode::LowTextContrastIssue)
                    }
                    "CorsIssue" | "corsissue" => Ok(InspectorIssueCode::CorsIssue),
                    "AttributionReportingIssue" | "attributionreportingissue" => {
                        Ok(InspectorIssueCode::AttributionReportingIssue)
                    }
                    "QuirksModeIssue" | "quirksmodeissue" => {
                        Ok(InspectorIssueCode::QuirksModeIssue)
                    }
                    "NavigatorUserAgentIssue" | "navigatoruseragentissue" => {
                        Ok(InspectorIssueCode::NavigatorUserAgentIssue)
                    }
                    "GenericIssue" | "genericissue" => Ok(InspectorIssueCode::GenericIssue),
                    "DeprecationIssue" | "deprecationissue" => {
                        Ok(InspectorIssueCode::DeprecationIssue)
                    }
                    "ClientHintIssue" | "clienthintissue" => {
                        Ok(InspectorIssueCode::ClientHintIssue)
                    }
                    "FederatedAuthRequestIssue" | "federatedauthrequestissue" => {
                        Ok(InspectorIssueCode::FederatedAuthRequestIssue)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "This struct holds a list of optional fields with additional information\nspecific to the kind of issue. When adding a new issue code, please also\nadd a new optional field to this type.\n[InspectorIssueDetails](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-InspectorIssueDetails)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct InspectorIssueDetails {
            #[serde(rename = "cookieIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub cookie_issue_details: Option<CookieIssueDetails>,
            #[serde(rename = "mixedContentIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub mixed_content_issue_details: Option<MixedContentIssueDetails>,
            #[serde(rename = "blockedByResponseIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub blocked_by_response_issue_details: Option<BlockedByResponseIssueDetails>,
            #[serde(rename = "heavyAdIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub heavy_ad_issue_details: Option<HeavyAdIssueDetails>,
            #[serde(rename = "contentSecurityPolicyIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub content_security_policy_issue_details: Option<ContentSecurityPolicyIssueDetails>,
            #[serde(rename = "sharedArrayBufferIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub shared_array_buffer_issue_details: Option<SharedArrayBufferIssueDetails>,
            #[serde(rename = "twaQualityEnforcementDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub twa_quality_enforcement_details: Option<TrustedWebActivityIssueDetails>,
            #[serde(rename = "lowTextContrastIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub low_text_contrast_issue_details: Option<LowTextContrastIssueDetails>,
            #[serde(rename = "corsIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub cors_issue_details: Option<CorsIssueDetails>,
            #[serde(rename = "attributionReportingIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub attribution_reporting_issue_details: Option<AttributionReportingIssueDetails>,
            #[serde(rename = "quirksModeIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub quirks_mode_issue_details: Option<QuirksModeIssueDetails>,
            #[serde(rename = "navigatorUserAgentIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub navigator_user_agent_issue_details: Option<NavigatorUserAgentIssueDetails>,
            #[serde(rename = "genericIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub generic_issue_details: Option<GenericIssueDetails>,
            #[serde(rename = "deprecationIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub deprecation_issue_details: Option<DeprecationIssueDetails>,
            #[serde(rename = "clientHintIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub client_hint_issue_details: Option<ClientHintIssueDetails>,
            #[serde(rename = "federatedAuthRequestIssueDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub federated_auth_request_issue_details: Option<FederatedAuthRequestIssueDetails>,
        }
        impl InspectorIssueDetails {
            pub fn builder() -> InspectorIssueDetailsBuilder {
                InspectorIssueDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct InspectorIssueDetailsBuilder {
            cookie_issue_details: Option<CookieIssueDetails>,
            mixed_content_issue_details: Option<MixedContentIssueDetails>,
            blocked_by_response_issue_details: Option<BlockedByResponseIssueDetails>,
            heavy_ad_issue_details: Option<HeavyAdIssueDetails>,
            content_security_policy_issue_details: Option<ContentSecurityPolicyIssueDetails>,
            shared_array_buffer_issue_details: Option<SharedArrayBufferIssueDetails>,
            twa_quality_enforcement_details: Option<TrustedWebActivityIssueDetails>,
            low_text_contrast_issue_details: Option<LowTextContrastIssueDetails>,
            cors_issue_details: Option<CorsIssueDetails>,
            attribution_reporting_issue_details: Option<AttributionReportingIssueDetails>,
            quirks_mode_issue_details: Option<QuirksModeIssueDetails>,
            navigator_user_agent_issue_details: Option<NavigatorUserAgentIssueDetails>,
            generic_issue_details: Option<GenericIssueDetails>,
            deprecation_issue_details: Option<DeprecationIssueDetails>,
            client_hint_issue_details: Option<ClientHintIssueDetails>,
            federated_auth_request_issue_details: Option<FederatedAuthRequestIssueDetails>,
        }
        impl InspectorIssueDetailsBuilder {
            pub fn cookie_issue_details(
                mut self,
                cookie_issue_details: impl Into<CookieIssueDetails>,
            ) -> Self {
                self.cookie_issue_details = Some(cookie_issue_details.into());
                self
            }
            pub fn mixed_content_issue_details(
                mut self,
                mixed_content_issue_details: impl Into<MixedContentIssueDetails>,
            ) -> Self {
                self.mixed_content_issue_details = Some(mixed_content_issue_details.into());
                self
            }
            pub fn blocked_by_response_issue_details(
                mut self,
                blocked_by_response_issue_details: impl Into<BlockedByResponseIssueDetails>,
            ) -> Self {
                self.blocked_by_response_issue_details =
                    Some(blocked_by_response_issue_details.into());
                self
            }
            pub fn heavy_ad_issue_details(
                mut self,
                heavy_ad_issue_details: impl Into<HeavyAdIssueDetails>,
            ) -> Self {
                self.heavy_ad_issue_details = Some(heavy_ad_issue_details.into());
                self
            }
            pub fn content_security_policy_issue_details(
                mut self,
                content_security_policy_issue_details: impl Into<ContentSecurityPolicyIssueDetails>,
            ) -> Self {
                self.content_security_policy_issue_details =
                    Some(content_security_policy_issue_details.into());
                self
            }
            pub fn shared_array_buffer_issue_details(
                mut self,
                shared_array_buffer_issue_details: impl Into<SharedArrayBufferIssueDetails>,
            ) -> Self {
                self.shared_array_buffer_issue_details =
                    Some(shared_array_buffer_issue_details.into());
                self
            }
            pub fn twa_quality_enforcement_details(
                mut self,
                twa_quality_enforcement_details: impl Into<TrustedWebActivityIssueDetails>,
            ) -> Self {
                self.twa_quality_enforcement_details = Some(twa_quality_enforcement_details.into());
                self
            }
            pub fn low_text_contrast_issue_details(
                mut self,
                low_text_contrast_issue_details: impl Into<LowTextContrastIssueDetails>,
            ) -> Self {
                self.low_text_contrast_issue_details = Some(low_text_contrast_issue_details.into());
                self
            }
            pub fn cors_issue_details(
                mut self,
                cors_issue_details: impl Into<CorsIssueDetails>,
            ) -> Self {
                self.cors_issue_details = Some(cors_issue_details.into());
                self
            }
            pub fn attribution_reporting_issue_details(
                mut self,
                attribution_reporting_issue_details: impl Into<AttributionReportingIssueDetails>,
            ) -> Self {
                self.attribution_reporting_issue_details =
                    Some(attribution_reporting_issue_details.into());
                self
            }
            pub fn quirks_mode_issue_details(
                mut self,
                quirks_mode_issue_details: impl Into<QuirksModeIssueDetails>,
            ) -> Self {
                self.quirks_mode_issue_details = Some(quirks_mode_issue_details.into());
                self
            }
            pub fn navigator_user_agent_issue_details(
                mut self,
                navigator_user_agent_issue_details: impl Into<NavigatorUserAgentIssueDetails>,
            ) -> Self {
                self.navigator_user_agent_issue_details =
                    Some(navigator_user_agent_issue_details.into());
                self
            }
            pub fn generic_issue_details(
                mut self,
                generic_issue_details: impl Into<GenericIssueDetails>,
            ) -> Self {
                self.generic_issue_details = Some(generic_issue_details.into());
                self
            }
            pub fn deprecation_issue_details(
                mut self,
                deprecation_issue_details: impl Into<DeprecationIssueDetails>,
            ) -> Self {
                self.deprecation_issue_details = Some(deprecation_issue_details.into());
                self
            }
            pub fn client_hint_issue_details(
                mut self,
                client_hint_issue_details: impl Into<ClientHintIssueDetails>,
            ) -> Self {
                self.client_hint_issue_details = Some(client_hint_issue_details.into());
                self
            }
            pub fn federated_auth_request_issue_details(
                mut self,
                federated_auth_request_issue_details: impl Into<FederatedAuthRequestIssueDetails>,
            ) -> Self {
                self.federated_auth_request_issue_details =
                    Some(federated_auth_request_issue_details.into());
                self
            }
            pub fn build(self) -> InspectorIssueDetails {
                InspectorIssueDetails {
                    cookie_issue_details: self.cookie_issue_details,
                    mixed_content_issue_details: self.mixed_content_issue_details,
                    blocked_by_response_issue_details: self.blocked_by_response_issue_details,
                    heavy_ad_issue_details: self.heavy_ad_issue_details,
                    content_security_policy_issue_details: self
                        .content_security_policy_issue_details,
                    shared_array_buffer_issue_details: self.shared_array_buffer_issue_details,
                    twa_quality_enforcement_details: self.twa_quality_enforcement_details,
                    low_text_contrast_issue_details: self.low_text_contrast_issue_details,
                    cors_issue_details: self.cors_issue_details,
                    attribution_reporting_issue_details: self.attribution_reporting_issue_details,
                    quirks_mode_issue_details: self.quirks_mode_issue_details,
                    navigator_user_agent_issue_details: self.navigator_user_agent_issue_details,
                    generic_issue_details: self.generic_issue_details,
                    deprecation_issue_details: self.deprecation_issue_details,
                    client_hint_issue_details: self.client_hint_issue_details,
                    federated_auth_request_issue_details: self.federated_auth_request_issue_details,
                }
            }
        }
        impl InspectorIssueDetails {
            pub const IDENTIFIER: &'static str = "Audits.InspectorIssueDetails";
        }
        #[doc = "A unique id for a DevTools inspector issue. Allows other entities (e.g.\nexceptions, CDP message, console messages, etc.) to reference an issue.\n[IssueId](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-IssueId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct IssueId(String);
        impl IssueId {
            pub fn new(val: impl Into<String>) -> Self {
                IssueId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for IssueId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<IssueId> for String {
            fn from(el: IssueId) -> String {
                el.0
            }
        }
        impl From<String> for IssueId {
            fn from(expr: String) -> Self {
                IssueId(expr)
            }
        }
        impl std::borrow::Borrow<str> for IssueId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl IssueId {
            pub const IDENTIFIER: &'static str = "Audits.IssueId";
        }
        #[doc = "An inspector issue reported from the back-end.\n[InspectorIssue](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#type-InspectorIssue)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InspectorIssue {
            #[serde(rename = "code")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub code: InspectorIssueCode,
            #[serde(rename = "details")]
            pub details: InspectorIssueDetails,
            #[doc = "A unique id for this issue. May be omitted if no other entity (e.g.\nexception, CDP message, etc.) is referencing this issue."]
            #[serde(rename = "issueId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub issue_id: Option<IssueId>,
        }
        impl InspectorIssue {
            pub fn new(
                code: impl Into<InspectorIssueCode>,
                details: impl Into<InspectorIssueDetails>,
            ) -> Self {
                Self {
                    code: code.into(),
                    details: details.into(),
                    issue_id: None,
                }
            }
        }
        impl InspectorIssue {
            pub fn builder() -> InspectorIssueBuilder {
                InspectorIssueBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct InspectorIssueBuilder {
            code: Option<InspectorIssueCode>,
            details: Option<InspectorIssueDetails>,
            issue_id: Option<IssueId>,
        }
        impl InspectorIssueBuilder {
            pub fn code(mut self, code: impl Into<InspectorIssueCode>) -> Self {
                self.code = Some(code.into());
                self
            }
            pub fn details(mut self, details: impl Into<InspectorIssueDetails>) -> Self {
                self.details = Some(details.into());
                self
            }
            pub fn issue_id(mut self, issue_id: impl Into<IssueId>) -> Self {
                self.issue_id = Some(issue_id.into());
                self
            }
            pub fn build(self) -> Result<InspectorIssue, String> {
                Ok(InspectorIssue {
                    code: self.code.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(code))
                    })?,
                    details: self.details.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(details))
                    })?,
                    issue_id: self.issue_id,
                })
            }
        }
        impl InspectorIssue {
            pub const IDENTIFIER: &'static str = "Audits.InspectorIssue";
        }
        #[doc = "Returns the response body and size if it were re-encoded with the specified settings. Only\napplies to images.\n[getEncodedResponse](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#method-getEncodedResponse)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetEncodedResponseParams {
            #[doc = "Identifier of the network request to get content for."]
            #[serde(rename = "requestId")]
            pub request_id: super::network::RequestId,
            #[doc = "The encoding to use."]
            #[serde(rename = "encoding")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub encoding: GetEncodedResponseEncoding,
            #[doc = "The quality of the encoding (0-1). (defaults to 1)"]
            #[serde(rename = "quality")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub quality: Option<f64>,
            #[doc = "Whether to only return the size information (defaults to false)."]
            #[serde(rename = "sizeOnly")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub size_only: Option<bool>,
        }
        #[doc = "The encoding to use."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum GetEncodedResponseEncoding {
            #[serde(rename = "webp")]
            Webp,
            #[serde(rename = "jpeg")]
            Jpeg,
            #[serde(rename = "png")]
            Png,
        }
        impl AsRef<str> for GetEncodedResponseEncoding {
            fn as_ref(&self) -> &str {
                match self {
                    GetEncodedResponseEncoding::Webp => "webp",
                    GetEncodedResponseEncoding::Jpeg => "jpeg",
                    GetEncodedResponseEncoding::Png => "png",
                }
            }
        }
        impl ::std::str::FromStr for GetEncodedResponseEncoding {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "webp" | "Webp" => Ok(GetEncodedResponseEncoding::Webp),
                    "jpeg" | "Jpeg" => Ok(GetEncodedResponseEncoding::Jpeg),
                    "png" | "Png" => Ok(GetEncodedResponseEncoding::Png),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl GetEncodedResponseParams {
            pub fn new(
                request_id: impl Into<super::network::RequestId>,
                encoding: impl Into<GetEncodedResponseEncoding>,
            ) -> Self {
                Self {
                    request_id: request_id.into(),
                    encoding: encoding.into(),
                    quality: None,
                    size_only: None,
                }
            }
        }
        impl GetEncodedResponseParams {
            pub fn builder() -> GetEncodedResponseParamsBuilder {
                GetEncodedResponseParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetEncodedResponseParamsBuilder {
            request_id: Option<super::network::RequestId>,
            encoding: Option<GetEncodedResponseEncoding>,
            quality: Option<f64>,
            size_only: Option<bool>,
        }
        impl GetEncodedResponseParamsBuilder {
            pub fn request_id(mut self, request_id: impl Into<super::network::RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn encoding(mut self, encoding: impl Into<GetEncodedResponseEncoding>) -> Self {
                self.encoding = Some(encoding.into());
                self
            }
            pub fn quality(mut self, quality: impl Into<f64>) -> Self {
                self.quality = Some(quality.into());
                self
            }
            pub fn size_only(mut self, size_only: impl Into<bool>) -> Self {
                self.size_only = Some(size_only.into());
                self
            }
            pub fn build(self) -> Result<GetEncodedResponseParams, String> {
                Ok(GetEncodedResponseParams {
                    request_id: self.request_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_id))
                    })?,
                    encoding: self.encoding.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(encoding))
                    })?,
                    quality: self.quality,
                    size_only: self.size_only,
                })
            }
        }
        impl GetEncodedResponseParams {
            pub const IDENTIFIER: &'static str = "Audits.getEncodedResponse";
        }
        impl chromiumoxide_types::Method for GetEncodedResponseParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetEncodedResponseParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the response body and size if it were re-encoded with the specified settings. Only\napplies to images.\n[getEncodedResponse](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#method-getEncodedResponse)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetEncodedResponseReturns {
            #[doc = "The encoded body as a base64 string. Omitted if sizeOnly is true."]
            #[serde(rename = "body")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub body: Option<chromiumoxide_types::Binary>,
            #[doc = "Size before re-encoding."]
            #[serde(rename = "originalSize")]
            pub original_size: i64,
            #[doc = "Size after re-encoding."]
            #[serde(rename = "encodedSize")]
            pub encoded_size: i64,
        }
        impl GetEncodedResponseReturns {
            pub fn new(original_size: impl Into<i64>, encoded_size: impl Into<i64>) -> Self {
                Self {
                    original_size: original_size.into(),
                    encoded_size: encoded_size.into(),
                    body: None,
                }
            }
        }
        impl GetEncodedResponseReturns {
            pub fn builder() -> GetEncodedResponseReturnsBuilder {
                GetEncodedResponseReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetEncodedResponseReturnsBuilder {
            body: Option<chromiumoxide_types::Binary>,
            original_size: Option<i64>,
            encoded_size: Option<i64>,
        }
        impl GetEncodedResponseReturnsBuilder {
            pub fn body(mut self, body: impl Into<chromiumoxide_types::Binary>) -> Self {
                self.body = Some(body.into());
                self
            }
            pub fn original_size(mut self, original_size: impl Into<i64>) -> Self {
                self.original_size = Some(original_size.into());
                self
            }
            pub fn encoded_size(mut self, encoded_size: impl Into<i64>) -> Self {
                self.encoded_size = Some(encoded_size.into());
                self
            }
            pub fn build(self) -> Result<GetEncodedResponseReturns, String> {
                Ok(GetEncodedResponseReturns {
                    body: self.body,
                    original_size: self.original_size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(original_size))
                    })?,
                    encoded_size: self.encoded_size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(encoded_size))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetEncodedResponseParams {
            type Response = GetEncodedResponseReturns;
        }
        #[doc = "Disables issues domain, prevents further issues from being reported to the client.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Audits.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables issues domain, prevents further issues from being reported to the client.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables issues domain, sends the issues collected so far to the client by means of the\n`issueAdded` event.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Audits.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables issues domain, sends the issues collected so far to the client by means of the\n`issueAdded` event.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Runs the contrast check for the target page. Found issues are reported\nusing Audits.issueAdded event.\n[checkContrast](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#method-checkContrast)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CheckContrastParams {
            #[doc = "Whether to report WCAG AAA level issues. Default is false."]
            #[serde(rename = "reportAAA")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub report_aaa: Option<bool>,
        }
        impl CheckContrastParams {
            pub fn builder() -> CheckContrastParamsBuilder {
                CheckContrastParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CheckContrastParamsBuilder {
            report_aaa: Option<bool>,
        }
        impl CheckContrastParamsBuilder {
            pub fn report_aaa(mut self, report_aaa: impl Into<bool>) -> Self {
                self.report_aaa = Some(report_aaa.into());
                self
            }
            pub fn build(self) -> CheckContrastParams {
                CheckContrastParams {
                    report_aaa: self.report_aaa,
                }
            }
        }
        impl CheckContrastParams {
            pub const IDENTIFIER: &'static str = "Audits.checkContrast";
        }
        impl chromiumoxide_types::Method for CheckContrastParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CheckContrastParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Runs the contrast check for the target page. Found issues are reported\nusing Audits.issueAdded event.\n[checkContrast](https://chromedevtools.github.io/devtools-protocol/tot/Audits/#method-checkContrast)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CheckContrastReturns {}
        impl chromiumoxide_types::Command for CheckContrastParams {
            type Response = CheckContrastReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventIssueAdded {
            #[serde(rename = "issue")]
            pub issue: InspectorIssue,
        }
        impl EventIssueAdded {
            pub const IDENTIFIER: &'static str = "Audits.issueAdded";
        }
        impl chromiumoxide_types::Method for EventIssueAdded {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventIssueAdded {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "Defines events for background web platform features."]
    pub mod background_service {
        use serde::{Deserialize, Serialize};
        #[doc = "The Background Service that will be associated with the commands/events.\nEvery Background Service operates independently, but they share the same\nAPI."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ServiceName {
            #[serde(rename = "backgroundFetch")]
            BackgroundFetch,
            #[serde(rename = "backgroundSync")]
            BackgroundSync,
            #[serde(rename = "pushMessaging")]
            PushMessaging,
            #[serde(rename = "notifications")]
            Notifications,
            #[serde(rename = "paymentHandler")]
            PaymentHandler,
            #[serde(rename = "periodicBackgroundSync")]
            PeriodicBackgroundSync,
        }
        impl AsRef<str> for ServiceName {
            fn as_ref(&self) -> &str {
                match self {
                    ServiceName::BackgroundFetch => "backgroundFetch",
                    ServiceName::BackgroundSync => "backgroundSync",
                    ServiceName::PushMessaging => "pushMessaging",
                    ServiceName::Notifications => "notifications",
                    ServiceName::PaymentHandler => "paymentHandler",
                    ServiceName::PeriodicBackgroundSync => "periodicBackgroundSync",
                }
            }
        }
        impl ::std::str::FromStr for ServiceName {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "backgroundFetch" | "BackgroundFetch" | "backgroundfetch" => {
                        Ok(ServiceName::BackgroundFetch)
                    }
                    "backgroundSync" | "BackgroundSync" | "backgroundsync" => {
                        Ok(ServiceName::BackgroundSync)
                    }
                    "pushMessaging" | "PushMessaging" | "pushmessaging" => {
                        Ok(ServiceName::PushMessaging)
                    }
                    "notifications" | "Notifications" => Ok(ServiceName::Notifications),
                    "paymentHandler" | "PaymentHandler" | "paymenthandler" => {
                        Ok(ServiceName::PaymentHandler)
                    }
                    "periodicBackgroundSync"
                    | "PeriodicBackgroundSync"
                    | "periodicbackgroundsync" => Ok(ServiceName::PeriodicBackgroundSync),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "A key-value pair for additional event information to pass along.\n[EventMetadata](https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#type-EventMetadata)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventMetadata {
            #[serde(rename = "key")]
            pub key: String,
            #[serde(rename = "value")]
            pub value: String,
        }
        impl EventMetadata {
            pub fn new(key: impl Into<String>, value: impl Into<String>) -> Self {
                Self {
                    key: key.into(),
                    value: value.into(),
                }
            }
        }
        impl EventMetadata {
            pub fn builder() -> EventMetadataBuilder {
                EventMetadataBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EventMetadataBuilder {
            key: Option<String>,
            value: Option<String>,
        }
        impl EventMetadataBuilder {
            pub fn key(mut self, key: impl Into<String>) -> Self {
                self.key = Some(key.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<EventMetadata, String> {
                Ok(EventMetadata {
                    key: self
                        .key
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(key)))?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl EventMetadata {
            pub const IDENTIFIER: &'static str = "BackgroundService.EventMetadata";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct BackgroundServiceEvent {
            #[doc = "Timestamp of the event (in seconds)."]
            #[serde(rename = "timestamp")]
            pub timestamp: super::network::TimeSinceEpoch,
            #[doc = "The origin this event belongs to."]
            #[serde(rename = "origin")]
            pub origin: String,
            #[doc = "The Service Worker ID that initiated the event."]
            #[serde(rename = "serviceWorkerRegistrationId")]
            pub service_worker_registration_id: super::service_worker::RegistrationId,
            #[doc = "The Background Service this event belongs to."]
            #[serde(rename = "service")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub service: ServiceName,
            #[doc = "A description of the event."]
            #[serde(rename = "eventName")]
            pub event_name: String,
            #[doc = "An identifier that groups related events together."]
            #[serde(rename = "instanceId")]
            pub instance_id: String,
            #[doc = "A list of event-specific information."]
            #[serde(rename = "eventMetadata")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub event_metadata: Vec<EventMetadata>,
        }
        impl BackgroundServiceEvent {
            pub fn builder() -> BackgroundServiceEventBuilder {
                BackgroundServiceEventBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BackgroundServiceEventBuilder {
            timestamp: Option<super::network::TimeSinceEpoch>,
            origin: Option<String>,
            service_worker_registration_id: Option<super::service_worker::RegistrationId>,
            service: Option<ServiceName>,
            event_name: Option<String>,
            instance_id: Option<String>,
            event_metadata: Option<Vec<EventMetadata>>,
        }
        impl BackgroundServiceEventBuilder {
            pub fn timestamp(
                mut self,
                timestamp: impl Into<super::network::TimeSinceEpoch>,
            ) -> Self {
                self.timestamp = Some(timestamp.into());
                self
            }
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn service_worker_registration_id(
                mut self,
                service_worker_registration_id: impl Into<super::service_worker::RegistrationId>,
            ) -> Self {
                self.service_worker_registration_id = Some(service_worker_registration_id.into());
                self
            }
            pub fn service(mut self, service: impl Into<ServiceName>) -> Self {
                self.service = Some(service.into());
                self
            }
            pub fn event_name(mut self, event_name: impl Into<String>) -> Self {
                self.event_name = Some(event_name.into());
                self
            }
            pub fn instance_id(mut self, instance_id: impl Into<String>) -> Self {
                self.instance_id = Some(instance_id.into());
                self
            }
            pub fn event_metadata(mut self, event_metadata: impl Into<EventMetadata>) -> Self {
                let v = self.event_metadata.get_or_insert(Vec::new());
                v.push(event_metadata.into());
                self
            }
            pub fn event_metadatas<I, S>(mut self, event_metadatas: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<EventMetadata>,
            {
                let v = self.event_metadata.get_or_insert(Vec::new());
                for val in event_metadatas {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<BackgroundServiceEvent, String> {
                Ok(BackgroundServiceEvent {
                    timestamp: self.timestamp.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(timestamp))
                    })?,
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    service_worker_registration_id: self
                        .service_worker_registration_id
                        .ok_or_else(|| {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(service_worker_registration_id)
                            )
                        })?,
                    service: self.service.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(service))
                    })?,
                    event_name: self.event_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(event_name))
                    })?,
                    instance_id: self.instance_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(instance_id))
                    })?,
                    event_metadata: self.event_metadata.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(event_metadata))
                    })?,
                })
            }
        }
        impl BackgroundServiceEvent {
            pub const IDENTIFIER: &'static str = "BackgroundService.BackgroundServiceEvent";
        }
        #[doc = "Enables event updates for the service.\n[startObserving](https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#method-startObserving)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StartObservingParams {
            #[serde(rename = "service")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub service: ServiceName,
        }
        impl StartObservingParams {
            pub fn new(service: impl Into<ServiceName>) -> Self {
                Self {
                    service: service.into(),
                }
            }
        }
        impl StartObservingParams {
            pub fn builder() -> StartObservingParamsBuilder {
                StartObservingParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StartObservingParamsBuilder {
            service: Option<ServiceName>,
        }
        impl StartObservingParamsBuilder {
            pub fn service(mut self, service: impl Into<ServiceName>) -> Self {
                self.service = Some(service.into());
                self
            }
            pub fn build(self) -> Result<StartObservingParams, String> {
                Ok(StartObservingParams {
                    service: self.service.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(service))
                    })?,
                })
            }
        }
        impl StartObservingParams {
            pub const IDENTIFIER: &'static str = "BackgroundService.startObserving";
        }
        impl chromiumoxide_types::Method for StartObservingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartObservingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables event updates for the service.\n[startObserving](https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#method-startObserving)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartObservingReturns {}
        impl chromiumoxide_types::Command for StartObservingParams {
            type Response = StartObservingReturns;
        }
        #[doc = "Disables event updates for the service.\n[stopObserving](https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#method-stopObserving)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StopObservingParams {
            #[serde(rename = "service")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub service: ServiceName,
        }
        impl StopObservingParams {
            pub fn new(service: impl Into<ServiceName>) -> Self {
                Self {
                    service: service.into(),
                }
            }
        }
        impl StopObservingParams {
            pub fn builder() -> StopObservingParamsBuilder {
                StopObservingParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StopObservingParamsBuilder {
            service: Option<ServiceName>,
        }
        impl StopObservingParamsBuilder {
            pub fn service(mut self, service: impl Into<ServiceName>) -> Self {
                self.service = Some(service.into());
                self
            }
            pub fn build(self) -> Result<StopObservingParams, String> {
                Ok(StopObservingParams {
                    service: self.service.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(service))
                    })?,
                })
            }
        }
        impl StopObservingParams {
            pub const IDENTIFIER: &'static str = "BackgroundService.stopObserving";
        }
        impl chromiumoxide_types::Method for StopObservingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopObservingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables event updates for the service.\n[stopObserving](https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#method-stopObserving)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopObservingReturns {}
        impl chromiumoxide_types::Command for StopObservingParams {
            type Response = StopObservingReturns;
        }
        #[doc = "Set the recording state for the service.\n[setRecording](https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#method-setRecording)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetRecordingParams {
            #[serde(rename = "shouldRecord")]
            pub should_record: bool,
            #[serde(rename = "service")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub service: ServiceName,
        }
        impl SetRecordingParams {
            pub fn new(should_record: impl Into<bool>, service: impl Into<ServiceName>) -> Self {
                Self {
                    should_record: should_record.into(),
                    service: service.into(),
                }
            }
        }
        impl SetRecordingParams {
            pub fn builder() -> SetRecordingParamsBuilder {
                SetRecordingParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetRecordingParamsBuilder {
            should_record: Option<bool>,
            service: Option<ServiceName>,
        }
        impl SetRecordingParamsBuilder {
            pub fn should_record(mut self, should_record: impl Into<bool>) -> Self {
                self.should_record = Some(should_record.into());
                self
            }
            pub fn service(mut self, service: impl Into<ServiceName>) -> Self {
                self.service = Some(service.into());
                self
            }
            pub fn build(self) -> Result<SetRecordingParams, String> {
                Ok(SetRecordingParams {
                    should_record: self.should_record.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(should_record))
                    })?,
                    service: self.service.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(service))
                    })?,
                })
            }
        }
        impl SetRecordingParams {
            pub const IDENTIFIER: &'static str = "BackgroundService.setRecording";
        }
        impl chromiumoxide_types::Method for SetRecordingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetRecordingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Set the recording state for the service.\n[setRecording](https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#method-setRecording)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetRecordingReturns {}
        impl chromiumoxide_types::Command for SetRecordingParams {
            type Response = SetRecordingReturns;
        }
        #[doc = "Clears all stored data for the service.\n[clearEvents](https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#method-clearEvents)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ClearEventsParams {
            #[serde(rename = "service")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub service: ServiceName,
        }
        impl ClearEventsParams {
            pub fn new(service: impl Into<ServiceName>) -> Self {
                Self {
                    service: service.into(),
                }
            }
        }
        impl ClearEventsParams {
            pub fn builder() -> ClearEventsParamsBuilder {
                ClearEventsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ClearEventsParamsBuilder {
            service: Option<ServiceName>,
        }
        impl ClearEventsParamsBuilder {
            pub fn service(mut self, service: impl Into<ServiceName>) -> Self {
                self.service = Some(service.into());
                self
            }
            pub fn build(self) -> Result<ClearEventsParams, String> {
                Ok(ClearEventsParams {
                    service: self.service.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(service))
                    })?,
                })
            }
        }
        impl ClearEventsParams {
            pub const IDENTIFIER: &'static str = "BackgroundService.clearEvents";
        }
        impl chromiumoxide_types::Method for ClearEventsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearEventsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears all stored data for the service.\n[clearEvents](https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#method-clearEvents)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearEventsReturns {}
        impl chromiumoxide_types::Command for ClearEventsParams {
            type Response = ClearEventsReturns;
        }
        #[doc = "Called when the recording state for the service has been updated.\n[recordingStateChanged](https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#event-recordingStateChanged)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventRecordingStateChanged {
            #[serde(rename = "isRecording")]
            pub is_recording: bool,
            #[serde(rename = "service")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub service: ServiceName,
        }
        impl EventRecordingStateChanged {
            pub const IDENTIFIER: &'static str = "BackgroundService.recordingStateChanged";
        }
        impl chromiumoxide_types::Method for EventRecordingStateChanged {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventRecordingStateChanged {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Called with all existing backgroundServiceEvents when enabled, and all new\nevents afterwards if enabled and recording.\n[backgroundServiceEventReceived](https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#event-backgroundServiceEventReceived)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventBackgroundServiceEventReceived {
            #[serde(rename = "backgroundServiceEvent")]
            pub background_service_event: BackgroundServiceEvent,
        }
        impl EventBackgroundServiceEventReceived {
            pub const IDENTIFIER: &'static str = "BackgroundService.backgroundServiceEventReceived";
        }
        impl chromiumoxide_types::Method for EventBackgroundServiceEventReceived {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventBackgroundServiceEventReceived {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "The Browser domain defines methods and events for browser managing."]
    pub mod browser {
        use serde::{Deserialize, Serialize};
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct BrowserContextId(String);
        impl BrowserContextId {
            pub fn new(val: impl Into<String>) -> Self {
                BrowserContextId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for BrowserContextId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<BrowserContextId> for String {
            fn from(el: BrowserContextId) -> String {
                el.0
            }
        }
        impl From<String> for BrowserContextId {
            fn from(expr: String) -> Self {
                BrowserContextId(expr)
            }
        }
        impl std::borrow::Borrow<str> for BrowserContextId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl BrowserContextId {
            pub const IDENTIFIER: &'static str = "Browser.BrowserContextID";
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Copy, Hash)]
        pub struct WindowId(i64);
        impl WindowId {
            pub fn new(val: impl Into<i64>) -> Self {
                WindowId(val.into())
            }
            pub fn inner(&self) -> &i64 {
                &self.0
            }
        }
        impl WindowId {
            pub const IDENTIFIER: &'static str = "Browser.WindowID";
        }
        #[doc = "The state of the browser window."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum WindowState {
            #[serde(rename = "normal")]
            Normal,
            #[serde(rename = "minimized")]
            Minimized,
            #[serde(rename = "maximized")]
            Maximized,
            #[serde(rename = "fullscreen")]
            Fullscreen,
        }
        impl AsRef<str> for WindowState {
            fn as_ref(&self) -> &str {
                match self {
                    WindowState::Normal => "normal",
                    WindowState::Minimized => "minimized",
                    WindowState::Maximized => "maximized",
                    WindowState::Fullscreen => "fullscreen",
                }
            }
        }
        impl ::std::str::FromStr for WindowState {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "normal" | "Normal" => Ok(WindowState::Normal),
                    "minimized" | "Minimized" => Ok(WindowState::Minimized),
                    "maximized" | "Maximized" => Ok(WindowState::Maximized),
                    "fullscreen" | "Fullscreen" => Ok(WindowState::Fullscreen),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Browser window bounds information\n[Bounds](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#type-Bounds)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct Bounds {
            #[doc = "The offset from the left edge of the screen to the window in pixels."]
            #[serde(rename = "left")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub left: Option<i64>,
            #[doc = "The offset from the top edge of the screen to the window in pixels."]
            #[serde(rename = "top")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub top: Option<i64>,
            #[doc = "The window width in pixels."]
            #[serde(rename = "width")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub width: Option<i64>,
            #[doc = "The window height in pixels."]
            #[serde(rename = "height")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub height: Option<i64>,
            #[doc = "The window state. Default to normal."]
            #[serde(rename = "windowState")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub window_state: Option<WindowState>,
        }
        impl Bounds {
            pub fn builder() -> BoundsBuilder {
                BoundsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BoundsBuilder {
            left: Option<i64>,
            top: Option<i64>,
            width: Option<i64>,
            height: Option<i64>,
            window_state: Option<WindowState>,
        }
        impl BoundsBuilder {
            pub fn left(mut self, left: impl Into<i64>) -> Self {
                self.left = Some(left.into());
                self
            }
            pub fn top(mut self, top: impl Into<i64>) -> Self {
                self.top = Some(top.into());
                self
            }
            pub fn width(mut self, width: impl Into<i64>) -> Self {
                self.width = Some(width.into());
                self
            }
            pub fn height(mut self, height: impl Into<i64>) -> Self {
                self.height = Some(height.into());
                self
            }
            pub fn window_state(mut self, window_state: impl Into<WindowState>) -> Self {
                self.window_state = Some(window_state.into());
                self
            }
            pub fn build(self) -> Bounds {
                Bounds {
                    left: self.left,
                    top: self.top,
                    width: self.width,
                    height: self.height,
                    window_state: self.window_state,
                }
            }
        }
        impl Bounds {
            pub const IDENTIFIER: &'static str = "Browser.Bounds";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PermissionType {
            #[serde(rename = "accessibilityEvents")]
            AccessibilityEvents,
            #[serde(rename = "audioCapture")]
            AudioCapture,
            #[serde(rename = "backgroundSync")]
            BackgroundSync,
            #[serde(rename = "backgroundFetch")]
            BackgroundFetch,
            #[serde(rename = "clipboardReadWrite")]
            ClipboardReadWrite,
            #[serde(rename = "clipboardSanitizedWrite")]
            ClipboardSanitizedWrite,
            #[serde(rename = "displayCapture")]
            DisplayCapture,
            #[serde(rename = "durableStorage")]
            DurableStorage,
            #[serde(rename = "flash")]
            Flash,
            #[serde(rename = "geolocation")]
            Geolocation,
            #[serde(rename = "midi")]
            Midi,
            #[serde(rename = "midiSysex")]
            MidiSysex,
            #[serde(rename = "nfc")]
            Nfc,
            #[serde(rename = "notifications")]
            Notifications,
            #[serde(rename = "paymentHandler")]
            PaymentHandler,
            #[serde(rename = "periodicBackgroundSync")]
            PeriodicBackgroundSync,
            #[serde(rename = "protectedMediaIdentifier")]
            ProtectedMediaIdentifier,
            #[serde(rename = "sensors")]
            Sensors,
            #[serde(rename = "videoCapture")]
            VideoCapture,
            #[serde(rename = "videoCapturePanTiltZoom")]
            VideoCapturePanTiltZoom,
            #[serde(rename = "idleDetection")]
            IdleDetection,
            #[serde(rename = "wakeLockScreen")]
            WakeLockScreen,
            #[serde(rename = "wakeLockSystem")]
            WakeLockSystem,
        }
        impl AsRef<str> for PermissionType {
            fn as_ref(&self) -> &str {
                match self {
                    PermissionType::AccessibilityEvents => "accessibilityEvents",
                    PermissionType::AudioCapture => "audioCapture",
                    PermissionType::BackgroundSync => "backgroundSync",
                    PermissionType::BackgroundFetch => "backgroundFetch",
                    PermissionType::ClipboardReadWrite => "clipboardReadWrite",
                    PermissionType::ClipboardSanitizedWrite => "clipboardSanitizedWrite",
                    PermissionType::DisplayCapture => "displayCapture",
                    PermissionType::DurableStorage => "durableStorage",
                    PermissionType::Flash => "flash",
                    PermissionType::Geolocation => "geolocation",
                    PermissionType::Midi => "midi",
                    PermissionType::MidiSysex => "midiSysex",
                    PermissionType::Nfc => "nfc",
                    PermissionType::Notifications => "notifications",
                    PermissionType::PaymentHandler => "paymentHandler",
                    PermissionType::PeriodicBackgroundSync => "periodicBackgroundSync",
                    PermissionType::ProtectedMediaIdentifier => "protectedMediaIdentifier",
                    PermissionType::Sensors => "sensors",
                    PermissionType::VideoCapture => "videoCapture",
                    PermissionType::VideoCapturePanTiltZoom => "videoCapturePanTiltZoom",
                    PermissionType::IdleDetection => "idleDetection",
                    PermissionType::WakeLockScreen => "wakeLockScreen",
                    PermissionType::WakeLockSystem => "wakeLockSystem",
                }
            }
        }
        impl ::std::str::FromStr for PermissionType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "accessibilityEvents" | "AccessibilityEvents" | "accessibilityevents" => {
                        Ok(PermissionType::AccessibilityEvents)
                    }
                    "audioCapture" | "AudioCapture" | "audiocapture" => {
                        Ok(PermissionType::AudioCapture)
                    }
                    "backgroundSync" | "BackgroundSync" | "backgroundsync" => {
                        Ok(PermissionType::BackgroundSync)
                    }
                    "backgroundFetch" | "BackgroundFetch" | "backgroundfetch" => {
                        Ok(PermissionType::BackgroundFetch)
                    }
                    "clipboardReadWrite" | "ClipboardReadWrite" | "clipboardreadwrite" => {
                        Ok(PermissionType::ClipboardReadWrite)
                    }
                    "clipboardSanitizedWrite"
                    | "ClipboardSanitizedWrite"
                    | "clipboardsanitizedwrite" => Ok(PermissionType::ClipboardSanitizedWrite),
                    "displayCapture" | "DisplayCapture" | "displaycapture" => {
                        Ok(PermissionType::DisplayCapture)
                    }
                    "durableStorage" | "DurableStorage" | "durablestorage" => {
                        Ok(PermissionType::DurableStorage)
                    }
                    "flash" | "Flash" => Ok(PermissionType::Flash),
                    "geolocation" | "Geolocation" => Ok(PermissionType::Geolocation),
                    "midi" | "Midi" => Ok(PermissionType::Midi),
                    "midiSysex" | "MidiSysex" | "midisysex" => Ok(PermissionType::MidiSysex),
                    "nfc" | "Nfc" => Ok(PermissionType::Nfc),
                    "notifications" | "Notifications" => Ok(PermissionType::Notifications),
                    "paymentHandler" | "PaymentHandler" | "paymenthandler" => {
                        Ok(PermissionType::PaymentHandler)
                    }
                    "periodicBackgroundSync"
                    | "PeriodicBackgroundSync"
                    | "periodicbackgroundsync" => Ok(PermissionType::PeriodicBackgroundSync),
                    "protectedMediaIdentifier"
                    | "ProtectedMediaIdentifier"
                    | "protectedmediaidentifier" => Ok(PermissionType::ProtectedMediaIdentifier),
                    "sensors" | "Sensors" => Ok(PermissionType::Sensors),
                    "videoCapture" | "VideoCapture" | "videocapture" => {
                        Ok(PermissionType::VideoCapture)
                    }
                    "videoCapturePanTiltZoom"
                    | "VideoCapturePanTiltZoom"
                    | "videocapturepantiltzoom" => Ok(PermissionType::VideoCapturePanTiltZoom),
                    "idleDetection" | "IdleDetection" | "idledetection" => {
                        Ok(PermissionType::IdleDetection)
                    }
                    "wakeLockScreen" | "WakeLockScreen" | "wakelockscreen" => {
                        Ok(PermissionType::WakeLockScreen)
                    }
                    "wakeLockSystem" | "WakeLockSystem" | "wakelocksystem" => {
                        Ok(PermissionType::WakeLockSystem)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PermissionSetting {
            #[serde(rename = "granted")]
            Granted,
            #[serde(rename = "denied")]
            Denied,
            #[serde(rename = "prompt")]
            Prompt,
        }
        impl AsRef<str> for PermissionSetting {
            fn as_ref(&self) -> &str {
                match self {
                    PermissionSetting::Granted => "granted",
                    PermissionSetting::Denied => "denied",
                    PermissionSetting::Prompt => "prompt",
                }
            }
        }
        impl ::std::str::FromStr for PermissionSetting {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "granted" | "Granted" => Ok(PermissionSetting::Granted),
                    "denied" | "Denied" => Ok(PermissionSetting::Denied),
                    "prompt" | "Prompt" => Ok(PermissionSetting::Prompt),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Definition of PermissionDescriptor defined in the Permissions API:\nhttps://w3c.github.io/permissions/#dictdef-permissiondescriptor.\n[PermissionDescriptor](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#type-PermissionDescriptor)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PermissionDescriptor {
            #[doc = "Name of permission.\nSee https://cs.chromium.org/chromium/src/third_party/blink/renderer/modules/permissions/permission_descriptor.idl for valid permission names."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "For \"midi\" permission, may also specify sysex control."]
            #[serde(rename = "sysex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub sysex: Option<bool>,
            #[doc = "For \"push\" permission, may specify userVisibleOnly.\nNote that userVisibleOnly = true is the only currently supported type."]
            #[serde(rename = "userVisibleOnly")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub user_visible_only: Option<bool>,
            #[doc = "For \"clipboard\" permission, may specify allowWithoutSanitization."]
            #[serde(rename = "allowWithoutSanitization")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub allow_without_sanitization: Option<bool>,
            #[doc = "For \"camera\" permission, may specify panTiltZoom."]
            #[serde(rename = "panTiltZoom")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pan_tilt_zoom: Option<bool>,
        }
        impl PermissionDescriptor {
            pub fn new(name: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    sysex: None,
                    user_visible_only: None,
                    allow_without_sanitization: None,
                    pan_tilt_zoom: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for PermissionDescriptor {
            fn from(url: T) -> Self {
                PermissionDescriptor::new(url)
            }
        }
        impl PermissionDescriptor {
            pub fn builder() -> PermissionDescriptorBuilder {
                PermissionDescriptorBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PermissionDescriptorBuilder {
            name: Option<String>,
            sysex: Option<bool>,
            user_visible_only: Option<bool>,
            allow_without_sanitization: Option<bool>,
            pan_tilt_zoom: Option<bool>,
        }
        impl PermissionDescriptorBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn sysex(mut self, sysex: impl Into<bool>) -> Self {
                self.sysex = Some(sysex.into());
                self
            }
            pub fn user_visible_only(mut self, user_visible_only: impl Into<bool>) -> Self {
                self.user_visible_only = Some(user_visible_only.into());
                self
            }
            pub fn allow_without_sanitization(
                mut self,
                allow_without_sanitization: impl Into<bool>,
            ) -> Self {
                self.allow_without_sanitization = Some(allow_without_sanitization.into());
                self
            }
            pub fn pan_tilt_zoom(mut self, pan_tilt_zoom: impl Into<bool>) -> Self {
                self.pan_tilt_zoom = Some(pan_tilt_zoom.into());
                self
            }
            pub fn build(self) -> Result<PermissionDescriptor, String> {
                Ok(PermissionDescriptor {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    sysex: self.sysex,
                    user_visible_only: self.user_visible_only,
                    allow_without_sanitization: self.allow_without_sanitization,
                    pan_tilt_zoom: self.pan_tilt_zoom,
                })
            }
        }
        impl PermissionDescriptor {
            pub const IDENTIFIER: &'static str = "Browser.PermissionDescriptor";
        }
        #[doc = "Browser command ids used by executeBrowserCommand."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum BrowserCommandId {
            #[serde(rename = "openTabSearch")]
            OpenTabSearch,
            #[serde(rename = "closeTabSearch")]
            CloseTabSearch,
        }
        impl AsRef<str> for BrowserCommandId {
            fn as_ref(&self) -> &str {
                match self {
                    BrowserCommandId::OpenTabSearch => "openTabSearch",
                    BrowserCommandId::CloseTabSearch => "closeTabSearch",
                }
            }
        }
        impl ::std::str::FromStr for BrowserCommandId {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "openTabSearch" | "OpenTabSearch" | "opentabsearch" => {
                        Ok(BrowserCommandId::OpenTabSearch)
                    }
                    "closeTabSearch" | "CloseTabSearch" | "closetabsearch" => {
                        Ok(BrowserCommandId::CloseTabSearch)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Chrome histogram bucket.\n[Bucket](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#type-Bucket)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Bucket {
            #[doc = "Minimum value (inclusive)."]
            #[serde(rename = "low")]
            pub low: i64,
            #[doc = "Maximum value (exclusive)."]
            #[serde(rename = "high")]
            pub high: i64,
            #[doc = "Number of samples."]
            #[serde(rename = "count")]
            pub count: i64,
        }
        impl Bucket {
            pub fn new(low: impl Into<i64>, high: impl Into<i64>, count: impl Into<i64>) -> Self {
                Self {
                    low: low.into(),
                    high: high.into(),
                    count: count.into(),
                }
            }
        }
        impl Bucket {
            pub fn builder() -> BucketBuilder {
                BucketBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BucketBuilder {
            low: Option<i64>,
            high: Option<i64>,
            count: Option<i64>,
        }
        impl BucketBuilder {
            pub fn low(mut self, low: impl Into<i64>) -> Self {
                self.low = Some(low.into());
                self
            }
            pub fn high(mut self, high: impl Into<i64>) -> Self {
                self.high = Some(high.into());
                self
            }
            pub fn count(mut self, count: impl Into<i64>) -> Self {
                self.count = Some(count.into());
                self
            }
            pub fn build(self) -> Result<Bucket, String> {
                Ok(Bucket {
                    low: self
                        .low
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(low)))?,
                    high: self.high.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(high))
                    })?,
                    count: self.count.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(count))
                    })?,
                })
            }
        }
        impl Bucket {
            pub const IDENTIFIER: &'static str = "Browser.Bucket";
        }
        #[doc = "Chrome histogram.\n[Histogram](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#type-Histogram)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Histogram {
            #[doc = "Name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Sum of sample values."]
            #[serde(rename = "sum")]
            pub sum: i64,
            #[doc = "Total number of samples."]
            #[serde(rename = "count")]
            pub count: i64,
            #[doc = "Buckets."]
            #[serde(rename = "buckets")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub buckets: Vec<Bucket>,
        }
        impl Histogram {
            pub fn new(
                name: impl Into<String>,
                sum: impl Into<i64>,
                count: impl Into<i64>,
                buckets: Vec<Bucket>,
            ) -> Self {
                Self {
                    name: name.into(),
                    sum: sum.into(),
                    count: count.into(),
                    buckets,
                }
            }
        }
        impl Histogram {
            pub fn builder() -> HistogramBuilder {
                HistogramBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct HistogramBuilder {
            name: Option<String>,
            sum: Option<i64>,
            count: Option<i64>,
            buckets: Option<Vec<Bucket>>,
        }
        impl HistogramBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn sum(mut self, sum: impl Into<i64>) -> Self {
                self.sum = Some(sum.into());
                self
            }
            pub fn count(mut self, count: impl Into<i64>) -> Self {
                self.count = Some(count.into());
                self
            }
            pub fn bucket(mut self, bucket: impl Into<Bucket>) -> Self {
                let v = self.buckets.get_or_insert(Vec::new());
                v.push(bucket.into());
                self
            }
            pub fn buckets<I, S>(mut self, buckets: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Bucket>,
            {
                let v = self.buckets.get_or_insert(Vec::new());
                for val in buckets {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<Histogram, String> {
                Ok(Histogram {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    sum: self
                        .sum
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(sum)))?,
                    count: self.count.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(count))
                    })?,
                    buckets: self.buckets.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(buckets))
                    })?,
                })
            }
        }
        impl Histogram {
            pub const IDENTIFIER: &'static str = "Browser.Histogram";
        }
        #[doc = "Set permission settings for given origin.\n[setPermission](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-setPermission)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetPermissionParams {
            #[doc = "Descriptor of permission to override."]
            #[serde(rename = "permission")]
            pub permission: PermissionDescriptor,
            #[doc = "Setting of the permission."]
            #[serde(rename = "setting")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub setting: PermissionSetting,
            #[doc = "Origin the permission applies to, all origins if not specified."]
            #[serde(rename = "origin")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub origin: Option<String>,
            #[doc = "Context to override. When omitted, default browser context is used."]
            #[serde(rename = "browserContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub browser_context_id: Option<BrowserContextId>,
        }
        impl SetPermissionParams {
            pub fn new(
                permission: impl Into<PermissionDescriptor>,
                setting: impl Into<PermissionSetting>,
            ) -> Self {
                Self {
                    permission: permission.into(),
                    setting: setting.into(),
                    origin: None,
                    browser_context_id: None,
                }
            }
        }
        impl SetPermissionParams {
            pub fn builder() -> SetPermissionParamsBuilder {
                SetPermissionParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetPermissionParamsBuilder {
            permission: Option<PermissionDescriptor>,
            setting: Option<PermissionSetting>,
            origin: Option<String>,
            browser_context_id: Option<BrowserContextId>,
        }
        impl SetPermissionParamsBuilder {
            pub fn permission(mut self, permission: impl Into<PermissionDescriptor>) -> Self {
                self.permission = Some(permission.into());
                self
            }
            pub fn setting(mut self, setting: impl Into<PermissionSetting>) -> Self {
                self.setting = Some(setting.into());
                self
            }
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn browser_context_id(
                mut self,
                browser_context_id: impl Into<BrowserContextId>,
            ) -> Self {
                self.browser_context_id = Some(browser_context_id.into());
                self
            }
            pub fn build(self) -> Result<SetPermissionParams, String> {
                Ok(SetPermissionParams {
                    permission: self.permission.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(permission))
                    })?,
                    setting: self.setting.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(setting))
                    })?,
                    origin: self.origin,
                    browser_context_id: self.browser_context_id,
                })
            }
        }
        impl SetPermissionParams {
            pub const IDENTIFIER: &'static str = "Browser.setPermission";
        }
        impl chromiumoxide_types::Method for SetPermissionParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetPermissionParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Set permission settings for given origin.\n[setPermission](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-setPermission)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetPermissionReturns {}
        impl chromiumoxide_types::Command for SetPermissionParams {
            type Response = SetPermissionReturns;
        }
        #[doc = "Grant specific permissions to the given origin and reject all others.\n[grantPermissions](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-grantPermissions)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GrantPermissionsParams {
            #[serde(rename = "permissions")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub permissions: Vec<PermissionType>,
            #[doc = "Origin the permission applies to, all origins if not specified."]
            #[serde(rename = "origin")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub origin: Option<String>,
            #[doc = "BrowserContext to override permissions. When omitted, default browser context is used."]
            #[serde(rename = "browserContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub browser_context_id: Option<BrowserContextId>,
        }
        impl GrantPermissionsParams {
            pub fn new(permissions: Vec<PermissionType>) -> Self {
                Self {
                    permissions,
                    origin: None,
                    browser_context_id: None,
                }
            }
        }
        impl GrantPermissionsParams {
            pub fn builder() -> GrantPermissionsParamsBuilder {
                GrantPermissionsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GrantPermissionsParamsBuilder {
            permissions: Option<Vec<PermissionType>>,
            origin: Option<String>,
            browser_context_id: Option<BrowserContextId>,
        }
        impl GrantPermissionsParamsBuilder {
            pub fn permission(mut self, permission: impl Into<PermissionType>) -> Self {
                let v = self.permissions.get_or_insert(Vec::new());
                v.push(permission.into());
                self
            }
            pub fn permissions<I, S>(mut self, permissions: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PermissionType>,
            {
                let v = self.permissions.get_or_insert(Vec::new());
                for val in permissions {
                    v.push(val.into());
                }
                self
            }
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn browser_context_id(
                mut self,
                browser_context_id: impl Into<BrowserContextId>,
            ) -> Self {
                self.browser_context_id = Some(browser_context_id.into());
                self
            }
            pub fn build(self) -> Result<GrantPermissionsParams, String> {
                Ok(GrantPermissionsParams {
                    permissions: self.permissions.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(permissions))
                    })?,
                    origin: self.origin,
                    browser_context_id: self.browser_context_id,
                })
            }
        }
        impl GrantPermissionsParams {
            pub const IDENTIFIER: &'static str = "Browser.grantPermissions";
        }
        impl chromiumoxide_types::Method for GrantPermissionsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GrantPermissionsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Grant specific permissions to the given origin and reject all others.\n[grantPermissions](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-grantPermissions)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GrantPermissionsReturns {}
        impl chromiumoxide_types::Command for GrantPermissionsParams {
            type Response = GrantPermissionsReturns;
        }
        #[doc = "Reset all permission management for all origins.\n[resetPermissions](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-resetPermissions)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ResetPermissionsParams {
            #[doc = "BrowserContext to reset permissions. When omitted, default browser context is used."]
            #[serde(rename = "browserContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub browser_context_id: Option<BrowserContextId>,
        }
        impl ResetPermissionsParams {
            pub fn builder() -> ResetPermissionsParamsBuilder {
                ResetPermissionsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ResetPermissionsParamsBuilder {
            browser_context_id: Option<BrowserContextId>,
        }
        impl ResetPermissionsParamsBuilder {
            pub fn browser_context_id(
                mut self,
                browser_context_id: impl Into<BrowserContextId>,
            ) -> Self {
                self.browser_context_id = Some(browser_context_id.into());
                self
            }
            pub fn build(self) -> ResetPermissionsParams {
                ResetPermissionsParams {
                    browser_context_id: self.browser_context_id,
                }
            }
        }
        impl ResetPermissionsParams {
            pub const IDENTIFIER: &'static str = "Browser.resetPermissions";
        }
        impl chromiumoxide_types::Method for ResetPermissionsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ResetPermissionsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Reset all permission management for all origins.\n[resetPermissions](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-resetPermissions)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ResetPermissionsReturns {}
        impl chromiumoxide_types::Command for ResetPermissionsParams {
            type Response = ResetPermissionsReturns;
        }
        #[doc = "Set the behavior when downloading a file.\n[setDownloadBehavior](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-setDownloadBehavior)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetDownloadBehaviorParams {
            #[doc = "Whether to allow all or deny all download requests, or use default Chrome behavior if\navailable (otherwise deny). |allowAndName| allows download and names files according to\ntheir dowmload guids."]
            #[serde(rename = "behavior")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub behavior: SetDownloadBehaviorBehavior,
            #[doc = "BrowserContext to set download behavior. When omitted, default browser context is used."]
            #[serde(rename = "browserContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub browser_context_id: Option<BrowserContextId>,
            #[doc = "The default path to save downloaded files to. This is required if behavior is set to 'allow'\nor 'allowAndName'."]
            #[serde(rename = "downloadPath")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub download_path: Option<String>,
            #[doc = "Whether to emit download events (defaults to false)."]
            #[serde(rename = "eventsEnabled")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub events_enabled: Option<bool>,
        }
        #[doc = "Whether to allow all or deny all download requests, or use default Chrome behavior if\navailable (otherwise deny). |allowAndName| allows download and names files according to\ntheir dowmload guids."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SetDownloadBehaviorBehavior {
            #[serde(rename = "deny")]
            Deny,
            #[serde(rename = "allow")]
            Allow,
            #[serde(rename = "allowAndName")]
            AllowAndName,
            #[serde(rename = "default")]
            Default,
        }
        impl AsRef<str> for SetDownloadBehaviorBehavior {
            fn as_ref(&self) -> &str {
                match self {
                    SetDownloadBehaviorBehavior::Deny => "deny",
                    SetDownloadBehaviorBehavior::Allow => "allow",
                    SetDownloadBehaviorBehavior::AllowAndName => "allowAndName",
                    SetDownloadBehaviorBehavior::Default => "default",
                }
            }
        }
        impl ::std::str::FromStr for SetDownloadBehaviorBehavior {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "deny" | "Deny" => Ok(SetDownloadBehaviorBehavior::Deny),
                    "allow" | "Allow" => Ok(SetDownloadBehaviorBehavior::Allow),
                    "allowAndName" | "AllowAndName" | "allowandname" => {
                        Ok(SetDownloadBehaviorBehavior::AllowAndName)
                    }
                    "default" | "Default" => Ok(SetDownloadBehaviorBehavior::Default),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl SetDownloadBehaviorParams {
            pub fn new(behavior: impl Into<SetDownloadBehaviorBehavior>) -> Self {
                Self {
                    behavior: behavior.into(),
                    browser_context_id: None,
                    download_path: None,
                    events_enabled: None,
                }
            }
        }
        impl SetDownloadBehaviorParams {
            pub fn builder() -> SetDownloadBehaviorParamsBuilder {
                SetDownloadBehaviorParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetDownloadBehaviorParamsBuilder {
            behavior: Option<SetDownloadBehaviorBehavior>,
            browser_context_id: Option<BrowserContextId>,
            download_path: Option<String>,
            events_enabled: Option<bool>,
        }
        impl SetDownloadBehaviorParamsBuilder {
            pub fn behavior(mut self, behavior: impl Into<SetDownloadBehaviorBehavior>) -> Self {
                self.behavior = Some(behavior.into());
                self
            }
            pub fn browser_context_id(
                mut self,
                browser_context_id: impl Into<BrowserContextId>,
            ) -> Self {
                self.browser_context_id = Some(browser_context_id.into());
                self
            }
            pub fn download_path(mut self, download_path: impl Into<String>) -> Self {
                self.download_path = Some(download_path.into());
                self
            }
            pub fn events_enabled(mut self, events_enabled: impl Into<bool>) -> Self {
                self.events_enabled = Some(events_enabled.into());
                self
            }
            pub fn build(self) -> Result<SetDownloadBehaviorParams, String> {
                Ok(SetDownloadBehaviorParams {
                    behavior: self.behavior.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(behavior))
                    })?,
                    browser_context_id: self.browser_context_id,
                    download_path: self.download_path,
                    events_enabled: self.events_enabled,
                })
            }
        }
        impl SetDownloadBehaviorParams {
            pub const IDENTIFIER: &'static str = "Browser.setDownloadBehavior";
        }
        impl chromiumoxide_types::Method for SetDownloadBehaviorParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetDownloadBehaviorParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Set the behavior when downloading a file.\n[setDownloadBehavior](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-setDownloadBehavior)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetDownloadBehaviorReturns {}
        impl chromiumoxide_types::Command for SetDownloadBehaviorParams {
            type Response = SetDownloadBehaviorReturns;
        }
        #[doc = "Cancel a download if in progress\n[cancelDownload](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-cancelDownload)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CancelDownloadParams {
            #[doc = "Global unique identifier of the download."]
            #[serde(rename = "guid")]
            pub guid: String,
            #[doc = "BrowserContext to perform the action in. When omitted, default browser context is used."]
            #[serde(rename = "browserContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub browser_context_id: Option<BrowserContextId>,
        }
        impl CancelDownloadParams {
            pub fn new(guid: impl Into<String>) -> Self {
                Self {
                    guid: guid.into(),
                    browser_context_id: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for CancelDownloadParams {
            fn from(url: T) -> Self {
                CancelDownloadParams::new(url)
            }
        }
        impl CancelDownloadParams {
            pub fn builder() -> CancelDownloadParamsBuilder {
                CancelDownloadParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CancelDownloadParamsBuilder {
            guid: Option<String>,
            browser_context_id: Option<BrowserContextId>,
        }
        impl CancelDownloadParamsBuilder {
            pub fn guid(mut self, guid: impl Into<String>) -> Self {
                self.guid = Some(guid.into());
                self
            }
            pub fn browser_context_id(
                mut self,
                browser_context_id: impl Into<BrowserContextId>,
            ) -> Self {
                self.browser_context_id = Some(browser_context_id.into());
                self
            }
            pub fn build(self) -> Result<CancelDownloadParams, String> {
                Ok(CancelDownloadParams {
                    guid: self.guid.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(guid))
                    })?,
                    browser_context_id: self.browser_context_id,
                })
            }
        }
        impl CancelDownloadParams {
            pub const IDENTIFIER: &'static str = "Browser.cancelDownload";
        }
        impl chromiumoxide_types::Method for CancelDownloadParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CancelDownloadParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Cancel a download if in progress\n[cancelDownload](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-cancelDownload)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CancelDownloadReturns {}
        impl chromiumoxide_types::Command for CancelDownloadParams {
            type Response = CancelDownloadReturns;
        }
        #[doc = "Close browser gracefully.\n[close](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-close)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CloseParams {}
        impl CloseParams {
            pub const IDENTIFIER: &'static str = "Browser.close";
        }
        impl chromiumoxide_types::Method for CloseParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CloseParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Close browser gracefully.\n[close](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-close)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CloseReturns {}
        impl chromiumoxide_types::Command for CloseParams {
            type Response = CloseReturns;
        }
        #[doc = "Crashes browser on the main thread.\n[crash](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-crash)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CrashParams {}
        impl CrashParams {
            pub const IDENTIFIER: &'static str = "Browser.crash";
        }
        impl chromiumoxide_types::Method for CrashParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CrashParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Crashes browser on the main thread.\n[crash](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-crash)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CrashReturns {}
        impl chromiumoxide_types::Command for CrashParams {
            type Response = CrashReturns;
        }
        #[doc = "Crashes GPU process.\n[crashGpuProcess](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-crashGpuProcess)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CrashGpuProcessParams {}
        impl CrashGpuProcessParams {
            pub const IDENTIFIER: &'static str = "Browser.crashGpuProcess";
        }
        impl chromiumoxide_types::Method for CrashGpuProcessParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CrashGpuProcessParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Crashes GPU process.\n[crashGpuProcess](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-crashGpuProcess)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CrashGpuProcessReturns {}
        impl chromiumoxide_types::Command for CrashGpuProcessParams {
            type Response = CrashGpuProcessReturns;
        }
        #[doc = "Returns version information.\n[getVersion](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getVersion)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetVersionParams {}
        impl GetVersionParams {
            pub const IDENTIFIER: &'static str = "Browser.getVersion";
        }
        impl chromiumoxide_types::Method for GetVersionParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetVersionParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns version information.\n[getVersion](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getVersion)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetVersionReturns {
            #[doc = "Protocol version."]
            #[serde(rename = "protocolVersion")]
            pub protocol_version: String,
            #[doc = "Product name."]
            #[serde(rename = "product")]
            pub product: String,
            #[doc = "Product revision."]
            #[serde(rename = "revision")]
            pub revision: String,
            #[doc = "User-Agent."]
            #[serde(rename = "userAgent")]
            pub user_agent: String,
            #[doc = "V8 version."]
            #[serde(rename = "jsVersion")]
            pub js_version: String,
        }
        impl GetVersionReturns {
            pub fn builder() -> GetVersionReturnsBuilder {
                GetVersionReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetVersionReturnsBuilder {
            protocol_version: Option<String>,
            product: Option<String>,
            revision: Option<String>,
            user_agent: Option<String>,
            js_version: Option<String>,
        }
        impl GetVersionReturnsBuilder {
            pub fn protocol_version(mut self, protocol_version: impl Into<String>) -> Self {
                self.protocol_version = Some(protocol_version.into());
                self
            }
            pub fn product(mut self, product: impl Into<String>) -> Self {
                self.product = Some(product.into());
                self
            }
            pub fn revision(mut self, revision: impl Into<String>) -> Self {
                self.revision = Some(revision.into());
                self
            }
            pub fn user_agent(mut self, user_agent: impl Into<String>) -> Self {
                self.user_agent = Some(user_agent.into());
                self
            }
            pub fn js_version(mut self, js_version: impl Into<String>) -> Self {
                self.js_version = Some(js_version.into());
                self
            }
            pub fn build(self) -> Result<GetVersionReturns, String> {
                Ok(GetVersionReturns {
                    protocol_version: self.protocol_version.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(protocol_version)
                        )
                    })?,
                    product: self.product.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(product))
                    })?,
                    revision: self.revision.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(revision))
                    })?,
                    user_agent: self.user_agent.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(user_agent))
                    })?,
                    js_version: self.js_version.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(js_version))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetVersionParams {
            type Response = GetVersionReturns;
        }
        #[doc = "Returns the command line switches for the browser process if, and only if\n--enable-automation is on the commandline.\n[getBrowserCommandLine](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getBrowserCommandLine)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetBrowserCommandLineParams {}
        impl GetBrowserCommandLineParams {
            pub const IDENTIFIER: &'static str = "Browser.getBrowserCommandLine";
        }
        impl chromiumoxide_types::Method for GetBrowserCommandLineParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetBrowserCommandLineParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the command line switches for the browser process if, and only if\n--enable-automation is on the commandline.\n[getBrowserCommandLine](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getBrowserCommandLine)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetBrowserCommandLineReturns {
            #[doc = "Commandline parameters"]
            #[serde(rename = "arguments")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub arguments: Vec<String>,
        }
        impl GetBrowserCommandLineReturns {
            pub fn new(arguments: Vec<String>) -> Self {
                Self { arguments }
            }
        }
        impl GetBrowserCommandLineReturns {
            pub fn builder() -> GetBrowserCommandLineReturnsBuilder {
                GetBrowserCommandLineReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetBrowserCommandLineReturnsBuilder {
            arguments: Option<Vec<String>>,
        }
        impl GetBrowserCommandLineReturnsBuilder {
            pub fn argument(mut self, argument: impl Into<String>) -> Self {
                let v = self.arguments.get_or_insert(Vec::new());
                v.push(argument.into());
                self
            }
            pub fn arguments<I, S>(mut self, arguments: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.arguments.get_or_insert(Vec::new());
                for val in arguments {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetBrowserCommandLineReturns, String> {
                Ok(GetBrowserCommandLineReturns {
                    arguments: self.arguments.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(arguments))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetBrowserCommandLineParams {
            type Response = GetBrowserCommandLineReturns;
        }
        #[doc = "Get Chrome histograms.\n[getHistograms](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getHistograms)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetHistogramsParams {
            #[doc = "Requested substring in name. Only histograms which have query as a\nsubstring in their name are extracted. An empty or absent query returns\nall histograms."]
            #[serde(rename = "query")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub query: Option<String>,
            #[doc = "If true, retrieve delta since last call."]
            #[serde(rename = "delta")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub delta: Option<bool>,
        }
        impl GetHistogramsParams {
            pub fn builder() -> GetHistogramsParamsBuilder {
                GetHistogramsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetHistogramsParamsBuilder {
            query: Option<String>,
            delta: Option<bool>,
        }
        impl GetHistogramsParamsBuilder {
            pub fn query(mut self, query: impl Into<String>) -> Self {
                self.query = Some(query.into());
                self
            }
            pub fn delta(mut self, delta: impl Into<bool>) -> Self {
                self.delta = Some(delta.into());
                self
            }
            pub fn build(self) -> GetHistogramsParams {
                GetHistogramsParams {
                    query: self.query,
                    delta: self.delta,
                }
            }
        }
        impl GetHistogramsParams {
            pub const IDENTIFIER: &'static str = "Browser.getHistograms";
        }
        impl chromiumoxide_types::Method for GetHistogramsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetHistogramsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Get Chrome histograms.\n[getHistograms](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getHistograms)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetHistogramsReturns {
            #[doc = "Histograms."]
            #[serde(rename = "histograms")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub histograms: Vec<Histogram>,
        }
        impl GetHistogramsReturns {
            pub fn new(histograms: Vec<Histogram>) -> Self {
                Self { histograms }
            }
        }
        impl GetHistogramsReturns {
            pub fn builder() -> GetHistogramsReturnsBuilder {
                GetHistogramsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetHistogramsReturnsBuilder {
            histograms: Option<Vec<Histogram>>,
        }
        impl GetHistogramsReturnsBuilder {
            pub fn histogram(mut self, histogram: impl Into<Histogram>) -> Self {
                let v = self.histograms.get_or_insert(Vec::new());
                v.push(histogram.into());
                self
            }
            pub fn histograms<I, S>(mut self, histograms: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Histogram>,
            {
                let v = self.histograms.get_or_insert(Vec::new());
                for val in histograms {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetHistogramsReturns, String> {
                Ok(GetHistogramsReturns {
                    histograms: self.histograms.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(histograms))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetHistogramsParams {
            type Response = GetHistogramsReturns;
        }
        #[doc = "Get a Chrome histogram by name.\n[getHistogram](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getHistogram)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetHistogramParams {
            #[doc = "Requested histogram name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "If true, retrieve delta since last call."]
            #[serde(rename = "delta")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub delta: Option<bool>,
        }
        impl GetHistogramParams {
            pub fn new(name: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    delta: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for GetHistogramParams {
            fn from(url: T) -> Self {
                GetHistogramParams::new(url)
            }
        }
        impl GetHistogramParams {
            pub fn builder() -> GetHistogramParamsBuilder {
                GetHistogramParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetHistogramParamsBuilder {
            name: Option<String>,
            delta: Option<bool>,
        }
        impl GetHistogramParamsBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn delta(mut self, delta: impl Into<bool>) -> Self {
                self.delta = Some(delta.into());
                self
            }
            pub fn build(self) -> Result<GetHistogramParams, String> {
                Ok(GetHistogramParams {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    delta: self.delta,
                })
            }
        }
        impl GetHistogramParams {
            pub const IDENTIFIER: &'static str = "Browser.getHistogram";
        }
        impl chromiumoxide_types::Method for GetHistogramParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetHistogramParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Get a Chrome histogram by name.\n[getHistogram](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getHistogram)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetHistogramReturns {
            #[doc = "Histogram."]
            #[serde(rename = "histogram")]
            pub histogram: Histogram,
        }
        impl GetHistogramReturns {
            pub fn new(histogram: impl Into<Histogram>) -> Self {
                Self {
                    histogram: histogram.into(),
                }
            }
        }
        impl GetHistogramReturns {
            pub fn builder() -> GetHistogramReturnsBuilder {
                GetHistogramReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetHistogramReturnsBuilder {
            histogram: Option<Histogram>,
        }
        impl GetHistogramReturnsBuilder {
            pub fn histogram(mut self, histogram: impl Into<Histogram>) -> Self {
                self.histogram = Some(histogram.into());
                self
            }
            pub fn build(self) -> Result<GetHistogramReturns, String> {
                Ok(GetHistogramReturns {
                    histogram: self.histogram.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(histogram))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetHistogramParams {
            type Response = GetHistogramReturns;
        }
        #[doc = "Get position and size of the browser window.\n[getWindowBounds](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getWindowBounds)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetWindowBoundsParams {
            #[doc = "Browser window id."]
            #[serde(rename = "windowId")]
            pub window_id: WindowId,
        }
        impl GetWindowBoundsParams {
            pub fn new(window_id: impl Into<WindowId>) -> Self {
                Self {
                    window_id: window_id.into(),
                }
            }
        }
        impl GetWindowBoundsParams {
            pub fn builder() -> GetWindowBoundsParamsBuilder {
                GetWindowBoundsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetWindowBoundsParamsBuilder {
            window_id: Option<WindowId>,
        }
        impl GetWindowBoundsParamsBuilder {
            pub fn window_id(mut self, window_id: impl Into<WindowId>) -> Self {
                self.window_id = Some(window_id.into());
                self
            }
            pub fn build(self) -> Result<GetWindowBoundsParams, String> {
                Ok(GetWindowBoundsParams {
                    window_id: self.window_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(window_id))
                    })?,
                })
            }
        }
        impl GetWindowBoundsParams {
            pub const IDENTIFIER: &'static str = "Browser.getWindowBounds";
        }
        impl chromiumoxide_types::Method for GetWindowBoundsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetWindowBoundsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Get position and size of the browser window.\n[getWindowBounds](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getWindowBounds)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetWindowBoundsReturns {
            #[doc = "Bounds information of the window. When window state is 'minimized', the restored window\nposition and size are returned."]
            #[serde(rename = "bounds")]
            pub bounds: Bounds,
        }
        impl GetWindowBoundsReturns {
            pub fn new(bounds: impl Into<Bounds>) -> Self {
                Self {
                    bounds: bounds.into(),
                }
            }
        }
        impl GetWindowBoundsReturns {
            pub fn builder() -> GetWindowBoundsReturnsBuilder {
                GetWindowBoundsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetWindowBoundsReturnsBuilder {
            bounds: Option<Bounds>,
        }
        impl GetWindowBoundsReturnsBuilder {
            pub fn bounds(mut self, bounds: impl Into<Bounds>) -> Self {
                self.bounds = Some(bounds.into());
                self
            }
            pub fn build(self) -> Result<GetWindowBoundsReturns, String> {
                Ok(GetWindowBoundsReturns {
                    bounds: self.bounds.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(bounds))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetWindowBoundsParams {
            type Response = GetWindowBoundsReturns;
        }
        #[doc = "Get the browser window that contains the devtools target.\n[getWindowForTarget](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getWindowForTarget)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetWindowForTargetParams {
            #[doc = "Devtools agent host id. If called as a part of the session, associated targetId is used."]
            #[serde(rename = "targetId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub target_id: Option<super::target::TargetId>,
        }
        impl GetWindowForTargetParams {
            pub fn builder() -> GetWindowForTargetParamsBuilder {
                GetWindowForTargetParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetWindowForTargetParamsBuilder {
            target_id: Option<super::target::TargetId>,
        }
        impl GetWindowForTargetParamsBuilder {
            pub fn target_id(mut self, target_id: impl Into<super::target::TargetId>) -> Self {
                self.target_id = Some(target_id.into());
                self
            }
            pub fn build(self) -> GetWindowForTargetParams {
                GetWindowForTargetParams {
                    target_id: self.target_id,
                }
            }
        }
        impl GetWindowForTargetParams {
            pub const IDENTIFIER: &'static str = "Browser.getWindowForTarget";
        }
        impl chromiumoxide_types::Method for GetWindowForTargetParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetWindowForTargetParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Get the browser window that contains the devtools target.\n[getWindowForTarget](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getWindowForTarget)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetWindowForTargetReturns {
            #[doc = "Browser window id."]
            #[serde(rename = "windowId")]
            pub window_id: WindowId,
            #[doc = "Bounds information of the window. When window state is 'minimized', the restored window\nposition and size are returned."]
            #[serde(rename = "bounds")]
            pub bounds: Bounds,
        }
        impl GetWindowForTargetReturns {
            pub fn new(window_id: impl Into<WindowId>, bounds: impl Into<Bounds>) -> Self {
                Self {
                    window_id: window_id.into(),
                    bounds: bounds.into(),
                }
            }
        }
        impl GetWindowForTargetReturns {
            pub fn builder() -> GetWindowForTargetReturnsBuilder {
                GetWindowForTargetReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetWindowForTargetReturnsBuilder {
            window_id: Option<WindowId>,
            bounds: Option<Bounds>,
        }
        impl GetWindowForTargetReturnsBuilder {
            pub fn window_id(mut self, window_id: impl Into<WindowId>) -> Self {
                self.window_id = Some(window_id.into());
                self
            }
            pub fn bounds(mut self, bounds: impl Into<Bounds>) -> Self {
                self.bounds = Some(bounds.into());
                self
            }
            pub fn build(self) -> Result<GetWindowForTargetReturns, String> {
                Ok(GetWindowForTargetReturns {
                    window_id: self.window_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(window_id))
                    })?,
                    bounds: self.bounds.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(bounds))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetWindowForTargetParams {
            type Response = GetWindowForTargetReturns;
        }
        #[doc = "Set position and/or size of the browser window.\n[setWindowBounds](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-setWindowBounds)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetWindowBoundsParams {
            #[doc = "Browser window id."]
            #[serde(rename = "windowId")]
            pub window_id: WindowId,
            #[doc = "New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combined\nwith 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged."]
            #[serde(rename = "bounds")]
            pub bounds: Bounds,
        }
        impl SetWindowBoundsParams {
            pub fn new(window_id: impl Into<WindowId>, bounds: impl Into<Bounds>) -> Self {
                Self {
                    window_id: window_id.into(),
                    bounds: bounds.into(),
                }
            }
        }
        impl SetWindowBoundsParams {
            pub fn builder() -> SetWindowBoundsParamsBuilder {
                SetWindowBoundsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetWindowBoundsParamsBuilder {
            window_id: Option<WindowId>,
            bounds: Option<Bounds>,
        }
        impl SetWindowBoundsParamsBuilder {
            pub fn window_id(mut self, window_id: impl Into<WindowId>) -> Self {
                self.window_id = Some(window_id.into());
                self
            }
            pub fn bounds(mut self, bounds: impl Into<Bounds>) -> Self {
                self.bounds = Some(bounds.into());
                self
            }
            pub fn build(self) -> Result<SetWindowBoundsParams, String> {
                Ok(SetWindowBoundsParams {
                    window_id: self.window_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(window_id))
                    })?,
                    bounds: self.bounds.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(bounds))
                    })?,
                })
            }
        }
        impl SetWindowBoundsParams {
            pub const IDENTIFIER: &'static str = "Browser.setWindowBounds";
        }
        impl chromiumoxide_types::Method for SetWindowBoundsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetWindowBoundsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Set position and/or size of the browser window.\n[setWindowBounds](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-setWindowBounds)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetWindowBoundsReturns {}
        impl chromiumoxide_types::Command for SetWindowBoundsParams {
            type Response = SetWindowBoundsReturns;
        }
        #[doc = "Set dock tile details, platform-specific.\n[setDockTile](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-setDockTile)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetDockTileParams {
            #[serde(rename = "badgeLabel")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub badge_label: Option<String>,
            #[doc = "Png encoded image."]
            #[serde(rename = "image")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub image: Option<chromiumoxide_types::Binary>,
        }
        impl SetDockTileParams {
            pub fn builder() -> SetDockTileParamsBuilder {
                SetDockTileParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetDockTileParamsBuilder {
            badge_label: Option<String>,
            image: Option<chromiumoxide_types::Binary>,
        }
        impl SetDockTileParamsBuilder {
            pub fn badge_label(mut self, badge_label: impl Into<String>) -> Self {
                self.badge_label = Some(badge_label.into());
                self
            }
            pub fn image(mut self, image: impl Into<chromiumoxide_types::Binary>) -> Self {
                self.image = Some(image.into());
                self
            }
            pub fn build(self) -> SetDockTileParams {
                SetDockTileParams {
                    badge_label: self.badge_label,
                    image: self.image,
                }
            }
        }
        impl SetDockTileParams {
            pub const IDENTIFIER: &'static str = "Browser.setDockTile";
        }
        impl chromiumoxide_types::Method for SetDockTileParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetDockTileParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Set dock tile details, platform-specific.\n[setDockTile](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-setDockTile)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetDockTileReturns {}
        impl chromiumoxide_types::Command for SetDockTileParams {
            type Response = SetDockTileReturns;
        }
        #[doc = "Invoke custom browser commands used by telemetry.\n[executeBrowserCommand](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-executeBrowserCommand)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ExecuteBrowserCommandParams {
            #[serde(rename = "commandId")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub command_id: BrowserCommandId,
        }
        impl ExecuteBrowserCommandParams {
            pub fn new(command_id: impl Into<BrowserCommandId>) -> Self {
                Self {
                    command_id: command_id.into(),
                }
            }
        }
        impl ExecuteBrowserCommandParams {
            pub fn builder() -> ExecuteBrowserCommandParamsBuilder {
                ExecuteBrowserCommandParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ExecuteBrowserCommandParamsBuilder {
            command_id: Option<BrowserCommandId>,
        }
        impl ExecuteBrowserCommandParamsBuilder {
            pub fn command_id(mut self, command_id: impl Into<BrowserCommandId>) -> Self {
                self.command_id = Some(command_id.into());
                self
            }
            pub fn build(self) -> Result<ExecuteBrowserCommandParams, String> {
                Ok(ExecuteBrowserCommandParams {
                    command_id: self.command_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(command_id))
                    })?,
                })
            }
        }
        impl ExecuteBrowserCommandParams {
            pub const IDENTIFIER: &'static str = "Browser.executeBrowserCommand";
        }
        impl chromiumoxide_types::Method for ExecuteBrowserCommandParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ExecuteBrowserCommandParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Invoke custom browser commands used by telemetry.\n[executeBrowserCommand](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-executeBrowserCommand)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ExecuteBrowserCommandReturns {}
        impl chromiumoxide_types::Command for ExecuteBrowserCommandParams {
            type Response = ExecuteBrowserCommandReturns;
        }
        #[doc = "Fired when page is about to start a download.\n[downloadWillBegin](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#event-downloadWillBegin)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDownloadWillBegin {
            #[doc = "Id of the frame that caused the download to begin."]
            #[serde(rename = "frameId")]
            pub frame_id: super::page::FrameId,
            #[doc = "Global unique identifier of the download."]
            #[serde(rename = "guid")]
            pub guid: String,
            #[doc = "URL of the resource being downloaded."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Suggested file name of the resource (the actual name of the file saved on disk may differ)."]
            #[serde(rename = "suggestedFilename")]
            pub suggested_filename: String,
        }
        impl EventDownloadWillBegin {
            pub const IDENTIFIER: &'static str = "Browser.downloadWillBegin";
        }
        impl chromiumoxide_types::Method for EventDownloadWillBegin {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDownloadWillBegin {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when download makes progress. Last call has |done| == true.\n[downloadProgress](https://chromedevtools.github.io/devtools-protocol/tot/Browser/#event-downloadProgress)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDownloadProgress {
            #[doc = "Global unique identifier of the download."]
            #[serde(rename = "guid")]
            pub guid: String,
            #[doc = "Total expected bytes to download."]
            #[serde(rename = "totalBytes")]
            pub total_bytes: f64,
            #[doc = "Total bytes received."]
            #[serde(rename = "receivedBytes")]
            pub received_bytes: f64,
            #[doc = "Download status."]
            #[serde(rename = "state")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub state: DownloadProgressState,
        }
        #[doc = "Download status."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum DownloadProgressState {
            #[serde(rename = "inProgress")]
            InProgress,
            #[serde(rename = "completed")]
            Completed,
            #[serde(rename = "canceled")]
            Canceled,
        }
        impl AsRef<str> for DownloadProgressState {
            fn as_ref(&self) -> &str {
                match self {
                    DownloadProgressState::InProgress => "inProgress",
                    DownloadProgressState::Completed => "completed",
                    DownloadProgressState::Canceled => "canceled",
                }
            }
        }
        impl ::std::str::FromStr for DownloadProgressState {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "inProgress" | "InProgress" | "inprogress" => {
                        Ok(DownloadProgressState::InProgress)
                    }
                    "completed" | "Completed" => Ok(DownloadProgressState::Completed),
                    "canceled" | "Canceled" => Ok(DownloadProgressState::Canceled),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl EventDownloadProgress {
            pub const IDENTIFIER: &'static str = "Browser.downloadProgress";
        }
        impl chromiumoxide_types::Method for EventDownloadProgress {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDownloadProgress {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles)\nhave an associated `id` used in subsequent operations on the related object. Each object type has\na specific `id` structure, and those are not interchangeable between objects of different kinds.\nCSS objects can be loaded using the `get*ForNode()` calls (which accept a DOM node id). A client\ncan also keep track of stylesheets via the `styleSheetAdded`/`styleSheetRemoved` events and\nsubsequently load the required stylesheet contents using the `getStyleSheet[Text]()` methods."]
    pub mod css {
        use serde::{Deserialize, Serialize};
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct StyleSheetId(String);
        impl StyleSheetId {
            pub fn new(val: impl Into<String>) -> Self {
                StyleSheetId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for StyleSheetId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<StyleSheetId> for String {
            fn from(el: StyleSheetId) -> String {
                el.0
            }
        }
        impl From<String> for StyleSheetId {
            fn from(expr: String) -> Self {
                StyleSheetId(expr)
            }
        }
        impl std::borrow::Borrow<str> for StyleSheetId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl StyleSheetId {
            pub const IDENTIFIER: &'static str = "CSS.StyleSheetId";
        }
        #[doc = "Stylesheet type: \"injected\" for stylesheets injected via extension, \"user-agent\" for user-agent\nstylesheets, \"inspector\" for stylesheets created by the inspector (i.e. those holding the \"via\ninspector\" rules), \"regular\" for regular stylesheets."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum StyleSheetOrigin {
            #[serde(rename = "injected")]
            Injected,
            #[serde(rename = "user-agent")]
            UserAgent,
            #[serde(rename = "inspector")]
            Inspector,
            #[serde(rename = "regular")]
            Regular,
        }
        impl AsRef<str> for StyleSheetOrigin {
            fn as_ref(&self) -> &str {
                match self {
                    StyleSheetOrigin::Injected => "injected",
                    StyleSheetOrigin::UserAgent => "user-agent",
                    StyleSheetOrigin::Inspector => "inspector",
                    StyleSheetOrigin::Regular => "regular",
                }
            }
        }
        impl ::std::str::FromStr for StyleSheetOrigin {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "injected" | "Injected" => Ok(StyleSheetOrigin::Injected),
                    "user-agent" | "UserAgent" => Ok(StyleSheetOrigin::UserAgent),
                    "inspector" | "Inspector" => Ok(StyleSheetOrigin::Inspector),
                    "regular" | "Regular" => Ok(StyleSheetOrigin::Regular),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "CSS rule collection for a single pseudo style.\n[PseudoElementMatches](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-PseudoElementMatches)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PseudoElementMatches {
            #[doc = "Pseudo element type."]
            #[serde(rename = "pseudoType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub pseudo_type: super::dom::PseudoType,
            #[doc = "Pseudo element custom ident."]
            #[serde(rename = "pseudoIdentifier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pseudo_identifier: Option<String>,
            #[doc = "Matches of CSS rules applicable to the pseudo style."]
            #[serde(rename = "matches")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub matches: Vec<RuleMatch>,
        }
        impl PseudoElementMatches {
            pub fn new(
                pseudo_type: impl Into<super::dom::PseudoType>,
                matches: Vec<RuleMatch>,
            ) -> Self {
                Self {
                    pseudo_type: pseudo_type.into(),
                    matches,
                    pseudo_identifier: None,
                }
            }
        }
        impl PseudoElementMatches {
            pub fn builder() -> PseudoElementMatchesBuilder {
                PseudoElementMatchesBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PseudoElementMatchesBuilder {
            pseudo_type: Option<super::dom::PseudoType>,
            pseudo_identifier: Option<String>,
            matches: Option<Vec<RuleMatch>>,
        }
        impl PseudoElementMatchesBuilder {
            pub fn pseudo_type(mut self, pseudo_type: impl Into<super::dom::PseudoType>) -> Self {
                self.pseudo_type = Some(pseudo_type.into());
                self
            }
            pub fn pseudo_identifier(mut self, pseudo_identifier: impl Into<String>) -> Self {
                self.pseudo_identifier = Some(pseudo_identifier.into());
                self
            }
            pub fn matche(mut self, matche: impl Into<RuleMatch>) -> Self {
                let v = self.matches.get_or_insert(Vec::new());
                v.push(matche.into());
                self
            }
            pub fn matches<I, S>(mut self, matches: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<RuleMatch>,
            {
                let v = self.matches.get_or_insert(Vec::new());
                for val in matches {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<PseudoElementMatches, String> {
                Ok(PseudoElementMatches {
                    pseudo_type: self.pseudo_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(pseudo_type))
                    })?,
                    pseudo_identifier: self.pseudo_identifier,
                    matches: self.matches.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(matches))
                    })?,
                })
            }
        }
        impl PseudoElementMatches {
            pub const IDENTIFIER: &'static str = "CSS.PseudoElementMatches";
        }
        #[doc = "Inherited CSS rule collection from ancestor node.\n[InheritedStyleEntry](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-InheritedStyleEntry)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InheritedStyleEntry {
            #[doc = "The ancestor node's inline style, if any, in the style inheritance chain."]
            #[serde(rename = "inlineStyle")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub inline_style: Option<CssStyle>,
            #[doc = "Matches of CSS rules matching the ancestor node in the style inheritance chain."]
            #[serde(rename = "matchedCSSRules")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub matched_css_rules: Vec<RuleMatch>,
        }
        impl InheritedStyleEntry {
            pub fn new(matched_css_rules: Vec<RuleMatch>) -> Self {
                Self {
                    matched_css_rules,
                    inline_style: None,
                }
            }
        }
        impl InheritedStyleEntry {
            pub fn builder() -> InheritedStyleEntryBuilder {
                InheritedStyleEntryBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct InheritedStyleEntryBuilder {
            inline_style: Option<CssStyle>,
            matched_css_rules: Option<Vec<RuleMatch>>,
        }
        impl InheritedStyleEntryBuilder {
            pub fn inline_style(mut self, inline_style: impl Into<CssStyle>) -> Self {
                self.inline_style = Some(inline_style.into());
                self
            }
            pub fn matched_css_rule(mut self, matched_css_rule: impl Into<RuleMatch>) -> Self {
                let v = self.matched_css_rules.get_or_insert(Vec::new());
                v.push(matched_css_rule.into());
                self
            }
            pub fn matched_css_rules<I, S>(mut self, matched_css_rules: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<RuleMatch>,
            {
                let v = self.matched_css_rules.get_or_insert(Vec::new());
                for val in matched_css_rules {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<InheritedStyleEntry, String> {
                Ok(InheritedStyleEntry {
                    inline_style: self.inline_style,
                    matched_css_rules: self.matched_css_rules.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(matched_css_rules)
                        )
                    })?,
                })
            }
        }
        impl InheritedStyleEntry {
            pub const IDENTIFIER: &'static str = "CSS.InheritedStyleEntry";
        }
        #[doc = "Inherited pseudo element matches from pseudos of an ancestor node.\n[InheritedPseudoElementMatches](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-InheritedPseudoElementMatches)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InheritedPseudoElementMatches {
            #[doc = "Matches of pseudo styles from the pseudos of an ancestor node."]
            #[serde(rename = "pseudoElements")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub pseudo_elements: Vec<PseudoElementMatches>,
        }
        impl InheritedPseudoElementMatches {
            pub fn new(pseudo_elements: Vec<PseudoElementMatches>) -> Self {
                Self { pseudo_elements }
            }
        }
        impl InheritedPseudoElementMatches {
            pub fn builder() -> InheritedPseudoElementMatchesBuilder {
                InheritedPseudoElementMatchesBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct InheritedPseudoElementMatchesBuilder {
            pseudo_elements: Option<Vec<PseudoElementMatches>>,
        }
        impl InheritedPseudoElementMatchesBuilder {
            pub fn pseudo_element(
                mut self,
                pseudo_element: impl Into<PseudoElementMatches>,
            ) -> Self {
                let v = self.pseudo_elements.get_or_insert(Vec::new());
                v.push(pseudo_element.into());
                self
            }
            pub fn pseudo_elements<I, S>(mut self, pseudo_elements: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PseudoElementMatches>,
            {
                let v = self.pseudo_elements.get_or_insert(Vec::new());
                for val in pseudo_elements {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<InheritedPseudoElementMatches, String> {
                Ok(InheritedPseudoElementMatches {
                    pseudo_elements: self.pseudo_elements.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(pseudo_elements))
                    })?,
                })
            }
        }
        impl InheritedPseudoElementMatches {
            pub const IDENTIFIER: &'static str = "CSS.InheritedPseudoElementMatches";
        }
        #[doc = "Match data for a CSS rule.\n[RuleMatch](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-RuleMatch)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RuleMatch {
            #[doc = "CSS rule in the match."]
            #[serde(rename = "rule")]
            pub rule: CssRule,
            #[doc = "Matching selector indices in the rule's selectorList selectors (0-based)."]
            #[serde(rename = "matchingSelectors")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub matching_selectors: Vec<i64>,
        }
        impl RuleMatch {
            pub fn new(rule: impl Into<CssRule>, matching_selectors: Vec<i64>) -> Self {
                Self {
                    rule: rule.into(),
                    matching_selectors,
                }
            }
        }
        impl RuleMatch {
            pub fn builder() -> RuleMatchBuilder {
                RuleMatchBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RuleMatchBuilder {
            rule: Option<CssRule>,
            matching_selectors: Option<Vec<i64>>,
        }
        impl RuleMatchBuilder {
            pub fn rule(mut self, rule: impl Into<CssRule>) -> Self {
                self.rule = Some(rule.into());
                self
            }
            pub fn matching_selector(mut self, matching_selector: impl Into<i64>) -> Self {
                let v = self.matching_selectors.get_or_insert(Vec::new());
                v.push(matching_selector.into());
                self
            }
            pub fn matching_selectors<I, S>(mut self, matching_selectors: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.matching_selectors.get_or_insert(Vec::new());
                for val in matching_selectors {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<RuleMatch, String> {
                Ok(RuleMatch {
                    rule: self.rule.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(rule))
                    })?,
                    matching_selectors: self.matching_selectors.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(matching_selectors)
                        )
                    })?,
                })
            }
        }
        impl RuleMatch {
            pub const IDENTIFIER: &'static str = "CSS.RuleMatch";
        }
        #[doc = "Data for a simple selector (these are delimited by commas in a selector list).\n[Value](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-Value)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Value {
            #[doc = "Value text."]
            #[serde(rename = "text")]
            pub text: String,
            #[doc = "Value range in the underlying resource (if available)."]
            #[serde(rename = "range")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub range: Option<SourceRange>,
        }
        impl Value {
            pub fn new(text: impl Into<String>) -> Self {
                Self {
                    text: text.into(),
                    range: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for Value {
            fn from(url: T) -> Self {
                Value::new(url)
            }
        }
        impl Value {
            pub fn builder() -> ValueBuilder {
                ValueBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ValueBuilder {
            text: Option<String>,
            range: Option<SourceRange>,
        }
        impl ValueBuilder {
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn build(self) -> Result<Value, String> {
                Ok(Value {
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                    range: self.range,
                })
            }
        }
        impl Value {
            pub const IDENTIFIER: &'static str = "CSS.Value";
        }
        #[doc = "Selector list data.\n[SelectorList](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-SelectorList)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SelectorList {
            #[doc = "Selectors in the list."]
            #[serde(rename = "selectors")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub selectors: Vec<Value>,
            #[doc = "Rule selector text."]
            #[serde(rename = "text")]
            pub text: String,
        }
        impl SelectorList {
            pub fn new(selectors: Vec<Value>, text: impl Into<String>) -> Self {
                Self {
                    selectors,
                    text: text.into(),
                }
            }
        }
        impl SelectorList {
            pub fn builder() -> SelectorListBuilder {
                SelectorListBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SelectorListBuilder {
            selectors: Option<Vec<Value>>,
            text: Option<String>,
        }
        impl SelectorListBuilder {
            pub fn selector(mut self, selector: impl Into<Value>) -> Self {
                let v = self.selectors.get_or_insert(Vec::new());
                v.push(selector.into());
                self
            }
            pub fn selectors<I, S>(mut self, selectors: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Value>,
            {
                let v = self.selectors.get_or_insert(Vec::new());
                for val in selectors {
                    v.push(val.into());
                }
                self
            }
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn build(self) -> Result<SelectorList, String> {
                Ok(SelectorList {
                    selectors: self.selectors.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(selectors))
                    })?,
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                })
            }
        }
        impl SelectorList {
            pub const IDENTIFIER: &'static str = "CSS.SelectorList";
        }
        #[doc = "CSS stylesheet metainformation.\n[CSSStyleSheetHeader](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-CSSStyleSheetHeader)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssStyleSheetHeader {
            #[doc = "The stylesheet identifier."]
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
            #[doc = "Owner frame identifier."]
            #[serde(rename = "frameId")]
            pub frame_id: super::page::FrameId,
            #[doc = "Stylesheet resource URL. Empty if this is a constructed stylesheet created using\nnew CSSStyleSheet() (but non-empty if this is a constructed sylesheet imported\nas a CSS module script)."]
            #[serde(rename = "sourceURL")]
            pub source_url: String,
            #[doc = "URL of source map associated with the stylesheet (if any)."]
            #[serde(rename = "sourceMapURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub source_map_url: Option<String>,
            #[doc = "Stylesheet origin."]
            #[serde(rename = "origin")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub origin: StyleSheetOrigin,
            #[doc = "Stylesheet title."]
            #[serde(rename = "title")]
            pub title: String,
            #[doc = "The backend id for the owner node of the stylesheet."]
            #[serde(rename = "ownerNode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub owner_node: Option<super::dom::BackendNodeId>,
            #[doc = "Denotes whether the stylesheet is disabled."]
            #[serde(rename = "disabled")]
            pub disabled: bool,
            #[doc = "Whether the sourceURL field value comes from the sourceURL comment."]
            #[serde(rename = "hasSourceURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub has_source_url: Option<bool>,
            #[doc = "Whether this stylesheet is created for STYLE tag by parser. This flag is not set for\ndocument.written STYLE tags."]
            #[serde(rename = "isInline")]
            pub is_inline: bool,
            #[doc = "Whether this stylesheet is mutable. Inline stylesheets become mutable\nafter they have been modified via CSSOM API.\n<link> element's stylesheets become mutable only if DevTools modifies them.\nConstructed stylesheets (new CSSStyleSheet()) are mutable immediately after creation."]
            #[serde(rename = "isMutable")]
            pub is_mutable: bool,
            #[doc = "True if this stylesheet is created through new CSSStyleSheet() or imported as a\nCSS module script."]
            #[serde(rename = "isConstructed")]
            pub is_constructed: bool,
            #[doc = "Line offset of the stylesheet within the resource (zero based)."]
            #[serde(rename = "startLine")]
            pub start_line: f64,
            #[doc = "Column offset of the stylesheet within the resource (zero based)."]
            #[serde(rename = "startColumn")]
            pub start_column: f64,
            #[doc = "Size of the content (in characters)."]
            #[serde(rename = "length")]
            pub length: f64,
            #[doc = "Line offset of the end of the stylesheet within the resource (zero based)."]
            #[serde(rename = "endLine")]
            pub end_line: f64,
            #[doc = "Column offset of the end of the stylesheet within the resource (zero based)."]
            #[serde(rename = "endColumn")]
            pub end_column: f64,
        }
        impl CssStyleSheetHeader {
            pub fn builder() -> CssStyleSheetHeaderBuilder {
                CssStyleSheetHeaderBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssStyleSheetHeaderBuilder {
            style_sheet_id: Option<StyleSheetId>,
            frame_id: Option<super::page::FrameId>,
            source_url: Option<String>,
            source_map_url: Option<String>,
            origin: Option<StyleSheetOrigin>,
            title: Option<String>,
            owner_node: Option<super::dom::BackendNodeId>,
            disabled: Option<bool>,
            has_source_url: Option<bool>,
            is_inline: Option<bool>,
            is_mutable: Option<bool>,
            is_constructed: Option<bool>,
            start_line: Option<f64>,
            start_column: Option<f64>,
            length: Option<f64>,
            end_line: Option<f64>,
            end_column: Option<f64>,
        }
        impl CssStyleSheetHeaderBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn source_url(mut self, source_url: impl Into<String>) -> Self {
                self.source_url = Some(source_url.into());
                self
            }
            pub fn source_map_url(mut self, source_map_url: impl Into<String>) -> Self {
                self.source_map_url = Some(source_map_url.into());
                self
            }
            pub fn origin(mut self, origin: impl Into<StyleSheetOrigin>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn title(mut self, title: impl Into<String>) -> Self {
                self.title = Some(title.into());
                self
            }
            pub fn owner_node(mut self, owner_node: impl Into<super::dom::BackendNodeId>) -> Self {
                self.owner_node = Some(owner_node.into());
                self
            }
            pub fn disabled(mut self, disabled: impl Into<bool>) -> Self {
                self.disabled = Some(disabled.into());
                self
            }
            pub fn has_source_url(mut self, has_source_url: impl Into<bool>) -> Self {
                self.has_source_url = Some(has_source_url.into());
                self
            }
            pub fn is_inline(mut self, is_inline: impl Into<bool>) -> Self {
                self.is_inline = Some(is_inline.into());
                self
            }
            pub fn is_mutable(mut self, is_mutable: impl Into<bool>) -> Self {
                self.is_mutable = Some(is_mutable.into());
                self
            }
            pub fn is_constructed(mut self, is_constructed: impl Into<bool>) -> Self {
                self.is_constructed = Some(is_constructed.into());
                self
            }
            pub fn start_line(mut self, start_line: impl Into<f64>) -> Self {
                self.start_line = Some(start_line.into());
                self
            }
            pub fn start_column(mut self, start_column: impl Into<f64>) -> Self {
                self.start_column = Some(start_column.into());
                self
            }
            pub fn length(mut self, length: impl Into<f64>) -> Self {
                self.length = Some(length.into());
                self
            }
            pub fn end_line(mut self, end_line: impl Into<f64>) -> Self {
                self.end_line = Some(end_line.into());
                self
            }
            pub fn end_column(mut self, end_column: impl Into<f64>) -> Self {
                self.end_column = Some(end_column.into());
                self
            }
            pub fn build(self) -> Result<CssStyleSheetHeader, String> {
                Ok(CssStyleSheetHeader {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                    source_url: self.source_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(source_url))
                    })?,
                    source_map_url: self.source_map_url,
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    title: self.title.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(title))
                    })?,
                    owner_node: self.owner_node,
                    disabled: self.disabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(disabled))
                    })?,
                    has_source_url: self.has_source_url,
                    is_inline: self.is_inline.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(is_inline))
                    })?,
                    is_mutable: self.is_mutable.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(is_mutable))
                    })?,
                    is_constructed: self.is_constructed.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(is_constructed))
                    })?,
                    start_line: self.start_line.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(start_line))
                    })?,
                    start_column: self.start_column.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(start_column))
                    })?,
                    length: self.length.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(length))
                    })?,
                    end_line: self.end_line.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(end_line))
                    })?,
                    end_column: self.end_column.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(end_column))
                    })?,
                })
            }
        }
        impl CssStyleSheetHeader {
            pub const IDENTIFIER: &'static str = "CSS.CSSStyleSheetHeader";
        }
        #[doc = "CSS rule representation.\n[CSSRule](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-CSSRule)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssRule {
            #[doc = "The css style sheet identifier (absent for user agent stylesheet and user-specified\nstylesheet rules) this rule came from."]
            #[serde(rename = "styleSheetId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub style_sheet_id: Option<StyleSheetId>,
            #[doc = "Rule selector data."]
            #[serde(rename = "selectorList")]
            pub selector_list: SelectorList,
            #[doc = "Parent stylesheet's origin."]
            #[serde(rename = "origin")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub origin: StyleSheetOrigin,
            #[doc = "Associated style declaration."]
            #[serde(rename = "style")]
            pub style: CssStyle,
            #[doc = "Media list array (for rules involving media queries). The array enumerates media queries\nstarting with the innermost one, going outwards."]
            #[serde(rename = "media")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub media: Option<Vec<CssMedia>>,
            #[doc = "Container query list array (for rules involving container queries).\nThe array enumerates container queries starting with the innermost one, going outwards."]
            #[serde(rename = "containerQueries")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub container_queries: Option<Vec<CssContainerQuery>>,
            #[doc = "@supports CSS at-rule array.\nThe array enumerates @supports at-rules starting with the innermost one, going outwards."]
            #[serde(rename = "supports")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub supports: Option<Vec<CssSupports>>,
            #[doc = "Cascade layer array. Contains the layer hierarchy that this rule belongs to starting\nwith the innermost layer and going outwards."]
            #[serde(rename = "layers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub layers: Option<Vec<CssLayer>>,
            #[doc = "@scope CSS at-rule array.\nThe array enumerates @scope at-rules starting with the innermost one, going outwards."]
            #[serde(rename = "scopes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub scopes: Option<Vec<CssScope>>,
        }
        impl CssRule {
            pub fn new(
                selector_list: impl Into<SelectorList>,
                origin: impl Into<StyleSheetOrigin>,
                style: impl Into<CssStyle>,
            ) -> Self {
                Self {
                    selector_list: selector_list.into(),
                    origin: origin.into(),
                    style: style.into(),
                    style_sheet_id: None,
                    media: None,
                    container_queries: None,
                    supports: None,
                    layers: None,
                    scopes: None,
                }
            }
        }
        impl CssRule {
            pub fn builder() -> CssRuleBuilder {
                CssRuleBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssRuleBuilder {
            style_sheet_id: Option<StyleSheetId>,
            selector_list: Option<SelectorList>,
            origin: Option<StyleSheetOrigin>,
            style: Option<CssStyle>,
            media: Option<Vec<CssMedia>>,
            container_queries: Option<Vec<CssContainerQuery>>,
            supports: Option<Vec<CssSupports>>,
            layers: Option<Vec<CssLayer>>,
            scopes: Option<Vec<CssScope>>,
        }
        impl CssRuleBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn selector_list(mut self, selector_list: impl Into<SelectorList>) -> Self {
                self.selector_list = Some(selector_list.into());
                self
            }
            pub fn origin(mut self, origin: impl Into<StyleSheetOrigin>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn style(mut self, style: impl Into<CssStyle>) -> Self {
                self.style = Some(style.into());
                self
            }
            pub fn media(mut self, media: impl Into<CssMedia>) -> Self {
                let v = self.media.get_or_insert(Vec::new());
                v.push(media.into());
                self
            }
            pub fn medias<I, S>(mut self, medias: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssMedia>,
            {
                let v = self.media.get_or_insert(Vec::new());
                for val in medias {
                    v.push(val.into());
                }
                self
            }
            pub fn container_querie(
                mut self,
                container_querie: impl Into<CssContainerQuery>,
            ) -> Self {
                let v = self.container_queries.get_or_insert(Vec::new());
                v.push(container_querie.into());
                self
            }
            pub fn container_queries<I, S>(mut self, container_queries: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssContainerQuery>,
            {
                let v = self.container_queries.get_or_insert(Vec::new());
                for val in container_queries {
                    v.push(val.into());
                }
                self
            }
            pub fn support(mut self, support: impl Into<CssSupports>) -> Self {
                let v = self.supports.get_or_insert(Vec::new());
                v.push(support.into());
                self
            }
            pub fn supports<I, S>(mut self, supports: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssSupports>,
            {
                let v = self.supports.get_or_insert(Vec::new());
                for val in supports {
                    v.push(val.into());
                }
                self
            }
            pub fn layer(mut self, layer: impl Into<CssLayer>) -> Self {
                let v = self.layers.get_or_insert(Vec::new());
                v.push(layer.into());
                self
            }
            pub fn layers<I, S>(mut self, layers: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssLayer>,
            {
                let v = self.layers.get_or_insert(Vec::new());
                for val in layers {
                    v.push(val.into());
                }
                self
            }
            pub fn scope(mut self, scope: impl Into<CssScope>) -> Self {
                let v = self.scopes.get_or_insert(Vec::new());
                v.push(scope.into());
                self
            }
            pub fn scopes<I, S>(mut self, scopes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssScope>,
            {
                let v = self.scopes.get_or_insert(Vec::new());
                for val in scopes {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<CssRule, String> {
                Ok(CssRule {
                    style_sheet_id: self.style_sheet_id,
                    selector_list: self.selector_list.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(selector_list))
                    })?,
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    style: self.style.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style))
                    })?,
                    media: self.media,
                    container_queries: self.container_queries,
                    supports: self.supports,
                    layers: self.layers,
                    scopes: self.scopes,
                })
            }
        }
        impl CssRule {
            pub const IDENTIFIER: &'static str = "CSS.CSSRule";
        }
        #[doc = "CSS coverage information.\n[RuleUsage](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-RuleUsage)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RuleUsage {
            #[doc = "The css style sheet identifier (absent for user agent stylesheet and user-specified\nstylesheet rules) this rule came from."]
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
            #[doc = "Offset of the start of the rule (including selector) from the beginning of the stylesheet."]
            #[serde(rename = "startOffset")]
            pub start_offset: f64,
            #[doc = "Offset of the end of the rule body from the beginning of the stylesheet."]
            #[serde(rename = "endOffset")]
            pub end_offset: f64,
            #[doc = "Indicates whether the rule was actually used by some element in the page."]
            #[serde(rename = "used")]
            pub used: bool,
        }
        impl RuleUsage {
            pub fn new(
                style_sheet_id: impl Into<StyleSheetId>,
                start_offset: impl Into<f64>,
                end_offset: impl Into<f64>,
                used: impl Into<bool>,
            ) -> Self {
                Self {
                    style_sheet_id: style_sheet_id.into(),
                    start_offset: start_offset.into(),
                    end_offset: end_offset.into(),
                    used: used.into(),
                }
            }
        }
        impl RuleUsage {
            pub fn builder() -> RuleUsageBuilder {
                RuleUsageBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RuleUsageBuilder {
            style_sheet_id: Option<StyleSheetId>,
            start_offset: Option<f64>,
            end_offset: Option<f64>,
            used: Option<bool>,
        }
        impl RuleUsageBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn start_offset(mut self, start_offset: impl Into<f64>) -> Self {
                self.start_offset = Some(start_offset.into());
                self
            }
            pub fn end_offset(mut self, end_offset: impl Into<f64>) -> Self {
                self.end_offset = Some(end_offset.into());
                self
            }
            pub fn used(mut self, used: impl Into<bool>) -> Self {
                self.used = Some(used.into());
                self
            }
            pub fn build(self) -> Result<RuleUsage, String> {
                Ok(RuleUsage {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                    start_offset: self.start_offset.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(start_offset))
                    })?,
                    end_offset: self.end_offset.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(end_offset))
                    })?,
                    used: self.used.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(used))
                    })?,
                })
            }
        }
        impl RuleUsage {
            pub const IDENTIFIER: &'static str = "CSS.RuleUsage";
        }
        #[doc = "Text range within a resource. All numbers are zero-based.\n[SourceRange](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-SourceRange)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SourceRange {
            #[doc = "Start line of range."]
            #[serde(rename = "startLine")]
            pub start_line: i64,
            #[doc = "Start column of range (inclusive)."]
            #[serde(rename = "startColumn")]
            pub start_column: i64,
            #[doc = "End line of range"]
            #[serde(rename = "endLine")]
            pub end_line: i64,
            #[doc = "End column of range (exclusive)."]
            #[serde(rename = "endColumn")]
            pub end_column: i64,
        }
        impl SourceRange {
            pub fn new(
                start_line: impl Into<i64>,
                start_column: impl Into<i64>,
                end_line: impl Into<i64>,
                end_column: impl Into<i64>,
            ) -> Self {
                Self {
                    start_line: start_line.into(),
                    start_column: start_column.into(),
                    end_line: end_line.into(),
                    end_column: end_column.into(),
                }
            }
        }
        impl SourceRange {
            pub fn builder() -> SourceRangeBuilder {
                SourceRangeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SourceRangeBuilder {
            start_line: Option<i64>,
            start_column: Option<i64>,
            end_line: Option<i64>,
            end_column: Option<i64>,
        }
        impl SourceRangeBuilder {
            pub fn start_line(mut self, start_line: impl Into<i64>) -> Self {
                self.start_line = Some(start_line.into());
                self
            }
            pub fn start_column(mut self, start_column: impl Into<i64>) -> Self {
                self.start_column = Some(start_column.into());
                self
            }
            pub fn end_line(mut self, end_line: impl Into<i64>) -> Self {
                self.end_line = Some(end_line.into());
                self
            }
            pub fn end_column(mut self, end_column: impl Into<i64>) -> Self {
                self.end_column = Some(end_column.into());
                self
            }
            pub fn build(self) -> Result<SourceRange, String> {
                Ok(SourceRange {
                    start_line: self.start_line.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(start_line))
                    })?,
                    start_column: self.start_column.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(start_column))
                    })?,
                    end_line: self.end_line.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(end_line))
                    })?,
                    end_column: self.end_column.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(end_column))
                    })?,
                })
            }
        }
        impl SourceRange {
            pub const IDENTIFIER: &'static str = "CSS.SourceRange";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ShorthandEntry {
            #[doc = "Shorthand name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Shorthand value."]
            #[serde(rename = "value")]
            pub value: String,
            #[doc = "Whether the property has \"!important\" annotation (implies `false` if absent)."]
            #[serde(rename = "important")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub important: Option<bool>,
        }
        impl ShorthandEntry {
            pub fn new(name: impl Into<String>, value: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                    important: None,
                }
            }
        }
        impl ShorthandEntry {
            pub fn builder() -> ShorthandEntryBuilder {
                ShorthandEntryBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ShorthandEntryBuilder {
            name: Option<String>,
            value: Option<String>,
            important: Option<bool>,
        }
        impl ShorthandEntryBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn important(mut self, important: impl Into<bool>) -> Self {
                self.important = Some(important.into());
                self
            }
            pub fn build(self) -> Result<ShorthandEntry, String> {
                Ok(ShorthandEntry {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                    important: self.important,
                })
            }
        }
        impl ShorthandEntry {
            pub const IDENTIFIER: &'static str = "CSS.ShorthandEntry";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssComputedStyleProperty {
            #[doc = "Computed style property name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Computed style property value."]
            #[serde(rename = "value")]
            pub value: String,
        }
        impl CssComputedStyleProperty {
            pub fn new(name: impl Into<String>, value: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                }
            }
        }
        impl CssComputedStyleProperty {
            pub fn builder() -> CssComputedStylePropertyBuilder {
                CssComputedStylePropertyBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssComputedStylePropertyBuilder {
            name: Option<String>,
            value: Option<String>,
        }
        impl CssComputedStylePropertyBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<CssComputedStyleProperty, String> {
                Ok(CssComputedStyleProperty {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl CssComputedStyleProperty {
            pub const IDENTIFIER: &'static str = "CSS.CSSComputedStyleProperty";
        }
        #[doc = "CSS style representation.\n[CSSStyle](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-CSSStyle)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssStyle {
            #[doc = "The css style sheet identifier (absent for user agent stylesheet and user-specified\nstylesheet rules) this rule came from."]
            #[serde(rename = "styleSheetId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub style_sheet_id: Option<StyleSheetId>,
            #[doc = "CSS properties in the style."]
            #[serde(rename = "cssProperties")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub css_properties: Vec<CssProperty>,
            #[doc = "Computed values for all shorthands found in the style."]
            #[serde(rename = "shorthandEntries")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub shorthand_entries: Vec<ShorthandEntry>,
            #[doc = "Style declaration text (if available)."]
            #[serde(rename = "cssText")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub css_text: Option<String>,
            #[doc = "Style declaration range in the enclosing stylesheet (if available)."]
            #[serde(rename = "range")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub range: Option<SourceRange>,
        }
        impl CssStyle {
            pub fn new(
                css_properties: Vec<CssProperty>,
                shorthand_entries: Vec<ShorthandEntry>,
            ) -> Self {
                Self {
                    css_properties,
                    shorthand_entries,
                    style_sheet_id: None,
                    css_text: None,
                    range: None,
                }
            }
        }
        impl CssStyle {
            pub fn builder() -> CssStyleBuilder {
                CssStyleBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssStyleBuilder {
            style_sheet_id: Option<StyleSheetId>,
            css_properties: Option<Vec<CssProperty>>,
            shorthand_entries: Option<Vec<ShorthandEntry>>,
            css_text: Option<String>,
            range: Option<SourceRange>,
        }
        impl CssStyleBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn css_propertie(mut self, css_propertie: impl Into<CssProperty>) -> Self {
                let v = self.css_properties.get_or_insert(Vec::new());
                v.push(css_propertie.into());
                self
            }
            pub fn css_properties<I, S>(mut self, css_properties: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssProperty>,
            {
                let v = self.css_properties.get_or_insert(Vec::new());
                for val in css_properties {
                    v.push(val.into());
                }
                self
            }
            pub fn shorthand_entrie(mut self, shorthand_entrie: impl Into<ShorthandEntry>) -> Self {
                let v = self.shorthand_entries.get_or_insert(Vec::new());
                v.push(shorthand_entrie.into());
                self
            }
            pub fn shorthand_entries<I, S>(mut self, shorthand_entries: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ShorthandEntry>,
            {
                let v = self.shorthand_entries.get_or_insert(Vec::new());
                for val in shorthand_entries {
                    v.push(val.into());
                }
                self
            }
            pub fn css_text(mut self, css_text: impl Into<String>) -> Self {
                self.css_text = Some(css_text.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn build(self) -> Result<CssStyle, String> {
                Ok(CssStyle {
                    style_sheet_id: self.style_sheet_id,
                    css_properties: self.css_properties.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(css_properties))
                    })?,
                    shorthand_entries: self.shorthand_entries.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(shorthand_entries)
                        )
                    })?,
                    css_text: self.css_text,
                    range: self.range,
                })
            }
        }
        impl CssStyle {
            pub const IDENTIFIER: &'static str = "CSS.CSSStyle";
        }
        #[doc = "CSS property declaration data.\n[CSSProperty](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-CSSProperty)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssProperty {
            #[doc = "The property name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "The property value."]
            #[serde(rename = "value")]
            pub value: String,
            #[doc = "Whether the property has \"!important\" annotation (implies `false` if absent)."]
            #[serde(rename = "important")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub important: Option<bool>,
            #[doc = "Whether the property is implicit (implies `false` if absent)."]
            #[serde(rename = "implicit")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub implicit: Option<bool>,
            #[doc = "The full property text as specified in the style."]
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub text: Option<String>,
            #[doc = "Whether the property is understood by the browser (implies `true` if absent)."]
            #[serde(rename = "parsedOk")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub parsed_ok: Option<bool>,
            #[doc = "Whether the property is disabled by the user (present for source-based properties only)."]
            #[serde(rename = "disabled")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub disabled: Option<bool>,
            #[doc = "The entire property range in the enclosing style declaration (if available)."]
            #[serde(rename = "range")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub range: Option<SourceRange>,
            #[doc = "Parsed longhand components of this property if it is a shorthand.\nThis field will be empty if the given property is not a shorthand."]
            #[serde(rename = "longhandProperties")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub longhand_properties: Option<Vec<CssProperty>>,
        }
        impl CssProperty {
            pub fn new(name: impl Into<String>, value: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                    important: None,
                    implicit: None,
                    text: None,
                    parsed_ok: None,
                    disabled: None,
                    range: None,
                    longhand_properties: None,
                }
            }
        }
        impl CssProperty {
            pub fn builder() -> CssPropertyBuilder {
                CssPropertyBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssPropertyBuilder {
            name: Option<String>,
            value: Option<String>,
            important: Option<bool>,
            implicit: Option<bool>,
            text: Option<String>,
            parsed_ok: Option<bool>,
            disabled: Option<bool>,
            range: Option<SourceRange>,
            longhand_properties: Option<Vec<CssProperty>>,
        }
        impl CssPropertyBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn important(mut self, important: impl Into<bool>) -> Self {
                self.important = Some(important.into());
                self
            }
            pub fn implicit(mut self, implicit: impl Into<bool>) -> Self {
                self.implicit = Some(implicit.into());
                self
            }
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn parsed_ok(mut self, parsed_ok: impl Into<bool>) -> Self {
                self.parsed_ok = Some(parsed_ok.into());
                self
            }
            pub fn disabled(mut self, disabled: impl Into<bool>) -> Self {
                self.disabled = Some(disabled.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn longhand_propertie(
                mut self,
                longhand_propertie: impl Into<CssProperty>,
            ) -> Self {
                let v = self.longhand_properties.get_or_insert(Vec::new());
                v.push(longhand_propertie.into());
                self
            }
            pub fn longhand_properties<I, S>(mut self, longhand_properties: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssProperty>,
            {
                let v = self.longhand_properties.get_or_insert(Vec::new());
                for val in longhand_properties {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<CssProperty, String> {
                Ok(CssProperty {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                    important: self.important,
                    implicit: self.implicit,
                    text: self.text,
                    parsed_ok: self.parsed_ok,
                    disabled: self.disabled,
                    range: self.range,
                    longhand_properties: self.longhand_properties,
                })
            }
        }
        impl CssProperty {
            pub const IDENTIFIER: &'static str = "CSS.CSSProperty";
        }
        #[doc = "CSS media rule descriptor.\n[CSSMedia](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-CSSMedia)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssMedia {
            #[doc = "Media query text."]
            #[serde(rename = "text")]
            pub text: String,
            #[doc = "Source of the media query: \"mediaRule\" if specified by a @media rule, \"importRule\" if\nspecified by an @import rule, \"linkedSheet\" if specified by a \"media\" attribute in a linked\nstylesheet's LINK tag, \"inlineSheet\" if specified by a \"media\" attribute in an inline\nstylesheet's STYLE tag."]
            #[serde(rename = "source")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub source: CssMediaSource,
            #[doc = "URL of the document containing the media query description."]
            #[serde(rename = "sourceURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub source_url: Option<String>,
            #[doc = "The associated rule (@media or @import) header range in the enclosing stylesheet (if\navailable)."]
            #[serde(rename = "range")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub range: Option<SourceRange>,
            #[doc = "Identifier of the stylesheet containing this object (if exists)."]
            #[serde(rename = "styleSheetId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub style_sheet_id: Option<StyleSheetId>,
            #[doc = "Array of media queries."]
            #[serde(rename = "mediaList")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub media_list: Option<Vec<MediaQuery>>,
        }
        #[doc = "Source of the media query: \"mediaRule\" if specified by a @media rule, \"importRule\" if\nspecified by an @import rule, \"linkedSheet\" if specified by a \"media\" attribute in a linked\nstylesheet's LINK tag, \"inlineSheet\" if specified by a \"media\" attribute in an inline\nstylesheet's STYLE tag."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CssMediaSource {
            #[serde(rename = "mediaRule")]
            MediaRule,
            #[serde(rename = "importRule")]
            ImportRule,
            #[serde(rename = "linkedSheet")]
            LinkedSheet,
            #[serde(rename = "inlineSheet")]
            InlineSheet,
        }
        impl AsRef<str> for CssMediaSource {
            fn as_ref(&self) -> &str {
                match self {
                    CssMediaSource::MediaRule => "mediaRule",
                    CssMediaSource::ImportRule => "importRule",
                    CssMediaSource::LinkedSheet => "linkedSheet",
                    CssMediaSource::InlineSheet => "inlineSheet",
                }
            }
        }
        impl ::std::str::FromStr for CssMediaSource {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "mediaRule" | "MediaRule" | "mediarule" => Ok(CssMediaSource::MediaRule),
                    "importRule" | "ImportRule" | "importrule" => Ok(CssMediaSource::ImportRule),
                    "linkedSheet" | "LinkedSheet" | "linkedsheet" => {
                        Ok(CssMediaSource::LinkedSheet)
                    }
                    "inlineSheet" | "InlineSheet" | "inlinesheet" => {
                        Ok(CssMediaSource::InlineSheet)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl CssMedia {
            pub fn new(text: impl Into<String>, source: impl Into<CssMediaSource>) -> Self {
                Self {
                    text: text.into(),
                    source: source.into(),
                    source_url: None,
                    range: None,
                    style_sheet_id: None,
                    media_list: None,
                }
            }
        }
        impl CssMedia {
            pub fn builder() -> CssMediaBuilder {
                CssMediaBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssMediaBuilder {
            text: Option<String>,
            source: Option<CssMediaSource>,
            source_url: Option<String>,
            range: Option<SourceRange>,
            style_sheet_id: Option<StyleSheetId>,
            media_list: Option<Vec<MediaQuery>>,
        }
        impl CssMediaBuilder {
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn source(mut self, source: impl Into<CssMediaSource>) -> Self {
                self.source = Some(source.into());
                self
            }
            pub fn source_url(mut self, source_url: impl Into<String>) -> Self {
                self.source_url = Some(source_url.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn media_list(mut self, media_list: impl Into<MediaQuery>) -> Self {
                let v = self.media_list.get_or_insert(Vec::new());
                v.push(media_list.into());
                self
            }
            pub fn media_lists<I, S>(mut self, media_lists: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<MediaQuery>,
            {
                let v = self.media_list.get_or_insert(Vec::new());
                for val in media_lists {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<CssMedia, String> {
                Ok(CssMedia {
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                    source: self.source.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(source))
                    })?,
                    source_url: self.source_url,
                    range: self.range,
                    style_sheet_id: self.style_sheet_id,
                    media_list: self.media_list,
                })
            }
        }
        impl CssMedia {
            pub const IDENTIFIER: &'static str = "CSS.CSSMedia";
        }
        #[doc = "Media query descriptor.\n[MediaQuery](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-MediaQuery)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct MediaQuery {
            #[doc = "Array of media query expressions."]
            #[serde(rename = "expressions")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub expressions: Vec<MediaQueryExpression>,
            #[doc = "Whether the media query condition is satisfied."]
            #[serde(rename = "active")]
            pub active: bool,
        }
        impl MediaQuery {
            pub fn new(expressions: Vec<MediaQueryExpression>, active: impl Into<bool>) -> Self {
                Self {
                    expressions,
                    active: active.into(),
                }
            }
        }
        impl MediaQuery {
            pub fn builder() -> MediaQueryBuilder {
                MediaQueryBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct MediaQueryBuilder {
            expressions: Option<Vec<MediaQueryExpression>>,
            active: Option<bool>,
        }
        impl MediaQueryBuilder {
            pub fn expression(mut self, expression: impl Into<MediaQueryExpression>) -> Self {
                let v = self.expressions.get_or_insert(Vec::new());
                v.push(expression.into());
                self
            }
            pub fn expressions<I, S>(mut self, expressions: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<MediaQueryExpression>,
            {
                let v = self.expressions.get_or_insert(Vec::new());
                for val in expressions {
                    v.push(val.into());
                }
                self
            }
            pub fn active(mut self, active: impl Into<bool>) -> Self {
                self.active = Some(active.into());
                self
            }
            pub fn build(self) -> Result<MediaQuery, String> {
                Ok(MediaQuery {
                    expressions: self.expressions.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(expressions))
                    })?,
                    active: self.active.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(active))
                    })?,
                })
            }
        }
        impl MediaQuery {
            pub const IDENTIFIER: &'static str = "CSS.MediaQuery";
        }
        #[doc = "Media query expression descriptor.\n[MediaQueryExpression](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-MediaQueryExpression)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct MediaQueryExpression {
            #[doc = "Media query expression value."]
            #[serde(rename = "value")]
            pub value: f64,
            #[doc = "Media query expression units."]
            #[serde(rename = "unit")]
            pub unit: String,
            #[doc = "Media query expression feature."]
            #[serde(rename = "feature")]
            pub feature: String,
            #[doc = "The associated range of the value text in the enclosing stylesheet (if available)."]
            #[serde(rename = "valueRange")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value_range: Option<SourceRange>,
            #[doc = "Computed length of media query expression (if applicable)."]
            #[serde(rename = "computedLength")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub computed_length: Option<f64>,
        }
        impl MediaQueryExpression {
            pub fn new(
                value: impl Into<f64>,
                unit: impl Into<String>,
                feature: impl Into<String>,
            ) -> Self {
                Self {
                    value: value.into(),
                    unit: unit.into(),
                    feature: feature.into(),
                    value_range: None,
                    computed_length: None,
                }
            }
        }
        impl MediaQueryExpression {
            pub fn builder() -> MediaQueryExpressionBuilder {
                MediaQueryExpressionBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct MediaQueryExpressionBuilder {
            value: Option<f64>,
            unit: Option<String>,
            feature: Option<String>,
            value_range: Option<SourceRange>,
            computed_length: Option<f64>,
        }
        impl MediaQueryExpressionBuilder {
            pub fn value(mut self, value: impl Into<f64>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn unit(mut self, unit: impl Into<String>) -> Self {
                self.unit = Some(unit.into());
                self
            }
            pub fn feature(mut self, feature: impl Into<String>) -> Self {
                self.feature = Some(feature.into());
                self
            }
            pub fn value_range(mut self, value_range: impl Into<SourceRange>) -> Self {
                self.value_range = Some(value_range.into());
                self
            }
            pub fn computed_length(mut self, computed_length: impl Into<f64>) -> Self {
                self.computed_length = Some(computed_length.into());
                self
            }
            pub fn build(self) -> Result<MediaQueryExpression, String> {
                Ok(MediaQueryExpression {
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                    unit: self.unit.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(unit))
                    })?,
                    feature: self.feature.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(feature))
                    })?,
                    value_range: self.value_range,
                    computed_length: self.computed_length,
                })
            }
        }
        impl MediaQueryExpression {
            pub const IDENTIFIER: &'static str = "CSS.MediaQueryExpression";
        }
        #[doc = "CSS container query rule descriptor.\n[CSSContainerQuery](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-CSSContainerQuery)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssContainerQuery {
            #[doc = "Container query text."]
            #[serde(rename = "text")]
            pub text: String,
            #[doc = "The associated rule header range in the enclosing stylesheet (if\navailable)."]
            #[serde(rename = "range")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub range: Option<SourceRange>,
            #[doc = "Identifier of the stylesheet containing this object (if exists)."]
            #[serde(rename = "styleSheetId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub style_sheet_id: Option<StyleSheetId>,
            #[doc = "Optional name for the container."]
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub name: Option<String>,
        }
        impl CssContainerQuery {
            pub fn new(text: impl Into<String>) -> Self {
                Self {
                    text: text.into(),
                    range: None,
                    style_sheet_id: None,
                    name: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for CssContainerQuery {
            fn from(url: T) -> Self {
                CssContainerQuery::new(url)
            }
        }
        impl CssContainerQuery {
            pub fn builder() -> CssContainerQueryBuilder {
                CssContainerQueryBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssContainerQueryBuilder {
            text: Option<String>,
            range: Option<SourceRange>,
            style_sheet_id: Option<StyleSheetId>,
            name: Option<String>,
        }
        impl CssContainerQueryBuilder {
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn build(self) -> Result<CssContainerQuery, String> {
                Ok(CssContainerQuery {
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                    range: self.range,
                    style_sheet_id: self.style_sheet_id,
                    name: self.name,
                })
            }
        }
        impl CssContainerQuery {
            pub const IDENTIFIER: &'static str = "CSS.CSSContainerQuery";
        }
        #[doc = "CSS Supports at-rule descriptor.\n[CSSSupports](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-CSSSupports)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssSupports {
            #[doc = "Supports rule text."]
            #[serde(rename = "text")]
            pub text: String,
            #[doc = "Whether the supports condition is satisfied."]
            #[serde(rename = "active")]
            pub active: bool,
            #[doc = "The associated rule header range in the enclosing stylesheet (if\navailable)."]
            #[serde(rename = "range")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub range: Option<SourceRange>,
            #[doc = "Identifier of the stylesheet containing this object (if exists)."]
            #[serde(rename = "styleSheetId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub style_sheet_id: Option<StyleSheetId>,
        }
        impl CssSupports {
            pub fn new(text: impl Into<String>, active: impl Into<bool>) -> Self {
                Self {
                    text: text.into(),
                    active: active.into(),
                    range: None,
                    style_sheet_id: None,
                }
            }
        }
        impl CssSupports {
            pub fn builder() -> CssSupportsBuilder {
                CssSupportsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssSupportsBuilder {
            text: Option<String>,
            active: Option<bool>,
            range: Option<SourceRange>,
            style_sheet_id: Option<StyleSheetId>,
        }
        impl CssSupportsBuilder {
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn active(mut self, active: impl Into<bool>) -> Self {
                self.active = Some(active.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn build(self) -> Result<CssSupports, String> {
                Ok(CssSupports {
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                    active: self.active.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(active))
                    })?,
                    range: self.range,
                    style_sheet_id: self.style_sheet_id,
                })
            }
        }
        impl CssSupports {
            pub const IDENTIFIER: &'static str = "CSS.CSSSupports";
        }
        #[doc = "CSS Scope at-rule descriptor.\n[CSSScope](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-CSSScope)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssScope {
            #[doc = "Scope rule text."]
            #[serde(rename = "text")]
            pub text: String,
            #[doc = "The associated rule header range in the enclosing stylesheet (if\navailable)."]
            #[serde(rename = "range")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub range: Option<SourceRange>,
            #[doc = "Identifier of the stylesheet containing this object (if exists)."]
            #[serde(rename = "styleSheetId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub style_sheet_id: Option<StyleSheetId>,
        }
        impl CssScope {
            pub fn new(text: impl Into<String>) -> Self {
                Self {
                    text: text.into(),
                    range: None,
                    style_sheet_id: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for CssScope {
            fn from(url: T) -> Self {
                CssScope::new(url)
            }
        }
        impl CssScope {
            pub fn builder() -> CssScopeBuilder {
                CssScopeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssScopeBuilder {
            text: Option<String>,
            range: Option<SourceRange>,
            style_sheet_id: Option<StyleSheetId>,
        }
        impl CssScopeBuilder {
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn build(self) -> Result<CssScope, String> {
                Ok(CssScope {
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                    range: self.range,
                    style_sheet_id: self.style_sheet_id,
                })
            }
        }
        impl CssScope {
            pub const IDENTIFIER: &'static str = "CSS.CSSScope";
        }
        #[doc = "CSS Layer at-rule descriptor.\n[CSSLayer](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-CSSLayer)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssLayer {
            #[doc = "Layer name."]
            #[serde(rename = "text")]
            pub text: String,
            #[doc = "The associated rule header range in the enclosing stylesheet (if\navailable)."]
            #[serde(rename = "range")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub range: Option<SourceRange>,
            #[doc = "Identifier of the stylesheet containing this object (if exists)."]
            #[serde(rename = "styleSheetId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub style_sheet_id: Option<StyleSheetId>,
        }
        impl CssLayer {
            pub fn new(text: impl Into<String>) -> Self {
                Self {
                    text: text.into(),
                    range: None,
                    style_sheet_id: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for CssLayer {
            fn from(url: T) -> Self {
                CssLayer::new(url)
            }
        }
        impl CssLayer {
            pub fn builder() -> CssLayerBuilder {
                CssLayerBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssLayerBuilder {
            text: Option<String>,
            range: Option<SourceRange>,
            style_sheet_id: Option<StyleSheetId>,
        }
        impl CssLayerBuilder {
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn build(self) -> Result<CssLayer, String> {
                Ok(CssLayer {
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                    range: self.range,
                    style_sheet_id: self.style_sheet_id,
                })
            }
        }
        impl CssLayer {
            pub const IDENTIFIER: &'static str = "CSS.CSSLayer";
        }
        #[doc = "CSS Layer data.\n[CSSLayerData](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-CSSLayerData)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssLayerData {
            #[doc = "Layer name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Direct sub-layers"]
            #[serde(rename = "subLayers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub sub_layers: Option<Vec<CssLayerData>>,
            #[doc = "Layer order. The order determines the order of the layer in the cascade order.\nA higher number has higher priority in the cascade order."]
            #[serde(rename = "order")]
            pub order: f64,
        }
        impl CssLayerData {
            pub fn new(name: impl Into<String>, order: impl Into<f64>) -> Self {
                Self {
                    name: name.into(),
                    order: order.into(),
                    sub_layers: None,
                }
            }
        }
        impl CssLayerData {
            pub fn builder() -> CssLayerDataBuilder {
                CssLayerDataBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssLayerDataBuilder {
            name: Option<String>,
            sub_layers: Option<Vec<CssLayerData>>,
            order: Option<f64>,
        }
        impl CssLayerDataBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn sub_layer(mut self, sub_layer: impl Into<CssLayerData>) -> Self {
                let v = self.sub_layers.get_or_insert(Vec::new());
                v.push(sub_layer.into());
                self
            }
            pub fn sub_layers<I, S>(mut self, sub_layers: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssLayerData>,
            {
                let v = self.sub_layers.get_or_insert(Vec::new());
                for val in sub_layers {
                    v.push(val.into());
                }
                self
            }
            pub fn order(mut self, order: impl Into<f64>) -> Self {
                self.order = Some(order.into());
                self
            }
            pub fn build(self) -> Result<CssLayerData, String> {
                Ok(CssLayerData {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    sub_layers: self.sub_layers,
                    order: self.order.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(order))
                    })?,
                })
            }
        }
        impl CssLayerData {
            pub const IDENTIFIER: &'static str = "CSS.CSSLayerData";
        }
        #[doc = "Information about amount of glyphs that were rendered with given font.\n[PlatformFontUsage](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-PlatformFontUsage)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PlatformFontUsage {
            #[doc = "Font's family name reported by platform."]
            #[serde(rename = "familyName")]
            pub family_name: String,
            #[doc = "Indicates if the font was downloaded or resolved locally."]
            #[serde(rename = "isCustomFont")]
            pub is_custom_font: bool,
            #[doc = "Amount of glyphs that were rendered with this font."]
            #[serde(rename = "glyphCount")]
            pub glyph_count: f64,
        }
        impl PlatformFontUsage {
            pub fn new(
                family_name: impl Into<String>,
                is_custom_font: impl Into<bool>,
                glyph_count: impl Into<f64>,
            ) -> Self {
                Self {
                    family_name: family_name.into(),
                    is_custom_font: is_custom_font.into(),
                    glyph_count: glyph_count.into(),
                }
            }
        }
        impl PlatformFontUsage {
            pub fn builder() -> PlatformFontUsageBuilder {
                PlatformFontUsageBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PlatformFontUsageBuilder {
            family_name: Option<String>,
            is_custom_font: Option<bool>,
            glyph_count: Option<f64>,
        }
        impl PlatformFontUsageBuilder {
            pub fn family_name(mut self, family_name: impl Into<String>) -> Self {
                self.family_name = Some(family_name.into());
                self
            }
            pub fn is_custom_font(mut self, is_custom_font: impl Into<bool>) -> Self {
                self.is_custom_font = Some(is_custom_font.into());
                self
            }
            pub fn glyph_count(mut self, glyph_count: impl Into<f64>) -> Self {
                self.glyph_count = Some(glyph_count.into());
                self
            }
            pub fn build(self) -> Result<PlatformFontUsage, String> {
                Ok(PlatformFontUsage {
                    family_name: self.family_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(family_name))
                    })?,
                    is_custom_font: self.is_custom_font.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(is_custom_font))
                    })?,
                    glyph_count: self.glyph_count.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(glyph_count))
                    })?,
                })
            }
        }
        impl PlatformFontUsage {
            pub const IDENTIFIER: &'static str = "CSS.PlatformFontUsage";
        }
        #[doc = "Information about font variation axes for variable fonts\n[FontVariationAxis](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-FontVariationAxis)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct FontVariationAxis {
            #[doc = "The font-variation-setting tag (a.k.a. \"axis tag\")."]
            #[serde(rename = "tag")]
            pub tag: String,
            #[doc = "Human-readable variation name in the default language (normally, \"en\")."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "The minimum value (inclusive) the font supports for this tag."]
            #[serde(rename = "minValue")]
            pub min_value: f64,
            #[doc = "The maximum value (inclusive) the font supports for this tag."]
            #[serde(rename = "maxValue")]
            pub max_value: f64,
            #[doc = "The default value."]
            #[serde(rename = "defaultValue")]
            pub default_value: f64,
        }
        impl FontVariationAxis {
            pub fn builder() -> FontVariationAxisBuilder {
                FontVariationAxisBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FontVariationAxisBuilder {
            tag: Option<String>,
            name: Option<String>,
            min_value: Option<f64>,
            max_value: Option<f64>,
            default_value: Option<f64>,
        }
        impl FontVariationAxisBuilder {
            pub fn tag(mut self, tag: impl Into<String>) -> Self {
                self.tag = Some(tag.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn min_value(mut self, min_value: impl Into<f64>) -> Self {
                self.min_value = Some(min_value.into());
                self
            }
            pub fn max_value(mut self, max_value: impl Into<f64>) -> Self {
                self.max_value = Some(max_value.into());
                self
            }
            pub fn default_value(mut self, default_value: impl Into<f64>) -> Self {
                self.default_value = Some(default_value.into());
                self
            }
            pub fn build(self) -> Result<FontVariationAxis, String> {
                Ok(FontVariationAxis {
                    tag: self
                        .tag
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(tag)))?,
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    min_value: self.min_value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(min_value))
                    })?,
                    max_value: self.max_value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(max_value))
                    })?,
                    default_value: self.default_value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(default_value))
                    })?,
                })
            }
        }
        impl FontVariationAxis {
            pub const IDENTIFIER: &'static str = "CSS.FontVariationAxis";
        }
        #[doc = "Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions\nand additional information such as platformFontFamily and fontVariationAxes.\n[FontFace](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-FontFace)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct FontFace {
            #[doc = "The font-family."]
            #[serde(rename = "fontFamily")]
            pub font_family: String,
            #[doc = "The font-style."]
            #[serde(rename = "fontStyle")]
            pub font_style: String,
            #[doc = "The font-variant."]
            #[serde(rename = "fontVariant")]
            pub font_variant: String,
            #[doc = "The font-weight."]
            #[serde(rename = "fontWeight")]
            pub font_weight: String,
            #[doc = "The font-stretch."]
            #[serde(rename = "fontStretch")]
            pub font_stretch: String,
            #[doc = "The font-display."]
            #[serde(rename = "fontDisplay")]
            pub font_display: String,
            #[doc = "The unicode-range."]
            #[serde(rename = "unicodeRange")]
            pub unicode_range: String,
            #[doc = "The src."]
            #[serde(rename = "src")]
            pub src: String,
            #[doc = "The resolved platform font family"]
            #[serde(rename = "platformFontFamily")]
            pub platform_font_family: String,
            #[doc = "Available variation settings (a.k.a. \"axes\")."]
            #[serde(rename = "fontVariationAxes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub font_variation_axes: Option<Vec<FontVariationAxis>>,
        }
        impl FontFace {
            pub fn builder() -> FontFaceBuilder {
                FontFaceBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FontFaceBuilder {
            font_family: Option<String>,
            font_style: Option<String>,
            font_variant: Option<String>,
            font_weight: Option<String>,
            font_stretch: Option<String>,
            font_display: Option<String>,
            unicode_range: Option<String>,
            src: Option<String>,
            platform_font_family: Option<String>,
            font_variation_axes: Option<Vec<FontVariationAxis>>,
        }
        impl FontFaceBuilder {
            pub fn font_family(mut self, font_family: impl Into<String>) -> Self {
                self.font_family = Some(font_family.into());
                self
            }
            pub fn font_style(mut self, font_style: impl Into<String>) -> Self {
                self.font_style = Some(font_style.into());
                self
            }
            pub fn font_variant(mut self, font_variant: impl Into<String>) -> Self {
                self.font_variant = Some(font_variant.into());
                self
            }
            pub fn font_weight(mut self, font_weight: impl Into<String>) -> Self {
                self.font_weight = Some(font_weight.into());
                self
            }
            pub fn font_stretch(mut self, font_stretch: impl Into<String>) -> Self {
                self.font_stretch = Some(font_stretch.into());
                self
            }
            pub fn font_display(mut self, font_display: impl Into<String>) -> Self {
                self.font_display = Some(font_display.into());
                self
            }
            pub fn unicode_range(mut self, unicode_range: impl Into<String>) -> Self {
                self.unicode_range = Some(unicode_range.into());
                self
            }
            pub fn src(mut self, src: impl Into<String>) -> Self {
                self.src = Some(src.into());
                self
            }
            pub fn platform_font_family(mut self, platform_font_family: impl Into<String>) -> Self {
                self.platform_font_family = Some(platform_font_family.into());
                self
            }
            pub fn font_variation_axe(
                mut self,
                font_variation_axe: impl Into<FontVariationAxis>,
            ) -> Self {
                let v = self.font_variation_axes.get_or_insert(Vec::new());
                v.push(font_variation_axe.into());
                self
            }
            pub fn font_variation_axes<I, S>(mut self, font_variation_axes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<FontVariationAxis>,
            {
                let v = self.font_variation_axes.get_or_insert(Vec::new());
                for val in font_variation_axes {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<FontFace, String> {
                Ok(FontFace {
                    font_family: self.font_family.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(font_family))
                    })?,
                    font_style: self.font_style.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(font_style))
                    })?,
                    font_variant: self.font_variant.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(font_variant))
                    })?,
                    font_weight: self.font_weight.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(font_weight))
                    })?,
                    font_stretch: self.font_stretch.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(font_stretch))
                    })?,
                    font_display: self.font_display.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(font_display))
                    })?,
                    unicode_range: self.unicode_range.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(unicode_range))
                    })?,
                    src: self
                        .src
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(src)))?,
                    platform_font_family: self.platform_font_family.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(platform_font_family)
                        )
                    })?,
                    font_variation_axes: self.font_variation_axes,
                })
            }
        }
        impl FontFace {
            pub const IDENTIFIER: &'static str = "CSS.FontFace";
        }
        #[doc = "CSS keyframes rule representation.\n[CSSKeyframesRule](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-CSSKeyframesRule)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssKeyframesRule {
            #[doc = "Animation name."]
            #[serde(rename = "animationName")]
            pub animation_name: Value,
            #[doc = "List of keyframes."]
            #[serde(rename = "keyframes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub keyframes: Vec<CssKeyframeRule>,
        }
        impl CssKeyframesRule {
            pub fn new(animation_name: impl Into<Value>, keyframes: Vec<CssKeyframeRule>) -> Self {
                Self {
                    animation_name: animation_name.into(),
                    keyframes,
                }
            }
        }
        impl CssKeyframesRule {
            pub fn builder() -> CssKeyframesRuleBuilder {
                CssKeyframesRuleBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssKeyframesRuleBuilder {
            animation_name: Option<Value>,
            keyframes: Option<Vec<CssKeyframeRule>>,
        }
        impl CssKeyframesRuleBuilder {
            pub fn animation_name(mut self, animation_name: impl Into<Value>) -> Self {
                self.animation_name = Some(animation_name.into());
                self
            }
            pub fn keyframe(mut self, keyframe: impl Into<CssKeyframeRule>) -> Self {
                let v = self.keyframes.get_or_insert(Vec::new());
                v.push(keyframe.into());
                self
            }
            pub fn keyframes<I, S>(mut self, keyframes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssKeyframeRule>,
            {
                let v = self.keyframes.get_or_insert(Vec::new());
                for val in keyframes {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<CssKeyframesRule, String> {
                Ok(CssKeyframesRule {
                    animation_name: self.animation_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(animation_name))
                    })?,
                    keyframes: self.keyframes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(keyframes))
                    })?,
                })
            }
        }
        impl CssKeyframesRule {
            pub const IDENTIFIER: &'static str = "CSS.CSSKeyframesRule";
        }
        #[doc = "CSS keyframe rule representation.\n[CSSKeyframeRule](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-CSSKeyframeRule)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssKeyframeRule {
            #[doc = "The css style sheet identifier (absent for user agent stylesheet and user-specified\nstylesheet rules) this rule came from."]
            #[serde(rename = "styleSheetId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub style_sheet_id: Option<StyleSheetId>,
            #[doc = "Parent stylesheet's origin."]
            #[serde(rename = "origin")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub origin: StyleSheetOrigin,
            #[doc = "Associated key text."]
            #[serde(rename = "keyText")]
            pub key_text: Value,
            #[doc = "Associated style declaration."]
            #[serde(rename = "style")]
            pub style: CssStyle,
        }
        impl CssKeyframeRule {
            pub fn new(
                origin: impl Into<StyleSheetOrigin>,
                key_text: impl Into<Value>,
                style: impl Into<CssStyle>,
            ) -> Self {
                Self {
                    origin: origin.into(),
                    key_text: key_text.into(),
                    style: style.into(),
                    style_sheet_id: None,
                }
            }
        }
        impl CssKeyframeRule {
            pub fn builder() -> CssKeyframeRuleBuilder {
                CssKeyframeRuleBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssKeyframeRuleBuilder {
            style_sheet_id: Option<StyleSheetId>,
            origin: Option<StyleSheetOrigin>,
            key_text: Option<Value>,
            style: Option<CssStyle>,
        }
        impl CssKeyframeRuleBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn origin(mut self, origin: impl Into<StyleSheetOrigin>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn key_text(mut self, key_text: impl Into<Value>) -> Self {
                self.key_text = Some(key_text.into());
                self
            }
            pub fn style(mut self, style: impl Into<CssStyle>) -> Self {
                self.style = Some(style.into());
                self
            }
            pub fn build(self) -> Result<CssKeyframeRule, String> {
                Ok(CssKeyframeRule {
                    style_sheet_id: self.style_sheet_id,
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    key_text: self.key_text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(key_text))
                    })?,
                    style: self.style.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style))
                    })?,
                })
            }
        }
        impl CssKeyframeRule {
            pub const IDENTIFIER: &'static str = "CSS.CSSKeyframeRule";
        }
        #[doc = "A descriptor of operation to mutate style declaration text.\n[StyleDeclarationEdit](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#type-StyleDeclarationEdit)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StyleDeclarationEdit {
            #[doc = "The css style sheet identifier."]
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
            #[doc = "The range of the style text in the enclosing stylesheet."]
            #[serde(rename = "range")]
            pub range: SourceRange,
            #[doc = "New style text."]
            #[serde(rename = "text")]
            pub text: String,
        }
        impl StyleDeclarationEdit {
            pub fn new(
                style_sheet_id: impl Into<StyleSheetId>,
                range: impl Into<SourceRange>,
                text: impl Into<String>,
            ) -> Self {
                Self {
                    style_sheet_id: style_sheet_id.into(),
                    range: range.into(),
                    text: text.into(),
                }
            }
        }
        impl StyleDeclarationEdit {
            pub fn builder() -> StyleDeclarationEditBuilder {
                StyleDeclarationEditBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StyleDeclarationEditBuilder {
            style_sheet_id: Option<StyleSheetId>,
            range: Option<SourceRange>,
            text: Option<String>,
        }
        impl StyleDeclarationEditBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn build(self) -> Result<StyleDeclarationEdit, String> {
                Ok(StyleDeclarationEdit {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                    range: self.range.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(range))
                    })?,
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                })
            }
        }
        impl StyleDeclarationEdit {
            pub const IDENTIFIER: &'static str = "CSS.StyleDeclarationEdit";
        }
        #[doc = "Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the\nposition specified by `location`.\n[addRule](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-addRule)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AddRuleParams {
            #[doc = "The css style sheet identifier where a new rule should be inserted."]
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
            #[doc = "The text of a new rule."]
            #[serde(rename = "ruleText")]
            pub rule_text: String,
            #[doc = "Text position of a new rule in the target style sheet."]
            #[serde(rename = "location")]
            pub location: SourceRange,
        }
        impl AddRuleParams {
            pub fn new(
                style_sheet_id: impl Into<StyleSheetId>,
                rule_text: impl Into<String>,
                location: impl Into<SourceRange>,
            ) -> Self {
                Self {
                    style_sheet_id: style_sheet_id.into(),
                    rule_text: rule_text.into(),
                    location: location.into(),
                }
            }
        }
        impl AddRuleParams {
            pub fn builder() -> AddRuleParamsBuilder {
                AddRuleParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AddRuleParamsBuilder {
            style_sheet_id: Option<StyleSheetId>,
            rule_text: Option<String>,
            location: Option<SourceRange>,
        }
        impl AddRuleParamsBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn rule_text(mut self, rule_text: impl Into<String>) -> Self {
                self.rule_text = Some(rule_text.into());
                self
            }
            pub fn location(mut self, location: impl Into<SourceRange>) -> Self {
                self.location = Some(location.into());
                self
            }
            pub fn build(self) -> Result<AddRuleParams, String> {
                Ok(AddRuleParams {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                    rule_text: self.rule_text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(rule_text))
                    })?,
                    location: self.location.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(location))
                    })?,
                })
            }
        }
        impl AddRuleParams {
            pub const IDENTIFIER: &'static str = "CSS.addRule";
        }
        impl chromiumoxide_types::Method for AddRuleParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for AddRuleParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the\nposition specified by `location`.\n[addRule](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-addRule)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AddRuleReturns {
            #[doc = "The newly created rule."]
            #[serde(rename = "rule")]
            pub rule: CssRule,
        }
        impl AddRuleReturns {
            pub fn new(rule: impl Into<CssRule>) -> Self {
                Self { rule: rule.into() }
            }
        }
        impl AddRuleReturns {
            pub fn builder() -> AddRuleReturnsBuilder {
                AddRuleReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AddRuleReturnsBuilder {
            rule: Option<CssRule>,
        }
        impl AddRuleReturnsBuilder {
            pub fn rule(mut self, rule: impl Into<CssRule>) -> Self {
                self.rule = Some(rule.into());
                self
            }
            pub fn build(self) -> Result<AddRuleReturns, String> {
                Ok(AddRuleReturns {
                    rule: self.rule.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(rule))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for AddRuleParams {
            type Response = AddRuleReturns;
        }
        #[doc = "Returns all class names from specified stylesheet.\n[collectClassNames](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-collectClassNames)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CollectClassNamesParams {
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
        }
        impl CollectClassNamesParams {
            pub fn new(style_sheet_id: impl Into<StyleSheetId>) -> Self {
                Self {
                    style_sheet_id: style_sheet_id.into(),
                }
            }
        }
        impl CollectClassNamesParams {
            pub fn builder() -> CollectClassNamesParamsBuilder {
                CollectClassNamesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CollectClassNamesParamsBuilder {
            style_sheet_id: Option<StyleSheetId>,
        }
        impl CollectClassNamesParamsBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn build(self) -> Result<CollectClassNamesParams, String> {
                Ok(CollectClassNamesParams {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                })
            }
        }
        impl CollectClassNamesParams {
            pub const IDENTIFIER: &'static str = "CSS.collectClassNames";
        }
        impl chromiumoxide_types::Method for CollectClassNamesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CollectClassNamesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns all class names from specified stylesheet.\n[collectClassNames](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-collectClassNames)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CollectClassNamesReturns {
            #[doc = "Class name list."]
            #[serde(rename = "classNames")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub class_names: Vec<String>,
        }
        impl CollectClassNamesReturns {
            pub fn new(class_names: Vec<String>) -> Self {
                Self { class_names }
            }
        }
        impl CollectClassNamesReturns {
            pub fn builder() -> CollectClassNamesReturnsBuilder {
                CollectClassNamesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CollectClassNamesReturnsBuilder {
            class_names: Option<Vec<String>>,
        }
        impl CollectClassNamesReturnsBuilder {
            pub fn class_name(mut self, class_name: impl Into<String>) -> Self {
                let v = self.class_names.get_or_insert(Vec::new());
                v.push(class_name.into());
                self
            }
            pub fn class_names<I, S>(mut self, class_names: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.class_names.get_or_insert(Vec::new());
                for val in class_names {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<CollectClassNamesReturns, String> {
                Ok(CollectClassNamesReturns {
                    class_names: self.class_names.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(class_names))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for CollectClassNamesParams {
            type Response = CollectClassNamesReturns;
        }
        #[doc = "Creates a new special \"via-inspector\" stylesheet in the frame with given `frameId`.\n[createStyleSheet](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-createStyleSheet)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CreateStyleSheetParams {
            #[doc = "Identifier of the frame where \"via-inspector\" stylesheet should be created."]
            #[serde(rename = "frameId")]
            pub frame_id: super::page::FrameId,
        }
        impl CreateStyleSheetParams {
            pub fn new(frame_id: impl Into<super::page::FrameId>) -> Self {
                Self {
                    frame_id: frame_id.into(),
                }
            }
        }
        impl CreateStyleSheetParams {
            pub fn builder() -> CreateStyleSheetParamsBuilder {
                CreateStyleSheetParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CreateStyleSheetParamsBuilder {
            frame_id: Option<super::page::FrameId>,
        }
        impl CreateStyleSheetParamsBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn build(self) -> Result<CreateStyleSheetParams, String> {
                Ok(CreateStyleSheetParams {
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                })
            }
        }
        impl CreateStyleSheetParams {
            pub const IDENTIFIER: &'static str = "CSS.createStyleSheet";
        }
        impl chromiumoxide_types::Method for CreateStyleSheetParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CreateStyleSheetParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Creates a new special \"via-inspector\" stylesheet in the frame with given `frameId`.\n[createStyleSheet](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-createStyleSheet)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CreateStyleSheetReturns {
            #[doc = "Identifier of the created \"via-inspector\" stylesheet."]
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
        }
        impl CreateStyleSheetReturns {
            pub fn new(style_sheet_id: impl Into<StyleSheetId>) -> Self {
                Self {
                    style_sheet_id: style_sheet_id.into(),
                }
            }
        }
        impl CreateStyleSheetReturns {
            pub fn builder() -> CreateStyleSheetReturnsBuilder {
                CreateStyleSheetReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CreateStyleSheetReturnsBuilder {
            style_sheet_id: Option<StyleSheetId>,
        }
        impl CreateStyleSheetReturnsBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn build(self) -> Result<CreateStyleSheetReturns, String> {
                Ok(CreateStyleSheetReturns {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for CreateStyleSheetParams {
            type Response = CreateStyleSheetReturns;
        }
        #[doc = "Disables the CSS agent for the given page.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "CSS.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables the CSS agent for the given page.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been\nenabled until the result of this command is received.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "CSS.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been\nenabled until the result of this command is received.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Ensures that the given node will have specified pseudo-classes whenever its style is computed by\nthe browser.\n[forcePseudoState](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-forcePseudoState)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ForcePseudoStateParams {
            #[doc = "The element id for which to force the pseudo state."]
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
            #[doc = "Element pseudo classes to force when computing the element's style."]
            #[serde(rename = "forcedPseudoClasses")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub forced_pseudo_classes: Vec<String>,
        }
        impl ForcePseudoStateParams {
            pub fn new(
                node_id: impl Into<super::dom::NodeId>,
                forced_pseudo_classes: Vec<String>,
            ) -> Self {
                Self {
                    node_id: node_id.into(),
                    forced_pseudo_classes,
                }
            }
        }
        impl ForcePseudoStateParams {
            pub fn builder() -> ForcePseudoStateParamsBuilder {
                ForcePseudoStateParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ForcePseudoStateParamsBuilder {
            node_id: Option<super::dom::NodeId>,
            forced_pseudo_classes: Option<Vec<String>>,
        }
        impl ForcePseudoStateParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn forced_pseudo_classe(mut self, forced_pseudo_classe: impl Into<String>) -> Self {
                let v = self.forced_pseudo_classes.get_or_insert(Vec::new());
                v.push(forced_pseudo_classe.into());
                self
            }
            pub fn forced_pseudo_classes<I, S>(mut self, forced_pseudo_classes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.forced_pseudo_classes.get_or_insert(Vec::new());
                for val in forced_pseudo_classes {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<ForcePseudoStateParams, String> {
                Ok(ForcePseudoStateParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    forced_pseudo_classes: self.forced_pseudo_classes.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(forced_pseudo_classes)
                        )
                    })?,
                })
            }
        }
        impl ForcePseudoStateParams {
            pub const IDENTIFIER: &'static str = "CSS.forcePseudoState";
        }
        impl chromiumoxide_types::Method for ForcePseudoStateParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ForcePseudoStateParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Ensures that the given node will have specified pseudo-classes whenever its style is computed by\nthe browser.\n[forcePseudoState](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-forcePseudoState)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ForcePseudoStateReturns {}
        impl chromiumoxide_types::Command for ForcePseudoStateParams {
            type Response = ForcePseudoStateReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetBackgroundColorsParams {
            #[doc = "Id of the node to get background colors for."]
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
        }
        impl GetBackgroundColorsParams {
            pub fn new(node_id: impl Into<super::dom::NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl GetBackgroundColorsParams {
            pub fn builder() -> GetBackgroundColorsParamsBuilder {
                GetBackgroundColorsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetBackgroundColorsParamsBuilder {
            node_id: Option<super::dom::NodeId>,
        }
        impl GetBackgroundColorsParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetBackgroundColorsParams, String> {
                Ok(GetBackgroundColorsParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl GetBackgroundColorsParams {
            pub const IDENTIFIER: &'static str = "CSS.getBackgroundColors";
        }
        impl chromiumoxide_types::Method for GetBackgroundColorsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetBackgroundColorsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetBackgroundColorsReturns {
            #[doc = "The range of background colors behind this element, if it contains any visible text. If no\nvisible text is present, this will be undefined. In the case of a flat background color,\nthis will consist of simply that color. In the case of a gradient, this will consist of each\nof the color stops. For anything more complicated, this will be an empty array. Images will\nbe ignored (as if the image had failed to load)."]
            #[serde(rename = "backgroundColors")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub background_colors: Option<Vec<String>>,
            #[doc = "The computed font size for this node, as a CSS computed value string (e.g. '12px')."]
            #[serde(rename = "computedFontSize")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub computed_font_size: Option<String>,
            #[doc = "The computed font weight for this node, as a CSS computed value string (e.g. 'normal' or\n'100')."]
            #[serde(rename = "computedFontWeight")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub computed_font_weight: Option<String>,
        }
        impl GetBackgroundColorsReturns {
            pub fn builder() -> GetBackgroundColorsReturnsBuilder {
                GetBackgroundColorsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetBackgroundColorsReturnsBuilder {
            background_colors: Option<Vec<String>>,
            computed_font_size: Option<String>,
            computed_font_weight: Option<String>,
        }
        impl GetBackgroundColorsReturnsBuilder {
            pub fn background_color(mut self, background_color: impl Into<String>) -> Self {
                let v = self.background_colors.get_or_insert(Vec::new());
                v.push(background_color.into());
                self
            }
            pub fn background_colors<I, S>(mut self, background_colors: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.background_colors.get_or_insert(Vec::new());
                for val in background_colors {
                    v.push(val.into());
                }
                self
            }
            pub fn computed_font_size(mut self, computed_font_size: impl Into<String>) -> Self {
                self.computed_font_size = Some(computed_font_size.into());
                self
            }
            pub fn computed_font_weight(mut self, computed_font_weight: impl Into<String>) -> Self {
                self.computed_font_weight = Some(computed_font_weight.into());
                self
            }
            pub fn build(self) -> GetBackgroundColorsReturns {
                GetBackgroundColorsReturns {
                    background_colors: self.background_colors,
                    computed_font_size: self.computed_font_size,
                    computed_font_weight: self.computed_font_weight,
                }
            }
        }
        impl chromiumoxide_types::Command for GetBackgroundColorsParams {
            type Response = GetBackgroundColorsReturns;
        }
        #[doc = "Returns the computed style for a DOM node identified by `nodeId`.\n[getComputedStyleForNode](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getComputedStyleForNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetComputedStyleForNodeParams {
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
        }
        impl GetComputedStyleForNodeParams {
            pub fn new(node_id: impl Into<super::dom::NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl GetComputedStyleForNodeParams {
            pub fn builder() -> GetComputedStyleForNodeParamsBuilder {
                GetComputedStyleForNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetComputedStyleForNodeParamsBuilder {
            node_id: Option<super::dom::NodeId>,
        }
        impl GetComputedStyleForNodeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetComputedStyleForNodeParams, String> {
                Ok(GetComputedStyleForNodeParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl GetComputedStyleForNodeParams {
            pub const IDENTIFIER: &'static str = "CSS.getComputedStyleForNode";
        }
        impl chromiumoxide_types::Method for GetComputedStyleForNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetComputedStyleForNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the computed style for a DOM node identified by `nodeId`.\n[getComputedStyleForNode](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getComputedStyleForNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetComputedStyleForNodeReturns {
            #[doc = "Computed style for the specified DOM node."]
            #[serde(rename = "computedStyle")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub computed_style: Vec<CssComputedStyleProperty>,
        }
        impl GetComputedStyleForNodeReturns {
            pub fn new(computed_style: Vec<CssComputedStyleProperty>) -> Self {
                Self { computed_style }
            }
        }
        impl GetComputedStyleForNodeReturns {
            pub fn builder() -> GetComputedStyleForNodeReturnsBuilder {
                GetComputedStyleForNodeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetComputedStyleForNodeReturnsBuilder {
            computed_style: Option<Vec<CssComputedStyleProperty>>,
        }
        impl GetComputedStyleForNodeReturnsBuilder {
            pub fn computed_style(
                mut self,
                computed_style: impl Into<CssComputedStyleProperty>,
            ) -> Self {
                let v = self.computed_style.get_or_insert(Vec::new());
                v.push(computed_style.into());
                self
            }
            pub fn computed_styles<I, S>(mut self, computed_styles: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssComputedStyleProperty>,
            {
                let v = self.computed_style.get_or_insert(Vec::new());
                for val in computed_styles {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetComputedStyleForNodeReturns, String> {
                Ok(GetComputedStyleForNodeReturns {
                    computed_style: self.computed_style.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(computed_style))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetComputedStyleForNodeParams {
            type Response = GetComputedStyleForNodeReturns;
        }
        #[doc = "Returns the styles defined inline (explicitly in the \"style\" attribute and implicitly, using DOM\nattributes) for a DOM node identified by `nodeId`.\n[getInlineStylesForNode](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getInlineStylesForNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetInlineStylesForNodeParams {
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
        }
        impl GetInlineStylesForNodeParams {
            pub fn new(node_id: impl Into<super::dom::NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl GetInlineStylesForNodeParams {
            pub fn builder() -> GetInlineStylesForNodeParamsBuilder {
                GetInlineStylesForNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetInlineStylesForNodeParamsBuilder {
            node_id: Option<super::dom::NodeId>,
        }
        impl GetInlineStylesForNodeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetInlineStylesForNodeParams, String> {
                Ok(GetInlineStylesForNodeParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl GetInlineStylesForNodeParams {
            pub const IDENTIFIER: &'static str = "CSS.getInlineStylesForNode";
        }
        impl chromiumoxide_types::Method for GetInlineStylesForNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetInlineStylesForNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the styles defined inline (explicitly in the \"style\" attribute and implicitly, using DOM\nattributes) for a DOM node identified by `nodeId`.\n[getInlineStylesForNode](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getInlineStylesForNode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetInlineStylesForNodeReturns {
            #[doc = "Inline style for the specified DOM node."]
            #[serde(rename = "inlineStyle")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub inline_style: Option<CssStyle>,
            #[doc = "Attribute-defined element style (e.g. resulting from \"width=20 height=100%\")."]
            #[serde(rename = "attributesStyle")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub attributes_style: Option<CssStyle>,
        }
        impl GetInlineStylesForNodeReturns {
            pub fn builder() -> GetInlineStylesForNodeReturnsBuilder {
                GetInlineStylesForNodeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetInlineStylesForNodeReturnsBuilder {
            inline_style: Option<CssStyle>,
            attributes_style: Option<CssStyle>,
        }
        impl GetInlineStylesForNodeReturnsBuilder {
            pub fn inline_style(mut self, inline_style: impl Into<CssStyle>) -> Self {
                self.inline_style = Some(inline_style.into());
                self
            }
            pub fn attributes_style(mut self, attributes_style: impl Into<CssStyle>) -> Self {
                self.attributes_style = Some(attributes_style.into());
                self
            }
            pub fn build(self) -> GetInlineStylesForNodeReturns {
                GetInlineStylesForNodeReturns {
                    inline_style: self.inline_style,
                    attributes_style: self.attributes_style,
                }
            }
        }
        impl chromiumoxide_types::Command for GetInlineStylesForNodeParams {
            type Response = GetInlineStylesForNodeReturns;
        }
        #[doc = "Returns requested styles for a DOM node identified by `nodeId`.\n[getMatchedStylesForNode](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getMatchedStylesForNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetMatchedStylesForNodeParams {
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
        }
        impl GetMatchedStylesForNodeParams {
            pub fn new(node_id: impl Into<super::dom::NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl GetMatchedStylesForNodeParams {
            pub fn builder() -> GetMatchedStylesForNodeParamsBuilder {
                GetMatchedStylesForNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetMatchedStylesForNodeParamsBuilder {
            node_id: Option<super::dom::NodeId>,
        }
        impl GetMatchedStylesForNodeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetMatchedStylesForNodeParams, String> {
                Ok(GetMatchedStylesForNodeParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl GetMatchedStylesForNodeParams {
            pub const IDENTIFIER: &'static str = "CSS.getMatchedStylesForNode";
        }
        impl chromiumoxide_types::Method for GetMatchedStylesForNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetMatchedStylesForNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns requested styles for a DOM node identified by `nodeId`.\n[getMatchedStylesForNode](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getMatchedStylesForNode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetMatchedStylesForNodeReturns {
            #[doc = "Inline style for the specified DOM node."]
            #[serde(rename = "inlineStyle")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub inline_style: Option<CssStyle>,
            #[doc = "Attribute-defined element style (e.g. resulting from \"width=20 height=100%\")."]
            #[serde(rename = "attributesStyle")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub attributes_style: Option<CssStyle>,
            #[doc = "CSS rules matching this node, from all applicable stylesheets."]
            #[serde(rename = "matchedCSSRules")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub matched_css_rules: Option<Vec<RuleMatch>>,
            #[doc = "Pseudo style matches for this node."]
            #[serde(rename = "pseudoElements")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pseudo_elements: Option<Vec<PseudoElementMatches>>,
            #[doc = "A chain of inherited styles (from the immediate node parent up to the DOM tree root)."]
            #[serde(rename = "inherited")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub inherited: Option<Vec<InheritedStyleEntry>>,
            #[doc = "A chain of inherited pseudo element styles (from the immediate node parent up to the DOM tree root)."]
            #[serde(rename = "inheritedPseudoElements")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub inherited_pseudo_elements: Option<Vec<InheritedPseudoElementMatches>>,
            #[doc = "A list of CSS keyframed animations matching this node."]
            #[serde(rename = "cssKeyframesRules")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub css_keyframes_rules: Option<Vec<CssKeyframesRule>>,
            #[doc = "Id of the first parent element that does not have display: contents."]
            #[serde(rename = "parentLayoutNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub parent_layout_node_id: Option<super::dom::NodeId>,
        }
        impl GetMatchedStylesForNodeReturns {
            pub fn builder() -> GetMatchedStylesForNodeReturnsBuilder {
                GetMatchedStylesForNodeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetMatchedStylesForNodeReturnsBuilder {
            inline_style: Option<CssStyle>,
            attributes_style: Option<CssStyle>,
            matched_css_rules: Option<Vec<RuleMatch>>,
            pseudo_elements: Option<Vec<PseudoElementMatches>>,
            inherited: Option<Vec<InheritedStyleEntry>>,
            inherited_pseudo_elements: Option<Vec<InheritedPseudoElementMatches>>,
            css_keyframes_rules: Option<Vec<CssKeyframesRule>>,
            parent_layout_node_id: Option<super::dom::NodeId>,
        }
        impl GetMatchedStylesForNodeReturnsBuilder {
            pub fn inline_style(mut self, inline_style: impl Into<CssStyle>) -> Self {
                self.inline_style = Some(inline_style.into());
                self
            }
            pub fn attributes_style(mut self, attributes_style: impl Into<CssStyle>) -> Self {
                self.attributes_style = Some(attributes_style.into());
                self
            }
            pub fn matched_css_rule(mut self, matched_css_rule: impl Into<RuleMatch>) -> Self {
                let v = self.matched_css_rules.get_or_insert(Vec::new());
                v.push(matched_css_rule.into());
                self
            }
            pub fn matched_css_rules<I, S>(mut self, matched_css_rules: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<RuleMatch>,
            {
                let v = self.matched_css_rules.get_or_insert(Vec::new());
                for val in matched_css_rules {
                    v.push(val.into());
                }
                self
            }
            pub fn pseudo_element(
                mut self,
                pseudo_element: impl Into<PseudoElementMatches>,
            ) -> Self {
                let v = self.pseudo_elements.get_or_insert(Vec::new());
                v.push(pseudo_element.into());
                self
            }
            pub fn pseudo_elements<I, S>(mut self, pseudo_elements: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PseudoElementMatches>,
            {
                let v = self.pseudo_elements.get_or_insert(Vec::new());
                for val in pseudo_elements {
                    v.push(val.into());
                }
                self
            }
            pub fn inherited(mut self, inherited: impl Into<InheritedStyleEntry>) -> Self {
                let v = self.inherited.get_or_insert(Vec::new());
                v.push(inherited.into());
                self
            }
            pub fn inheriteds<I, S>(mut self, inheriteds: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<InheritedStyleEntry>,
            {
                let v = self.inherited.get_or_insert(Vec::new());
                for val in inheriteds {
                    v.push(val.into());
                }
                self
            }
            pub fn inherited_pseudo_element(
                mut self,
                inherited_pseudo_element: impl Into<InheritedPseudoElementMatches>,
            ) -> Self {
                let v = self.inherited_pseudo_elements.get_or_insert(Vec::new());
                v.push(inherited_pseudo_element.into());
                self
            }
            pub fn inherited_pseudo_elements<I, S>(mut self, inherited_pseudo_elements: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<InheritedPseudoElementMatches>,
            {
                let v = self.inherited_pseudo_elements.get_or_insert(Vec::new());
                for val in inherited_pseudo_elements {
                    v.push(val.into());
                }
                self
            }
            pub fn css_keyframes_rule(
                mut self,
                css_keyframes_rule: impl Into<CssKeyframesRule>,
            ) -> Self {
                let v = self.css_keyframes_rules.get_or_insert(Vec::new());
                v.push(css_keyframes_rule.into());
                self
            }
            pub fn css_keyframes_rules<I, S>(mut self, css_keyframes_rules: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssKeyframesRule>,
            {
                let v = self.css_keyframes_rules.get_or_insert(Vec::new());
                for val in css_keyframes_rules {
                    v.push(val.into());
                }
                self
            }
            pub fn parent_layout_node_id(
                mut self,
                parent_layout_node_id: impl Into<super::dom::NodeId>,
            ) -> Self {
                self.parent_layout_node_id = Some(parent_layout_node_id.into());
                self
            }
            pub fn build(self) -> GetMatchedStylesForNodeReturns {
                GetMatchedStylesForNodeReturns {
                    inline_style: self.inline_style,
                    attributes_style: self.attributes_style,
                    matched_css_rules: self.matched_css_rules,
                    pseudo_elements: self.pseudo_elements,
                    inherited: self.inherited,
                    inherited_pseudo_elements: self.inherited_pseudo_elements,
                    css_keyframes_rules: self.css_keyframes_rules,
                    parent_layout_node_id: self.parent_layout_node_id,
                }
            }
        }
        impl chromiumoxide_types::Command for GetMatchedStylesForNodeParams {
            type Response = GetMatchedStylesForNodeReturns;
        }
        #[doc = "Returns all media queries parsed by the rendering engine.\n[getMediaQueries](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getMediaQueries)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetMediaQueriesParams {}
        impl GetMediaQueriesParams {
            pub const IDENTIFIER: &'static str = "CSS.getMediaQueries";
        }
        impl chromiumoxide_types::Method for GetMediaQueriesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetMediaQueriesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns all media queries parsed by the rendering engine.\n[getMediaQueries](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getMediaQueries)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetMediaQueriesReturns {
            #[serde(rename = "medias")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub medias: Vec<CssMedia>,
        }
        impl GetMediaQueriesReturns {
            pub fn new(medias: Vec<CssMedia>) -> Self {
                Self { medias }
            }
        }
        impl GetMediaQueriesReturns {
            pub fn builder() -> GetMediaQueriesReturnsBuilder {
                GetMediaQueriesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetMediaQueriesReturnsBuilder {
            medias: Option<Vec<CssMedia>>,
        }
        impl GetMediaQueriesReturnsBuilder {
            pub fn media(mut self, media: impl Into<CssMedia>) -> Self {
                let v = self.medias.get_or_insert(Vec::new());
                v.push(media.into());
                self
            }
            pub fn medias<I, S>(mut self, medias: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssMedia>,
            {
                let v = self.medias.get_or_insert(Vec::new());
                for val in medias {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetMediaQueriesReturns, String> {
                Ok(GetMediaQueriesReturns {
                    medias: self.medias.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(medias))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetMediaQueriesParams {
            type Response = GetMediaQueriesReturns;
        }
        #[doc = "Requests information about platform fonts which we used to render child TextNodes in the given\nnode.\n[getPlatformFontsForNode](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getPlatformFontsForNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetPlatformFontsForNodeParams {
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
        }
        impl GetPlatformFontsForNodeParams {
            pub fn new(node_id: impl Into<super::dom::NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl GetPlatformFontsForNodeParams {
            pub fn builder() -> GetPlatformFontsForNodeParamsBuilder {
                GetPlatformFontsForNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetPlatformFontsForNodeParamsBuilder {
            node_id: Option<super::dom::NodeId>,
        }
        impl GetPlatformFontsForNodeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetPlatformFontsForNodeParams, String> {
                Ok(GetPlatformFontsForNodeParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl GetPlatformFontsForNodeParams {
            pub const IDENTIFIER: &'static str = "CSS.getPlatformFontsForNode";
        }
        impl chromiumoxide_types::Method for GetPlatformFontsForNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetPlatformFontsForNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests information about platform fonts which we used to render child TextNodes in the given\nnode.\n[getPlatformFontsForNode](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getPlatformFontsForNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetPlatformFontsForNodeReturns {
            #[doc = "Usage statistics for every employed platform font."]
            #[serde(rename = "fonts")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub fonts: Vec<PlatformFontUsage>,
        }
        impl GetPlatformFontsForNodeReturns {
            pub fn new(fonts: Vec<PlatformFontUsage>) -> Self {
                Self { fonts }
            }
        }
        impl GetPlatformFontsForNodeReturns {
            pub fn builder() -> GetPlatformFontsForNodeReturnsBuilder {
                GetPlatformFontsForNodeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetPlatformFontsForNodeReturnsBuilder {
            fonts: Option<Vec<PlatformFontUsage>>,
        }
        impl GetPlatformFontsForNodeReturnsBuilder {
            pub fn font(mut self, font: impl Into<PlatformFontUsage>) -> Self {
                let v = self.fonts.get_or_insert(Vec::new());
                v.push(font.into());
                self
            }
            pub fn fonts<I, S>(mut self, fonts: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PlatformFontUsage>,
            {
                let v = self.fonts.get_or_insert(Vec::new());
                for val in fonts {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetPlatformFontsForNodeReturns, String> {
                Ok(GetPlatformFontsForNodeReturns {
                    fonts: self.fonts.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(fonts))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetPlatformFontsForNodeParams {
            type Response = GetPlatformFontsForNodeReturns;
        }
        #[doc = "Returns the current textual content for a stylesheet.\n[getStyleSheetText](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getStyleSheetText)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetStyleSheetTextParams {
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
        }
        impl GetStyleSheetTextParams {
            pub fn new(style_sheet_id: impl Into<StyleSheetId>) -> Self {
                Self {
                    style_sheet_id: style_sheet_id.into(),
                }
            }
        }
        impl GetStyleSheetTextParams {
            pub fn builder() -> GetStyleSheetTextParamsBuilder {
                GetStyleSheetTextParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetStyleSheetTextParamsBuilder {
            style_sheet_id: Option<StyleSheetId>,
        }
        impl GetStyleSheetTextParamsBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn build(self) -> Result<GetStyleSheetTextParams, String> {
                Ok(GetStyleSheetTextParams {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                })
            }
        }
        impl GetStyleSheetTextParams {
            pub const IDENTIFIER: &'static str = "CSS.getStyleSheetText";
        }
        impl chromiumoxide_types::Method for GetStyleSheetTextParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetStyleSheetTextParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the current textual content for a stylesheet.\n[getStyleSheetText](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getStyleSheetText)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetStyleSheetTextReturns {
            #[doc = "The stylesheet text."]
            #[serde(rename = "text")]
            pub text: String,
        }
        impl GetStyleSheetTextReturns {
            pub fn new(text: impl Into<String>) -> Self {
                Self { text: text.into() }
            }
        }
        impl<T: Into<String>> From<T> for GetStyleSheetTextReturns {
            fn from(url: T) -> Self {
                GetStyleSheetTextReturns::new(url)
            }
        }
        impl GetStyleSheetTextReturns {
            pub fn builder() -> GetStyleSheetTextReturnsBuilder {
                GetStyleSheetTextReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetStyleSheetTextReturnsBuilder {
            text: Option<String>,
        }
        impl GetStyleSheetTextReturnsBuilder {
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn build(self) -> Result<GetStyleSheetTextReturns, String> {
                Ok(GetStyleSheetTextReturns {
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetStyleSheetTextParams {
            type Response = GetStyleSheetTextReturns;
        }
        #[doc = "Returns all layers parsed by the rendering engine for the tree scope of a node.\nGiven a DOM element identified by nodeId, getLayersForNode returns the root\nlayer for the nearest ancestor document or shadow root. The layer root contains\nthe full layer tree for the tree scope and their ordering.\n[getLayersForNode](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getLayersForNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetLayersForNodeParams {
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
        }
        impl GetLayersForNodeParams {
            pub fn new(node_id: impl Into<super::dom::NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl GetLayersForNodeParams {
            pub fn builder() -> GetLayersForNodeParamsBuilder {
                GetLayersForNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetLayersForNodeParamsBuilder {
            node_id: Option<super::dom::NodeId>,
        }
        impl GetLayersForNodeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetLayersForNodeParams, String> {
                Ok(GetLayersForNodeParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl GetLayersForNodeParams {
            pub const IDENTIFIER: &'static str = "CSS.getLayersForNode";
        }
        impl chromiumoxide_types::Method for GetLayersForNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetLayersForNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns all layers parsed by the rendering engine for the tree scope of a node.\nGiven a DOM element identified by nodeId, getLayersForNode returns the root\nlayer for the nearest ancestor document or shadow root. The layer root contains\nthe full layer tree for the tree scope and their ordering.\n[getLayersForNode](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getLayersForNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetLayersForNodeReturns {
            #[serde(rename = "rootLayer")]
            pub root_layer: CssLayerData,
        }
        impl GetLayersForNodeReturns {
            pub fn new(root_layer: impl Into<CssLayerData>) -> Self {
                Self {
                    root_layer: root_layer.into(),
                }
            }
        }
        impl GetLayersForNodeReturns {
            pub fn builder() -> GetLayersForNodeReturnsBuilder {
                GetLayersForNodeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetLayersForNodeReturnsBuilder {
            root_layer: Option<CssLayerData>,
        }
        impl GetLayersForNodeReturnsBuilder {
            pub fn root_layer(mut self, root_layer: impl Into<CssLayerData>) -> Self {
                self.root_layer = Some(root_layer.into());
                self
            }
            pub fn build(self) -> Result<GetLayersForNodeReturns, String> {
                Ok(GetLayersForNodeReturns {
                    root_layer: self.root_layer.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(root_layer))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetLayersForNodeParams {
            type Response = GetLayersForNodeReturns;
        }
        #[doc = "Starts tracking the given computed styles for updates. The specified array of properties\nreplaces the one previously specified. Pass empty array to disable tracking.\nUse takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.\nThe changes to computed style properties are only tracked for nodes pushed to the front-end\nby the DOM agent. If no changes to the tracked properties occur after the node has been pushed\nto the front-end, no updates will be issued for the node.\n[trackComputedStyleUpdates](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-trackComputedStyleUpdates)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TrackComputedStyleUpdatesParams {
            #[serde(rename = "propertiesToTrack")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub properties_to_track: Vec<CssComputedStyleProperty>,
        }
        impl TrackComputedStyleUpdatesParams {
            pub fn new(properties_to_track: Vec<CssComputedStyleProperty>) -> Self {
                Self {
                    properties_to_track,
                }
            }
        }
        impl TrackComputedStyleUpdatesParams {
            pub fn builder() -> TrackComputedStyleUpdatesParamsBuilder {
                TrackComputedStyleUpdatesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TrackComputedStyleUpdatesParamsBuilder {
            properties_to_track: Option<Vec<CssComputedStyleProperty>>,
        }
        impl TrackComputedStyleUpdatesParamsBuilder {
            pub fn properties_to_track(
                mut self,
                properties_to_track: impl Into<CssComputedStyleProperty>,
            ) -> Self {
                let v = self.properties_to_track.get_or_insert(Vec::new());
                v.push(properties_to_track.into());
                self
            }
            pub fn properties_to_tracks<I, S>(mut self, properties_to_tracks: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssComputedStyleProperty>,
            {
                let v = self.properties_to_track.get_or_insert(Vec::new());
                for val in properties_to_tracks {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<TrackComputedStyleUpdatesParams, String> {
                Ok(TrackComputedStyleUpdatesParams {
                    properties_to_track: self.properties_to_track.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(properties_to_track)
                        )
                    })?,
                })
            }
        }
        impl TrackComputedStyleUpdatesParams {
            pub const IDENTIFIER: &'static str = "CSS.trackComputedStyleUpdates";
        }
        impl chromiumoxide_types::Method for TrackComputedStyleUpdatesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for TrackComputedStyleUpdatesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Starts tracking the given computed styles for updates. The specified array of properties\nreplaces the one previously specified. Pass empty array to disable tracking.\nUse takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.\nThe changes to computed style properties are only tracked for nodes pushed to the front-end\nby the DOM agent. If no changes to the tracked properties occur after the node has been pushed\nto the front-end, no updates will be issued for the node.\n[trackComputedStyleUpdates](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-trackComputedStyleUpdates)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TrackComputedStyleUpdatesReturns {}
        impl chromiumoxide_types::Command for TrackComputedStyleUpdatesParams {
            type Response = TrackComputedStyleUpdatesReturns;
        }
        #[doc = "Polls the next batch of computed style updates.\n[takeComputedStyleUpdates](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-takeComputedStyleUpdates)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TakeComputedStyleUpdatesParams {}
        impl TakeComputedStyleUpdatesParams {
            pub const IDENTIFIER: &'static str = "CSS.takeComputedStyleUpdates";
        }
        impl chromiumoxide_types::Method for TakeComputedStyleUpdatesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for TakeComputedStyleUpdatesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Polls the next batch of computed style updates.\n[takeComputedStyleUpdates](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-takeComputedStyleUpdates)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TakeComputedStyleUpdatesReturns {
            #[doc = "The list of node Ids that have their tracked computed styles updated"]
            #[serde(rename = "nodeIds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub node_ids: Vec<super::dom::NodeId>,
        }
        impl TakeComputedStyleUpdatesReturns {
            pub fn new(node_ids: Vec<super::dom::NodeId>) -> Self {
                Self { node_ids }
            }
        }
        impl TakeComputedStyleUpdatesReturns {
            pub fn builder() -> TakeComputedStyleUpdatesReturnsBuilder {
                TakeComputedStyleUpdatesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TakeComputedStyleUpdatesReturnsBuilder {
            node_ids: Option<Vec<super::dom::NodeId>>,
        }
        impl TakeComputedStyleUpdatesReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                let v = self.node_ids.get_or_insert(Vec::new());
                v.push(node_id.into());
                self
            }
            pub fn node_ids<I, S>(mut self, node_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<super::dom::NodeId>,
            {
                let v = self.node_ids.get_or_insert(Vec::new());
                for val in node_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<TakeComputedStyleUpdatesReturns, String> {
                Ok(TakeComputedStyleUpdatesReturns {
                    node_ids: self.node_ids.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_ids))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for TakeComputedStyleUpdatesParams {
            type Response = TakeComputedStyleUpdatesReturns;
        }
        #[doc = "Find a rule with the given active property for the given node and set the new value for this\nproperty\n[setEffectivePropertyValueForNode](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setEffectivePropertyValueForNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetEffectivePropertyValueForNodeParams {
            #[doc = "The element id for which to set property."]
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
            #[serde(rename = "propertyName")]
            pub property_name: String,
            #[serde(rename = "value")]
            pub value: String,
        }
        impl SetEffectivePropertyValueForNodeParams {
            pub fn new(
                node_id: impl Into<super::dom::NodeId>,
                property_name: impl Into<String>,
                value: impl Into<String>,
            ) -> Self {
                Self {
                    node_id: node_id.into(),
                    property_name: property_name.into(),
                    value: value.into(),
                }
            }
        }
        impl SetEffectivePropertyValueForNodeParams {
            pub fn builder() -> SetEffectivePropertyValueForNodeParamsBuilder {
                SetEffectivePropertyValueForNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetEffectivePropertyValueForNodeParamsBuilder {
            node_id: Option<super::dom::NodeId>,
            property_name: Option<String>,
            value: Option<String>,
        }
        impl SetEffectivePropertyValueForNodeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn property_name(mut self, property_name: impl Into<String>) -> Self {
                self.property_name = Some(property_name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<SetEffectivePropertyValueForNodeParams, String> {
                Ok(SetEffectivePropertyValueForNodeParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    property_name: self.property_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(property_name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl SetEffectivePropertyValueForNodeParams {
            pub const IDENTIFIER: &'static str = "CSS.setEffectivePropertyValueForNode";
        }
        impl chromiumoxide_types::Method for SetEffectivePropertyValueForNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetEffectivePropertyValueForNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Find a rule with the given active property for the given node and set the new value for this\nproperty\n[setEffectivePropertyValueForNode](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setEffectivePropertyValueForNode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetEffectivePropertyValueForNodeReturns {}
        impl chromiumoxide_types::Command for SetEffectivePropertyValueForNodeParams {
            type Response = SetEffectivePropertyValueForNodeReturns;
        }
        #[doc = "Modifies the keyframe rule key text.\n[setKeyframeKey](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setKeyframeKey)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetKeyframeKeyParams {
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
            #[serde(rename = "range")]
            pub range: SourceRange,
            #[serde(rename = "keyText")]
            pub key_text: String,
        }
        impl SetKeyframeKeyParams {
            pub fn new(
                style_sheet_id: impl Into<StyleSheetId>,
                range: impl Into<SourceRange>,
                key_text: impl Into<String>,
            ) -> Self {
                Self {
                    style_sheet_id: style_sheet_id.into(),
                    range: range.into(),
                    key_text: key_text.into(),
                }
            }
        }
        impl SetKeyframeKeyParams {
            pub fn builder() -> SetKeyframeKeyParamsBuilder {
                SetKeyframeKeyParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetKeyframeKeyParamsBuilder {
            style_sheet_id: Option<StyleSheetId>,
            range: Option<SourceRange>,
            key_text: Option<String>,
        }
        impl SetKeyframeKeyParamsBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn key_text(mut self, key_text: impl Into<String>) -> Self {
                self.key_text = Some(key_text.into());
                self
            }
            pub fn build(self) -> Result<SetKeyframeKeyParams, String> {
                Ok(SetKeyframeKeyParams {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                    range: self.range.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(range))
                    })?,
                    key_text: self.key_text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(key_text))
                    })?,
                })
            }
        }
        impl SetKeyframeKeyParams {
            pub const IDENTIFIER: &'static str = "CSS.setKeyframeKey";
        }
        impl chromiumoxide_types::Method for SetKeyframeKeyParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetKeyframeKeyParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Modifies the keyframe rule key text.\n[setKeyframeKey](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setKeyframeKey)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetKeyframeKeyReturns {
            #[doc = "The resulting key text after modification."]
            #[serde(rename = "keyText")]
            pub key_text: Value,
        }
        impl SetKeyframeKeyReturns {
            pub fn new(key_text: impl Into<Value>) -> Self {
                Self {
                    key_text: key_text.into(),
                }
            }
        }
        impl SetKeyframeKeyReturns {
            pub fn builder() -> SetKeyframeKeyReturnsBuilder {
                SetKeyframeKeyReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetKeyframeKeyReturnsBuilder {
            key_text: Option<Value>,
        }
        impl SetKeyframeKeyReturnsBuilder {
            pub fn key_text(mut self, key_text: impl Into<Value>) -> Self {
                self.key_text = Some(key_text.into());
                self
            }
            pub fn build(self) -> Result<SetKeyframeKeyReturns, String> {
                Ok(SetKeyframeKeyReturns {
                    key_text: self.key_text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(key_text))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SetKeyframeKeyParams {
            type Response = SetKeyframeKeyReturns;
        }
        #[doc = "Modifies the rule selector.\n[setMediaText](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setMediaText)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetMediaTextParams {
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
            #[serde(rename = "range")]
            pub range: SourceRange,
            #[serde(rename = "text")]
            pub text: String,
        }
        impl SetMediaTextParams {
            pub fn new(
                style_sheet_id: impl Into<StyleSheetId>,
                range: impl Into<SourceRange>,
                text: impl Into<String>,
            ) -> Self {
                Self {
                    style_sheet_id: style_sheet_id.into(),
                    range: range.into(),
                    text: text.into(),
                }
            }
        }
        impl SetMediaTextParams {
            pub fn builder() -> SetMediaTextParamsBuilder {
                SetMediaTextParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetMediaTextParamsBuilder {
            style_sheet_id: Option<StyleSheetId>,
            range: Option<SourceRange>,
            text: Option<String>,
        }
        impl SetMediaTextParamsBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn build(self) -> Result<SetMediaTextParams, String> {
                Ok(SetMediaTextParams {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                    range: self.range.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(range))
                    })?,
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                })
            }
        }
        impl SetMediaTextParams {
            pub const IDENTIFIER: &'static str = "CSS.setMediaText";
        }
        impl chromiumoxide_types::Method for SetMediaTextParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetMediaTextParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Modifies the rule selector.\n[setMediaText](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setMediaText)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetMediaTextReturns {
            #[doc = "The resulting CSS media rule after modification."]
            #[serde(rename = "media")]
            pub media: CssMedia,
        }
        impl SetMediaTextReturns {
            pub fn new(media: impl Into<CssMedia>) -> Self {
                Self {
                    media: media.into(),
                }
            }
        }
        impl SetMediaTextReturns {
            pub fn builder() -> SetMediaTextReturnsBuilder {
                SetMediaTextReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetMediaTextReturnsBuilder {
            media: Option<CssMedia>,
        }
        impl SetMediaTextReturnsBuilder {
            pub fn media(mut self, media: impl Into<CssMedia>) -> Self {
                self.media = Some(media.into());
                self
            }
            pub fn build(self) -> Result<SetMediaTextReturns, String> {
                Ok(SetMediaTextReturns {
                    media: self.media.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(media))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SetMediaTextParams {
            type Response = SetMediaTextReturns;
        }
        #[doc = "Modifies the expression of a container query.\n[setContainerQueryText](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setContainerQueryText)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetContainerQueryTextParams {
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
            #[serde(rename = "range")]
            pub range: SourceRange,
            #[serde(rename = "text")]
            pub text: String,
        }
        impl SetContainerQueryTextParams {
            pub fn new(
                style_sheet_id: impl Into<StyleSheetId>,
                range: impl Into<SourceRange>,
                text: impl Into<String>,
            ) -> Self {
                Self {
                    style_sheet_id: style_sheet_id.into(),
                    range: range.into(),
                    text: text.into(),
                }
            }
        }
        impl SetContainerQueryTextParams {
            pub fn builder() -> SetContainerQueryTextParamsBuilder {
                SetContainerQueryTextParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetContainerQueryTextParamsBuilder {
            style_sheet_id: Option<StyleSheetId>,
            range: Option<SourceRange>,
            text: Option<String>,
        }
        impl SetContainerQueryTextParamsBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn build(self) -> Result<SetContainerQueryTextParams, String> {
                Ok(SetContainerQueryTextParams {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                    range: self.range.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(range))
                    })?,
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                })
            }
        }
        impl SetContainerQueryTextParams {
            pub const IDENTIFIER: &'static str = "CSS.setContainerQueryText";
        }
        impl chromiumoxide_types::Method for SetContainerQueryTextParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetContainerQueryTextParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Modifies the expression of a container query.\n[setContainerQueryText](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setContainerQueryText)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetContainerQueryTextReturns {
            #[doc = "The resulting CSS container query rule after modification."]
            #[serde(rename = "containerQuery")]
            pub container_query: CssContainerQuery,
        }
        impl SetContainerQueryTextReturns {
            pub fn new(container_query: impl Into<CssContainerQuery>) -> Self {
                Self {
                    container_query: container_query.into(),
                }
            }
        }
        impl SetContainerQueryTextReturns {
            pub fn builder() -> SetContainerQueryTextReturnsBuilder {
                SetContainerQueryTextReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetContainerQueryTextReturnsBuilder {
            container_query: Option<CssContainerQuery>,
        }
        impl SetContainerQueryTextReturnsBuilder {
            pub fn container_query(
                mut self,
                container_query: impl Into<CssContainerQuery>,
            ) -> Self {
                self.container_query = Some(container_query.into());
                self
            }
            pub fn build(self) -> Result<SetContainerQueryTextReturns, String> {
                Ok(SetContainerQueryTextReturns {
                    container_query: self.container_query.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(container_query))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SetContainerQueryTextParams {
            type Response = SetContainerQueryTextReturns;
        }
        #[doc = "Modifies the expression of a supports at-rule.\n[setSupportsText](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setSupportsText)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetSupportsTextParams {
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
            #[serde(rename = "range")]
            pub range: SourceRange,
            #[serde(rename = "text")]
            pub text: String,
        }
        impl SetSupportsTextParams {
            pub fn new(
                style_sheet_id: impl Into<StyleSheetId>,
                range: impl Into<SourceRange>,
                text: impl Into<String>,
            ) -> Self {
                Self {
                    style_sheet_id: style_sheet_id.into(),
                    range: range.into(),
                    text: text.into(),
                }
            }
        }
        impl SetSupportsTextParams {
            pub fn builder() -> SetSupportsTextParamsBuilder {
                SetSupportsTextParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetSupportsTextParamsBuilder {
            style_sheet_id: Option<StyleSheetId>,
            range: Option<SourceRange>,
            text: Option<String>,
        }
        impl SetSupportsTextParamsBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn build(self) -> Result<SetSupportsTextParams, String> {
                Ok(SetSupportsTextParams {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                    range: self.range.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(range))
                    })?,
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                })
            }
        }
        impl SetSupportsTextParams {
            pub const IDENTIFIER: &'static str = "CSS.setSupportsText";
        }
        impl chromiumoxide_types::Method for SetSupportsTextParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetSupportsTextParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Modifies the expression of a supports at-rule.\n[setSupportsText](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setSupportsText)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetSupportsTextReturns {
            #[doc = "The resulting CSS Supports rule after modification."]
            #[serde(rename = "supports")]
            pub supports: CssSupports,
        }
        impl SetSupportsTextReturns {
            pub fn new(supports: impl Into<CssSupports>) -> Self {
                Self {
                    supports: supports.into(),
                }
            }
        }
        impl SetSupportsTextReturns {
            pub fn builder() -> SetSupportsTextReturnsBuilder {
                SetSupportsTextReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetSupportsTextReturnsBuilder {
            supports: Option<CssSupports>,
        }
        impl SetSupportsTextReturnsBuilder {
            pub fn supports(mut self, supports: impl Into<CssSupports>) -> Self {
                self.supports = Some(supports.into());
                self
            }
            pub fn build(self) -> Result<SetSupportsTextReturns, String> {
                Ok(SetSupportsTextReturns {
                    supports: self.supports.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(supports))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SetSupportsTextParams {
            type Response = SetSupportsTextReturns;
        }
        #[doc = "Modifies the expression of a scope at-rule.\n[setScopeText](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setScopeText)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetScopeTextParams {
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
            #[serde(rename = "range")]
            pub range: SourceRange,
            #[serde(rename = "text")]
            pub text: String,
        }
        impl SetScopeTextParams {
            pub fn new(
                style_sheet_id: impl Into<StyleSheetId>,
                range: impl Into<SourceRange>,
                text: impl Into<String>,
            ) -> Self {
                Self {
                    style_sheet_id: style_sheet_id.into(),
                    range: range.into(),
                    text: text.into(),
                }
            }
        }
        impl SetScopeTextParams {
            pub fn builder() -> SetScopeTextParamsBuilder {
                SetScopeTextParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetScopeTextParamsBuilder {
            style_sheet_id: Option<StyleSheetId>,
            range: Option<SourceRange>,
            text: Option<String>,
        }
        impl SetScopeTextParamsBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn build(self) -> Result<SetScopeTextParams, String> {
                Ok(SetScopeTextParams {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                    range: self.range.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(range))
                    })?,
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                })
            }
        }
        impl SetScopeTextParams {
            pub const IDENTIFIER: &'static str = "CSS.setScopeText";
        }
        impl chromiumoxide_types::Method for SetScopeTextParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetScopeTextParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Modifies the expression of a scope at-rule.\n[setScopeText](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setScopeText)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetScopeTextReturns {
            #[doc = "The resulting CSS Scope rule after modification."]
            #[serde(rename = "scope")]
            pub scope: CssScope,
        }
        impl SetScopeTextReturns {
            pub fn new(scope: impl Into<CssScope>) -> Self {
                Self {
                    scope: scope.into(),
                }
            }
        }
        impl SetScopeTextReturns {
            pub fn builder() -> SetScopeTextReturnsBuilder {
                SetScopeTextReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetScopeTextReturnsBuilder {
            scope: Option<CssScope>,
        }
        impl SetScopeTextReturnsBuilder {
            pub fn scope(mut self, scope: impl Into<CssScope>) -> Self {
                self.scope = Some(scope.into());
                self
            }
            pub fn build(self) -> Result<SetScopeTextReturns, String> {
                Ok(SetScopeTextReturns {
                    scope: self.scope.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scope))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SetScopeTextParams {
            type Response = SetScopeTextReturns;
        }
        #[doc = "Modifies the rule selector.\n[setRuleSelector](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setRuleSelector)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetRuleSelectorParams {
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
            #[serde(rename = "range")]
            pub range: SourceRange,
            #[serde(rename = "selector")]
            pub selector: String,
        }
        impl SetRuleSelectorParams {
            pub fn new(
                style_sheet_id: impl Into<StyleSheetId>,
                range: impl Into<SourceRange>,
                selector: impl Into<String>,
            ) -> Self {
                Self {
                    style_sheet_id: style_sheet_id.into(),
                    range: range.into(),
                    selector: selector.into(),
                }
            }
        }
        impl SetRuleSelectorParams {
            pub fn builder() -> SetRuleSelectorParamsBuilder {
                SetRuleSelectorParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetRuleSelectorParamsBuilder {
            style_sheet_id: Option<StyleSheetId>,
            range: Option<SourceRange>,
            selector: Option<String>,
        }
        impl SetRuleSelectorParamsBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn range(mut self, range: impl Into<SourceRange>) -> Self {
                self.range = Some(range.into());
                self
            }
            pub fn selector(mut self, selector: impl Into<String>) -> Self {
                self.selector = Some(selector.into());
                self
            }
            pub fn build(self) -> Result<SetRuleSelectorParams, String> {
                Ok(SetRuleSelectorParams {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                    range: self.range.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(range))
                    })?,
                    selector: self.selector.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(selector))
                    })?,
                })
            }
        }
        impl SetRuleSelectorParams {
            pub const IDENTIFIER: &'static str = "CSS.setRuleSelector";
        }
        impl chromiumoxide_types::Method for SetRuleSelectorParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetRuleSelectorParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Modifies the rule selector.\n[setRuleSelector](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setRuleSelector)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetRuleSelectorReturns {
            #[doc = "The resulting selector list after modification."]
            #[serde(rename = "selectorList")]
            pub selector_list: SelectorList,
        }
        impl SetRuleSelectorReturns {
            pub fn new(selector_list: impl Into<SelectorList>) -> Self {
                Self {
                    selector_list: selector_list.into(),
                }
            }
        }
        impl SetRuleSelectorReturns {
            pub fn builder() -> SetRuleSelectorReturnsBuilder {
                SetRuleSelectorReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetRuleSelectorReturnsBuilder {
            selector_list: Option<SelectorList>,
        }
        impl SetRuleSelectorReturnsBuilder {
            pub fn selector_list(mut self, selector_list: impl Into<SelectorList>) -> Self {
                self.selector_list = Some(selector_list.into());
                self
            }
            pub fn build(self) -> Result<SetRuleSelectorReturns, String> {
                Ok(SetRuleSelectorReturns {
                    selector_list: self.selector_list.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(selector_list))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SetRuleSelectorParams {
            type Response = SetRuleSelectorReturns;
        }
        #[doc = "Sets the new stylesheet text.\n[setStyleSheetText](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setStyleSheetText)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetStyleSheetTextParams {
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
            #[serde(rename = "text")]
            pub text: String,
        }
        impl SetStyleSheetTextParams {
            pub fn new(style_sheet_id: impl Into<StyleSheetId>, text: impl Into<String>) -> Self {
                Self {
                    style_sheet_id: style_sheet_id.into(),
                    text: text.into(),
                }
            }
        }
        impl SetStyleSheetTextParams {
            pub fn builder() -> SetStyleSheetTextParamsBuilder {
                SetStyleSheetTextParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetStyleSheetTextParamsBuilder {
            style_sheet_id: Option<StyleSheetId>,
            text: Option<String>,
        }
        impl SetStyleSheetTextParamsBuilder {
            pub fn style_sheet_id(mut self, style_sheet_id: impl Into<StyleSheetId>) -> Self {
                self.style_sheet_id = Some(style_sheet_id.into());
                self
            }
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn build(self) -> Result<SetStyleSheetTextParams, String> {
                Ok(SetStyleSheetTextParams {
                    style_sheet_id: self.style_sheet_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(style_sheet_id))
                    })?,
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                })
            }
        }
        impl SetStyleSheetTextParams {
            pub const IDENTIFIER: &'static str = "CSS.setStyleSheetText";
        }
        impl chromiumoxide_types::Method for SetStyleSheetTextParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetStyleSheetTextParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets the new stylesheet text.\n[setStyleSheetText](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setStyleSheetText)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetStyleSheetTextReturns {
            #[doc = "URL of source map associated with script (if any)."]
            #[serde(rename = "sourceMapURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub source_map_url: Option<String>,
        }
        impl SetStyleSheetTextReturns {
            pub fn builder() -> SetStyleSheetTextReturnsBuilder {
                SetStyleSheetTextReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetStyleSheetTextReturnsBuilder {
            source_map_url: Option<String>,
        }
        impl SetStyleSheetTextReturnsBuilder {
            pub fn source_map_url(mut self, source_map_url: impl Into<String>) -> Self {
                self.source_map_url = Some(source_map_url.into());
                self
            }
            pub fn build(self) -> SetStyleSheetTextReturns {
                SetStyleSheetTextReturns {
                    source_map_url: self.source_map_url,
                }
            }
        }
        impl chromiumoxide_types::Command for SetStyleSheetTextParams {
            type Response = SetStyleSheetTextReturns;
        }
        #[doc = "Applies specified style edits one after another in the given order.\n[setStyleTexts](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setStyleTexts)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetStyleTextsParams {
            #[serde(rename = "edits")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub edits: Vec<StyleDeclarationEdit>,
        }
        impl SetStyleTextsParams {
            pub fn new(edits: Vec<StyleDeclarationEdit>) -> Self {
                Self { edits }
            }
        }
        impl SetStyleTextsParams {
            pub fn builder() -> SetStyleTextsParamsBuilder {
                SetStyleTextsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetStyleTextsParamsBuilder {
            edits: Option<Vec<StyleDeclarationEdit>>,
        }
        impl SetStyleTextsParamsBuilder {
            pub fn edit(mut self, edit: impl Into<StyleDeclarationEdit>) -> Self {
                let v = self.edits.get_or_insert(Vec::new());
                v.push(edit.into());
                self
            }
            pub fn edits<I, S>(mut self, edits: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<StyleDeclarationEdit>,
            {
                let v = self.edits.get_or_insert(Vec::new());
                for val in edits {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetStyleTextsParams, String> {
                Ok(SetStyleTextsParams {
                    edits: self.edits.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(edits))
                    })?,
                })
            }
        }
        impl SetStyleTextsParams {
            pub const IDENTIFIER: &'static str = "CSS.setStyleTexts";
        }
        impl chromiumoxide_types::Method for SetStyleTextsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetStyleTextsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Applies specified style edits one after another in the given order.\n[setStyleTexts](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setStyleTexts)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetStyleTextsReturns {
            #[doc = "The resulting styles after modification."]
            #[serde(rename = "styles")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub styles: Vec<CssStyle>,
        }
        impl SetStyleTextsReturns {
            pub fn new(styles: Vec<CssStyle>) -> Self {
                Self { styles }
            }
        }
        impl SetStyleTextsReturns {
            pub fn builder() -> SetStyleTextsReturnsBuilder {
                SetStyleTextsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetStyleTextsReturnsBuilder {
            styles: Option<Vec<CssStyle>>,
        }
        impl SetStyleTextsReturnsBuilder {
            pub fn style(mut self, style: impl Into<CssStyle>) -> Self {
                let v = self.styles.get_or_insert(Vec::new());
                v.push(style.into());
                self
            }
            pub fn styles<I, S>(mut self, styles: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssStyle>,
            {
                let v = self.styles.get_or_insert(Vec::new());
                for val in styles {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetStyleTextsReturns, String> {
                Ok(SetStyleTextsReturns {
                    styles: self.styles.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(styles))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SetStyleTextsParams {
            type Response = SetStyleTextsReturns;
        }
        #[doc = "Enables the selector recording.\n[startRuleUsageTracking](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-startRuleUsageTracking)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartRuleUsageTrackingParams {}
        impl StartRuleUsageTrackingParams {
            pub const IDENTIFIER: &'static str = "CSS.startRuleUsageTracking";
        }
        impl chromiumoxide_types::Method for StartRuleUsageTrackingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartRuleUsageTrackingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables the selector recording.\n[startRuleUsageTracking](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-startRuleUsageTracking)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartRuleUsageTrackingReturns {}
        impl chromiumoxide_types::Command for StartRuleUsageTrackingParams {
            type Response = StartRuleUsageTrackingReturns;
        }
        #[doc = "Stop tracking rule usage and return the list of rules that were used since last call to\n`takeCoverageDelta` (or since start of coverage instrumentation)\n[stopRuleUsageTracking](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-stopRuleUsageTracking)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopRuleUsageTrackingParams {}
        impl StopRuleUsageTrackingParams {
            pub const IDENTIFIER: &'static str = "CSS.stopRuleUsageTracking";
        }
        impl chromiumoxide_types::Method for StopRuleUsageTrackingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopRuleUsageTrackingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Stop tracking rule usage and return the list of rules that were used since last call to\n`takeCoverageDelta` (or since start of coverage instrumentation)\n[stopRuleUsageTracking](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-stopRuleUsageTracking)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StopRuleUsageTrackingReturns {
            #[serde(rename = "ruleUsage")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub rule_usage: Vec<RuleUsage>,
        }
        impl StopRuleUsageTrackingReturns {
            pub fn new(rule_usage: Vec<RuleUsage>) -> Self {
                Self { rule_usage }
            }
        }
        impl StopRuleUsageTrackingReturns {
            pub fn builder() -> StopRuleUsageTrackingReturnsBuilder {
                StopRuleUsageTrackingReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StopRuleUsageTrackingReturnsBuilder {
            rule_usage: Option<Vec<RuleUsage>>,
        }
        impl StopRuleUsageTrackingReturnsBuilder {
            pub fn rule_usage(mut self, rule_usage: impl Into<RuleUsage>) -> Self {
                let v = self.rule_usage.get_or_insert(Vec::new());
                v.push(rule_usage.into());
                self
            }
            pub fn rule_usages<I, S>(mut self, rule_usages: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<RuleUsage>,
            {
                let v = self.rule_usage.get_or_insert(Vec::new());
                for val in rule_usages {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<StopRuleUsageTrackingReturns, String> {
                Ok(StopRuleUsageTrackingReturns {
                    rule_usage: self.rule_usage.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(rule_usage))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for StopRuleUsageTrackingParams {
            type Response = StopRuleUsageTrackingReturns;
        }
        #[doc = "Obtain list of rules that became used since last call to this method (or since start of coverage\ninstrumentation)\n[takeCoverageDelta](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-takeCoverageDelta)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TakeCoverageDeltaParams {}
        impl TakeCoverageDeltaParams {
            pub const IDENTIFIER: &'static str = "CSS.takeCoverageDelta";
        }
        impl chromiumoxide_types::Method for TakeCoverageDeltaParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for TakeCoverageDeltaParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Obtain list of rules that became used since last call to this method (or since start of coverage\ninstrumentation)\n[takeCoverageDelta](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-takeCoverageDelta)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TakeCoverageDeltaReturns {
            #[serde(rename = "coverage")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub coverage: Vec<RuleUsage>,
            #[doc = "Monotonically increasing time, in seconds."]
            #[serde(rename = "timestamp")]
            pub timestamp: f64,
        }
        impl TakeCoverageDeltaReturns {
            pub fn new(coverage: Vec<RuleUsage>, timestamp: impl Into<f64>) -> Self {
                Self {
                    coverage,
                    timestamp: timestamp.into(),
                }
            }
        }
        impl TakeCoverageDeltaReturns {
            pub fn builder() -> TakeCoverageDeltaReturnsBuilder {
                TakeCoverageDeltaReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TakeCoverageDeltaReturnsBuilder {
            coverage: Option<Vec<RuleUsage>>,
            timestamp: Option<f64>,
        }
        impl TakeCoverageDeltaReturnsBuilder {
            pub fn coverage(mut self, coverage: impl Into<RuleUsage>) -> Self {
                let v = self.coverage.get_or_insert(Vec::new());
                v.push(coverage.into());
                self
            }
            pub fn coverages<I, S>(mut self, coverages: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<RuleUsage>,
            {
                let v = self.coverage.get_or_insert(Vec::new());
                for val in coverages {
                    v.push(val.into());
                }
                self
            }
            pub fn timestamp(mut self, timestamp: impl Into<f64>) -> Self {
                self.timestamp = Some(timestamp.into());
                self
            }
            pub fn build(self) -> Result<TakeCoverageDeltaReturns, String> {
                Ok(TakeCoverageDeltaReturns {
                    coverage: self.coverage.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(coverage))
                    })?,
                    timestamp: self.timestamp.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(timestamp))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for TakeCoverageDeltaParams {
            type Response = TakeCoverageDeltaReturns;
        }
        #[doc = "Enables/disables rendering of local CSS fonts (enabled by default).\n[setLocalFontsEnabled](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setLocalFontsEnabled)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetLocalFontsEnabledParams {
            #[doc = "Whether rendering of local fonts is enabled."]
            #[serde(rename = "enabled")]
            pub enabled: bool,
        }
        impl SetLocalFontsEnabledParams {
            pub fn new(enabled: impl Into<bool>) -> Self {
                Self {
                    enabled: enabled.into(),
                }
            }
        }
        impl SetLocalFontsEnabledParams {
            pub fn builder() -> SetLocalFontsEnabledParamsBuilder {
                SetLocalFontsEnabledParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetLocalFontsEnabledParamsBuilder {
            enabled: Option<bool>,
        }
        impl SetLocalFontsEnabledParamsBuilder {
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn build(self) -> Result<SetLocalFontsEnabledParams, String> {
                Ok(SetLocalFontsEnabledParams {
                    enabled: self.enabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enabled))
                    })?,
                })
            }
        }
        impl SetLocalFontsEnabledParams {
            pub const IDENTIFIER: &'static str = "CSS.setLocalFontsEnabled";
        }
        impl chromiumoxide_types::Method for SetLocalFontsEnabledParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetLocalFontsEnabledParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables/disables rendering of local CSS fonts (enabled by default).\n[setLocalFontsEnabled](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setLocalFontsEnabled)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetLocalFontsEnabledReturns {}
        impl chromiumoxide_types::Command for SetLocalFontsEnabledParams {
            type Response = SetLocalFontsEnabledReturns;
        }
        #[doc = "Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded\nweb font\n[fontsUpdated](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#event-fontsUpdated)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventFontsUpdated {
            #[doc = "The web font that has loaded."]
            #[serde(rename = "font")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub font: Option<FontFace>,
        }
        impl EventFontsUpdated {
            pub const IDENTIFIER: &'static str = "CSS.fontsUpdated";
        }
        impl chromiumoxide_types::Method for EventFontsUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventFontsUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fires whenever a MediaQuery result changes (for example, after a browser window has been\nresized.) The current implementation considers only viewport-dependent media features.\n[mediaQueryResultChanged](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#event-mediaQueryResultChanged)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventMediaQueryResultChanged {}
        impl EventMediaQueryResultChanged {
            pub const IDENTIFIER: &'static str = "CSS.mediaQueryResultChanged";
        }
        impl chromiumoxide_types::Method for EventMediaQueryResultChanged {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventMediaQueryResultChanged {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired whenever an active document stylesheet is added.\n[styleSheetAdded](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#event-styleSheetAdded)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventStyleSheetAdded {
            #[doc = "Added stylesheet metainfo."]
            #[serde(rename = "header")]
            pub header: CssStyleSheetHeader,
        }
        impl EventStyleSheetAdded {
            pub const IDENTIFIER: &'static str = "CSS.styleSheetAdded";
        }
        impl chromiumoxide_types::Method for EventStyleSheetAdded {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventStyleSheetAdded {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired whenever a stylesheet is changed as a result of the client operation.\n[styleSheetChanged](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#event-styleSheetChanged)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventStyleSheetChanged {
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
        }
        impl EventStyleSheetChanged {
            pub const IDENTIFIER: &'static str = "CSS.styleSheetChanged";
        }
        impl chromiumoxide_types::Method for EventStyleSheetChanged {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventStyleSheetChanged {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired whenever an active document stylesheet is removed.\n[styleSheetRemoved](https://chromedevtools.github.io/devtools-protocol/tot/CSS/#event-styleSheetRemoved)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventStyleSheetRemoved {
            #[doc = "Identifier of the removed stylesheet."]
            #[serde(rename = "styleSheetId")]
            pub style_sheet_id: StyleSheetId,
        }
        impl EventStyleSheetRemoved {
            pub const IDENTIFIER: &'static str = "CSS.styleSheetRemoved";
        }
        impl chromiumoxide_types::Method for EventStyleSheetRemoved {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventStyleSheetRemoved {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    pub mod cache_storage {
        use serde::{Deserialize, Serialize};
        #[doc = "Unique identifier of the Cache object.\n[CacheId](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#type-CacheId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct CacheId(String);
        impl CacheId {
            pub fn new(val: impl Into<String>) -> Self {
                CacheId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for CacheId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<CacheId> for String {
            fn from(el: CacheId) -> String {
                el.0
            }
        }
        impl From<String> for CacheId {
            fn from(expr: String) -> Self {
                CacheId(expr)
            }
        }
        impl std::borrow::Borrow<str> for CacheId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl CacheId {
            pub const IDENTIFIER: &'static str = "CacheStorage.CacheId";
        }
        #[doc = "type of HTTP response cached"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CachedResponseType {
            #[serde(rename = "basic")]
            Basic,
            #[serde(rename = "cors")]
            Cors,
            #[serde(rename = "default")]
            Default,
            #[serde(rename = "error")]
            Error,
            #[serde(rename = "opaqueResponse")]
            OpaqueResponse,
            #[serde(rename = "opaqueRedirect")]
            OpaqueRedirect,
        }
        impl AsRef<str> for CachedResponseType {
            fn as_ref(&self) -> &str {
                match self {
                    CachedResponseType::Basic => "basic",
                    CachedResponseType::Cors => "cors",
                    CachedResponseType::Default => "default",
                    CachedResponseType::Error => "error",
                    CachedResponseType::OpaqueResponse => "opaqueResponse",
                    CachedResponseType::OpaqueRedirect => "opaqueRedirect",
                }
            }
        }
        impl ::std::str::FromStr for CachedResponseType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "basic" | "Basic" => Ok(CachedResponseType::Basic),
                    "cors" | "Cors" => Ok(CachedResponseType::Cors),
                    "default" | "Default" => Ok(CachedResponseType::Default),
                    "error" | "Error" => Ok(CachedResponseType::Error),
                    "opaqueResponse" | "OpaqueResponse" | "opaqueresponse" => {
                        Ok(CachedResponseType::OpaqueResponse)
                    }
                    "opaqueRedirect" | "OpaqueRedirect" | "opaqueredirect" => {
                        Ok(CachedResponseType::OpaqueRedirect)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Data entry.\n[DataEntry](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#type-DataEntry)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DataEntry {
            #[doc = "Request URL."]
            #[serde(rename = "requestURL")]
            pub request_url: String,
            #[doc = "Request method."]
            #[serde(rename = "requestMethod")]
            pub request_method: String,
            #[doc = "Request headers"]
            #[serde(rename = "requestHeaders")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub request_headers: Vec<Header>,
            #[doc = "Number of seconds since epoch."]
            #[serde(rename = "responseTime")]
            pub response_time: f64,
            #[doc = "HTTP response status code."]
            #[serde(rename = "responseStatus")]
            pub response_status: i64,
            #[doc = "HTTP response status text."]
            #[serde(rename = "responseStatusText")]
            pub response_status_text: String,
            #[doc = "HTTP response type"]
            #[serde(rename = "responseType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub response_type: CachedResponseType,
            #[doc = "Response headers"]
            #[serde(rename = "responseHeaders")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub response_headers: Vec<Header>,
        }
        impl DataEntry {
            pub fn builder() -> DataEntryBuilder {
                DataEntryBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DataEntryBuilder {
            request_url: Option<String>,
            request_method: Option<String>,
            request_headers: Option<Vec<Header>>,
            response_time: Option<f64>,
            response_status: Option<i64>,
            response_status_text: Option<String>,
            response_type: Option<CachedResponseType>,
            response_headers: Option<Vec<Header>>,
        }
        impl DataEntryBuilder {
            pub fn request_url(mut self, request_url: impl Into<String>) -> Self {
                self.request_url = Some(request_url.into());
                self
            }
            pub fn request_method(mut self, request_method: impl Into<String>) -> Self {
                self.request_method = Some(request_method.into());
                self
            }
            pub fn request_header(mut self, request_header: impl Into<Header>) -> Self {
                let v = self.request_headers.get_or_insert(Vec::new());
                v.push(request_header.into());
                self
            }
            pub fn request_headers<I, S>(mut self, request_headers: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Header>,
            {
                let v = self.request_headers.get_or_insert(Vec::new());
                for val in request_headers {
                    v.push(val.into());
                }
                self
            }
            pub fn response_time(mut self, response_time: impl Into<f64>) -> Self {
                self.response_time = Some(response_time.into());
                self
            }
            pub fn response_status(mut self, response_status: impl Into<i64>) -> Self {
                self.response_status = Some(response_status.into());
                self
            }
            pub fn response_status_text(mut self, response_status_text: impl Into<String>) -> Self {
                self.response_status_text = Some(response_status_text.into());
                self
            }
            pub fn response_type(mut self, response_type: impl Into<CachedResponseType>) -> Self {
                self.response_type = Some(response_type.into());
                self
            }
            pub fn response_header(mut self, response_header: impl Into<Header>) -> Self {
                let v = self.response_headers.get_or_insert(Vec::new());
                v.push(response_header.into());
                self
            }
            pub fn response_headers<I, S>(mut self, response_headers: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Header>,
            {
                let v = self.response_headers.get_or_insert(Vec::new());
                for val in response_headers {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<DataEntry, String> {
                Ok(DataEntry {
                    request_url: self.request_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_url))
                    })?,
                    request_method: self.request_method.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_method))
                    })?,
                    request_headers: self.request_headers.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_headers))
                    })?,
                    response_time: self.response_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(response_time))
                    })?,
                    response_status: self.response_status.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(response_status))
                    })?,
                    response_status_text: self.response_status_text.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(response_status_text)
                        )
                    })?,
                    response_type: self.response_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(response_type))
                    })?,
                    response_headers: self.response_headers.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(response_headers)
                        )
                    })?,
                })
            }
        }
        impl DataEntry {
            pub const IDENTIFIER: &'static str = "CacheStorage.DataEntry";
        }
        #[doc = "Cache identifier.\n[Cache](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#type-Cache)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Cache {
            #[doc = "An opaque unique id of the cache."]
            #[serde(rename = "cacheId")]
            pub cache_id: CacheId,
            #[doc = "Security origin of the cache."]
            #[serde(rename = "securityOrigin")]
            pub security_origin: String,
            #[doc = "The name of the cache."]
            #[serde(rename = "cacheName")]
            pub cache_name: String,
        }
        impl Cache {
            pub fn new(
                cache_id: impl Into<CacheId>,
                security_origin: impl Into<String>,
                cache_name: impl Into<String>,
            ) -> Self {
                Self {
                    cache_id: cache_id.into(),
                    security_origin: security_origin.into(),
                    cache_name: cache_name.into(),
                }
            }
        }
        impl Cache {
            pub fn builder() -> CacheBuilder {
                CacheBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CacheBuilder {
            cache_id: Option<CacheId>,
            security_origin: Option<String>,
            cache_name: Option<String>,
        }
        impl CacheBuilder {
            pub fn cache_id(mut self, cache_id: impl Into<CacheId>) -> Self {
                self.cache_id = Some(cache_id.into());
                self
            }
            pub fn security_origin(mut self, security_origin: impl Into<String>) -> Self {
                self.security_origin = Some(security_origin.into());
                self
            }
            pub fn cache_name(mut self, cache_name: impl Into<String>) -> Self {
                self.cache_name = Some(cache_name.into());
                self
            }
            pub fn build(self) -> Result<Cache, String> {
                Ok(Cache {
                    cache_id: self.cache_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cache_id))
                    })?,
                    security_origin: self.security_origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(security_origin))
                    })?,
                    cache_name: self.cache_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cache_name))
                    })?,
                })
            }
        }
        impl Cache {
            pub const IDENTIFIER: &'static str = "CacheStorage.Cache";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Header {
            #[serde(rename = "name")]
            pub name: String,
            #[serde(rename = "value")]
            pub value: String,
        }
        impl Header {
            pub fn new(name: impl Into<String>, value: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                }
            }
        }
        impl Header {
            pub fn builder() -> HeaderBuilder {
                HeaderBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct HeaderBuilder {
            name: Option<String>,
            value: Option<String>,
        }
        impl HeaderBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<Header, String> {
                Ok(Header {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl Header {
            pub const IDENTIFIER: &'static str = "CacheStorage.Header";
        }
        #[doc = "Cached response\n[CachedResponse](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#type-CachedResponse)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CachedResponse {
            #[doc = "Entry content, base64-encoded."]
            #[serde(rename = "body")]
            pub body: chromiumoxide_types::Binary,
        }
        impl CachedResponse {
            pub fn new(body: impl Into<chromiumoxide_types::Binary>) -> Self {
                Self { body: body.into() }
            }
        }
        impl CachedResponse {
            pub fn builder() -> CachedResponseBuilder {
                CachedResponseBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CachedResponseBuilder {
            body: Option<chromiumoxide_types::Binary>,
        }
        impl CachedResponseBuilder {
            pub fn body(mut self, body: impl Into<chromiumoxide_types::Binary>) -> Self {
                self.body = Some(body.into());
                self
            }
            pub fn build(self) -> Result<CachedResponse, String> {
                Ok(CachedResponse {
                    body: self.body.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(body))
                    })?,
                })
            }
        }
        impl CachedResponse {
            pub const IDENTIFIER: &'static str = "CacheStorage.CachedResponse";
        }
        #[doc = "Deletes a cache.\n[deleteCache](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-deleteCache)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DeleteCacheParams {
            #[doc = "Id of cache for deletion."]
            #[serde(rename = "cacheId")]
            pub cache_id: CacheId,
        }
        impl DeleteCacheParams {
            pub fn new(cache_id: impl Into<CacheId>) -> Self {
                Self {
                    cache_id: cache_id.into(),
                }
            }
        }
        impl DeleteCacheParams {
            pub fn builder() -> DeleteCacheParamsBuilder {
                DeleteCacheParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DeleteCacheParamsBuilder {
            cache_id: Option<CacheId>,
        }
        impl DeleteCacheParamsBuilder {
            pub fn cache_id(mut self, cache_id: impl Into<CacheId>) -> Self {
                self.cache_id = Some(cache_id.into());
                self
            }
            pub fn build(self) -> Result<DeleteCacheParams, String> {
                Ok(DeleteCacheParams {
                    cache_id: self.cache_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cache_id))
                    })?,
                })
            }
        }
        impl DeleteCacheParams {
            pub const IDENTIFIER: &'static str = "CacheStorage.deleteCache";
        }
        impl chromiumoxide_types::Method for DeleteCacheParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DeleteCacheParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Deletes a cache.\n[deleteCache](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-deleteCache)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DeleteCacheReturns {}
        impl chromiumoxide_types::Command for DeleteCacheParams {
            type Response = DeleteCacheReturns;
        }
        #[doc = "Deletes a cache entry.\n[deleteEntry](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-deleteEntry)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DeleteEntryParams {
            #[doc = "Id of cache where the entry will be deleted."]
            #[serde(rename = "cacheId")]
            pub cache_id: CacheId,
            #[doc = "URL spec of the request."]
            #[serde(rename = "request")]
            pub request: String,
        }
        impl DeleteEntryParams {
            pub fn new(cache_id: impl Into<CacheId>, request: impl Into<String>) -> Self {
                Self {
                    cache_id: cache_id.into(),
                    request: request.into(),
                }
            }
        }
        impl DeleteEntryParams {
            pub fn builder() -> DeleteEntryParamsBuilder {
                DeleteEntryParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DeleteEntryParamsBuilder {
            cache_id: Option<CacheId>,
            request: Option<String>,
        }
        impl DeleteEntryParamsBuilder {
            pub fn cache_id(mut self, cache_id: impl Into<CacheId>) -> Self {
                self.cache_id = Some(cache_id.into());
                self
            }
            pub fn request(mut self, request: impl Into<String>) -> Self {
                self.request = Some(request.into());
                self
            }
            pub fn build(self) -> Result<DeleteEntryParams, String> {
                Ok(DeleteEntryParams {
                    cache_id: self.cache_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cache_id))
                    })?,
                    request: self.request.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request))
                    })?,
                })
            }
        }
        impl DeleteEntryParams {
            pub const IDENTIFIER: &'static str = "CacheStorage.deleteEntry";
        }
        impl chromiumoxide_types::Method for DeleteEntryParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DeleteEntryParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Deletes a cache entry.\n[deleteEntry](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-deleteEntry)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DeleteEntryReturns {}
        impl chromiumoxide_types::Command for DeleteEntryParams {
            type Response = DeleteEntryReturns;
        }
        #[doc = "Requests cache names.\n[requestCacheNames](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-requestCacheNames)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestCacheNamesParams {
            #[doc = "Security origin."]
            #[serde(rename = "securityOrigin")]
            pub security_origin: String,
        }
        impl RequestCacheNamesParams {
            pub fn new(security_origin: impl Into<String>) -> Self {
                Self {
                    security_origin: security_origin.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for RequestCacheNamesParams {
            fn from(url: T) -> Self {
                RequestCacheNamesParams::new(url)
            }
        }
        impl RequestCacheNamesParams {
            pub fn builder() -> RequestCacheNamesParamsBuilder {
                RequestCacheNamesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestCacheNamesParamsBuilder {
            security_origin: Option<String>,
        }
        impl RequestCacheNamesParamsBuilder {
            pub fn security_origin(mut self, security_origin: impl Into<String>) -> Self {
                self.security_origin = Some(security_origin.into());
                self
            }
            pub fn build(self) -> Result<RequestCacheNamesParams, String> {
                Ok(RequestCacheNamesParams {
                    security_origin: self.security_origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(security_origin))
                    })?,
                })
            }
        }
        impl RequestCacheNamesParams {
            pub const IDENTIFIER: &'static str = "CacheStorage.requestCacheNames";
        }
        impl chromiumoxide_types::Method for RequestCacheNamesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RequestCacheNamesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests cache names.\n[requestCacheNames](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-requestCacheNames)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestCacheNamesReturns {
            #[doc = "Caches for the security origin."]
            #[serde(rename = "caches")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub caches: Vec<Cache>,
        }
        impl RequestCacheNamesReturns {
            pub fn new(caches: Vec<Cache>) -> Self {
                Self { caches }
            }
        }
        impl RequestCacheNamesReturns {
            pub fn builder() -> RequestCacheNamesReturnsBuilder {
                RequestCacheNamesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestCacheNamesReturnsBuilder {
            caches: Option<Vec<Cache>>,
        }
        impl RequestCacheNamesReturnsBuilder {
            pub fn cache(mut self, cache: impl Into<Cache>) -> Self {
                let v = self.caches.get_or_insert(Vec::new());
                v.push(cache.into());
                self
            }
            pub fn caches<I, S>(mut self, caches: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Cache>,
            {
                let v = self.caches.get_or_insert(Vec::new());
                for val in caches {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<RequestCacheNamesReturns, String> {
                Ok(RequestCacheNamesReturns {
                    caches: self.caches.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(caches))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for RequestCacheNamesParams {
            type Response = RequestCacheNamesReturns;
        }
        #[doc = "Fetches cache entry.\n[requestCachedResponse](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-requestCachedResponse)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestCachedResponseParams {
            #[doc = "Id of cache that contains the entry."]
            #[serde(rename = "cacheId")]
            pub cache_id: CacheId,
            #[doc = "URL spec of the request."]
            #[serde(rename = "requestURL")]
            pub request_url: String,
            #[doc = "headers of the request."]
            #[serde(rename = "requestHeaders")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub request_headers: Vec<Header>,
        }
        impl RequestCachedResponseParams {
            pub fn new(
                cache_id: impl Into<CacheId>,
                request_url: impl Into<String>,
                request_headers: Vec<Header>,
            ) -> Self {
                Self {
                    cache_id: cache_id.into(),
                    request_url: request_url.into(),
                    request_headers,
                }
            }
        }
        impl RequestCachedResponseParams {
            pub fn builder() -> RequestCachedResponseParamsBuilder {
                RequestCachedResponseParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestCachedResponseParamsBuilder {
            cache_id: Option<CacheId>,
            request_url: Option<String>,
            request_headers: Option<Vec<Header>>,
        }
        impl RequestCachedResponseParamsBuilder {
            pub fn cache_id(mut self, cache_id: impl Into<CacheId>) -> Self {
                self.cache_id = Some(cache_id.into());
                self
            }
            pub fn request_url(mut self, request_url: impl Into<String>) -> Self {
                self.request_url = Some(request_url.into());
                self
            }
            pub fn request_header(mut self, request_header: impl Into<Header>) -> Self {
                let v = self.request_headers.get_or_insert(Vec::new());
                v.push(request_header.into());
                self
            }
            pub fn request_headers<I, S>(mut self, request_headers: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Header>,
            {
                let v = self.request_headers.get_or_insert(Vec::new());
                for val in request_headers {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<RequestCachedResponseParams, String> {
                Ok(RequestCachedResponseParams {
                    cache_id: self.cache_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cache_id))
                    })?,
                    request_url: self.request_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_url))
                    })?,
                    request_headers: self.request_headers.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_headers))
                    })?,
                })
            }
        }
        impl RequestCachedResponseParams {
            pub const IDENTIFIER: &'static str = "CacheStorage.requestCachedResponse";
        }
        impl chromiumoxide_types::Method for RequestCachedResponseParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RequestCachedResponseParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fetches cache entry.\n[requestCachedResponse](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-requestCachedResponse)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestCachedResponseReturns {
            #[doc = "Response read from the cache."]
            #[serde(rename = "response")]
            pub response: CachedResponse,
        }
        impl RequestCachedResponseReturns {
            pub fn new(response: impl Into<CachedResponse>) -> Self {
                Self {
                    response: response.into(),
                }
            }
        }
        impl RequestCachedResponseReturns {
            pub fn builder() -> RequestCachedResponseReturnsBuilder {
                RequestCachedResponseReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestCachedResponseReturnsBuilder {
            response: Option<CachedResponse>,
        }
        impl RequestCachedResponseReturnsBuilder {
            pub fn response(mut self, response: impl Into<CachedResponse>) -> Self {
                self.response = Some(response.into());
                self
            }
            pub fn build(self) -> Result<RequestCachedResponseReturns, String> {
                Ok(RequestCachedResponseReturns {
                    response: self.response.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(response))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for RequestCachedResponseParams {
            type Response = RequestCachedResponseReturns;
        }
        #[doc = "Requests data from cache.\n[requestEntries](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-requestEntries)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestEntriesParams {
            #[doc = "ID of cache to get entries from."]
            #[serde(rename = "cacheId")]
            pub cache_id: CacheId,
            #[doc = "Number of records to skip."]
            #[serde(rename = "skipCount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub skip_count: Option<i64>,
            #[doc = "Number of records to fetch."]
            #[serde(rename = "pageSize")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub page_size: Option<i64>,
            #[doc = "If present, only return the entries containing this substring in the path"]
            #[serde(rename = "pathFilter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub path_filter: Option<String>,
        }
        impl RequestEntriesParams {
            pub fn new(cache_id: impl Into<CacheId>) -> Self {
                Self {
                    cache_id: cache_id.into(),
                    skip_count: None,
                    page_size: None,
                    path_filter: None,
                }
            }
        }
        impl RequestEntriesParams {
            pub fn builder() -> RequestEntriesParamsBuilder {
                RequestEntriesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestEntriesParamsBuilder {
            cache_id: Option<CacheId>,
            skip_count: Option<i64>,
            page_size: Option<i64>,
            path_filter: Option<String>,
        }
        impl RequestEntriesParamsBuilder {
            pub fn cache_id(mut self, cache_id: impl Into<CacheId>) -> Self {
                self.cache_id = Some(cache_id.into());
                self
            }
            pub fn skip_count(mut self, skip_count: impl Into<i64>) -> Self {
                self.skip_count = Some(skip_count.into());
                self
            }
            pub fn page_size(mut self, page_size: impl Into<i64>) -> Self {
                self.page_size = Some(page_size.into());
                self
            }
            pub fn path_filter(mut self, path_filter: impl Into<String>) -> Self {
                self.path_filter = Some(path_filter.into());
                self
            }
            pub fn build(self) -> Result<RequestEntriesParams, String> {
                Ok(RequestEntriesParams {
                    cache_id: self.cache_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cache_id))
                    })?,
                    skip_count: self.skip_count,
                    page_size: self.page_size,
                    path_filter: self.path_filter,
                })
            }
        }
        impl RequestEntriesParams {
            pub const IDENTIFIER: &'static str = "CacheStorage.requestEntries";
        }
        impl chromiumoxide_types::Method for RequestEntriesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RequestEntriesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests data from cache.\n[requestEntries](https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-requestEntries)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestEntriesReturns {
            #[doc = "Array of object store data entries."]
            #[serde(rename = "cacheDataEntries")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub cache_data_entries: Vec<DataEntry>,
            #[doc = "Count of returned entries from this storage. If pathFilter is empty, it\nis the count of all entries from this storage."]
            #[serde(rename = "returnCount")]
            pub return_count: f64,
        }
        impl RequestEntriesReturns {
            pub fn new(cache_data_entries: Vec<DataEntry>, return_count: impl Into<f64>) -> Self {
                Self {
                    cache_data_entries,
                    return_count: return_count.into(),
                }
            }
        }
        impl RequestEntriesReturns {
            pub fn builder() -> RequestEntriesReturnsBuilder {
                RequestEntriesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestEntriesReturnsBuilder {
            cache_data_entries: Option<Vec<DataEntry>>,
            return_count: Option<f64>,
        }
        impl RequestEntriesReturnsBuilder {
            pub fn cache_data_entrie(mut self, cache_data_entrie: impl Into<DataEntry>) -> Self {
                let v = self.cache_data_entries.get_or_insert(Vec::new());
                v.push(cache_data_entrie.into());
                self
            }
            pub fn cache_data_entries<I, S>(mut self, cache_data_entries: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<DataEntry>,
            {
                let v = self.cache_data_entries.get_or_insert(Vec::new());
                for val in cache_data_entries {
                    v.push(val.into());
                }
                self
            }
            pub fn return_count(mut self, return_count: impl Into<f64>) -> Self {
                self.return_count = Some(return_count.into());
                self
            }
            pub fn build(self) -> Result<RequestEntriesReturns, String> {
                Ok(RequestEntriesReturns {
                    cache_data_entries: self.cache_data_entries.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(cache_data_entries)
                        )
                    })?,
                    return_count: self.return_count.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(return_count))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for RequestEntriesParams {
            type Response = RequestEntriesReturns;
        }
    }
    #[doc = "A domain for interacting with Cast, Presentation API, and Remote Playback API\nfunctionalities."]
    pub mod cast {
        use serde::{Deserialize, Serialize};
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Sink {
            #[serde(rename = "name")]
            pub name: String,
            #[serde(rename = "id")]
            pub id: String,
            #[doc = "Text describing the current session. Present only if there is an active\nsession on the sink."]
            #[serde(rename = "session")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub session: Option<String>,
        }
        impl Sink {
            pub fn new(name: impl Into<String>, id: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    id: id.into(),
                    session: None,
                }
            }
        }
        impl Sink {
            pub fn builder() -> SinkBuilder {
                SinkBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SinkBuilder {
            name: Option<String>,
            id: Option<String>,
            session: Option<String>,
        }
        impl SinkBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn id(mut self, id: impl Into<String>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn session(mut self, session: impl Into<String>) -> Self {
                self.session = Some(session.into());
                self
            }
            pub fn build(self) -> Result<Sink, String> {
                Ok(Sink {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                    session: self.session,
                })
            }
        }
        impl Sink {
            pub const IDENTIFIER: &'static str = "Cast.Sink";
        }
        #[doc = "Starts observing for sinks that can be used for tab mirroring, and if set,\nsinks compatible with |presentationUrl| as well. When sinks are found, a\n|sinksUpdated| event is fired.\nAlso starts observing for issue messages. When an issue is added or removed,\nan |issueUpdated| event is fired.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {
            #[serde(rename = "presentationUrl")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub presentation_url: Option<String>,
        }
        impl EnableParams {
            pub fn builder() -> EnableParamsBuilder {
                EnableParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EnableParamsBuilder {
            presentation_url: Option<String>,
        }
        impl EnableParamsBuilder {
            pub fn presentation_url(mut self, presentation_url: impl Into<String>) -> Self {
                self.presentation_url = Some(presentation_url.into());
                self
            }
            pub fn build(self) -> EnableParams {
                EnableParams {
                    presentation_url: self.presentation_url,
                }
            }
        }
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Cast.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Starts observing for sinks that can be used for tab mirroring, and if set,\nsinks compatible with |presentationUrl| as well. When sinks are found, a\n|sinksUpdated| event is fired.\nAlso starts observing for issue messages. When an issue is added or removed,\nan |issueUpdated| event is fired.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Stops observing for sinks and issues.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Cast.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Stops observing for sinks and issues.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Sets a sink to be used when the web page requests the browser to choose a\nsink via Presentation API, Remote Playback API, or Cast SDK.\n[setSinkToUse](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-setSinkToUse)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetSinkToUseParams {
            #[serde(rename = "sinkName")]
            pub sink_name: String,
        }
        impl SetSinkToUseParams {
            pub fn new(sink_name: impl Into<String>) -> Self {
                Self {
                    sink_name: sink_name.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for SetSinkToUseParams {
            fn from(url: T) -> Self {
                SetSinkToUseParams::new(url)
            }
        }
        impl SetSinkToUseParams {
            pub fn builder() -> SetSinkToUseParamsBuilder {
                SetSinkToUseParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetSinkToUseParamsBuilder {
            sink_name: Option<String>,
        }
        impl SetSinkToUseParamsBuilder {
            pub fn sink_name(mut self, sink_name: impl Into<String>) -> Self {
                self.sink_name = Some(sink_name.into());
                self
            }
            pub fn build(self) -> Result<SetSinkToUseParams, String> {
                Ok(SetSinkToUseParams {
                    sink_name: self.sink_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(sink_name))
                    })?,
                })
            }
        }
        impl SetSinkToUseParams {
            pub const IDENTIFIER: &'static str = "Cast.setSinkToUse";
        }
        impl chromiumoxide_types::Method for SetSinkToUseParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetSinkToUseParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets a sink to be used when the web page requests the browser to choose a\nsink via Presentation API, Remote Playback API, or Cast SDK.\n[setSinkToUse](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-setSinkToUse)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetSinkToUseReturns {}
        impl chromiumoxide_types::Command for SetSinkToUseParams {
            type Response = SetSinkToUseReturns;
        }
        #[doc = "Starts mirroring the desktop to the sink.\n[startDesktopMirroring](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-startDesktopMirroring)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StartDesktopMirroringParams {
            #[serde(rename = "sinkName")]
            pub sink_name: String,
        }
        impl StartDesktopMirroringParams {
            pub fn new(sink_name: impl Into<String>) -> Self {
                Self {
                    sink_name: sink_name.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for StartDesktopMirroringParams {
            fn from(url: T) -> Self {
                StartDesktopMirroringParams::new(url)
            }
        }
        impl StartDesktopMirroringParams {
            pub fn builder() -> StartDesktopMirroringParamsBuilder {
                StartDesktopMirroringParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StartDesktopMirroringParamsBuilder {
            sink_name: Option<String>,
        }
        impl StartDesktopMirroringParamsBuilder {
            pub fn sink_name(mut self, sink_name: impl Into<String>) -> Self {
                self.sink_name = Some(sink_name.into());
                self
            }
            pub fn build(self) -> Result<StartDesktopMirroringParams, String> {
                Ok(StartDesktopMirroringParams {
                    sink_name: self.sink_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(sink_name))
                    })?,
                })
            }
        }
        impl StartDesktopMirroringParams {
            pub const IDENTIFIER: &'static str = "Cast.startDesktopMirroring";
        }
        impl chromiumoxide_types::Method for StartDesktopMirroringParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartDesktopMirroringParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Starts mirroring the desktop to the sink.\n[startDesktopMirroring](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-startDesktopMirroring)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartDesktopMirroringReturns {}
        impl chromiumoxide_types::Command for StartDesktopMirroringParams {
            type Response = StartDesktopMirroringReturns;
        }
        #[doc = "Starts mirroring the tab to the sink.\n[startTabMirroring](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-startTabMirroring)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StartTabMirroringParams {
            #[serde(rename = "sinkName")]
            pub sink_name: String,
        }
        impl StartTabMirroringParams {
            pub fn new(sink_name: impl Into<String>) -> Self {
                Self {
                    sink_name: sink_name.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for StartTabMirroringParams {
            fn from(url: T) -> Self {
                StartTabMirroringParams::new(url)
            }
        }
        impl StartTabMirroringParams {
            pub fn builder() -> StartTabMirroringParamsBuilder {
                StartTabMirroringParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StartTabMirroringParamsBuilder {
            sink_name: Option<String>,
        }
        impl StartTabMirroringParamsBuilder {
            pub fn sink_name(mut self, sink_name: impl Into<String>) -> Self {
                self.sink_name = Some(sink_name.into());
                self
            }
            pub fn build(self) -> Result<StartTabMirroringParams, String> {
                Ok(StartTabMirroringParams {
                    sink_name: self.sink_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(sink_name))
                    })?,
                })
            }
        }
        impl StartTabMirroringParams {
            pub const IDENTIFIER: &'static str = "Cast.startTabMirroring";
        }
        impl chromiumoxide_types::Method for StartTabMirroringParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartTabMirroringParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Starts mirroring the tab to the sink.\n[startTabMirroring](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-startTabMirroring)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartTabMirroringReturns {}
        impl chromiumoxide_types::Command for StartTabMirroringParams {
            type Response = StartTabMirroringReturns;
        }
        #[doc = "Stops the active Cast session on the sink.\n[stopCasting](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-stopCasting)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StopCastingParams {
            #[serde(rename = "sinkName")]
            pub sink_name: String,
        }
        impl StopCastingParams {
            pub fn new(sink_name: impl Into<String>) -> Self {
                Self {
                    sink_name: sink_name.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for StopCastingParams {
            fn from(url: T) -> Self {
                StopCastingParams::new(url)
            }
        }
        impl StopCastingParams {
            pub fn builder() -> StopCastingParamsBuilder {
                StopCastingParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StopCastingParamsBuilder {
            sink_name: Option<String>,
        }
        impl StopCastingParamsBuilder {
            pub fn sink_name(mut self, sink_name: impl Into<String>) -> Self {
                self.sink_name = Some(sink_name.into());
                self
            }
            pub fn build(self) -> Result<StopCastingParams, String> {
                Ok(StopCastingParams {
                    sink_name: self.sink_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(sink_name))
                    })?,
                })
            }
        }
        impl StopCastingParams {
            pub const IDENTIFIER: &'static str = "Cast.stopCasting";
        }
        impl chromiumoxide_types::Method for StopCastingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopCastingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Stops the active Cast session on the sink.\n[stopCasting](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-stopCasting)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopCastingReturns {}
        impl chromiumoxide_types::Command for StopCastingParams {
            type Response = StopCastingReturns;
        }
        #[doc = "This is fired whenever the list of available sinks changes. A sink is a\ndevice or a software surface that you can cast to.\n[sinksUpdated](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#event-sinksUpdated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventSinksUpdated {
            #[serde(rename = "sinks")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub sinks: Vec<Sink>,
        }
        impl EventSinksUpdated {
            pub const IDENTIFIER: &'static str = "Cast.sinksUpdated";
        }
        impl chromiumoxide_types::Method for EventSinksUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventSinksUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "This is fired whenever the outstanding issue/error message changes.\n|issueMessage| is empty if there is no issue.\n[issueUpdated](https://chromedevtools.github.io/devtools-protocol/tot/Cast/#event-issueUpdated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventIssueUpdated {
            #[serde(rename = "issueMessage")]
            pub issue_message: String,
        }
        impl EventIssueUpdated {
            pub const IDENTIFIER: &'static str = "Cast.issueUpdated";
        }
        impl chromiumoxide_types::Method for EventIssueUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventIssueUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object\nthat has an `id`. This `id` can be used to get additional information on the Node, resolve it into\nthe JavaScript object wrapper, etc. It is important that client receives DOM events only for the\nnodes that are known to the client. Backend keeps track of the nodes that were sent to the client\nand never sends the same node twice. It is client's responsibility to collect information about\nthe nodes that were sent to the client.<p>Note that `iframe` owner elements will return\ncorresponding document elements as their child nodes.</p>"]
    pub mod dom {
        use serde::{Deserialize, Serialize};
        #[doc = "Unique DOM node identifier.\n[NodeId](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#type-NodeId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Copy, Hash)]
        pub struct NodeId(i64);
        impl NodeId {
            pub fn new(val: impl Into<i64>) -> Self {
                NodeId(val.into())
            }
            pub fn inner(&self) -> &i64 {
                &self.0
            }
        }
        impl NodeId {
            pub const IDENTIFIER: &'static str = "DOM.NodeId";
        }
        #[doc = "Unique DOM node identifier used to reference a node that may not have been pushed to the\nfront-end.\n[BackendNodeId](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#type-BackendNodeId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Copy, Hash)]
        pub struct BackendNodeId(i64);
        impl BackendNodeId {
            pub fn new(val: impl Into<i64>) -> Self {
                BackendNodeId(val.into())
            }
            pub fn inner(&self) -> &i64 {
                &self.0
            }
        }
        impl BackendNodeId {
            pub const IDENTIFIER: &'static str = "DOM.BackendNodeId";
        }
        #[doc = "Backend node with a friendly name.\n[BackendNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#type-BackendNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct BackendNode {
            #[doc = "`Node`'s nodeType."]
            #[serde(rename = "nodeType")]
            pub node_type: i64,
            #[doc = "`Node`'s nodeName."]
            #[serde(rename = "nodeName")]
            pub node_name: String,
            #[serde(rename = "backendNodeId")]
            pub backend_node_id: BackendNodeId,
        }
        impl BackendNode {
            pub fn new(
                node_type: impl Into<i64>,
                node_name: impl Into<String>,
                backend_node_id: impl Into<BackendNodeId>,
            ) -> Self {
                Self {
                    node_type: node_type.into(),
                    node_name: node_name.into(),
                    backend_node_id: backend_node_id.into(),
                }
            }
        }
        impl BackendNode {
            pub fn builder() -> BackendNodeBuilder {
                BackendNodeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BackendNodeBuilder {
            node_type: Option<i64>,
            node_name: Option<String>,
            backend_node_id: Option<BackendNodeId>,
        }
        impl BackendNodeBuilder {
            pub fn node_type(mut self, node_type: impl Into<i64>) -> Self {
                self.node_type = Some(node_type.into());
                self
            }
            pub fn node_name(mut self, node_name: impl Into<String>) -> Self {
                self.node_name = Some(node_name.into());
                self
            }
            pub fn backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn build(self) -> Result<BackendNode, String> {
                Ok(BackendNode {
                    node_type: self.node_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_type))
                    })?,
                    node_name: self.node_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_name))
                    })?,
                    backend_node_id: self.backend_node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(backend_node_id))
                    })?,
                })
            }
        }
        impl BackendNode {
            pub const IDENTIFIER: &'static str = "DOM.BackendNode";
        }
        #[doc = "Pseudo element type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PseudoType {
            #[serde(rename = "first-line")]
            FirstLine,
            #[serde(rename = "first-letter")]
            FirstLetter,
            #[serde(rename = "before")]
            Before,
            #[serde(rename = "after")]
            After,
            #[serde(rename = "marker")]
            Marker,
            #[serde(rename = "backdrop")]
            Backdrop,
            #[serde(rename = "selection")]
            Selection,
            #[serde(rename = "target-text")]
            TargetText,
            #[serde(rename = "spelling-error")]
            SpellingError,
            #[serde(rename = "grammar-error")]
            GrammarError,
            #[serde(rename = "highlight")]
            Highlight,
            #[serde(rename = "first-line-inherited")]
            FirstLineInherited,
            #[serde(rename = "scrollbar")]
            Scrollbar,
            #[serde(rename = "scrollbar-thumb")]
            ScrollbarThumb,
            #[serde(rename = "scrollbar-button")]
            ScrollbarButton,
            #[serde(rename = "scrollbar-track")]
            ScrollbarTrack,
            #[serde(rename = "scrollbar-track-piece")]
            ScrollbarTrackPiece,
            #[serde(rename = "scrollbar-corner")]
            ScrollbarCorner,
            #[serde(rename = "resizer")]
            Resizer,
            #[serde(rename = "input-list-button")]
            InputListButton,
            #[serde(rename = "page-transition")]
            PageTransition,
            #[serde(rename = "page-transition-container")]
            PageTransitionContainer,
            #[serde(rename = "page-transition-image-wrapper")]
            PageTransitionImageWrapper,
            #[serde(rename = "page-transition-outgoing-image")]
            PageTransitionOutgoingImage,
            #[serde(rename = "page-transition-incoming-image")]
            PageTransitionIncomingImage,
        }
        impl AsRef<str> for PseudoType {
            fn as_ref(&self) -> &str {
                match self {
                    PseudoType::FirstLine => "first-line",
                    PseudoType::FirstLetter => "first-letter",
                    PseudoType::Before => "before",
                    PseudoType::After => "after",
                    PseudoType::Marker => "marker",
                    PseudoType::Backdrop => "backdrop",
                    PseudoType::Selection => "selection",
                    PseudoType::TargetText => "target-text",
                    PseudoType::SpellingError => "spelling-error",
                    PseudoType::GrammarError => "grammar-error",
                    PseudoType::Highlight => "highlight",
                    PseudoType::FirstLineInherited => "first-line-inherited",
                    PseudoType::Scrollbar => "scrollbar",
                    PseudoType::ScrollbarThumb => "scrollbar-thumb",
                    PseudoType::ScrollbarButton => "scrollbar-button",
                    PseudoType::ScrollbarTrack => "scrollbar-track",
                    PseudoType::ScrollbarTrackPiece => "scrollbar-track-piece",
                    PseudoType::ScrollbarCorner => "scrollbar-corner",
                    PseudoType::Resizer => "resizer",
                    PseudoType::InputListButton => "input-list-button",
                    PseudoType::PageTransition => "page-transition",
                    PseudoType::PageTransitionContainer => "page-transition-container",
                    PseudoType::PageTransitionImageWrapper => "page-transition-image-wrapper",
                    PseudoType::PageTransitionOutgoingImage => "page-transition-outgoing-image",
                    PseudoType::PageTransitionIncomingImage => "page-transition-incoming-image",
                }
            }
        }
        impl ::std::str::FromStr for PseudoType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "first-line" | "FirstLine" => Ok(PseudoType::FirstLine),
                    "first-letter" | "FirstLetter" => Ok(PseudoType::FirstLetter),
                    "before" | "Before" => Ok(PseudoType::Before),
                    "after" | "After" => Ok(PseudoType::After),
                    "marker" | "Marker" => Ok(PseudoType::Marker),
                    "backdrop" | "Backdrop" => Ok(PseudoType::Backdrop),
                    "selection" | "Selection" => Ok(PseudoType::Selection),
                    "target-text" | "TargetText" => Ok(PseudoType::TargetText),
                    "spelling-error" | "SpellingError" => Ok(PseudoType::SpellingError),
                    "grammar-error" | "GrammarError" => Ok(PseudoType::GrammarError),
                    "highlight" | "Highlight" => Ok(PseudoType::Highlight),
                    "first-line-inherited" | "FirstLineInherited" => {
                        Ok(PseudoType::FirstLineInherited)
                    }
                    "scrollbar" | "Scrollbar" => Ok(PseudoType::Scrollbar),
                    "scrollbar-thumb" | "ScrollbarThumb" => Ok(PseudoType::ScrollbarThumb),
                    "scrollbar-button" | "ScrollbarButton" => Ok(PseudoType::ScrollbarButton),
                    "scrollbar-track" | "ScrollbarTrack" => Ok(PseudoType::ScrollbarTrack),
                    "scrollbar-track-piece" | "ScrollbarTrackPiece" => {
                        Ok(PseudoType::ScrollbarTrackPiece)
                    }
                    "scrollbar-corner" | "ScrollbarCorner" => Ok(PseudoType::ScrollbarCorner),
                    "resizer" | "Resizer" => Ok(PseudoType::Resizer),
                    "input-list-button" | "InputListButton" => Ok(PseudoType::InputListButton),
                    "page-transition" | "PageTransition" => Ok(PseudoType::PageTransition),
                    "page-transition-container" | "PageTransitionContainer" => {
                        Ok(PseudoType::PageTransitionContainer)
                    }
                    "page-transition-image-wrapper" | "PageTransitionImageWrapper" => {
                        Ok(PseudoType::PageTransitionImageWrapper)
                    }
                    "page-transition-outgoing-image" | "PageTransitionOutgoingImage" => {
                        Ok(PseudoType::PageTransitionOutgoingImage)
                    }
                    "page-transition-incoming-image" | "PageTransitionIncomingImage" => {
                        Ok(PseudoType::PageTransitionIncomingImage)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Shadow root type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ShadowRootType {
            #[serde(rename = "user-agent")]
            UserAgent,
            #[serde(rename = "open")]
            Open,
            #[serde(rename = "closed")]
            Closed,
        }
        impl AsRef<str> for ShadowRootType {
            fn as_ref(&self) -> &str {
                match self {
                    ShadowRootType::UserAgent => "user-agent",
                    ShadowRootType::Open => "open",
                    ShadowRootType::Closed => "closed",
                }
            }
        }
        impl ::std::str::FromStr for ShadowRootType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "user-agent" | "UserAgent" => Ok(ShadowRootType::UserAgent),
                    "open" | "Open" => Ok(ShadowRootType::Open),
                    "closed" | "Closed" => Ok(ShadowRootType::Closed),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Document compatibility mode."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CompatibilityMode {
            #[serde(rename = "QuirksMode")]
            QuirksMode,
            #[serde(rename = "LimitedQuirksMode")]
            LimitedQuirksMode,
            #[serde(rename = "NoQuirksMode")]
            NoQuirksMode,
        }
        impl AsRef<str> for CompatibilityMode {
            fn as_ref(&self) -> &str {
                match self {
                    CompatibilityMode::QuirksMode => "QuirksMode",
                    CompatibilityMode::LimitedQuirksMode => "LimitedQuirksMode",
                    CompatibilityMode::NoQuirksMode => "NoQuirksMode",
                }
            }
        }
        impl ::std::str::FromStr for CompatibilityMode {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "QuirksMode" | "quirksmode" => Ok(CompatibilityMode::QuirksMode),
                    "LimitedQuirksMode" | "limitedquirksmode" => {
                        Ok(CompatibilityMode::LimitedQuirksMode)
                    }
                    "NoQuirksMode" | "noquirksmode" => Ok(CompatibilityMode::NoQuirksMode),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.\nDOMNode is a base node mirror type.\n[Node](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#type-Node)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Node {
            #[doc = "Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend\nwill only push node with given `id` once. It is aware of all requested nodes and will only\nfire DOM events for nodes known to the client."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "The id of the parent node if any."]
            #[serde(rename = "parentId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub parent_id: Option<NodeId>,
            #[doc = "The BackendNodeId for this node."]
            #[serde(rename = "backendNodeId")]
            pub backend_node_id: BackendNodeId,
            #[doc = "`Node`'s nodeType."]
            #[serde(rename = "nodeType")]
            pub node_type: i64,
            #[doc = "`Node`'s nodeName."]
            #[serde(rename = "nodeName")]
            pub node_name: String,
            #[doc = "`Node`'s localName."]
            #[serde(rename = "localName")]
            pub local_name: String,
            #[doc = "`Node`'s nodeValue."]
            #[serde(rename = "nodeValue")]
            pub node_value: String,
            #[doc = "Child count for `Container` nodes."]
            #[serde(rename = "childNodeCount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub child_node_count: Option<i64>,
            #[doc = "Child nodes of this node when requested with children."]
            #[serde(rename = "children")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub children: Option<Vec<Node>>,
            #[doc = "Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`."]
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub attributes: Option<Vec<String>>,
            #[doc = "Document URL that `Document` or `FrameOwner` node points to."]
            #[serde(rename = "documentURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub document_url: Option<String>,
            #[doc = "Base URL that `Document` or `FrameOwner` node uses for URL completion."]
            #[serde(rename = "baseURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub base_url: Option<String>,
            #[doc = "`DocumentType`'s publicId."]
            #[serde(rename = "publicId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub public_id: Option<String>,
            #[doc = "`DocumentType`'s systemId."]
            #[serde(rename = "systemId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub system_id: Option<String>,
            #[doc = "`DocumentType`'s internalSubset."]
            #[serde(rename = "internalSubset")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub internal_subset: Option<String>,
            #[doc = "`Document`'s XML version in case of XML documents."]
            #[serde(rename = "xmlVersion")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub xml_version: Option<String>,
            #[doc = "`Attr`'s name."]
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub name: Option<String>,
            #[doc = "`Attr`'s value."]
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value: Option<String>,
            #[doc = "Pseudo element type for this node."]
            #[serde(rename = "pseudoType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub pseudo_type: Option<PseudoType>,
            #[doc = "Pseudo element identifier for this node. Only present if there is a\nvalid pseudoType."]
            #[serde(rename = "pseudoIdentifier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pseudo_identifier: Option<String>,
            #[doc = "Shadow root type."]
            #[serde(rename = "shadowRootType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub shadow_root_type: Option<ShadowRootType>,
            #[doc = "Frame ID for frame owner elements."]
            #[serde(rename = "frameId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_id: Option<super::page::FrameId>,
            #[doc = "Content document for frame owner elements."]
            #[serde(rename = "contentDocument")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub content_document: Option<Box<Node>>,
            #[doc = "Shadow root list for given element host."]
            #[serde(rename = "shadowRoots")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub shadow_roots: Option<Vec<Node>>,
            #[doc = "Content document fragment for template elements."]
            #[serde(rename = "templateContent")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub template_content: Option<Box<Node>>,
            #[doc = "Pseudo elements associated with this node."]
            #[serde(rename = "pseudoElements")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pseudo_elements: Option<Vec<Node>>,
            #[doc = "Distributed nodes for given insertion point."]
            #[serde(rename = "distributedNodes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub distributed_nodes: Option<Vec<BackendNode>>,
            #[doc = "Whether the node is SVG."]
            #[serde(rename = "isSVG")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_svg: Option<bool>,
            #[serde(rename = "compatibilityMode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub compatibility_mode: Option<CompatibilityMode>,
            #[serde(rename = "assignedSlot")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub assigned_slot: Option<BackendNode>,
        }
        impl Node {
            pub fn builder() -> NodeBuilder {
                NodeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct NodeBuilder {
            node_id: Option<NodeId>,
            parent_id: Option<NodeId>,
            backend_node_id: Option<BackendNodeId>,
            node_type: Option<i64>,
            node_name: Option<String>,
            local_name: Option<String>,
            node_value: Option<String>,
            child_node_count: Option<i64>,
            children: Option<Vec<Node>>,
            attributes: Option<Vec<String>>,
            document_url: Option<String>,
            base_url: Option<String>,
            public_id: Option<String>,
            system_id: Option<String>,
            internal_subset: Option<String>,
            xml_version: Option<String>,
            name: Option<String>,
            value: Option<String>,
            pseudo_type: Option<PseudoType>,
            pseudo_identifier: Option<String>,
            shadow_root_type: Option<ShadowRootType>,
            frame_id: Option<super::page::FrameId>,
            content_document: Option<Node>,
            shadow_roots: Option<Vec<Node>>,
            template_content: Option<Node>,
            pseudo_elements: Option<Vec<Node>>,
            distributed_nodes: Option<Vec<BackendNode>>,
            is_svg: Option<bool>,
            compatibility_mode: Option<CompatibilityMode>,
            assigned_slot: Option<BackendNode>,
        }
        impl NodeBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn parent_id(mut self, parent_id: impl Into<NodeId>) -> Self {
                self.parent_id = Some(parent_id.into());
                self
            }
            pub fn backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn node_type(mut self, node_type: impl Into<i64>) -> Self {
                self.node_type = Some(node_type.into());
                self
            }
            pub fn node_name(mut self, node_name: impl Into<String>) -> Self {
                self.node_name = Some(node_name.into());
                self
            }
            pub fn local_name(mut self, local_name: impl Into<String>) -> Self {
                self.local_name = Some(local_name.into());
                self
            }
            pub fn node_value(mut self, node_value: impl Into<String>) -> Self {
                self.node_value = Some(node_value.into());
                self
            }
            pub fn child_node_count(mut self, child_node_count: impl Into<i64>) -> Self {
                self.child_node_count = Some(child_node_count.into());
                self
            }
            pub fn children(mut self, children: impl Into<Node>) -> Self {
                let v = self.children.get_or_insert(Vec::new());
                v.push(children.into());
                self
            }
            pub fn childrens<I, S>(mut self, childrens: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Node>,
            {
                let v = self.children.get_or_insert(Vec::new());
                for val in childrens {
                    v.push(val.into());
                }
                self
            }
            pub fn attribute(mut self, attribute: impl Into<String>) -> Self {
                let v = self.attributes.get_or_insert(Vec::new());
                v.push(attribute.into());
                self
            }
            pub fn attributes<I, S>(mut self, attributes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.attributes.get_or_insert(Vec::new());
                for val in attributes {
                    v.push(val.into());
                }
                self
            }
            pub fn document_url(mut self, document_url: impl Into<String>) -> Self {
                self.document_url = Some(document_url.into());
                self
            }
            pub fn base_url(mut self, base_url: impl Into<String>) -> Self {
                self.base_url = Some(base_url.into());
                self
            }
            pub fn public_id(mut self, public_id: impl Into<String>) -> Self {
                self.public_id = Some(public_id.into());
                self
            }
            pub fn system_id(mut self, system_id: impl Into<String>) -> Self {
                self.system_id = Some(system_id.into());
                self
            }
            pub fn internal_subset(mut self, internal_subset: impl Into<String>) -> Self {
                self.internal_subset = Some(internal_subset.into());
                self
            }
            pub fn xml_version(mut self, xml_version: impl Into<String>) -> Self {
                self.xml_version = Some(xml_version.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn pseudo_type(mut self, pseudo_type: impl Into<PseudoType>) -> Self {
                self.pseudo_type = Some(pseudo_type.into());
                self
            }
            pub fn pseudo_identifier(mut self, pseudo_identifier: impl Into<String>) -> Self {
                self.pseudo_identifier = Some(pseudo_identifier.into());
                self
            }
            pub fn shadow_root_type(mut self, shadow_root_type: impl Into<ShadowRootType>) -> Self {
                self.shadow_root_type = Some(shadow_root_type.into());
                self
            }
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn content_document(mut self, content_document: impl Into<Node>) -> Self {
                self.content_document = Some(content_document.into());
                self
            }
            pub fn shadow_root(mut self, shadow_root: impl Into<Node>) -> Self {
                let v = self.shadow_roots.get_or_insert(Vec::new());
                v.push(shadow_root.into());
                self
            }
            pub fn shadow_roots<I, S>(mut self, shadow_roots: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Node>,
            {
                let v = self.shadow_roots.get_or_insert(Vec::new());
                for val in shadow_roots {
                    v.push(val.into());
                }
                self
            }
            pub fn template_content(mut self, template_content: impl Into<Node>) -> Self {
                self.template_content = Some(template_content.into());
                self
            }
            pub fn pseudo_element(mut self, pseudo_element: impl Into<Node>) -> Self {
                let v = self.pseudo_elements.get_or_insert(Vec::new());
                v.push(pseudo_element.into());
                self
            }
            pub fn pseudo_elements<I, S>(mut self, pseudo_elements: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Node>,
            {
                let v = self.pseudo_elements.get_or_insert(Vec::new());
                for val in pseudo_elements {
                    v.push(val.into());
                }
                self
            }
            pub fn distributed_node(mut self, distributed_node: impl Into<BackendNode>) -> Self {
                let v = self.distributed_nodes.get_or_insert(Vec::new());
                v.push(distributed_node.into());
                self
            }
            pub fn distributed_nodes<I, S>(mut self, distributed_nodes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<BackendNode>,
            {
                let v = self.distributed_nodes.get_or_insert(Vec::new());
                for val in distributed_nodes {
                    v.push(val.into());
                }
                self
            }
            pub fn is_svg(mut self, is_svg: impl Into<bool>) -> Self {
                self.is_svg = Some(is_svg.into());
                self
            }
            pub fn compatibility_mode(
                mut self,
                compatibility_mode: impl Into<CompatibilityMode>,
            ) -> Self {
                self.compatibility_mode = Some(compatibility_mode.into());
                self
            }
            pub fn assigned_slot(mut self, assigned_slot: impl Into<BackendNode>) -> Self {
                self.assigned_slot = Some(assigned_slot.into());
                self
            }
            pub fn build(self) -> Result<Node, String> {
                Ok(Node {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    parent_id: self.parent_id,
                    backend_node_id: self.backend_node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(backend_node_id))
                    })?,
                    node_type: self.node_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_type))
                    })?,
                    node_name: self.node_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_name))
                    })?,
                    local_name: self.local_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(local_name))
                    })?,
                    node_value: self.node_value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_value))
                    })?,
                    child_node_count: self.child_node_count,
                    children: self.children,
                    attributes: self.attributes,
                    document_url: self.document_url,
                    base_url: self.base_url,
                    public_id: self.public_id,
                    system_id: self.system_id,
                    internal_subset: self.internal_subset,
                    xml_version: self.xml_version,
                    name: self.name,
                    value: self.value,
                    pseudo_type: self.pseudo_type,
                    pseudo_identifier: self.pseudo_identifier,
                    shadow_root_type: self.shadow_root_type,
                    frame_id: self.frame_id,
                    content_document: self.content_document.map(Box::new),
                    shadow_roots: self.shadow_roots,
                    template_content: self.template_content.map(Box::new),
                    pseudo_elements: self.pseudo_elements,
                    distributed_nodes: self.distributed_nodes,
                    is_svg: self.is_svg,
                    compatibility_mode: self.compatibility_mode,
                    assigned_slot: self.assigned_slot,
                })
            }
        }
        impl Node {
            pub const IDENTIFIER: &'static str = "DOM.Node";
        }
        #[doc = "A structure holding an RGBA color.\n[RGBA](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#type-RGBA)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Rgba {
            #[doc = "The red component, in the [0-255] range."]
            #[serde(rename = "r")]
            pub r: i64,
            #[doc = "The green component, in the [0-255] range."]
            #[serde(rename = "g")]
            pub g: i64,
            #[doc = "The blue component, in the [0-255] range."]
            #[serde(rename = "b")]
            pub b: i64,
            #[doc = "The alpha component, in the [0-1] range (default: 1)."]
            #[serde(rename = "a")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub a: Option<f64>,
        }
        impl Rgba {
            pub fn new(r: impl Into<i64>, g: impl Into<i64>, b: impl Into<i64>) -> Self {
                Self {
                    r: r.into(),
                    g: g.into(),
                    b: b.into(),
                    a: None,
                }
            }
        }
        impl Rgba {
            pub fn builder() -> RgbaBuilder {
                RgbaBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RgbaBuilder {
            r: Option<i64>,
            g: Option<i64>,
            b: Option<i64>,
            a: Option<f64>,
        }
        impl RgbaBuilder {
            pub fn r(mut self, r: impl Into<i64>) -> Self {
                self.r = Some(r.into());
                self
            }
            pub fn g(mut self, g: impl Into<i64>) -> Self {
                self.g = Some(g.into());
                self
            }
            pub fn b(mut self, b: impl Into<i64>) -> Self {
                self.b = Some(b.into());
                self
            }
            pub fn a(mut self, a: impl Into<f64>) -> Self {
                self.a = Some(a.into());
                self
            }
            pub fn build(self) -> Result<Rgba, String> {
                Ok(Rgba {
                    r: self
                        .r
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(r)))?,
                    g: self
                        .g
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(g)))?,
                    b: self
                        .b
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(b)))?,
                    a: self.a,
                })
            }
        }
        impl Rgba {
            pub const IDENTIFIER: &'static str = "DOM.RGBA";
        }
        #[doc = "An array of quad vertices, x immediately followed by y for each point, points clock-wise.\n[Quad](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#type-Quad)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct Quad(Vec<f64>);
        impl Quad {
            pub fn new(val: impl Into<Vec<f64>>) -> Self {
                Quad(val.into())
            }
            pub fn inner(&self) -> &Vec<f64> {
                &self.0
            }
        }
        impl Quad {
            pub const IDENTIFIER: &'static str = "DOM.Quad";
        }
        #[doc = "Box model.\n[BoxModel](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#type-BoxModel)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct BoxModel {
            #[doc = "Content box"]
            #[serde(rename = "content")]
            pub content: Quad,
            #[doc = "Padding box"]
            #[serde(rename = "padding")]
            pub padding: Quad,
            #[doc = "Border box"]
            #[serde(rename = "border")]
            pub border: Quad,
            #[doc = "Margin box"]
            #[serde(rename = "margin")]
            pub margin: Quad,
            #[doc = "Node width"]
            #[serde(rename = "width")]
            pub width: i64,
            #[doc = "Node height"]
            #[serde(rename = "height")]
            pub height: i64,
            #[doc = "Shape outside coordinates"]
            #[serde(rename = "shapeOutside")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub shape_outside: Option<ShapeOutsideInfo>,
        }
        impl BoxModel {
            pub fn builder() -> BoxModelBuilder {
                BoxModelBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BoxModelBuilder {
            content: Option<Quad>,
            padding: Option<Quad>,
            border: Option<Quad>,
            margin: Option<Quad>,
            width: Option<i64>,
            height: Option<i64>,
            shape_outside: Option<ShapeOutsideInfo>,
        }
        impl BoxModelBuilder {
            pub fn content(mut self, content: impl Into<Quad>) -> Self {
                self.content = Some(content.into());
                self
            }
            pub fn padding(mut self, padding: impl Into<Quad>) -> Self {
                self.padding = Some(padding.into());
                self
            }
            pub fn border(mut self, border: impl Into<Quad>) -> Self {
                self.border = Some(border.into());
                self
            }
            pub fn margin(mut self, margin: impl Into<Quad>) -> Self {
                self.margin = Some(margin.into());
                self
            }
            pub fn width(mut self, width: impl Into<i64>) -> Self {
                self.width = Some(width.into());
                self
            }
            pub fn height(mut self, height: impl Into<i64>) -> Self {
                self.height = Some(height.into());
                self
            }
            pub fn shape_outside(mut self, shape_outside: impl Into<ShapeOutsideInfo>) -> Self {
                self.shape_outside = Some(shape_outside.into());
                self
            }
            pub fn build(self) -> Result<BoxModel, String> {
                Ok(BoxModel {
                    content: self.content.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(content))
                    })?,
                    padding: self.padding.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(padding))
                    })?,
                    border: self.border.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(border))
                    })?,
                    margin: self.margin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(margin))
                    })?,
                    width: self.width.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(width))
                    })?,
                    height: self.height.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(height))
                    })?,
                    shape_outside: self.shape_outside,
                })
            }
        }
        impl BoxModel {
            pub const IDENTIFIER: &'static str = "DOM.BoxModel";
        }
        #[doc = "CSS Shape Outside details.\n[ShapeOutsideInfo](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#type-ShapeOutsideInfo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ShapeOutsideInfo {
            #[doc = "Shape bounds"]
            #[serde(rename = "bounds")]
            pub bounds: Quad,
            #[doc = "Shape coordinate details"]
            #[serde(rename = "shape")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub shape: Vec<serde_json::Value>,
            #[doc = "Margin shape bounds"]
            #[serde(rename = "marginShape")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub margin_shape: Vec<serde_json::Value>,
        }
        impl ShapeOutsideInfo {
            pub fn new(
                bounds: impl Into<Quad>,
                shape: Vec<serde_json::Value>,
                margin_shape: Vec<serde_json::Value>,
            ) -> Self {
                Self {
                    bounds: bounds.into(),
                    shape,
                    margin_shape,
                }
            }
        }
        impl ShapeOutsideInfo {
            pub fn builder() -> ShapeOutsideInfoBuilder {
                ShapeOutsideInfoBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ShapeOutsideInfoBuilder {
            bounds: Option<Quad>,
            shape: Option<Vec<serde_json::Value>>,
            margin_shape: Option<Vec<serde_json::Value>>,
        }
        impl ShapeOutsideInfoBuilder {
            pub fn bounds(mut self, bounds: impl Into<Quad>) -> Self {
                self.bounds = Some(bounds.into());
                self
            }
            pub fn shape(mut self, shape: impl Into<serde_json::Value>) -> Self {
                let v = self.shape.get_or_insert(Vec::new());
                v.push(shape.into());
                self
            }
            pub fn shapes<I, S>(mut self, shapes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<serde_json::Value>,
            {
                let v = self.shape.get_or_insert(Vec::new());
                for val in shapes {
                    v.push(val.into());
                }
                self
            }
            pub fn margin_shape(mut self, margin_shape: impl Into<serde_json::Value>) -> Self {
                let v = self.margin_shape.get_or_insert(Vec::new());
                v.push(margin_shape.into());
                self
            }
            pub fn margin_shapes<I, S>(mut self, margin_shapes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<serde_json::Value>,
            {
                let v = self.margin_shape.get_or_insert(Vec::new());
                for val in margin_shapes {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<ShapeOutsideInfo, String> {
                Ok(ShapeOutsideInfo {
                    bounds: self.bounds.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(bounds))
                    })?,
                    shape: self.shape.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(shape))
                    })?,
                    margin_shape: self.margin_shape.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(margin_shape))
                    })?,
                })
            }
        }
        impl ShapeOutsideInfo {
            pub const IDENTIFIER: &'static str = "DOM.ShapeOutsideInfo";
        }
        #[doc = "Rectangle.\n[Rect](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#type-Rect)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Rect {
            #[doc = "X coordinate"]
            #[serde(rename = "x")]
            pub x: f64,
            #[doc = "Y coordinate"]
            #[serde(rename = "y")]
            pub y: f64,
            #[doc = "Rectangle width"]
            #[serde(rename = "width")]
            pub width: f64,
            #[doc = "Rectangle height"]
            #[serde(rename = "height")]
            pub height: f64,
        }
        impl Rect {
            pub fn new(
                x: impl Into<f64>,
                y: impl Into<f64>,
                width: impl Into<f64>,
                height: impl Into<f64>,
            ) -> Self {
                Self {
                    x: x.into(),
                    y: y.into(),
                    width: width.into(),
                    height: height.into(),
                }
            }
        }
        impl Rect {
            pub fn builder() -> RectBuilder {
                RectBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RectBuilder {
            x: Option<f64>,
            y: Option<f64>,
            width: Option<f64>,
            height: Option<f64>,
        }
        impl RectBuilder {
            pub fn x(mut self, x: impl Into<f64>) -> Self {
                self.x = Some(x.into());
                self
            }
            pub fn y(mut self, y: impl Into<f64>) -> Self {
                self.y = Some(y.into());
                self
            }
            pub fn width(mut self, width: impl Into<f64>) -> Self {
                self.width = Some(width.into());
                self
            }
            pub fn height(mut self, height: impl Into<f64>) -> Self {
                self.height = Some(height.into());
                self
            }
            pub fn build(self) -> Result<Rect, String> {
                Ok(Rect {
                    x: self
                        .x
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(x)))?,
                    y: self
                        .y
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(y)))?,
                    width: self.width.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(width))
                    })?,
                    height: self.height.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(height))
                    })?,
                })
            }
        }
        impl Rect {
            pub const IDENTIFIER: &'static str = "DOM.Rect";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CssComputedStyleProperty {
            #[doc = "Computed style property name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Computed style property value."]
            #[serde(rename = "value")]
            pub value: String,
        }
        impl CssComputedStyleProperty {
            pub fn new(name: impl Into<String>, value: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                }
            }
        }
        impl CssComputedStyleProperty {
            pub fn builder() -> CssComputedStylePropertyBuilder {
                CssComputedStylePropertyBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CssComputedStylePropertyBuilder {
            name: Option<String>,
            value: Option<String>,
        }
        impl CssComputedStylePropertyBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<CssComputedStyleProperty, String> {
                Ok(CssComputedStyleProperty {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl CssComputedStyleProperty {
            pub const IDENTIFIER: &'static str = "DOM.CSSComputedStyleProperty";
        }
        #[doc = "Collects class names for the node with given id and all of it's child nodes.\n[collectClassNamesFromSubtree](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-collectClassNamesFromSubtree)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CollectClassNamesFromSubtreeParams {
            #[doc = "Id of the node to collect class names."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl CollectClassNamesFromSubtreeParams {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl CollectClassNamesFromSubtreeParams {
            pub fn builder() -> CollectClassNamesFromSubtreeParamsBuilder {
                CollectClassNamesFromSubtreeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CollectClassNamesFromSubtreeParamsBuilder {
            node_id: Option<NodeId>,
        }
        impl CollectClassNamesFromSubtreeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<CollectClassNamesFromSubtreeParams, String> {
                Ok(CollectClassNamesFromSubtreeParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl CollectClassNamesFromSubtreeParams {
            pub const IDENTIFIER: &'static str = "DOM.collectClassNamesFromSubtree";
        }
        impl chromiumoxide_types::Method for CollectClassNamesFromSubtreeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CollectClassNamesFromSubtreeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Collects class names for the node with given id and all of it's child nodes.\n[collectClassNamesFromSubtree](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-collectClassNamesFromSubtree)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CollectClassNamesFromSubtreeReturns {
            #[doc = "Class name list."]
            #[serde(rename = "classNames")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub class_names: Vec<String>,
        }
        impl CollectClassNamesFromSubtreeReturns {
            pub fn new(class_names: Vec<String>) -> Self {
                Self { class_names }
            }
        }
        impl CollectClassNamesFromSubtreeReturns {
            pub fn builder() -> CollectClassNamesFromSubtreeReturnsBuilder {
                CollectClassNamesFromSubtreeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CollectClassNamesFromSubtreeReturnsBuilder {
            class_names: Option<Vec<String>>,
        }
        impl CollectClassNamesFromSubtreeReturnsBuilder {
            pub fn class_name(mut self, class_name: impl Into<String>) -> Self {
                let v = self.class_names.get_or_insert(Vec::new());
                v.push(class_name.into());
                self
            }
            pub fn class_names<I, S>(mut self, class_names: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.class_names.get_or_insert(Vec::new());
                for val in class_names {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<CollectClassNamesFromSubtreeReturns, String> {
                Ok(CollectClassNamesFromSubtreeReturns {
                    class_names: self.class_names.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(class_names))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for CollectClassNamesFromSubtreeParams {
            type Response = CollectClassNamesFromSubtreeReturns;
        }
        #[doc = "Creates a deep copy of the specified node and places it into the target container before the\ngiven anchor.\n[copyTo](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-copyTo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CopyToParams {
            #[doc = "Id of the node to copy."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "Id of the element to drop the copy into."]
            #[serde(rename = "targetNodeId")]
            pub target_node_id: NodeId,
            #[doc = "Drop the copy before this node (if absent, the copy becomes the last child of\n`targetNodeId`)."]
            #[serde(rename = "insertBeforeNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub insert_before_node_id: Option<NodeId>,
        }
        impl CopyToParams {
            pub fn new(node_id: impl Into<NodeId>, target_node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                    target_node_id: target_node_id.into(),
                    insert_before_node_id: None,
                }
            }
        }
        impl CopyToParams {
            pub fn builder() -> CopyToParamsBuilder {
                CopyToParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CopyToParamsBuilder {
            node_id: Option<NodeId>,
            target_node_id: Option<NodeId>,
            insert_before_node_id: Option<NodeId>,
        }
        impl CopyToParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn target_node_id(mut self, target_node_id: impl Into<NodeId>) -> Self {
                self.target_node_id = Some(target_node_id.into());
                self
            }
            pub fn insert_before_node_id(
                mut self,
                insert_before_node_id: impl Into<NodeId>,
            ) -> Self {
                self.insert_before_node_id = Some(insert_before_node_id.into());
                self
            }
            pub fn build(self) -> Result<CopyToParams, String> {
                Ok(CopyToParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    target_node_id: self.target_node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(target_node_id))
                    })?,
                    insert_before_node_id: self.insert_before_node_id,
                })
            }
        }
        impl CopyToParams {
            pub const IDENTIFIER: &'static str = "DOM.copyTo";
        }
        impl chromiumoxide_types::Method for CopyToParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CopyToParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Creates a deep copy of the specified node and places it into the target container before the\ngiven anchor.\n[copyTo](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-copyTo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CopyToReturns {
            #[doc = "Id of the node clone."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl CopyToReturns {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl CopyToReturns {
            pub fn builder() -> CopyToReturnsBuilder {
                CopyToReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CopyToReturnsBuilder {
            node_id: Option<NodeId>,
        }
        impl CopyToReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<CopyToReturns, String> {
                Ok(CopyToReturns {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for CopyToParams {
            type Response = CopyToReturns;
        }
        #[doc = "Describes node given its id, does not require domain to be enabled. Does not start tracking any\nobjects, can be used for automation.\n[describeNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-describeNode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DescribeNodeParams {
            #[doc = "Identifier of the node."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<NodeId>,
            #[doc = "Identifier of the backend node."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<BackendNodeId>,
            #[doc = "JavaScript object id of the node wrapper."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
            #[doc = "The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the\nentire subtree or provide an integer larger than 0."]
            #[serde(rename = "depth")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub depth: Option<i64>,
            #[doc = "Whether or not iframes and shadow roots should be traversed when returning the subtree\n(default is false)."]
            #[serde(rename = "pierce")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pierce: Option<bool>,
        }
        impl DescribeNodeParams {
            pub fn builder() -> DescribeNodeParamsBuilder {
                DescribeNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DescribeNodeParamsBuilder {
            node_id: Option<NodeId>,
            backend_node_id: Option<BackendNodeId>,
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
            depth: Option<i64>,
            pierce: Option<bool>,
        }
        impl DescribeNodeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn depth(mut self, depth: impl Into<i64>) -> Self {
                self.depth = Some(depth.into());
                self
            }
            pub fn pierce(mut self, pierce: impl Into<bool>) -> Self {
                self.pierce = Some(pierce.into());
                self
            }
            pub fn build(self) -> DescribeNodeParams {
                DescribeNodeParams {
                    node_id: self.node_id,
                    backend_node_id: self.backend_node_id,
                    object_id: self.object_id,
                    depth: self.depth,
                    pierce: self.pierce,
                }
            }
        }
        impl DescribeNodeParams {
            pub const IDENTIFIER: &'static str = "DOM.describeNode";
        }
        impl chromiumoxide_types::Method for DescribeNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DescribeNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Describes node given its id, does not require domain to be enabled. Does not start tracking any\nobjects, can be used for automation.\n[describeNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-describeNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DescribeNodeReturns {
            #[doc = "Node description."]
            #[serde(rename = "node")]
            pub node: Node,
        }
        impl DescribeNodeReturns {
            pub fn new(node: impl Into<Node>) -> Self {
                Self { node: node.into() }
            }
        }
        impl DescribeNodeReturns {
            pub fn builder() -> DescribeNodeReturnsBuilder {
                DescribeNodeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DescribeNodeReturnsBuilder {
            node: Option<Node>,
        }
        impl DescribeNodeReturnsBuilder {
            pub fn node(mut self, node: impl Into<Node>) -> Self {
                self.node = Some(node.into());
                self
            }
            pub fn build(self) -> Result<DescribeNodeReturns, String> {
                Ok(DescribeNodeReturns {
                    node: self.node.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for DescribeNodeParams {
            type Response = DescribeNodeReturns;
        }
        #[doc = "Scrolls the specified rect of the given node into view if not already visible.\nNote: exactly one between nodeId, backendNodeId and objectId should be passed\nto identify the node.\n[scrollIntoViewIfNeeded](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-scrollIntoViewIfNeeded)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ScrollIntoViewIfNeededParams {
            #[doc = "Identifier of the node."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<NodeId>,
            #[doc = "Identifier of the backend node."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<BackendNodeId>,
            #[doc = "JavaScript object id of the node wrapper."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
            #[doc = "The rect to be scrolled into view, relative to the node's border box, in CSS pixels.\nWhen omitted, center of the node will be used, similar to Element.scrollIntoView."]
            #[serde(rename = "rect")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub rect: Option<Rect>,
        }
        impl ScrollIntoViewIfNeededParams {
            pub fn builder() -> ScrollIntoViewIfNeededParamsBuilder {
                ScrollIntoViewIfNeededParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ScrollIntoViewIfNeededParamsBuilder {
            node_id: Option<NodeId>,
            backend_node_id: Option<BackendNodeId>,
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
            rect: Option<Rect>,
        }
        impl ScrollIntoViewIfNeededParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn rect(mut self, rect: impl Into<Rect>) -> Self {
                self.rect = Some(rect.into());
                self
            }
            pub fn build(self) -> ScrollIntoViewIfNeededParams {
                ScrollIntoViewIfNeededParams {
                    node_id: self.node_id,
                    backend_node_id: self.backend_node_id,
                    object_id: self.object_id,
                    rect: self.rect,
                }
            }
        }
        impl ScrollIntoViewIfNeededParams {
            pub const IDENTIFIER: &'static str = "DOM.scrollIntoViewIfNeeded";
        }
        impl chromiumoxide_types::Method for ScrollIntoViewIfNeededParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ScrollIntoViewIfNeededParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Scrolls the specified rect of the given node into view if not already visible.\nNote: exactly one between nodeId, backendNodeId and objectId should be passed\nto identify the node.\n[scrollIntoViewIfNeeded](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-scrollIntoViewIfNeeded)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ScrollIntoViewIfNeededReturns {}
        impl chromiumoxide_types::Command for ScrollIntoViewIfNeededParams {
            type Response = ScrollIntoViewIfNeededReturns;
        }
        #[doc = "Disables DOM agent for the given page.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "DOM.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables DOM agent for the given page.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Discards search results from the session with the given id. `getSearchResults` should no longer\nbe called for that search.\n[discardSearchResults](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-discardSearchResults)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DiscardSearchResultsParams {
            #[doc = "Unique search session identifier."]
            #[serde(rename = "searchId")]
            pub search_id: String,
        }
        impl DiscardSearchResultsParams {
            pub fn new(search_id: impl Into<String>) -> Self {
                Self {
                    search_id: search_id.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for DiscardSearchResultsParams {
            fn from(url: T) -> Self {
                DiscardSearchResultsParams::new(url)
            }
        }
        impl DiscardSearchResultsParams {
            pub fn builder() -> DiscardSearchResultsParamsBuilder {
                DiscardSearchResultsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DiscardSearchResultsParamsBuilder {
            search_id: Option<String>,
        }
        impl DiscardSearchResultsParamsBuilder {
            pub fn search_id(mut self, search_id: impl Into<String>) -> Self {
                self.search_id = Some(search_id.into());
                self
            }
            pub fn build(self) -> Result<DiscardSearchResultsParams, String> {
                Ok(DiscardSearchResultsParams {
                    search_id: self.search_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(search_id))
                    })?,
                })
            }
        }
        impl DiscardSearchResultsParams {
            pub const IDENTIFIER: &'static str = "DOM.discardSearchResults";
        }
        impl chromiumoxide_types::Method for DiscardSearchResultsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DiscardSearchResultsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Discards search results from the session with the given id. `getSearchResults` should no longer\nbe called for that search.\n[discardSearchResults](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-discardSearchResults)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DiscardSearchResultsReturns {}
        impl chromiumoxide_types::Command for DiscardSearchResultsParams {
            type Response = DiscardSearchResultsReturns;
        }
        #[doc = "Enables DOM agent for the given page.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {
            #[doc = "Whether to include whitespaces in the children array of returned Nodes."]
            #[serde(rename = "includeWhitespace")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub include_whitespace: Option<EnableIncludeWhitespace>,
        }
        #[doc = "Whether to include whitespaces in the children array of returned Nodes."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum EnableIncludeWhitespace {
            #[doc = "Strip whitespaces from child arrays (default)."]
            #[serde(rename = "none")]
            None,
            #[doc = "Return all children including block-level whitespace nodes."]
            #[serde(rename = "all")]
            All,
        }
        impl AsRef<str> for EnableIncludeWhitespace {
            fn as_ref(&self) -> &str {
                match self {
                    EnableIncludeWhitespace::None => "none",
                    EnableIncludeWhitespace::All => "all",
                }
            }
        }
        impl ::std::str::FromStr for EnableIncludeWhitespace {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "none" | "None" => Ok(EnableIncludeWhitespace::None),
                    "all" | "All" => Ok(EnableIncludeWhitespace::All),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl EnableParams {
            pub fn builder() -> EnableParamsBuilder {
                EnableParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EnableParamsBuilder {
            include_whitespace: Option<EnableIncludeWhitespace>,
        }
        impl EnableParamsBuilder {
            pub fn include_whitespace(
                mut self,
                include_whitespace: impl Into<EnableIncludeWhitespace>,
            ) -> Self {
                self.include_whitespace = Some(include_whitespace.into());
                self
            }
            pub fn build(self) -> EnableParams {
                EnableParams {
                    include_whitespace: self.include_whitespace,
                }
            }
        }
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "DOM.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables DOM agent for the given page.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Focuses the given element.\n[focus](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-focus)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct FocusParams {
            #[doc = "Identifier of the node."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<NodeId>,
            #[doc = "Identifier of the backend node."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<BackendNodeId>,
            #[doc = "JavaScript object id of the node wrapper."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl FocusParams {
            pub fn builder() -> FocusParamsBuilder {
                FocusParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FocusParamsBuilder {
            node_id: Option<NodeId>,
            backend_node_id: Option<BackendNodeId>,
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl FocusParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> FocusParams {
                FocusParams {
                    node_id: self.node_id,
                    backend_node_id: self.backend_node_id,
                    object_id: self.object_id,
                }
            }
        }
        impl FocusParams {
            pub const IDENTIFIER: &'static str = "DOM.focus";
        }
        impl chromiumoxide_types::Method for FocusParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for FocusParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Focuses the given element.\n[focus](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-focus)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct FocusReturns {}
        impl chromiumoxide_types::Command for FocusParams {
            type Response = FocusReturns;
        }
        #[doc = "Returns attributes for the specified node.\n[getAttributes](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getAttributes)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetAttributesParams {
            #[doc = "Id of the node to retrieve attibutes for."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl GetAttributesParams {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl GetAttributesParams {
            pub fn builder() -> GetAttributesParamsBuilder {
                GetAttributesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetAttributesParamsBuilder {
            node_id: Option<NodeId>,
        }
        impl GetAttributesParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetAttributesParams, String> {
                Ok(GetAttributesParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl GetAttributesParams {
            pub const IDENTIFIER: &'static str = "DOM.getAttributes";
        }
        impl chromiumoxide_types::Method for GetAttributesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetAttributesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns attributes for the specified node.\n[getAttributes](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getAttributes)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetAttributesReturns {
            #[doc = "An interleaved array of node attribute names and values."]
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub attributes: Vec<String>,
        }
        impl GetAttributesReturns {
            pub fn new(attributes: Vec<String>) -> Self {
                Self { attributes }
            }
        }
        impl GetAttributesReturns {
            pub fn builder() -> GetAttributesReturnsBuilder {
                GetAttributesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetAttributesReturnsBuilder {
            attributes: Option<Vec<String>>,
        }
        impl GetAttributesReturnsBuilder {
            pub fn attribute(mut self, attribute: impl Into<String>) -> Self {
                let v = self.attributes.get_or_insert(Vec::new());
                v.push(attribute.into());
                self
            }
            pub fn attributes<I, S>(mut self, attributes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.attributes.get_or_insert(Vec::new());
                for val in attributes {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetAttributesReturns, String> {
                Ok(GetAttributesReturns {
                    attributes: self.attributes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(attributes))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetAttributesParams {
            type Response = GetAttributesReturns;
        }
        #[doc = "Returns boxes for the given node.\n[getBoxModel](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getBoxModel)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetBoxModelParams {
            #[doc = "Identifier of the node."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<NodeId>,
            #[doc = "Identifier of the backend node."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<BackendNodeId>,
            #[doc = "JavaScript object id of the node wrapper."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl GetBoxModelParams {
            pub fn builder() -> GetBoxModelParamsBuilder {
                GetBoxModelParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetBoxModelParamsBuilder {
            node_id: Option<NodeId>,
            backend_node_id: Option<BackendNodeId>,
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl GetBoxModelParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> GetBoxModelParams {
                GetBoxModelParams {
                    node_id: self.node_id,
                    backend_node_id: self.backend_node_id,
                    object_id: self.object_id,
                }
            }
        }
        impl GetBoxModelParams {
            pub const IDENTIFIER: &'static str = "DOM.getBoxModel";
        }
        impl chromiumoxide_types::Method for GetBoxModelParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetBoxModelParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns boxes for the given node.\n[getBoxModel](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getBoxModel)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetBoxModelReturns {
            #[doc = "Box model for the node."]
            #[serde(rename = "model")]
            pub model: BoxModel,
        }
        impl GetBoxModelReturns {
            pub fn new(model: impl Into<BoxModel>) -> Self {
                Self {
                    model: model.into(),
                }
            }
        }
        impl GetBoxModelReturns {
            pub fn builder() -> GetBoxModelReturnsBuilder {
                GetBoxModelReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetBoxModelReturnsBuilder {
            model: Option<BoxModel>,
        }
        impl GetBoxModelReturnsBuilder {
            pub fn model(mut self, model: impl Into<BoxModel>) -> Self {
                self.model = Some(model.into());
                self
            }
            pub fn build(self) -> Result<GetBoxModelReturns, String> {
                Ok(GetBoxModelReturns {
                    model: self.model.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(model))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetBoxModelParams {
            type Response = GetBoxModelReturns;
        }
        #[doc = "Returns quads that describe node position on the page. This method\nmight return multiple quads for inline nodes.\n[getContentQuads](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getContentQuads)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetContentQuadsParams {
            #[doc = "Identifier of the node."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<NodeId>,
            #[doc = "Identifier of the backend node."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<BackendNodeId>,
            #[doc = "JavaScript object id of the node wrapper."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl GetContentQuadsParams {
            pub fn builder() -> GetContentQuadsParamsBuilder {
                GetContentQuadsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetContentQuadsParamsBuilder {
            node_id: Option<NodeId>,
            backend_node_id: Option<BackendNodeId>,
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl GetContentQuadsParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> GetContentQuadsParams {
                GetContentQuadsParams {
                    node_id: self.node_id,
                    backend_node_id: self.backend_node_id,
                    object_id: self.object_id,
                }
            }
        }
        impl GetContentQuadsParams {
            pub const IDENTIFIER: &'static str = "DOM.getContentQuads";
        }
        impl chromiumoxide_types::Method for GetContentQuadsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetContentQuadsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns quads that describe node position on the page. This method\nmight return multiple quads for inline nodes.\n[getContentQuads](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getContentQuads)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetContentQuadsReturns {
            #[doc = "Quads that describe node layout relative to viewport."]
            #[serde(rename = "quads")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub quads: Vec<Quad>,
        }
        impl GetContentQuadsReturns {
            pub fn new(quads: Vec<Quad>) -> Self {
                Self { quads }
            }
        }
        impl GetContentQuadsReturns {
            pub fn builder() -> GetContentQuadsReturnsBuilder {
                GetContentQuadsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetContentQuadsReturnsBuilder {
            quads: Option<Vec<Quad>>,
        }
        impl GetContentQuadsReturnsBuilder {
            pub fn quad(mut self, quad: impl Into<Quad>) -> Self {
                let v = self.quads.get_or_insert(Vec::new());
                v.push(quad.into());
                self
            }
            pub fn quads<I, S>(mut self, quads: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Quad>,
            {
                let v = self.quads.get_or_insert(Vec::new());
                for val in quads {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetContentQuadsReturns, String> {
                Ok(GetContentQuadsReturns {
                    quads: self.quads.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(quads))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetContentQuadsParams {
            type Response = GetContentQuadsReturns;
        }
        #[doc = "Returns the root DOM node (and optionally the subtree) to the caller.\n[getDocument](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getDocument)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetDocumentParams {
            #[doc = "The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the\nentire subtree or provide an integer larger than 0."]
            #[serde(rename = "depth")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub depth: Option<i64>,
            #[doc = "Whether or not iframes and shadow roots should be traversed when returning the subtree\n(default is false)."]
            #[serde(rename = "pierce")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pierce: Option<bool>,
        }
        impl GetDocumentParams {
            pub fn builder() -> GetDocumentParamsBuilder {
                GetDocumentParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetDocumentParamsBuilder {
            depth: Option<i64>,
            pierce: Option<bool>,
        }
        impl GetDocumentParamsBuilder {
            pub fn depth(mut self, depth: impl Into<i64>) -> Self {
                self.depth = Some(depth.into());
                self
            }
            pub fn pierce(mut self, pierce: impl Into<bool>) -> Self {
                self.pierce = Some(pierce.into());
                self
            }
            pub fn build(self) -> GetDocumentParams {
                GetDocumentParams {
                    depth: self.depth,
                    pierce: self.pierce,
                }
            }
        }
        impl GetDocumentParams {
            pub const IDENTIFIER: &'static str = "DOM.getDocument";
        }
        impl chromiumoxide_types::Method for GetDocumentParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetDocumentParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the root DOM node (and optionally the subtree) to the caller.\n[getDocument](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getDocument)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetDocumentReturns {
            #[doc = "Resulting node."]
            #[serde(rename = "root")]
            pub root: Node,
        }
        impl GetDocumentReturns {
            pub fn new(root: impl Into<Node>) -> Self {
                Self { root: root.into() }
            }
        }
        impl GetDocumentReturns {
            pub fn builder() -> GetDocumentReturnsBuilder {
                GetDocumentReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetDocumentReturnsBuilder {
            root: Option<Node>,
        }
        impl GetDocumentReturnsBuilder {
            pub fn root(mut self, root: impl Into<Node>) -> Self {
                self.root = Some(root.into());
                self
            }
            pub fn build(self) -> Result<GetDocumentReturns, String> {
                Ok(GetDocumentReturns {
                    root: self.root.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(root))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetDocumentParams {
            type Response = GetDocumentReturns;
        }
        #[doc = "Finds nodes with a given computed style in a subtree.\n[getNodesForSubtreeByStyle](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getNodesForSubtreeByStyle)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetNodesForSubtreeByStyleParams {
            #[doc = "Node ID pointing to the root of a subtree."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "The style to filter nodes by (includes nodes if any of properties matches)."]
            #[serde(rename = "computedStyles")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub computed_styles: Vec<CssComputedStyleProperty>,
            #[doc = "Whether or not iframes and shadow roots in the same target should be traversed when returning the\nresults (default is false)."]
            #[serde(rename = "pierce")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pierce: Option<bool>,
        }
        impl GetNodesForSubtreeByStyleParams {
            pub fn new(
                node_id: impl Into<NodeId>,
                computed_styles: Vec<CssComputedStyleProperty>,
            ) -> Self {
                Self {
                    node_id: node_id.into(),
                    computed_styles,
                    pierce: None,
                }
            }
        }
        impl GetNodesForSubtreeByStyleParams {
            pub fn builder() -> GetNodesForSubtreeByStyleParamsBuilder {
                GetNodesForSubtreeByStyleParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetNodesForSubtreeByStyleParamsBuilder {
            node_id: Option<NodeId>,
            computed_styles: Option<Vec<CssComputedStyleProperty>>,
            pierce: Option<bool>,
        }
        impl GetNodesForSubtreeByStyleParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn computed_style(
                mut self,
                computed_style: impl Into<CssComputedStyleProperty>,
            ) -> Self {
                let v = self.computed_styles.get_or_insert(Vec::new());
                v.push(computed_style.into());
                self
            }
            pub fn computed_styles<I, S>(mut self, computed_styles: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CssComputedStyleProperty>,
            {
                let v = self.computed_styles.get_or_insert(Vec::new());
                for val in computed_styles {
                    v.push(val.into());
                }
                self
            }
            pub fn pierce(mut self, pierce: impl Into<bool>) -> Self {
                self.pierce = Some(pierce.into());
                self
            }
            pub fn build(self) -> Result<GetNodesForSubtreeByStyleParams, String> {
                Ok(GetNodesForSubtreeByStyleParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    computed_styles: self.computed_styles.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(computed_styles))
                    })?,
                    pierce: self.pierce,
                })
            }
        }
        impl GetNodesForSubtreeByStyleParams {
            pub const IDENTIFIER: &'static str = "DOM.getNodesForSubtreeByStyle";
        }
        impl chromiumoxide_types::Method for GetNodesForSubtreeByStyleParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetNodesForSubtreeByStyleParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Finds nodes with a given computed style in a subtree.\n[getNodesForSubtreeByStyle](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getNodesForSubtreeByStyle)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetNodesForSubtreeByStyleReturns {
            #[doc = "Resulting nodes."]
            #[serde(rename = "nodeIds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub node_ids: Vec<NodeId>,
        }
        impl GetNodesForSubtreeByStyleReturns {
            pub fn new(node_ids: Vec<NodeId>) -> Self {
                Self { node_ids }
            }
        }
        impl GetNodesForSubtreeByStyleReturns {
            pub fn builder() -> GetNodesForSubtreeByStyleReturnsBuilder {
                GetNodesForSubtreeByStyleReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetNodesForSubtreeByStyleReturnsBuilder {
            node_ids: Option<Vec<NodeId>>,
        }
        impl GetNodesForSubtreeByStyleReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                let v = self.node_ids.get_or_insert(Vec::new());
                v.push(node_id.into());
                self
            }
            pub fn node_ids<I, S>(mut self, node_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<NodeId>,
            {
                let v = self.node_ids.get_or_insert(Vec::new());
                for val in node_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetNodesForSubtreeByStyleReturns, String> {
                Ok(GetNodesForSubtreeByStyleReturns {
                    node_ids: self.node_ids.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_ids))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetNodesForSubtreeByStyleParams {
            type Response = GetNodesForSubtreeByStyleReturns;
        }
        #[doc = "Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is\neither returned or not.\n[getNodeForLocation](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getNodeForLocation)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetNodeForLocationParams {
            #[doc = "X coordinate."]
            #[serde(rename = "x")]
            pub x: i64,
            #[doc = "Y coordinate."]
            #[serde(rename = "y")]
            pub y: i64,
            #[doc = "False to skip to the nearest non-UA shadow root ancestor (default: false)."]
            #[serde(rename = "includeUserAgentShadowDOM")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub include_user_agent_shadow_dom: Option<bool>,
            #[doc = "Whether to ignore pointer-events: none on elements and hit test them."]
            #[serde(rename = "ignorePointerEventsNone")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub ignore_pointer_events_none: Option<bool>,
        }
        impl GetNodeForLocationParams {
            pub fn new(x: impl Into<i64>, y: impl Into<i64>) -> Self {
                Self {
                    x: x.into(),
                    y: y.into(),
                    include_user_agent_shadow_dom: None,
                    ignore_pointer_events_none: None,
                }
            }
        }
        impl GetNodeForLocationParams {
            pub fn builder() -> GetNodeForLocationParamsBuilder {
                GetNodeForLocationParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetNodeForLocationParamsBuilder {
            x: Option<i64>,
            y: Option<i64>,
            include_user_agent_shadow_dom: Option<bool>,
            ignore_pointer_events_none: Option<bool>,
        }
        impl GetNodeForLocationParamsBuilder {
            pub fn x(mut self, x: impl Into<i64>) -> Self {
                self.x = Some(x.into());
                self
            }
            pub fn y(mut self, y: impl Into<i64>) -> Self {
                self.y = Some(y.into());
                self
            }
            pub fn include_user_agent_shadow_dom(
                mut self,
                include_user_agent_shadow_dom: impl Into<bool>,
            ) -> Self {
                self.include_user_agent_shadow_dom = Some(include_user_agent_shadow_dom.into());
                self
            }
            pub fn ignore_pointer_events_none(
                mut self,
                ignore_pointer_events_none: impl Into<bool>,
            ) -> Self {
                self.ignore_pointer_events_none = Some(ignore_pointer_events_none.into());
                self
            }
            pub fn build(self) -> Result<GetNodeForLocationParams, String> {
                Ok(GetNodeForLocationParams {
                    x: self
                        .x
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(x)))?,
                    y: self
                        .y
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(y)))?,
                    include_user_agent_shadow_dom: self.include_user_agent_shadow_dom,
                    ignore_pointer_events_none: self.ignore_pointer_events_none,
                })
            }
        }
        impl GetNodeForLocationParams {
            pub const IDENTIFIER: &'static str = "DOM.getNodeForLocation";
        }
        impl chromiumoxide_types::Method for GetNodeForLocationParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetNodeForLocationParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is\neither returned or not.\n[getNodeForLocation](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getNodeForLocation)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetNodeForLocationReturns {
            #[doc = "Resulting node."]
            #[serde(rename = "backendNodeId")]
            pub backend_node_id: BackendNodeId,
            #[doc = "Frame this node belongs to."]
            #[serde(rename = "frameId")]
            pub frame_id: super::page::FrameId,
            #[doc = "Id of the node at given coordinates, only when enabled and requested document."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<NodeId>,
        }
        impl GetNodeForLocationReturns {
            pub fn new(
                backend_node_id: impl Into<BackendNodeId>,
                frame_id: impl Into<super::page::FrameId>,
            ) -> Self {
                Self {
                    backend_node_id: backend_node_id.into(),
                    frame_id: frame_id.into(),
                    node_id: None,
                }
            }
        }
        impl GetNodeForLocationReturns {
            pub fn builder() -> GetNodeForLocationReturnsBuilder {
                GetNodeForLocationReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetNodeForLocationReturnsBuilder {
            backend_node_id: Option<BackendNodeId>,
            frame_id: Option<super::page::FrameId>,
            node_id: Option<NodeId>,
        }
        impl GetNodeForLocationReturnsBuilder {
            pub fn backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetNodeForLocationReturns, String> {
                Ok(GetNodeForLocationReturns {
                    backend_node_id: self.backend_node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(backend_node_id))
                    })?,
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                    node_id: self.node_id,
                })
            }
        }
        impl chromiumoxide_types::Command for GetNodeForLocationParams {
            type Response = GetNodeForLocationReturns;
        }
        #[doc = "Returns node's HTML markup.\n[getOuterHTML](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getOuterHTML)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetOuterHtmlParams {
            #[doc = "Identifier of the node."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<NodeId>,
            #[doc = "Identifier of the backend node."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<BackendNodeId>,
            #[doc = "JavaScript object id of the node wrapper."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl GetOuterHtmlParams {
            pub fn builder() -> GetOuterHtmlParamsBuilder {
                GetOuterHtmlParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetOuterHtmlParamsBuilder {
            node_id: Option<NodeId>,
            backend_node_id: Option<BackendNodeId>,
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl GetOuterHtmlParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> GetOuterHtmlParams {
                GetOuterHtmlParams {
                    node_id: self.node_id,
                    backend_node_id: self.backend_node_id,
                    object_id: self.object_id,
                }
            }
        }
        impl GetOuterHtmlParams {
            pub const IDENTIFIER: &'static str = "DOM.getOuterHTML";
        }
        impl chromiumoxide_types::Method for GetOuterHtmlParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetOuterHtmlParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns node's HTML markup.\n[getOuterHTML](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getOuterHTML)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetOuterHtmlReturns {
            #[doc = "Outer HTML markup."]
            #[serde(rename = "outerHTML")]
            pub outer_html: String,
        }
        impl GetOuterHtmlReturns {
            pub fn new(outer_html: impl Into<String>) -> Self {
                Self {
                    outer_html: outer_html.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for GetOuterHtmlReturns {
            fn from(url: T) -> Self {
                GetOuterHtmlReturns::new(url)
            }
        }
        impl GetOuterHtmlReturns {
            pub fn builder() -> GetOuterHtmlReturnsBuilder {
                GetOuterHtmlReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetOuterHtmlReturnsBuilder {
            outer_html: Option<String>,
        }
        impl GetOuterHtmlReturnsBuilder {
            pub fn outer_html(mut self, outer_html: impl Into<String>) -> Self {
                self.outer_html = Some(outer_html.into());
                self
            }
            pub fn build(self) -> Result<GetOuterHtmlReturns, String> {
                Ok(GetOuterHtmlReturns {
                    outer_html: self.outer_html.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(outer_html))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetOuterHtmlParams {
            type Response = GetOuterHtmlReturns;
        }
        #[doc = "Returns the id of the nearest ancestor that is a relayout boundary.\n[getRelayoutBoundary](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getRelayoutBoundary)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetRelayoutBoundaryParams {
            #[doc = "Id of the node."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl GetRelayoutBoundaryParams {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl GetRelayoutBoundaryParams {
            pub fn builder() -> GetRelayoutBoundaryParamsBuilder {
                GetRelayoutBoundaryParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetRelayoutBoundaryParamsBuilder {
            node_id: Option<NodeId>,
        }
        impl GetRelayoutBoundaryParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetRelayoutBoundaryParams, String> {
                Ok(GetRelayoutBoundaryParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl GetRelayoutBoundaryParams {
            pub const IDENTIFIER: &'static str = "DOM.getRelayoutBoundary";
        }
        impl chromiumoxide_types::Method for GetRelayoutBoundaryParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetRelayoutBoundaryParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the id of the nearest ancestor that is a relayout boundary.\n[getRelayoutBoundary](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getRelayoutBoundary)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetRelayoutBoundaryReturns {
            #[doc = "Relayout boundary node id for the given node."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl GetRelayoutBoundaryReturns {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl GetRelayoutBoundaryReturns {
            pub fn builder() -> GetRelayoutBoundaryReturnsBuilder {
                GetRelayoutBoundaryReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetRelayoutBoundaryReturnsBuilder {
            node_id: Option<NodeId>,
        }
        impl GetRelayoutBoundaryReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetRelayoutBoundaryReturns, String> {
                Ok(GetRelayoutBoundaryReturns {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetRelayoutBoundaryParams {
            type Response = GetRelayoutBoundaryReturns;
        }
        #[doc = "Returns search results from given `fromIndex` to given `toIndex` from the search with the given\nidentifier.\n[getSearchResults](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getSearchResults)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetSearchResultsParams {
            #[doc = "Unique search session identifier."]
            #[serde(rename = "searchId")]
            pub search_id: String,
            #[doc = "Start index of the search result to be returned."]
            #[serde(rename = "fromIndex")]
            pub from_index: i64,
            #[doc = "End index of the search result to be returned."]
            #[serde(rename = "toIndex")]
            pub to_index: i64,
        }
        impl GetSearchResultsParams {
            pub fn new(
                search_id: impl Into<String>,
                from_index: impl Into<i64>,
                to_index: impl Into<i64>,
            ) -> Self {
                Self {
                    search_id: search_id.into(),
                    from_index: from_index.into(),
                    to_index: to_index.into(),
                }
            }
        }
        impl GetSearchResultsParams {
            pub fn builder() -> GetSearchResultsParamsBuilder {
                GetSearchResultsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetSearchResultsParamsBuilder {
            search_id: Option<String>,
            from_index: Option<i64>,
            to_index: Option<i64>,
        }
        impl GetSearchResultsParamsBuilder {
            pub fn search_id(mut self, search_id: impl Into<String>) -> Self {
                self.search_id = Some(search_id.into());
                self
            }
            pub fn from_index(mut self, from_index: impl Into<i64>) -> Self {
                self.from_index = Some(from_index.into());
                self
            }
            pub fn to_index(mut self, to_index: impl Into<i64>) -> Self {
                self.to_index = Some(to_index.into());
                self
            }
            pub fn build(self) -> Result<GetSearchResultsParams, String> {
                Ok(GetSearchResultsParams {
                    search_id: self.search_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(search_id))
                    })?,
                    from_index: self.from_index.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(from_index))
                    })?,
                    to_index: self.to_index.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(to_index))
                    })?,
                })
            }
        }
        impl GetSearchResultsParams {
            pub const IDENTIFIER: &'static str = "DOM.getSearchResults";
        }
        impl chromiumoxide_types::Method for GetSearchResultsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetSearchResultsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns search results from given `fromIndex` to given `toIndex` from the search with the given\nidentifier.\n[getSearchResults](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getSearchResults)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetSearchResultsReturns {
            #[doc = "Ids of the search result nodes."]
            #[serde(rename = "nodeIds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub node_ids: Vec<NodeId>,
        }
        impl GetSearchResultsReturns {
            pub fn new(node_ids: Vec<NodeId>) -> Self {
                Self { node_ids }
            }
        }
        impl GetSearchResultsReturns {
            pub fn builder() -> GetSearchResultsReturnsBuilder {
                GetSearchResultsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetSearchResultsReturnsBuilder {
            node_ids: Option<Vec<NodeId>>,
        }
        impl GetSearchResultsReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                let v = self.node_ids.get_or_insert(Vec::new());
                v.push(node_id.into());
                self
            }
            pub fn node_ids<I, S>(mut self, node_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<NodeId>,
            {
                let v = self.node_ids.get_or_insert(Vec::new());
                for val in node_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetSearchResultsReturns, String> {
                Ok(GetSearchResultsReturns {
                    node_ids: self.node_ids.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_ids))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetSearchResultsParams {
            type Response = GetSearchResultsReturns;
        }
        #[doc = "Hides any highlight.\n[hideHighlight](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-hideHighlight)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HideHighlightParams {}
        impl HideHighlightParams {
            pub const IDENTIFIER: &'static str = "DOM.hideHighlight";
        }
        impl chromiumoxide_types::Method for HideHighlightParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for HideHighlightParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Hides any highlight.\n[hideHighlight](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-hideHighlight)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HideHighlightReturns {}
        impl chromiumoxide_types::Command for HideHighlightParams {
            type Response = HideHighlightReturns;
        }
        #[doc = "Highlights DOM node.\n[highlightNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-highlightNode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HighlightNodeParams {}
        impl HighlightNodeParams {
            pub const IDENTIFIER: &'static str = "DOM.highlightNode";
        }
        impl chromiumoxide_types::Method for HighlightNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for HighlightNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Highlights DOM node.\n[highlightNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-highlightNode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HighlightNodeReturns {}
        impl chromiumoxide_types::Command for HighlightNodeParams {
            type Response = HighlightNodeReturns;
        }
        #[doc = "Highlights given rectangle.\n[highlightRect](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-highlightRect)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HighlightRectParams {}
        impl HighlightRectParams {
            pub const IDENTIFIER: &'static str = "DOM.highlightRect";
        }
        impl chromiumoxide_types::Method for HighlightRectParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for HighlightRectParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Highlights given rectangle.\n[highlightRect](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-highlightRect)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HighlightRectReturns {}
        impl chromiumoxide_types::Command for HighlightRectParams {
            type Response = HighlightRectReturns;
        }
        #[doc = "Marks last undoable state.\n[markUndoableState](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-markUndoableState)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct MarkUndoableStateParams {}
        impl MarkUndoableStateParams {
            pub const IDENTIFIER: &'static str = "DOM.markUndoableState";
        }
        impl chromiumoxide_types::Method for MarkUndoableStateParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for MarkUndoableStateParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Marks last undoable state.\n[markUndoableState](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-markUndoableState)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct MarkUndoableStateReturns {}
        impl chromiumoxide_types::Command for MarkUndoableStateParams {
            type Response = MarkUndoableStateReturns;
        }
        #[doc = "Moves node into the new container, places it before the given anchor.\n[moveTo](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-moveTo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct MoveToParams {
            #[doc = "Id of the node to move."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "Id of the element to drop the moved node into."]
            #[serde(rename = "targetNodeId")]
            pub target_node_id: NodeId,
            #[doc = "Drop node before this one (if absent, the moved node becomes the last child of\n`targetNodeId`)."]
            #[serde(rename = "insertBeforeNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub insert_before_node_id: Option<NodeId>,
        }
        impl MoveToParams {
            pub fn new(node_id: impl Into<NodeId>, target_node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                    target_node_id: target_node_id.into(),
                    insert_before_node_id: None,
                }
            }
        }
        impl MoveToParams {
            pub fn builder() -> MoveToParamsBuilder {
                MoveToParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct MoveToParamsBuilder {
            node_id: Option<NodeId>,
            target_node_id: Option<NodeId>,
            insert_before_node_id: Option<NodeId>,
        }
        impl MoveToParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn target_node_id(mut self, target_node_id: impl Into<NodeId>) -> Self {
                self.target_node_id = Some(target_node_id.into());
                self
            }
            pub fn insert_before_node_id(
                mut self,
                insert_before_node_id: impl Into<NodeId>,
            ) -> Self {
                self.insert_before_node_id = Some(insert_before_node_id.into());
                self
            }
            pub fn build(self) -> Result<MoveToParams, String> {
                Ok(MoveToParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    target_node_id: self.target_node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(target_node_id))
                    })?,
                    insert_before_node_id: self.insert_before_node_id,
                })
            }
        }
        impl MoveToParams {
            pub const IDENTIFIER: &'static str = "DOM.moveTo";
        }
        impl chromiumoxide_types::Method for MoveToParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for MoveToParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Moves node into the new container, places it before the given anchor.\n[moveTo](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-moveTo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct MoveToReturns {
            #[doc = "New id of the moved node."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl MoveToReturns {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl MoveToReturns {
            pub fn builder() -> MoveToReturnsBuilder {
                MoveToReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct MoveToReturnsBuilder {
            node_id: Option<NodeId>,
        }
        impl MoveToReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<MoveToReturns, String> {
                Ok(MoveToReturns {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for MoveToParams {
            type Response = MoveToReturns;
        }
        #[doc = "Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or\n`cancelSearch` to end this search session.\n[performSearch](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-performSearch)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PerformSearchParams {
            #[doc = "Plain text or query selector or XPath search query."]
            #[serde(rename = "query")]
            pub query: String,
            #[doc = "True to search in user agent shadow DOM."]
            #[serde(rename = "includeUserAgentShadowDOM")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub include_user_agent_shadow_dom: Option<bool>,
        }
        impl PerformSearchParams {
            pub fn new(query: impl Into<String>) -> Self {
                Self {
                    query: query.into(),
                    include_user_agent_shadow_dom: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for PerformSearchParams {
            fn from(url: T) -> Self {
                PerformSearchParams::new(url)
            }
        }
        impl PerformSearchParams {
            pub fn builder() -> PerformSearchParamsBuilder {
                PerformSearchParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PerformSearchParamsBuilder {
            query: Option<String>,
            include_user_agent_shadow_dom: Option<bool>,
        }
        impl PerformSearchParamsBuilder {
            pub fn query(mut self, query: impl Into<String>) -> Self {
                self.query = Some(query.into());
                self
            }
            pub fn include_user_agent_shadow_dom(
                mut self,
                include_user_agent_shadow_dom: impl Into<bool>,
            ) -> Self {
                self.include_user_agent_shadow_dom = Some(include_user_agent_shadow_dom.into());
                self
            }
            pub fn build(self) -> Result<PerformSearchParams, String> {
                Ok(PerformSearchParams {
                    query: self.query.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(query))
                    })?,
                    include_user_agent_shadow_dom: self.include_user_agent_shadow_dom,
                })
            }
        }
        impl PerformSearchParams {
            pub const IDENTIFIER: &'static str = "DOM.performSearch";
        }
        impl chromiumoxide_types::Method for PerformSearchParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for PerformSearchParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or\n`cancelSearch` to end this search session.\n[performSearch](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-performSearch)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PerformSearchReturns {
            #[doc = "Unique search session identifier."]
            #[serde(rename = "searchId")]
            pub search_id: String,
            #[doc = "Number of search results."]
            #[serde(rename = "resultCount")]
            pub result_count: i64,
        }
        impl PerformSearchReturns {
            pub fn new(search_id: impl Into<String>, result_count: impl Into<i64>) -> Self {
                Self {
                    search_id: search_id.into(),
                    result_count: result_count.into(),
                }
            }
        }
        impl PerformSearchReturns {
            pub fn builder() -> PerformSearchReturnsBuilder {
                PerformSearchReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PerformSearchReturnsBuilder {
            search_id: Option<String>,
            result_count: Option<i64>,
        }
        impl PerformSearchReturnsBuilder {
            pub fn search_id(mut self, search_id: impl Into<String>) -> Self {
                self.search_id = Some(search_id.into());
                self
            }
            pub fn result_count(mut self, result_count: impl Into<i64>) -> Self {
                self.result_count = Some(result_count.into());
                self
            }
            pub fn build(self) -> Result<PerformSearchReturns, String> {
                Ok(PerformSearchReturns {
                    search_id: self.search_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(search_id))
                    })?,
                    result_count: self.result_count.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result_count))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for PerformSearchParams {
            type Response = PerformSearchReturns;
        }
        #[doc = "Requests that the node is sent to the caller given its path. // FIXME, use XPath\n[pushNodeByPathToFrontend](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-pushNodeByPathToFrontend)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PushNodeByPathToFrontendParams {
            #[doc = "Path to node in the proprietary format."]
            #[serde(rename = "path")]
            pub path: String,
        }
        impl PushNodeByPathToFrontendParams {
            pub fn new(path: impl Into<String>) -> Self {
                Self { path: path.into() }
            }
        }
        impl<T: Into<String>> From<T> for PushNodeByPathToFrontendParams {
            fn from(url: T) -> Self {
                PushNodeByPathToFrontendParams::new(url)
            }
        }
        impl PushNodeByPathToFrontendParams {
            pub fn builder() -> PushNodeByPathToFrontendParamsBuilder {
                PushNodeByPathToFrontendParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PushNodeByPathToFrontendParamsBuilder {
            path: Option<String>,
        }
        impl PushNodeByPathToFrontendParamsBuilder {
            pub fn path(mut self, path: impl Into<String>) -> Self {
                self.path = Some(path.into());
                self
            }
            pub fn build(self) -> Result<PushNodeByPathToFrontendParams, String> {
                Ok(PushNodeByPathToFrontendParams {
                    path: self.path.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(path))
                    })?,
                })
            }
        }
        impl PushNodeByPathToFrontendParams {
            pub const IDENTIFIER: &'static str = "DOM.pushNodeByPathToFrontend";
        }
        impl chromiumoxide_types::Method for PushNodeByPathToFrontendParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for PushNodeByPathToFrontendParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests that the node is sent to the caller given its path. // FIXME, use XPath\n[pushNodeByPathToFrontend](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-pushNodeByPathToFrontend)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PushNodeByPathToFrontendReturns {
            #[doc = "Id of the node for given path."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl PushNodeByPathToFrontendReturns {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl PushNodeByPathToFrontendReturns {
            pub fn builder() -> PushNodeByPathToFrontendReturnsBuilder {
                PushNodeByPathToFrontendReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PushNodeByPathToFrontendReturnsBuilder {
            node_id: Option<NodeId>,
        }
        impl PushNodeByPathToFrontendReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<PushNodeByPathToFrontendReturns, String> {
                Ok(PushNodeByPathToFrontendReturns {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for PushNodeByPathToFrontendParams {
            type Response = PushNodeByPathToFrontendReturns;
        }
        #[doc = "Requests that a batch of nodes is sent to the caller given their backend node ids.\n[pushNodesByBackendIdsToFrontend](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-pushNodesByBackendIdsToFrontend)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PushNodesByBackendIdsToFrontendParams {
            #[doc = "The array of backend node ids."]
            #[serde(rename = "backendNodeIds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub backend_node_ids: Vec<BackendNodeId>,
        }
        impl PushNodesByBackendIdsToFrontendParams {
            pub fn new(backend_node_ids: Vec<BackendNodeId>) -> Self {
                Self { backend_node_ids }
            }
        }
        impl PushNodesByBackendIdsToFrontendParams {
            pub fn builder() -> PushNodesByBackendIdsToFrontendParamsBuilder {
                PushNodesByBackendIdsToFrontendParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PushNodesByBackendIdsToFrontendParamsBuilder {
            backend_node_ids: Option<Vec<BackendNodeId>>,
        }
        impl PushNodesByBackendIdsToFrontendParamsBuilder {
            pub fn backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
                let v = self.backend_node_ids.get_or_insert(Vec::new());
                v.push(backend_node_id.into());
                self
            }
            pub fn backend_node_ids<I, S>(mut self, backend_node_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<BackendNodeId>,
            {
                let v = self.backend_node_ids.get_or_insert(Vec::new());
                for val in backend_node_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<PushNodesByBackendIdsToFrontendParams, String> {
                Ok(PushNodesByBackendIdsToFrontendParams {
                    backend_node_ids: self.backend_node_ids.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(backend_node_ids)
                        )
                    })?,
                })
            }
        }
        impl PushNodesByBackendIdsToFrontendParams {
            pub const IDENTIFIER: &'static str = "DOM.pushNodesByBackendIdsToFrontend";
        }
        impl chromiumoxide_types::Method for PushNodesByBackendIdsToFrontendParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for PushNodesByBackendIdsToFrontendParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests that a batch of nodes is sent to the caller given their backend node ids.\n[pushNodesByBackendIdsToFrontend](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-pushNodesByBackendIdsToFrontend)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PushNodesByBackendIdsToFrontendReturns {
            #[doc = "The array of ids of pushed nodes that correspond to the backend ids specified in\nbackendNodeIds."]
            #[serde(rename = "nodeIds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub node_ids: Vec<NodeId>,
        }
        impl PushNodesByBackendIdsToFrontendReturns {
            pub fn new(node_ids: Vec<NodeId>) -> Self {
                Self { node_ids }
            }
        }
        impl PushNodesByBackendIdsToFrontendReturns {
            pub fn builder() -> PushNodesByBackendIdsToFrontendReturnsBuilder {
                PushNodesByBackendIdsToFrontendReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PushNodesByBackendIdsToFrontendReturnsBuilder {
            node_ids: Option<Vec<NodeId>>,
        }
        impl PushNodesByBackendIdsToFrontendReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                let v = self.node_ids.get_or_insert(Vec::new());
                v.push(node_id.into());
                self
            }
            pub fn node_ids<I, S>(mut self, node_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<NodeId>,
            {
                let v = self.node_ids.get_or_insert(Vec::new());
                for val in node_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<PushNodesByBackendIdsToFrontendReturns, String> {
                Ok(PushNodesByBackendIdsToFrontendReturns {
                    node_ids: self.node_ids.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_ids))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for PushNodesByBackendIdsToFrontendParams {
            type Response = PushNodesByBackendIdsToFrontendReturns;
        }
        #[doc = "Executes `querySelector` on a given node.\n[querySelector](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-querySelector)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct QuerySelectorParams {
            #[doc = "Id of the node to query upon."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "Selector string."]
            #[serde(rename = "selector")]
            pub selector: String,
        }
        impl QuerySelectorParams {
            pub fn new(node_id: impl Into<NodeId>, selector: impl Into<String>) -> Self {
                Self {
                    node_id: node_id.into(),
                    selector: selector.into(),
                }
            }
        }
        impl QuerySelectorParams {
            pub fn builder() -> QuerySelectorParamsBuilder {
                QuerySelectorParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct QuerySelectorParamsBuilder {
            node_id: Option<NodeId>,
            selector: Option<String>,
        }
        impl QuerySelectorParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn selector(mut self, selector: impl Into<String>) -> Self {
                self.selector = Some(selector.into());
                self
            }
            pub fn build(self) -> Result<QuerySelectorParams, String> {
                Ok(QuerySelectorParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    selector: self.selector.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(selector))
                    })?,
                })
            }
        }
        impl QuerySelectorParams {
            pub const IDENTIFIER: &'static str = "DOM.querySelector";
        }
        impl chromiumoxide_types::Method for QuerySelectorParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for QuerySelectorParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Executes `querySelector` on a given node.\n[querySelector](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-querySelector)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct QuerySelectorReturns {
            #[doc = "Query selector result."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl QuerySelectorReturns {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl QuerySelectorReturns {
            pub fn builder() -> QuerySelectorReturnsBuilder {
                QuerySelectorReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct QuerySelectorReturnsBuilder {
            node_id: Option<NodeId>,
        }
        impl QuerySelectorReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<QuerySelectorReturns, String> {
                Ok(QuerySelectorReturns {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for QuerySelectorParams {
            type Response = QuerySelectorReturns;
        }
        #[doc = "Executes `querySelectorAll` on a given node.\n[querySelectorAll](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-querySelectorAll)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct QuerySelectorAllParams {
            #[doc = "Id of the node to query upon."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "Selector string."]
            #[serde(rename = "selector")]
            pub selector: String,
        }
        impl QuerySelectorAllParams {
            pub fn new(node_id: impl Into<NodeId>, selector: impl Into<String>) -> Self {
                Self {
                    node_id: node_id.into(),
                    selector: selector.into(),
                }
            }
        }
        impl QuerySelectorAllParams {
            pub fn builder() -> QuerySelectorAllParamsBuilder {
                QuerySelectorAllParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct QuerySelectorAllParamsBuilder {
            node_id: Option<NodeId>,
            selector: Option<String>,
        }
        impl QuerySelectorAllParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn selector(mut self, selector: impl Into<String>) -> Self {
                self.selector = Some(selector.into());
                self
            }
            pub fn build(self) -> Result<QuerySelectorAllParams, String> {
                Ok(QuerySelectorAllParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    selector: self.selector.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(selector))
                    })?,
                })
            }
        }
        impl QuerySelectorAllParams {
            pub const IDENTIFIER: &'static str = "DOM.querySelectorAll";
        }
        impl chromiumoxide_types::Method for QuerySelectorAllParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for QuerySelectorAllParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Executes `querySelectorAll` on a given node.\n[querySelectorAll](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-querySelectorAll)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct QuerySelectorAllReturns {
            #[doc = "Query selector result."]
            #[serde(rename = "nodeIds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub node_ids: Vec<NodeId>,
        }
        impl QuerySelectorAllReturns {
            pub fn new(node_ids: Vec<NodeId>) -> Self {
                Self { node_ids }
            }
        }
        impl QuerySelectorAllReturns {
            pub fn builder() -> QuerySelectorAllReturnsBuilder {
                QuerySelectorAllReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct QuerySelectorAllReturnsBuilder {
            node_ids: Option<Vec<NodeId>>,
        }
        impl QuerySelectorAllReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                let v = self.node_ids.get_or_insert(Vec::new());
                v.push(node_id.into());
                self
            }
            pub fn node_ids<I, S>(mut self, node_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<NodeId>,
            {
                let v = self.node_ids.get_or_insert(Vec::new());
                for val in node_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<QuerySelectorAllReturns, String> {
                Ok(QuerySelectorAllReturns {
                    node_ids: self.node_ids.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_ids))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for QuerySelectorAllParams {
            type Response = QuerySelectorAllReturns;
        }
        #[doc = "Returns NodeIds of current top layer elements.\nTop layer is rendered closest to the user within a viewport, therefore its elements always\nappear on top of all other content.\n[getTopLayerElements](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getTopLayerElements)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetTopLayerElementsParams {}
        impl GetTopLayerElementsParams {
            pub const IDENTIFIER: &'static str = "DOM.getTopLayerElements";
        }
        impl chromiumoxide_types::Method for GetTopLayerElementsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetTopLayerElementsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns NodeIds of current top layer elements.\nTop layer is rendered closest to the user within a viewport, therefore its elements always\nappear on top of all other content.\n[getTopLayerElements](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getTopLayerElements)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetTopLayerElementsReturns {
            #[doc = "NodeIds of top layer elements"]
            #[serde(rename = "nodeIds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub node_ids: Vec<NodeId>,
        }
        impl GetTopLayerElementsReturns {
            pub fn new(node_ids: Vec<NodeId>) -> Self {
                Self { node_ids }
            }
        }
        impl GetTopLayerElementsReturns {
            pub fn builder() -> GetTopLayerElementsReturnsBuilder {
                GetTopLayerElementsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetTopLayerElementsReturnsBuilder {
            node_ids: Option<Vec<NodeId>>,
        }
        impl GetTopLayerElementsReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                let v = self.node_ids.get_or_insert(Vec::new());
                v.push(node_id.into());
                self
            }
            pub fn node_ids<I, S>(mut self, node_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<NodeId>,
            {
                let v = self.node_ids.get_or_insert(Vec::new());
                for val in node_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetTopLayerElementsReturns, String> {
                Ok(GetTopLayerElementsReturns {
                    node_ids: self.node_ids.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_ids))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetTopLayerElementsParams {
            type Response = GetTopLayerElementsReturns;
        }
        #[doc = "Re-does the last undone action.\n[redo](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-redo)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RedoParams {}
        impl RedoParams {
            pub const IDENTIFIER: &'static str = "DOM.redo";
        }
        impl chromiumoxide_types::Method for RedoParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RedoParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Re-does the last undone action.\n[redo](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-redo)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RedoReturns {}
        impl chromiumoxide_types::Command for RedoParams {
            type Response = RedoReturns;
        }
        #[doc = "Removes attribute with given name from an element with given id.\n[removeAttribute](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-removeAttribute)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoveAttributeParams {
            #[doc = "Id of the element to remove attribute from."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "Name of the attribute to remove."]
            #[serde(rename = "name")]
            pub name: String,
        }
        impl RemoveAttributeParams {
            pub fn new(node_id: impl Into<NodeId>, name: impl Into<String>) -> Self {
                Self {
                    node_id: node_id.into(),
                    name: name.into(),
                }
            }
        }
        impl RemoveAttributeParams {
            pub fn builder() -> RemoveAttributeParamsBuilder {
                RemoveAttributeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoveAttributeParamsBuilder {
            node_id: Option<NodeId>,
            name: Option<String>,
        }
        impl RemoveAttributeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn build(self) -> Result<RemoveAttributeParams, String> {
                Ok(RemoveAttributeParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                })
            }
        }
        impl RemoveAttributeParams {
            pub const IDENTIFIER: &'static str = "DOM.removeAttribute";
        }
        impl chromiumoxide_types::Method for RemoveAttributeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RemoveAttributeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Removes attribute with given name from an element with given id.\n[removeAttribute](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-removeAttribute)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RemoveAttributeReturns {}
        impl chromiumoxide_types::Command for RemoveAttributeParams {
            type Response = RemoveAttributeReturns;
        }
        #[doc = "Removes node with given id.\n[removeNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-removeNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoveNodeParams {
            #[doc = "Id of the node to remove."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl RemoveNodeParams {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl RemoveNodeParams {
            pub fn builder() -> RemoveNodeParamsBuilder {
                RemoveNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoveNodeParamsBuilder {
            node_id: Option<NodeId>,
        }
        impl RemoveNodeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<RemoveNodeParams, String> {
                Ok(RemoveNodeParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl RemoveNodeParams {
            pub const IDENTIFIER: &'static str = "DOM.removeNode";
        }
        impl chromiumoxide_types::Method for RemoveNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RemoveNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Removes node with given id.\n[removeNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-removeNode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RemoveNodeReturns {}
        impl chromiumoxide_types::Command for RemoveNodeParams {
            type Response = RemoveNodeReturns;
        }
        #[doc = "Requests that children of the node with given id are returned to the caller in form of\n`setChildNodes` events where not only immediate children are retrieved, but all children down to\nthe specified depth.\n[requestChildNodes](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-requestChildNodes)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestChildNodesParams {
            #[doc = "Id of the node to get children for."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the\nentire subtree or provide an integer larger than 0."]
            #[serde(rename = "depth")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub depth: Option<i64>,
            #[doc = "Whether or not iframes and shadow roots should be traversed when returning the sub-tree\n(default is false)."]
            #[serde(rename = "pierce")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pierce: Option<bool>,
        }
        impl RequestChildNodesParams {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                    depth: None,
                    pierce: None,
                }
            }
        }
        impl RequestChildNodesParams {
            pub fn builder() -> RequestChildNodesParamsBuilder {
                RequestChildNodesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestChildNodesParamsBuilder {
            node_id: Option<NodeId>,
            depth: Option<i64>,
            pierce: Option<bool>,
        }
        impl RequestChildNodesParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn depth(mut self, depth: impl Into<i64>) -> Self {
                self.depth = Some(depth.into());
                self
            }
            pub fn pierce(mut self, pierce: impl Into<bool>) -> Self {
                self.pierce = Some(pierce.into());
                self
            }
            pub fn build(self) -> Result<RequestChildNodesParams, String> {
                Ok(RequestChildNodesParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    depth: self.depth,
                    pierce: self.pierce,
                })
            }
        }
        impl RequestChildNodesParams {
            pub const IDENTIFIER: &'static str = "DOM.requestChildNodes";
        }
        impl chromiumoxide_types::Method for RequestChildNodesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RequestChildNodesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests that children of the node with given id are returned to the caller in form of\n`setChildNodes` events where not only immediate children are retrieved, but all children down to\nthe specified depth.\n[requestChildNodes](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-requestChildNodes)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RequestChildNodesReturns {}
        impl chromiumoxide_types::Command for RequestChildNodesParams {
            type Response = RequestChildNodesReturns;
        }
        #[doc = "Requests that the node is sent to the caller given the JavaScript node object reference. All\nnodes that form the path from the node to the root are also sent to the client as a series of\n`setChildNodes` notifications.\n[requestNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-requestNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestNodeParams {
            #[doc = "JavaScript object id to convert into node."]
            #[serde(rename = "objectId")]
            pub object_id: super::super::js_protocol::runtime::RemoteObjectId,
        }
        impl RequestNodeParams {
            pub fn new(
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                Self {
                    object_id: object_id.into(),
                }
            }
        }
        impl RequestNodeParams {
            pub fn builder() -> RequestNodeParamsBuilder {
                RequestNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestNodeParamsBuilder {
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl RequestNodeParamsBuilder {
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> Result<RequestNodeParams, String> {
                Ok(RequestNodeParams {
                    object_id: self.object_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(object_id))
                    })?,
                })
            }
        }
        impl RequestNodeParams {
            pub const IDENTIFIER: &'static str = "DOM.requestNode";
        }
        impl chromiumoxide_types::Method for RequestNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RequestNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests that the node is sent to the caller given the JavaScript node object reference. All\nnodes that form the path from the node to the root are also sent to the client as a series of\n`setChildNodes` notifications.\n[requestNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-requestNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestNodeReturns {
            #[doc = "Node id for given object."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl RequestNodeReturns {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl RequestNodeReturns {
            pub fn builder() -> RequestNodeReturnsBuilder {
                RequestNodeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestNodeReturnsBuilder {
            node_id: Option<NodeId>,
        }
        impl RequestNodeReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<RequestNodeReturns, String> {
                Ok(RequestNodeReturns {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for RequestNodeParams {
            type Response = RequestNodeReturns;
        }
        #[doc = "Resolves the JavaScript node object for a given NodeId or BackendNodeId.\n[resolveNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-resolveNode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ResolveNodeParams {
            #[doc = "Id of the node to resolve."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<NodeId>,
            #[doc = "Backend identifier of the node to resolve."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<super::dom::BackendNodeId>,
            #[doc = "Symbolic group name that can be used to release multiple objects."]
            #[serde(rename = "objectGroup")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_group: Option<String>,
            #[doc = "Execution context in which to resolve the node."]
            #[serde(rename = "executionContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub execution_context_id:
                Option<super::super::js_protocol::runtime::ExecutionContextId>,
        }
        impl ResolveNodeParams {
            pub fn builder() -> ResolveNodeParamsBuilder {
                ResolveNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ResolveNodeParamsBuilder {
            node_id: Option<NodeId>,
            backend_node_id: Option<super::dom::BackendNodeId>,
            object_group: Option<String>,
            execution_context_id: Option<super::super::js_protocol::runtime::ExecutionContextId>,
        }
        impl ResolveNodeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn backend_node_id(
                mut self,
                backend_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn object_group(mut self, object_group: impl Into<String>) -> Self {
                self.object_group = Some(object_group.into());
                self
            }
            pub fn execution_context_id(
                mut self,
                execution_context_id: impl Into<super::super::js_protocol::runtime::ExecutionContextId>,
            ) -> Self {
                self.execution_context_id = Some(execution_context_id.into());
                self
            }
            pub fn build(self) -> ResolveNodeParams {
                ResolveNodeParams {
                    node_id: self.node_id,
                    backend_node_id: self.backend_node_id,
                    object_group: self.object_group,
                    execution_context_id: self.execution_context_id,
                }
            }
        }
        impl ResolveNodeParams {
            pub const IDENTIFIER: &'static str = "DOM.resolveNode";
        }
        impl chromiumoxide_types::Method for ResolveNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ResolveNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Resolves the JavaScript node object for a given NodeId or BackendNodeId.\n[resolveNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-resolveNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ResolveNodeReturns {
            #[doc = "JavaScript object wrapper for given node."]
            #[serde(rename = "object")]
            pub object: super::super::js_protocol::runtime::RemoteObject,
        }
        impl ResolveNodeReturns {
            pub fn new(
                object: impl Into<super::super::js_protocol::runtime::RemoteObject>,
            ) -> Self {
                Self {
                    object: object.into(),
                }
            }
        }
        impl ResolveNodeReturns {
            pub fn builder() -> ResolveNodeReturnsBuilder {
                ResolveNodeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ResolveNodeReturnsBuilder {
            object: Option<super::super::js_protocol::runtime::RemoteObject>,
        }
        impl ResolveNodeReturnsBuilder {
            pub fn object(
                mut self,
                object: impl Into<super::super::js_protocol::runtime::RemoteObject>,
            ) -> Self {
                self.object = Some(object.into());
                self
            }
            pub fn build(self) -> Result<ResolveNodeReturns, String> {
                Ok(ResolveNodeReturns {
                    object: self.object.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(object))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for ResolveNodeParams {
            type Response = ResolveNodeReturns;
        }
        #[doc = "Sets attribute for an element with given id.\n[setAttributeValue](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setAttributeValue)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetAttributeValueParams {
            #[doc = "Id of the element to set attribute for."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "Attribute name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Attribute value."]
            #[serde(rename = "value")]
            pub value: String,
        }
        impl SetAttributeValueParams {
            pub fn new(
                node_id: impl Into<NodeId>,
                name: impl Into<String>,
                value: impl Into<String>,
            ) -> Self {
                Self {
                    node_id: node_id.into(),
                    name: name.into(),
                    value: value.into(),
                }
            }
        }
        impl SetAttributeValueParams {
            pub fn builder() -> SetAttributeValueParamsBuilder {
                SetAttributeValueParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetAttributeValueParamsBuilder {
            node_id: Option<NodeId>,
            name: Option<String>,
            value: Option<String>,
        }
        impl SetAttributeValueParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<SetAttributeValueParams, String> {
                Ok(SetAttributeValueParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl SetAttributeValueParams {
            pub const IDENTIFIER: &'static str = "DOM.setAttributeValue";
        }
        impl chromiumoxide_types::Method for SetAttributeValueParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetAttributeValueParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets attribute for an element with given id.\n[setAttributeValue](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setAttributeValue)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetAttributeValueReturns {}
        impl chromiumoxide_types::Command for SetAttributeValueParams {
            type Response = SetAttributeValueReturns;
        }
        #[doc = "Sets attributes on element with given id. This method is useful when user edits some existing\nattribute value and types in several attribute name/value pairs.\n[setAttributesAsText](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setAttributesAsText)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetAttributesAsTextParams {
            #[doc = "Id of the element to set attributes for."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "Text with a number of attributes. Will parse this text using HTML parser."]
            #[serde(rename = "text")]
            pub text: String,
            #[doc = "Attribute name to replace with new attributes derived from text in case text parsed\nsuccessfully."]
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub name: Option<String>,
        }
        impl SetAttributesAsTextParams {
            pub fn new(node_id: impl Into<NodeId>, text: impl Into<String>) -> Self {
                Self {
                    node_id: node_id.into(),
                    text: text.into(),
                    name: None,
                }
            }
        }
        impl SetAttributesAsTextParams {
            pub fn builder() -> SetAttributesAsTextParamsBuilder {
                SetAttributesAsTextParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetAttributesAsTextParamsBuilder {
            node_id: Option<NodeId>,
            text: Option<String>,
            name: Option<String>,
        }
        impl SetAttributesAsTextParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn build(self) -> Result<SetAttributesAsTextParams, String> {
                Ok(SetAttributesAsTextParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                    name: self.name,
                })
            }
        }
        impl SetAttributesAsTextParams {
            pub const IDENTIFIER: &'static str = "DOM.setAttributesAsText";
        }
        impl chromiumoxide_types::Method for SetAttributesAsTextParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetAttributesAsTextParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets attributes on element with given id. This method is useful when user edits some existing\nattribute value and types in several attribute name/value pairs.\n[setAttributesAsText](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setAttributesAsText)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetAttributesAsTextReturns {}
        impl chromiumoxide_types::Command for SetAttributesAsTextParams {
            type Response = SetAttributesAsTextReturns;
        }
        #[doc = "Sets files for the given file input element.\n[setFileInputFiles](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setFileInputFiles)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetFileInputFilesParams {
            #[doc = "Array of file paths to set."]
            #[serde(rename = "files")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub files: Vec<String>,
            #[doc = "Identifier of the node."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<NodeId>,
            #[doc = "Identifier of the backend node."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<BackendNodeId>,
            #[doc = "JavaScript object id of the node wrapper."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl SetFileInputFilesParams {
            pub fn new(files: Vec<String>) -> Self {
                Self {
                    files,
                    node_id: None,
                    backend_node_id: None,
                    object_id: None,
                }
            }
        }
        impl SetFileInputFilesParams {
            pub fn builder() -> SetFileInputFilesParamsBuilder {
                SetFileInputFilesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetFileInputFilesParamsBuilder {
            files: Option<Vec<String>>,
            node_id: Option<NodeId>,
            backend_node_id: Option<BackendNodeId>,
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl SetFileInputFilesParamsBuilder {
            pub fn file(mut self, file: impl Into<String>) -> Self {
                let v = self.files.get_or_insert(Vec::new());
                v.push(file.into());
                self
            }
            pub fn files<I, S>(mut self, files: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.files.get_or_insert(Vec::new());
                for val in files {
                    v.push(val.into());
                }
                self
            }
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> Result<SetFileInputFilesParams, String> {
                Ok(SetFileInputFilesParams {
                    files: self.files.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(files))
                    })?,
                    node_id: self.node_id,
                    backend_node_id: self.backend_node_id,
                    object_id: self.object_id,
                })
            }
        }
        impl SetFileInputFilesParams {
            pub const IDENTIFIER: &'static str = "DOM.setFileInputFiles";
        }
        impl chromiumoxide_types::Method for SetFileInputFilesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetFileInputFilesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets files for the given file input element.\n[setFileInputFiles](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setFileInputFiles)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetFileInputFilesReturns {}
        impl chromiumoxide_types::Command for SetFileInputFilesParams {
            type Response = SetFileInputFilesReturns;
        }
        #[doc = "Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.\n[setNodeStackTracesEnabled](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setNodeStackTracesEnabled)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetNodeStackTracesEnabledParams {
            #[doc = "Enable or disable."]
            #[serde(rename = "enable")]
            pub enable: bool,
        }
        impl SetNodeStackTracesEnabledParams {
            pub fn new(enable: impl Into<bool>) -> Self {
                Self {
                    enable: enable.into(),
                }
            }
        }
        impl SetNodeStackTracesEnabledParams {
            pub fn builder() -> SetNodeStackTracesEnabledParamsBuilder {
                SetNodeStackTracesEnabledParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetNodeStackTracesEnabledParamsBuilder {
            enable: Option<bool>,
        }
        impl SetNodeStackTracesEnabledParamsBuilder {
            pub fn enable(mut self, enable: impl Into<bool>) -> Self {
                self.enable = Some(enable.into());
                self
            }
            pub fn build(self) -> Result<SetNodeStackTracesEnabledParams, String> {
                Ok(SetNodeStackTracesEnabledParams {
                    enable: self.enable.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enable))
                    })?,
                })
            }
        }
        impl SetNodeStackTracesEnabledParams {
            pub const IDENTIFIER: &'static str = "DOM.setNodeStackTracesEnabled";
        }
        impl chromiumoxide_types::Method for SetNodeStackTracesEnabledParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetNodeStackTracesEnabledParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.\n[setNodeStackTracesEnabled](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setNodeStackTracesEnabled)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetNodeStackTracesEnabledReturns {}
        impl chromiumoxide_types::Command for SetNodeStackTracesEnabledParams {
            type Response = SetNodeStackTracesEnabledReturns;
        }
        #[doc = "Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.\n[getNodeStackTraces](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getNodeStackTraces)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetNodeStackTracesParams {
            #[doc = "Id of the node to get stack traces for."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl GetNodeStackTracesParams {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl GetNodeStackTracesParams {
            pub fn builder() -> GetNodeStackTracesParamsBuilder {
                GetNodeStackTracesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetNodeStackTracesParamsBuilder {
            node_id: Option<NodeId>,
        }
        impl GetNodeStackTracesParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetNodeStackTracesParams, String> {
                Ok(GetNodeStackTracesParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl GetNodeStackTracesParams {
            pub const IDENTIFIER: &'static str = "DOM.getNodeStackTraces";
        }
        impl chromiumoxide_types::Method for GetNodeStackTracesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetNodeStackTracesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.\n[getNodeStackTraces](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getNodeStackTraces)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetNodeStackTracesReturns {
            #[doc = "Creation stack trace, if available."]
            #[serde(rename = "creation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub creation: Option<super::super::js_protocol::runtime::StackTrace>,
        }
        impl GetNodeStackTracesReturns {
            pub fn builder() -> GetNodeStackTracesReturnsBuilder {
                GetNodeStackTracesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetNodeStackTracesReturnsBuilder {
            creation: Option<super::super::js_protocol::runtime::StackTrace>,
        }
        impl GetNodeStackTracesReturnsBuilder {
            pub fn creation(
                mut self,
                creation: impl Into<super::super::js_protocol::runtime::StackTrace>,
            ) -> Self {
                self.creation = Some(creation.into());
                self
            }
            pub fn build(self) -> GetNodeStackTracesReturns {
                GetNodeStackTracesReturns {
                    creation: self.creation,
                }
            }
        }
        impl chromiumoxide_types::Command for GetNodeStackTracesParams {
            type Response = GetNodeStackTracesReturns;
        }
        #[doc = "Returns file information for the given\nFile wrapper.\n[getFileInfo](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getFileInfo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetFileInfoParams {
            #[doc = "JavaScript object id of the node wrapper."]
            #[serde(rename = "objectId")]
            pub object_id: super::super::js_protocol::runtime::RemoteObjectId,
        }
        impl GetFileInfoParams {
            pub fn new(
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                Self {
                    object_id: object_id.into(),
                }
            }
        }
        impl GetFileInfoParams {
            pub fn builder() -> GetFileInfoParamsBuilder {
                GetFileInfoParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetFileInfoParamsBuilder {
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl GetFileInfoParamsBuilder {
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> Result<GetFileInfoParams, String> {
                Ok(GetFileInfoParams {
                    object_id: self.object_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(object_id))
                    })?,
                })
            }
        }
        impl GetFileInfoParams {
            pub const IDENTIFIER: &'static str = "DOM.getFileInfo";
        }
        impl chromiumoxide_types::Method for GetFileInfoParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetFileInfoParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns file information for the given\nFile wrapper.\n[getFileInfo](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getFileInfo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetFileInfoReturns {
            #[serde(rename = "path")]
            pub path: String,
        }
        impl GetFileInfoReturns {
            pub fn new(path: impl Into<String>) -> Self {
                Self { path: path.into() }
            }
        }
        impl<T: Into<String>> From<T> for GetFileInfoReturns {
            fn from(url: T) -> Self {
                GetFileInfoReturns::new(url)
            }
        }
        impl GetFileInfoReturns {
            pub fn builder() -> GetFileInfoReturnsBuilder {
                GetFileInfoReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetFileInfoReturnsBuilder {
            path: Option<String>,
        }
        impl GetFileInfoReturnsBuilder {
            pub fn path(mut self, path: impl Into<String>) -> Self {
                self.path = Some(path.into());
                self
            }
            pub fn build(self) -> Result<GetFileInfoReturns, String> {
                Ok(GetFileInfoReturns {
                    path: self.path.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(path))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetFileInfoParams {
            type Response = GetFileInfoReturns;
        }
        #[doc = "Enables console to refer to the node with given id via $x (see Command Line API for more details\n$x functions).\n[setInspectedNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setInspectedNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetInspectedNodeParams {
            #[doc = "DOM node id to be accessible by means of $x command line API."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl SetInspectedNodeParams {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl SetInspectedNodeParams {
            pub fn builder() -> SetInspectedNodeParamsBuilder {
                SetInspectedNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetInspectedNodeParamsBuilder {
            node_id: Option<NodeId>,
        }
        impl SetInspectedNodeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<SetInspectedNodeParams, String> {
                Ok(SetInspectedNodeParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl SetInspectedNodeParams {
            pub const IDENTIFIER: &'static str = "DOM.setInspectedNode";
        }
        impl chromiumoxide_types::Method for SetInspectedNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetInspectedNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables console to refer to the node with given id via $x (see Command Line API for more details\n$x functions).\n[setInspectedNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setInspectedNode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetInspectedNodeReturns {}
        impl chromiumoxide_types::Command for SetInspectedNodeParams {
            type Response = SetInspectedNodeReturns;
        }
        #[doc = "Sets node name for a node with given id.\n[setNodeName](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setNodeName)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetNodeNameParams {
            #[doc = "Id of the node to set name for."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "New node's name."]
            #[serde(rename = "name")]
            pub name: String,
        }
        impl SetNodeNameParams {
            pub fn new(node_id: impl Into<NodeId>, name: impl Into<String>) -> Self {
                Self {
                    node_id: node_id.into(),
                    name: name.into(),
                }
            }
        }
        impl SetNodeNameParams {
            pub fn builder() -> SetNodeNameParamsBuilder {
                SetNodeNameParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetNodeNameParamsBuilder {
            node_id: Option<NodeId>,
            name: Option<String>,
        }
        impl SetNodeNameParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn build(self) -> Result<SetNodeNameParams, String> {
                Ok(SetNodeNameParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                })
            }
        }
        impl SetNodeNameParams {
            pub const IDENTIFIER: &'static str = "DOM.setNodeName";
        }
        impl chromiumoxide_types::Method for SetNodeNameParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetNodeNameParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets node name for a node with given id.\n[setNodeName](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setNodeName)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetNodeNameReturns {
            #[doc = "New node's id."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl SetNodeNameReturns {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl SetNodeNameReturns {
            pub fn builder() -> SetNodeNameReturnsBuilder {
                SetNodeNameReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetNodeNameReturnsBuilder {
            node_id: Option<NodeId>,
        }
        impl SetNodeNameReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<SetNodeNameReturns, String> {
                Ok(SetNodeNameReturns {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SetNodeNameParams {
            type Response = SetNodeNameReturns;
        }
        #[doc = "Sets node value for a node with given id.\n[setNodeValue](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setNodeValue)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetNodeValueParams {
            #[doc = "Id of the node to set value for."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "New node's value."]
            #[serde(rename = "value")]
            pub value: String,
        }
        impl SetNodeValueParams {
            pub fn new(node_id: impl Into<NodeId>, value: impl Into<String>) -> Self {
                Self {
                    node_id: node_id.into(),
                    value: value.into(),
                }
            }
        }
        impl SetNodeValueParams {
            pub fn builder() -> SetNodeValueParamsBuilder {
                SetNodeValueParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetNodeValueParamsBuilder {
            node_id: Option<NodeId>,
            value: Option<String>,
        }
        impl SetNodeValueParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<SetNodeValueParams, String> {
                Ok(SetNodeValueParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl SetNodeValueParams {
            pub const IDENTIFIER: &'static str = "DOM.setNodeValue";
        }
        impl chromiumoxide_types::Method for SetNodeValueParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetNodeValueParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets node value for a node with given id.\n[setNodeValue](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setNodeValue)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetNodeValueReturns {}
        impl chromiumoxide_types::Command for SetNodeValueParams {
            type Response = SetNodeValueReturns;
        }
        #[doc = "Sets node HTML markup, returns new node id.\n[setOuterHTML](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setOuterHTML)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetOuterHtmlParams {
            #[doc = "Id of the node to set markup for."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "Outer HTML markup to set."]
            #[serde(rename = "outerHTML")]
            pub outer_html: String,
        }
        impl SetOuterHtmlParams {
            pub fn new(node_id: impl Into<NodeId>, outer_html: impl Into<String>) -> Self {
                Self {
                    node_id: node_id.into(),
                    outer_html: outer_html.into(),
                }
            }
        }
        impl SetOuterHtmlParams {
            pub fn builder() -> SetOuterHtmlParamsBuilder {
                SetOuterHtmlParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetOuterHtmlParamsBuilder {
            node_id: Option<NodeId>,
            outer_html: Option<String>,
        }
        impl SetOuterHtmlParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn outer_html(mut self, outer_html: impl Into<String>) -> Self {
                self.outer_html = Some(outer_html.into());
                self
            }
            pub fn build(self) -> Result<SetOuterHtmlParams, String> {
                Ok(SetOuterHtmlParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    outer_html: self.outer_html.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(outer_html))
                    })?,
                })
            }
        }
        impl SetOuterHtmlParams {
            pub const IDENTIFIER: &'static str = "DOM.setOuterHTML";
        }
        impl chromiumoxide_types::Method for SetOuterHtmlParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetOuterHtmlParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets node HTML markup, returns new node id.\n[setOuterHTML](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setOuterHTML)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetOuterHtmlReturns {}
        impl chromiumoxide_types::Command for SetOuterHtmlParams {
            type Response = SetOuterHtmlReturns;
        }
        #[doc = "Undoes the last performed action.\n[undo](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-undo)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct UndoParams {}
        impl UndoParams {
            pub const IDENTIFIER: &'static str = "DOM.undo";
        }
        impl chromiumoxide_types::Method for UndoParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for UndoParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Undoes the last performed action.\n[undo](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-undo)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct UndoReturns {}
        impl chromiumoxide_types::Command for UndoParams {
            type Response = UndoReturns;
        }
        #[doc = "Returns iframe node that owns iframe with the given domain.\n[getFrameOwner](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getFrameOwner)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetFrameOwnerParams {
            #[serde(rename = "frameId")]
            pub frame_id: super::page::FrameId,
        }
        impl GetFrameOwnerParams {
            pub fn new(frame_id: impl Into<super::page::FrameId>) -> Self {
                Self {
                    frame_id: frame_id.into(),
                }
            }
        }
        impl GetFrameOwnerParams {
            pub fn builder() -> GetFrameOwnerParamsBuilder {
                GetFrameOwnerParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetFrameOwnerParamsBuilder {
            frame_id: Option<super::page::FrameId>,
        }
        impl GetFrameOwnerParamsBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn build(self) -> Result<GetFrameOwnerParams, String> {
                Ok(GetFrameOwnerParams {
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                })
            }
        }
        impl GetFrameOwnerParams {
            pub const IDENTIFIER: &'static str = "DOM.getFrameOwner";
        }
        impl chromiumoxide_types::Method for GetFrameOwnerParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetFrameOwnerParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns iframe node that owns iframe with the given domain.\n[getFrameOwner](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getFrameOwner)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetFrameOwnerReturns {
            #[doc = "Resulting node."]
            #[serde(rename = "backendNodeId")]
            pub backend_node_id: BackendNodeId,
            #[doc = "Id of the node at given coordinates, only when enabled and requested document."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<NodeId>,
        }
        impl GetFrameOwnerReturns {
            pub fn new(backend_node_id: impl Into<BackendNodeId>) -> Self {
                Self {
                    backend_node_id: backend_node_id.into(),
                    node_id: None,
                }
            }
        }
        impl GetFrameOwnerReturns {
            pub fn builder() -> GetFrameOwnerReturnsBuilder {
                GetFrameOwnerReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetFrameOwnerReturnsBuilder {
            backend_node_id: Option<BackendNodeId>,
            node_id: Option<NodeId>,
        }
        impl GetFrameOwnerReturnsBuilder {
            pub fn backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetFrameOwnerReturns, String> {
                Ok(GetFrameOwnerReturns {
                    backend_node_id: self.backend_node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(backend_node_id))
                    })?,
                    node_id: self.node_id,
                })
            }
        }
        impl chromiumoxide_types::Command for GetFrameOwnerParams {
            type Response = GetFrameOwnerReturns;
        }
        #[doc = "Returns the container of the given node based on container query conditions.\nIf containerName is given, it will find the nearest container with a matching name;\notherwise it will find the nearest container regardless of its container name.\n[getContainerForNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getContainerForNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetContainerForNodeParams {
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[serde(rename = "containerName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub container_name: Option<String>,
        }
        impl GetContainerForNodeParams {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                    container_name: None,
                }
            }
        }
        impl GetContainerForNodeParams {
            pub fn builder() -> GetContainerForNodeParamsBuilder {
                GetContainerForNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetContainerForNodeParamsBuilder {
            node_id: Option<NodeId>,
            container_name: Option<String>,
        }
        impl GetContainerForNodeParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn container_name(mut self, container_name: impl Into<String>) -> Self {
                self.container_name = Some(container_name.into());
                self
            }
            pub fn build(self) -> Result<GetContainerForNodeParams, String> {
                Ok(GetContainerForNodeParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    container_name: self.container_name,
                })
            }
        }
        impl GetContainerForNodeParams {
            pub const IDENTIFIER: &'static str = "DOM.getContainerForNode";
        }
        impl chromiumoxide_types::Method for GetContainerForNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetContainerForNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the container of the given node based on container query conditions.\nIf containerName is given, it will find the nearest container with a matching name;\notherwise it will find the nearest container regardless of its container name.\n[getContainerForNode](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getContainerForNode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetContainerForNodeReturns {
            #[doc = "The container node for the given node, or null if not found."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<NodeId>,
        }
        impl GetContainerForNodeReturns {
            pub fn builder() -> GetContainerForNodeReturnsBuilder {
                GetContainerForNodeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetContainerForNodeReturnsBuilder {
            node_id: Option<NodeId>,
        }
        impl GetContainerForNodeReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> GetContainerForNodeReturns {
                GetContainerForNodeReturns {
                    node_id: self.node_id,
                }
            }
        }
        impl chromiumoxide_types::Command for GetContainerForNodeParams {
            type Response = GetContainerForNodeReturns;
        }
        #[doc = "Returns the descendants of a container query container that have\ncontainer queries against this container.\n[getQueryingDescendantsForContainer](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getQueryingDescendantsForContainer)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetQueryingDescendantsForContainerParams {
            #[doc = "Id of the container node to find querying descendants from."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl GetQueryingDescendantsForContainerParams {
            pub fn new(node_id: impl Into<NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl GetQueryingDescendantsForContainerParams {
            pub fn builder() -> GetQueryingDescendantsForContainerParamsBuilder {
                GetQueryingDescendantsForContainerParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetQueryingDescendantsForContainerParamsBuilder {
            node_id: Option<NodeId>,
        }
        impl GetQueryingDescendantsForContainerParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetQueryingDescendantsForContainerParams, String> {
                Ok(GetQueryingDescendantsForContainerParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl GetQueryingDescendantsForContainerParams {
            pub const IDENTIFIER: &'static str = "DOM.getQueryingDescendantsForContainer";
        }
        impl chromiumoxide_types::Method for GetQueryingDescendantsForContainerParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetQueryingDescendantsForContainerParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the descendants of a container query container that have\ncontainer queries against this container.\n[getQueryingDescendantsForContainer](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getQueryingDescendantsForContainer)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetQueryingDescendantsForContainerReturns {
            #[doc = "Descendant nodes with container queries against the given container."]
            #[serde(rename = "nodeIds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub node_ids: Vec<NodeId>,
        }
        impl GetQueryingDescendantsForContainerReturns {
            pub fn new(node_ids: Vec<NodeId>) -> Self {
                Self { node_ids }
            }
        }
        impl GetQueryingDescendantsForContainerReturns {
            pub fn builder() -> GetQueryingDescendantsForContainerReturnsBuilder {
                GetQueryingDescendantsForContainerReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetQueryingDescendantsForContainerReturnsBuilder {
            node_ids: Option<Vec<NodeId>>,
        }
        impl GetQueryingDescendantsForContainerReturnsBuilder {
            pub fn node_id(mut self, node_id: impl Into<NodeId>) -> Self {
                let v = self.node_ids.get_or_insert(Vec::new());
                v.push(node_id.into());
                self
            }
            pub fn node_ids<I, S>(mut self, node_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<NodeId>,
            {
                let v = self.node_ids.get_or_insert(Vec::new());
                for val in node_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetQueryingDescendantsForContainerReturns, String> {
                Ok(GetQueryingDescendantsForContainerReturns {
                    node_ids: self.node_ids.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_ids))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetQueryingDescendantsForContainerParams {
            type Response = GetQueryingDescendantsForContainerReturns;
        }
        #[doc = "Fired when `Element`'s attribute is modified.\n[attributeModified](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-attributeModified)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAttributeModified {
            #[doc = "Id of the node that has changed."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "Attribute name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Attribute value."]
            #[serde(rename = "value")]
            pub value: String,
        }
        impl EventAttributeModified {
            pub const IDENTIFIER: &'static str = "DOM.attributeModified";
        }
        impl chromiumoxide_types::Method for EventAttributeModified {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAttributeModified {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when `Element`'s attribute is removed.\n[attributeRemoved](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-attributeRemoved)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAttributeRemoved {
            #[doc = "Id of the node that has changed."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "A ttribute name."]
            #[serde(rename = "name")]
            pub name: String,
        }
        impl EventAttributeRemoved {
            pub const IDENTIFIER: &'static str = "DOM.attributeRemoved";
        }
        impl chromiumoxide_types::Method for EventAttributeRemoved {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAttributeRemoved {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Mirrors `DOMCharacterDataModified` event.\n[characterDataModified](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-characterDataModified)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventCharacterDataModified {
            #[doc = "Id of the node that has changed."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "New text value."]
            #[serde(rename = "characterData")]
            pub character_data: String,
        }
        impl EventCharacterDataModified {
            pub const IDENTIFIER: &'static str = "DOM.characterDataModified";
        }
        impl chromiumoxide_types::Method for EventCharacterDataModified {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventCharacterDataModified {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when `Container`'s child node count has changed.\n[childNodeCountUpdated](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-childNodeCountUpdated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventChildNodeCountUpdated {
            #[doc = "Id of the node that has changed."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
            #[doc = "New node count."]
            #[serde(rename = "childNodeCount")]
            pub child_node_count: i64,
        }
        impl EventChildNodeCountUpdated {
            pub const IDENTIFIER: &'static str = "DOM.childNodeCountUpdated";
        }
        impl chromiumoxide_types::Method for EventChildNodeCountUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventChildNodeCountUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Mirrors `DOMNodeInserted` event.\n[childNodeInserted](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-childNodeInserted)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventChildNodeInserted {
            #[doc = "Id of the node that has changed."]
            #[serde(rename = "parentNodeId")]
            pub parent_node_id: NodeId,
            #[doc = "Id of the previous sibling."]
            #[serde(rename = "previousNodeId")]
            pub previous_node_id: NodeId,
            #[doc = "Inserted node data."]
            #[serde(rename = "node")]
            pub node: Node,
        }
        impl EventChildNodeInserted {
            pub const IDENTIFIER: &'static str = "DOM.childNodeInserted";
        }
        impl chromiumoxide_types::Method for EventChildNodeInserted {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventChildNodeInserted {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Mirrors `DOMNodeRemoved` event.\n[childNodeRemoved](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-childNodeRemoved)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventChildNodeRemoved {
            #[doc = "Parent id."]
            #[serde(rename = "parentNodeId")]
            pub parent_node_id: NodeId,
            #[doc = "Id of the node that has been removed."]
            #[serde(rename = "nodeId")]
            pub node_id: NodeId,
        }
        impl EventChildNodeRemoved {
            pub const IDENTIFIER: &'static str = "DOM.childNodeRemoved";
        }
        impl chromiumoxide_types::Method for EventChildNodeRemoved {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventChildNodeRemoved {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Called when distribution is changed.\n[distributedNodesUpdated](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-distributedNodesUpdated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDistributedNodesUpdated {
            #[doc = "Insertion point where distributed nodes were updated."]
            #[serde(rename = "insertionPointId")]
            pub insertion_point_id: NodeId,
            #[doc = "Distributed nodes for given insertion point."]
            #[serde(rename = "distributedNodes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub distributed_nodes: Vec<BackendNode>,
        }
        impl EventDistributedNodesUpdated {
            pub const IDENTIFIER: &'static str = "DOM.distributedNodesUpdated";
        }
        impl chromiumoxide_types::Method for EventDistributedNodesUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDistributedNodesUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when `Document` has been totally updated. Node ids are no longer valid.\n[documentUpdated](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-documentUpdated)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventDocumentUpdated {}
        impl EventDocumentUpdated {
            pub const IDENTIFIER: &'static str = "DOM.documentUpdated";
        }
        impl chromiumoxide_types::Method for EventDocumentUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDocumentUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when `Element`'s inline style is modified via a CSS property modification.\n[inlineStyleInvalidated](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-inlineStyleInvalidated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventInlineStyleInvalidated {
            #[doc = "Ids of the nodes for which the inline styles have been invalidated."]
            #[serde(rename = "nodeIds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub node_ids: Vec<NodeId>,
        }
        impl EventInlineStyleInvalidated {
            pub const IDENTIFIER: &'static str = "DOM.inlineStyleInvalidated";
        }
        impl chromiumoxide_types::Method for EventInlineStyleInvalidated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventInlineStyleInvalidated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Called when a pseudo element is added to an element.\n[pseudoElementAdded](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-pseudoElementAdded)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventPseudoElementAdded {
            #[doc = "Pseudo element's parent element id."]
            #[serde(rename = "parentId")]
            pub parent_id: NodeId,
            #[doc = "The added pseudo element."]
            #[serde(rename = "pseudoElement")]
            pub pseudo_element: Node,
        }
        impl EventPseudoElementAdded {
            pub const IDENTIFIER: &'static str = "DOM.pseudoElementAdded";
        }
        impl chromiumoxide_types::Method for EventPseudoElementAdded {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventPseudoElementAdded {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Called when top layer elements are changed.\n[topLayerElementsUpdated](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-topLayerElementsUpdated)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventTopLayerElementsUpdated {}
        impl EventTopLayerElementsUpdated {
            pub const IDENTIFIER: &'static str = "DOM.topLayerElementsUpdated";
        }
        impl chromiumoxide_types::Method for EventTopLayerElementsUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventTopLayerElementsUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Called when a pseudo element is removed from an element.\n[pseudoElementRemoved](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-pseudoElementRemoved)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventPseudoElementRemoved {
            #[doc = "Pseudo element's parent element id."]
            #[serde(rename = "parentId")]
            pub parent_id: NodeId,
            #[doc = "The removed pseudo element id."]
            #[serde(rename = "pseudoElementId")]
            pub pseudo_element_id: NodeId,
        }
        impl EventPseudoElementRemoved {
            pub const IDENTIFIER: &'static str = "DOM.pseudoElementRemoved";
        }
        impl chromiumoxide_types::Method for EventPseudoElementRemoved {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventPseudoElementRemoved {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when backend wants to provide client with the missing DOM structure. This happens upon\nmost of the calls requesting node ids.\n[setChildNodes](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-setChildNodes)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventSetChildNodes {
            #[doc = "Parent node id to populate with children."]
            #[serde(rename = "parentId")]
            pub parent_id: NodeId,
            #[doc = "Child nodes array."]
            #[serde(rename = "nodes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub nodes: Vec<Node>,
        }
        impl EventSetChildNodes {
            pub const IDENTIFIER: &'static str = "DOM.setChildNodes";
        }
        impl chromiumoxide_types::Method for EventSetChildNodes {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventSetChildNodes {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Called when shadow root is popped from the element.\n[shadowRootPopped](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-shadowRootPopped)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventShadowRootPopped {
            #[doc = "Host element id."]
            #[serde(rename = "hostId")]
            pub host_id: NodeId,
            #[doc = "Shadow root id."]
            #[serde(rename = "rootId")]
            pub root_id: NodeId,
        }
        impl EventShadowRootPopped {
            pub const IDENTIFIER: &'static str = "DOM.shadowRootPopped";
        }
        impl chromiumoxide_types::Method for EventShadowRootPopped {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventShadowRootPopped {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Called when shadow root is pushed into the element.\n[shadowRootPushed](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-shadowRootPushed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventShadowRootPushed {
            #[doc = "Host element id."]
            #[serde(rename = "hostId")]
            pub host_id: NodeId,
            #[doc = "Shadow root."]
            #[serde(rename = "root")]
            pub root: Node,
        }
        impl EventShadowRootPushed {
            pub const IDENTIFIER: &'static str = "DOM.shadowRootPushed";
        }
        impl chromiumoxide_types::Method for EventShadowRootPushed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventShadowRootPushed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript\nexecution will stop on these operations as if there was a regular breakpoint set."]
    pub mod dom_debugger {
        use serde::{Deserialize, Serialize};
        #[doc = "DOM breakpoint type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum DomBreakpointType {
            #[serde(rename = "subtree-modified")]
            SubtreeModified,
            #[serde(rename = "attribute-modified")]
            AttributeModified,
            #[serde(rename = "node-removed")]
            NodeRemoved,
        }
        impl AsRef<str> for DomBreakpointType {
            fn as_ref(&self) -> &str {
                match self {
                    DomBreakpointType::SubtreeModified => "subtree-modified",
                    DomBreakpointType::AttributeModified => "attribute-modified",
                    DomBreakpointType::NodeRemoved => "node-removed",
                }
            }
        }
        impl ::std::str::FromStr for DomBreakpointType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "subtree-modified" | "SubtreeModified" => {
                        Ok(DomBreakpointType::SubtreeModified)
                    }
                    "attribute-modified" | "AttributeModified" => {
                        Ok(DomBreakpointType::AttributeModified)
                    }
                    "node-removed" | "NodeRemoved" => Ok(DomBreakpointType::NodeRemoved),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "CSP Violation type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CspViolationType {
            #[serde(rename = "trustedtype-sink-violation")]
            TrustedtypeSinkViolation,
            #[serde(rename = "trustedtype-policy-violation")]
            TrustedtypePolicyViolation,
        }
        impl AsRef<str> for CspViolationType {
            fn as_ref(&self) -> &str {
                match self {
                    CspViolationType::TrustedtypeSinkViolation => "trustedtype-sink-violation",
                    CspViolationType::TrustedtypePolicyViolation => "trustedtype-policy-violation",
                }
            }
        }
        impl ::std::str::FromStr for CspViolationType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "trustedtype-sink-violation" | "TrustedtypeSinkViolation" => {
                        Ok(CspViolationType::TrustedtypeSinkViolation)
                    }
                    "trustedtype-policy-violation" | "TrustedtypePolicyViolation" => {
                        Ok(CspViolationType::TrustedtypePolicyViolation)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Object event listener.\n[EventListener](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#type-EventListener)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventListener {
            #[doc = "`EventListener`'s type."]
            #[serde(rename = "type")]
            pub r#type: String,
            #[doc = "`EventListener`'s useCapture."]
            #[serde(rename = "useCapture")]
            pub use_capture: bool,
            #[doc = "`EventListener`'s passive flag."]
            #[serde(rename = "passive")]
            pub passive: bool,
            #[doc = "`EventListener`'s once flag."]
            #[serde(rename = "once")]
            pub once: bool,
            #[doc = "Script id of the handler code."]
            #[serde(rename = "scriptId")]
            pub script_id: super::super::js_protocol::runtime::ScriptId,
            #[doc = "Line number in the script (0-based)."]
            #[serde(rename = "lineNumber")]
            pub line_number: i64,
            #[doc = "Column number in the script (0-based)."]
            #[serde(rename = "columnNumber")]
            pub column_number: i64,
            #[doc = "Event handler function value."]
            #[serde(rename = "handler")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub handler: Option<super::super::js_protocol::runtime::RemoteObject>,
            #[doc = "Event original handler function value."]
            #[serde(rename = "originalHandler")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub original_handler: Option<super::super::js_protocol::runtime::RemoteObject>,
            #[doc = "Node the listener is added to (if any)."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<super::dom::BackendNodeId>,
        }
        impl EventListener {
            pub fn builder() -> EventListenerBuilder {
                EventListenerBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EventListenerBuilder {
            r#type: Option<String>,
            use_capture: Option<bool>,
            passive: Option<bool>,
            once: Option<bool>,
            script_id: Option<super::super::js_protocol::runtime::ScriptId>,
            line_number: Option<i64>,
            column_number: Option<i64>,
            handler: Option<super::super::js_protocol::runtime::RemoteObject>,
            original_handler: Option<super::super::js_protocol::runtime::RemoteObject>,
            backend_node_id: Option<super::dom::BackendNodeId>,
        }
        impl EventListenerBuilder {
            pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn use_capture(mut self, use_capture: impl Into<bool>) -> Self {
                self.use_capture = Some(use_capture.into());
                self
            }
            pub fn passive(mut self, passive: impl Into<bool>) -> Self {
                self.passive = Some(passive.into());
                self
            }
            pub fn once(mut self, once: impl Into<bool>) -> Self {
                self.once = Some(once.into());
                self
            }
            pub fn script_id(
                mut self,
                script_id: impl Into<super::super::js_protocol::runtime::ScriptId>,
            ) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn line_number(mut self, line_number: impl Into<i64>) -> Self {
                self.line_number = Some(line_number.into());
                self
            }
            pub fn column_number(mut self, column_number: impl Into<i64>) -> Self {
                self.column_number = Some(column_number.into());
                self
            }
            pub fn handler(
                mut self,
                handler: impl Into<super::super::js_protocol::runtime::RemoteObject>,
            ) -> Self {
                self.handler = Some(handler.into());
                self
            }
            pub fn original_handler(
                mut self,
                original_handler: impl Into<super::super::js_protocol::runtime::RemoteObject>,
            ) -> Self {
                self.original_handler = Some(original_handler.into());
                self
            }
            pub fn backend_node_id(
                mut self,
                backend_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn build(self) -> Result<EventListener, String> {
                Ok(EventListener {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    use_capture: self.use_capture.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(use_capture))
                    })?,
                    passive: self.passive.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(passive))
                    })?,
                    once: self.once.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(once))
                    })?,
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                    line_number: self.line_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line_number))
                    })?,
                    column_number: self.column_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(column_number))
                    })?,
                    handler: self.handler,
                    original_handler: self.original_handler,
                    backend_node_id: self.backend_node_id,
                })
            }
        }
        impl EventListener {
            pub const IDENTIFIER: &'static str = "DOMDebugger.EventListener";
        }
        #[doc = "Returns event listeners of the given object.\n[getEventListeners](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-getEventListeners)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetEventListenersParams {
            #[doc = "Identifier of the object to return listeners for."]
            #[serde(rename = "objectId")]
            pub object_id: super::super::js_protocol::runtime::RemoteObjectId,
            #[doc = "The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for the\nentire subtree or provide an integer larger than 0."]
            #[serde(rename = "depth")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub depth: Option<i64>,
            #[doc = "Whether or not iframes and shadow roots should be traversed when returning the subtree\n(default is false). Reports listeners for all contexts if pierce is enabled."]
            #[serde(rename = "pierce")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pierce: Option<bool>,
        }
        impl GetEventListenersParams {
            pub fn new(
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                Self {
                    object_id: object_id.into(),
                    depth: None,
                    pierce: None,
                }
            }
        }
        impl GetEventListenersParams {
            pub fn builder() -> GetEventListenersParamsBuilder {
                GetEventListenersParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetEventListenersParamsBuilder {
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
            depth: Option<i64>,
            pierce: Option<bool>,
        }
        impl GetEventListenersParamsBuilder {
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn depth(mut self, depth: impl Into<i64>) -> Self {
                self.depth = Some(depth.into());
                self
            }
            pub fn pierce(mut self, pierce: impl Into<bool>) -> Self {
                self.pierce = Some(pierce.into());
                self
            }
            pub fn build(self) -> Result<GetEventListenersParams, String> {
                Ok(GetEventListenersParams {
                    object_id: self.object_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(object_id))
                    })?,
                    depth: self.depth,
                    pierce: self.pierce,
                })
            }
        }
        impl GetEventListenersParams {
            pub const IDENTIFIER: &'static str = "DOMDebugger.getEventListeners";
        }
        impl chromiumoxide_types::Method for GetEventListenersParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetEventListenersParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns event listeners of the given object.\n[getEventListeners](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-getEventListeners)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetEventListenersReturns {
            #[doc = "Array of relevant listeners."]
            #[serde(rename = "listeners")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub listeners: Vec<EventListener>,
        }
        impl GetEventListenersReturns {
            pub fn new(listeners: Vec<EventListener>) -> Self {
                Self { listeners }
            }
        }
        impl GetEventListenersReturns {
            pub fn builder() -> GetEventListenersReturnsBuilder {
                GetEventListenersReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetEventListenersReturnsBuilder {
            listeners: Option<Vec<EventListener>>,
        }
        impl GetEventListenersReturnsBuilder {
            pub fn listener(mut self, listener: impl Into<EventListener>) -> Self {
                let v = self.listeners.get_or_insert(Vec::new());
                v.push(listener.into());
                self
            }
            pub fn listeners<I, S>(mut self, listeners: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<EventListener>,
            {
                let v = self.listeners.get_or_insert(Vec::new());
                for val in listeners {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetEventListenersReturns, String> {
                Ok(GetEventListenersReturns {
                    listeners: self.listeners.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(listeners))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetEventListenersParams {
            type Response = GetEventListenersReturns;
        }
        #[doc = "Removes DOM breakpoint that was set using `setDOMBreakpoint`.\n[removeDOMBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-removeDOMBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoveDomBreakpointParams {
            #[doc = "Identifier of the node to remove breakpoint from."]
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
            #[doc = "Type of the breakpoint to remove."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: DomBreakpointType,
        }
        impl RemoveDomBreakpointParams {
            pub fn new(
                node_id: impl Into<super::dom::NodeId>,
                r#type: impl Into<DomBreakpointType>,
            ) -> Self {
                Self {
                    node_id: node_id.into(),
                    r#type: r#type.into(),
                }
            }
        }
        impl RemoveDomBreakpointParams {
            pub fn builder() -> RemoveDomBreakpointParamsBuilder {
                RemoveDomBreakpointParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoveDomBreakpointParamsBuilder {
            node_id: Option<super::dom::NodeId>,
            r#type: Option<DomBreakpointType>,
        }
        impl RemoveDomBreakpointParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<DomBreakpointType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn build(self) -> Result<RemoveDomBreakpointParams, String> {
                Ok(RemoveDomBreakpointParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                })
            }
        }
        impl RemoveDomBreakpointParams {
            pub const IDENTIFIER: &'static str = "DOMDebugger.removeDOMBreakpoint";
        }
        impl chromiumoxide_types::Method for RemoveDomBreakpointParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RemoveDomBreakpointParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Removes DOM breakpoint that was set using `setDOMBreakpoint`.\n[removeDOMBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-removeDOMBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RemoveDomBreakpointReturns {}
        impl chromiumoxide_types::Command for RemoveDomBreakpointParams {
            type Response = RemoveDomBreakpointReturns;
        }
        #[doc = "Removes breakpoint on particular DOM event.\n[removeEventListenerBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-removeEventListenerBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoveEventListenerBreakpointParams {
            #[doc = "Event name."]
            #[serde(rename = "eventName")]
            pub event_name: String,
            #[doc = "EventTarget interface name."]
            #[serde(rename = "targetName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub target_name: Option<String>,
        }
        impl RemoveEventListenerBreakpointParams {
            pub fn new(event_name: impl Into<String>) -> Self {
                Self {
                    event_name: event_name.into(),
                    target_name: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for RemoveEventListenerBreakpointParams {
            fn from(url: T) -> Self {
                RemoveEventListenerBreakpointParams::new(url)
            }
        }
        impl RemoveEventListenerBreakpointParams {
            pub fn builder() -> RemoveEventListenerBreakpointParamsBuilder {
                RemoveEventListenerBreakpointParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoveEventListenerBreakpointParamsBuilder {
            event_name: Option<String>,
            target_name: Option<String>,
        }
        impl RemoveEventListenerBreakpointParamsBuilder {
            pub fn event_name(mut self, event_name: impl Into<String>) -> Self {
                self.event_name = Some(event_name.into());
                self
            }
            pub fn target_name(mut self, target_name: impl Into<String>) -> Self {
                self.target_name = Some(target_name.into());
                self
            }
            pub fn build(self) -> Result<RemoveEventListenerBreakpointParams, String> {
                Ok(RemoveEventListenerBreakpointParams {
                    event_name: self.event_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(event_name))
                    })?,
                    target_name: self.target_name,
                })
            }
        }
        impl RemoveEventListenerBreakpointParams {
            pub const IDENTIFIER: &'static str = "DOMDebugger.removeEventListenerBreakpoint";
        }
        impl chromiumoxide_types::Method for RemoveEventListenerBreakpointParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RemoveEventListenerBreakpointParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Removes breakpoint on particular DOM event.\n[removeEventListenerBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-removeEventListenerBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RemoveEventListenerBreakpointReturns {}
        impl chromiumoxide_types::Command for RemoveEventListenerBreakpointParams {
            type Response = RemoveEventListenerBreakpointReturns;
        }
        #[doc = "Removes breakpoint on particular native event.\n[removeInstrumentationBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-removeInstrumentationBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoveInstrumentationBreakpointParams {
            #[doc = "Instrumentation name to stop on."]
            #[serde(rename = "eventName")]
            pub event_name: String,
        }
        impl RemoveInstrumentationBreakpointParams {
            pub fn new(event_name: impl Into<String>) -> Self {
                Self {
                    event_name: event_name.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for RemoveInstrumentationBreakpointParams {
            fn from(url: T) -> Self {
                RemoveInstrumentationBreakpointParams::new(url)
            }
        }
        impl RemoveInstrumentationBreakpointParams {
            pub fn builder() -> RemoveInstrumentationBreakpointParamsBuilder {
                RemoveInstrumentationBreakpointParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoveInstrumentationBreakpointParamsBuilder {
            event_name: Option<String>,
        }
        impl RemoveInstrumentationBreakpointParamsBuilder {
            pub fn event_name(mut self, event_name: impl Into<String>) -> Self {
                self.event_name = Some(event_name.into());
                self
            }
            pub fn build(self) -> Result<RemoveInstrumentationBreakpointParams, String> {
                Ok(RemoveInstrumentationBreakpointParams {
                    event_name: self.event_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(event_name))
                    })?,
                })
            }
        }
        impl RemoveInstrumentationBreakpointParams {
            pub const IDENTIFIER: &'static str = "DOMDebugger.removeInstrumentationBreakpoint";
        }
        impl chromiumoxide_types::Method for RemoveInstrumentationBreakpointParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RemoveInstrumentationBreakpointParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Removes breakpoint on particular native event.\n[removeInstrumentationBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-removeInstrumentationBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RemoveInstrumentationBreakpointReturns {}
        impl chromiumoxide_types::Command for RemoveInstrumentationBreakpointParams {
            type Response = RemoveInstrumentationBreakpointReturns;
        }
        #[doc = "Removes breakpoint from XMLHttpRequest.\n[removeXHRBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-removeXHRBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoveXhrBreakpointParams {
            #[doc = "Resource URL substring."]
            #[serde(rename = "url")]
            pub url: String,
        }
        impl RemoveXhrBreakpointParams {
            pub fn new(url: impl Into<String>) -> Self {
                Self { url: url.into() }
            }
        }
        impl<T: Into<String>> From<T> for RemoveXhrBreakpointParams {
            fn from(url: T) -> Self {
                RemoveXhrBreakpointParams::new(url)
            }
        }
        impl RemoveXhrBreakpointParams {
            pub fn builder() -> RemoveXhrBreakpointParamsBuilder {
                RemoveXhrBreakpointParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoveXhrBreakpointParamsBuilder {
            url: Option<String>,
        }
        impl RemoveXhrBreakpointParamsBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn build(self) -> Result<RemoveXhrBreakpointParams, String> {
                Ok(RemoveXhrBreakpointParams {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                })
            }
        }
        impl RemoveXhrBreakpointParams {
            pub const IDENTIFIER: &'static str = "DOMDebugger.removeXHRBreakpoint";
        }
        impl chromiumoxide_types::Method for RemoveXhrBreakpointParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RemoveXhrBreakpointParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Removes breakpoint from XMLHttpRequest.\n[removeXHRBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-removeXHRBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RemoveXhrBreakpointReturns {}
        impl chromiumoxide_types::Command for RemoveXhrBreakpointParams {
            type Response = RemoveXhrBreakpointReturns;
        }
        #[doc = "Sets breakpoint on particular CSP violations.\n[setBreakOnCSPViolation](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setBreakOnCSPViolation)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetBreakOnCspViolationParams {
            #[doc = "CSP Violations to stop upon."]
            #[serde(rename = "violationTypes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub violation_types: Vec<CspViolationType>,
        }
        impl SetBreakOnCspViolationParams {
            pub fn new(violation_types: Vec<CspViolationType>) -> Self {
                Self { violation_types }
            }
        }
        impl SetBreakOnCspViolationParams {
            pub fn builder() -> SetBreakOnCspViolationParamsBuilder {
                SetBreakOnCspViolationParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetBreakOnCspViolationParamsBuilder {
            violation_types: Option<Vec<CspViolationType>>,
        }
        impl SetBreakOnCspViolationParamsBuilder {
            pub fn violation_type(mut self, violation_type: impl Into<CspViolationType>) -> Self {
                let v = self.violation_types.get_or_insert(Vec::new());
                v.push(violation_type.into());
                self
            }
            pub fn violation_types<I, S>(mut self, violation_types: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CspViolationType>,
            {
                let v = self.violation_types.get_or_insert(Vec::new());
                for val in violation_types {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetBreakOnCspViolationParams, String> {
                Ok(SetBreakOnCspViolationParams {
                    violation_types: self.violation_types.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(violation_types))
                    })?,
                })
            }
        }
        impl SetBreakOnCspViolationParams {
            pub const IDENTIFIER: &'static str = "DOMDebugger.setBreakOnCSPViolation";
        }
        impl chromiumoxide_types::Method for SetBreakOnCspViolationParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetBreakOnCspViolationParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets breakpoint on particular CSP violations.\n[setBreakOnCSPViolation](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setBreakOnCSPViolation)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetBreakOnCspViolationReturns {}
        impl chromiumoxide_types::Command for SetBreakOnCspViolationParams {
            type Response = SetBreakOnCspViolationReturns;
        }
        #[doc = "Sets breakpoint on particular operation with DOM.\n[setDOMBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setDOMBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetDomBreakpointParams {
            #[doc = "Identifier of the node to set breakpoint on."]
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
            #[doc = "Type of the operation to stop upon."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: DomBreakpointType,
        }
        impl SetDomBreakpointParams {
            pub fn new(
                node_id: impl Into<super::dom::NodeId>,
                r#type: impl Into<DomBreakpointType>,
            ) -> Self {
                Self {
                    node_id: node_id.into(),
                    r#type: r#type.into(),
                }
            }
        }
        impl SetDomBreakpointParams {
            pub fn builder() -> SetDomBreakpointParamsBuilder {
                SetDomBreakpointParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetDomBreakpointParamsBuilder {
            node_id: Option<super::dom::NodeId>,
            r#type: Option<DomBreakpointType>,
        }
        impl SetDomBreakpointParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<DomBreakpointType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn build(self) -> Result<SetDomBreakpointParams, String> {
                Ok(SetDomBreakpointParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                })
            }
        }
        impl SetDomBreakpointParams {
            pub const IDENTIFIER: &'static str = "DOMDebugger.setDOMBreakpoint";
        }
        impl chromiumoxide_types::Method for SetDomBreakpointParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetDomBreakpointParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets breakpoint on particular operation with DOM.\n[setDOMBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setDOMBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetDomBreakpointReturns {}
        impl chromiumoxide_types::Command for SetDomBreakpointParams {
            type Response = SetDomBreakpointReturns;
        }
        #[doc = "Sets breakpoint on particular DOM event.\n[setEventListenerBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setEventListenerBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetEventListenerBreakpointParams {
            #[doc = "DOM Event name to stop on (any DOM event will do)."]
            #[serde(rename = "eventName")]
            pub event_name: String,
            #[doc = "EventTarget interface name to stop on. If equal to `\"*\"` or not provided, will stop on any\nEventTarget."]
            #[serde(rename = "targetName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub target_name: Option<String>,
        }
        impl SetEventListenerBreakpointParams {
            pub fn new(event_name: impl Into<String>) -> Self {
                Self {
                    event_name: event_name.into(),
                    target_name: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for SetEventListenerBreakpointParams {
            fn from(url: T) -> Self {
                SetEventListenerBreakpointParams::new(url)
            }
        }
        impl SetEventListenerBreakpointParams {
            pub fn builder() -> SetEventListenerBreakpointParamsBuilder {
                SetEventListenerBreakpointParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetEventListenerBreakpointParamsBuilder {
            event_name: Option<String>,
            target_name: Option<String>,
        }
        impl SetEventListenerBreakpointParamsBuilder {
            pub fn event_name(mut self, event_name: impl Into<String>) -> Self {
                self.event_name = Some(event_name.into());
                self
            }
            pub fn target_name(mut self, target_name: impl Into<String>) -> Self {
                self.target_name = Some(target_name.into());
                self
            }
            pub fn build(self) -> Result<SetEventListenerBreakpointParams, String> {
                Ok(SetEventListenerBreakpointParams {
                    event_name: self.event_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(event_name))
                    })?,
                    target_name: self.target_name,
                })
            }
        }
        impl SetEventListenerBreakpointParams {
            pub const IDENTIFIER: &'static str = "DOMDebugger.setEventListenerBreakpoint";
        }
        impl chromiumoxide_types::Method for SetEventListenerBreakpointParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetEventListenerBreakpointParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets breakpoint on particular DOM event.\n[setEventListenerBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setEventListenerBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetEventListenerBreakpointReturns {}
        impl chromiumoxide_types::Command for SetEventListenerBreakpointParams {
            type Response = SetEventListenerBreakpointReturns;
        }
        #[doc = "Sets breakpoint on particular native event.\n[setInstrumentationBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setInstrumentationBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetInstrumentationBreakpointParams {
            #[doc = "Instrumentation name to stop on."]
            #[serde(rename = "eventName")]
            pub event_name: String,
        }
        impl SetInstrumentationBreakpointParams {
            pub fn new(event_name: impl Into<String>) -> Self {
                Self {
                    event_name: event_name.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for SetInstrumentationBreakpointParams {
            fn from(url: T) -> Self {
                SetInstrumentationBreakpointParams::new(url)
            }
        }
        impl SetInstrumentationBreakpointParams {
            pub fn builder() -> SetInstrumentationBreakpointParamsBuilder {
                SetInstrumentationBreakpointParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetInstrumentationBreakpointParamsBuilder {
            event_name: Option<String>,
        }
        impl SetInstrumentationBreakpointParamsBuilder {
            pub fn event_name(mut self, event_name: impl Into<String>) -> Self {
                self.event_name = Some(event_name.into());
                self
            }
            pub fn build(self) -> Result<SetInstrumentationBreakpointParams, String> {
                Ok(SetInstrumentationBreakpointParams {
                    event_name: self.event_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(event_name))
                    })?,
                })
            }
        }
        impl SetInstrumentationBreakpointParams {
            pub const IDENTIFIER: &'static str = "DOMDebugger.setInstrumentationBreakpoint";
        }
        impl chromiumoxide_types::Method for SetInstrumentationBreakpointParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetInstrumentationBreakpointParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets breakpoint on particular native event.\n[setInstrumentationBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setInstrumentationBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetInstrumentationBreakpointReturns {}
        impl chromiumoxide_types::Command for SetInstrumentationBreakpointParams {
            type Response = SetInstrumentationBreakpointReturns;
        }
        #[doc = "Sets breakpoint on XMLHttpRequest.\n[setXHRBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setXHRBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetXhrBreakpointParams {
            #[doc = "Resource URL substring. All XHRs having this substring in the URL will get stopped upon."]
            #[serde(rename = "url")]
            pub url: String,
        }
        impl SetXhrBreakpointParams {
            pub fn new(url: impl Into<String>) -> Self {
                Self { url: url.into() }
            }
        }
        impl<T: Into<String>> From<T> for SetXhrBreakpointParams {
            fn from(url: T) -> Self {
                SetXhrBreakpointParams::new(url)
            }
        }
        impl SetXhrBreakpointParams {
            pub fn builder() -> SetXhrBreakpointParamsBuilder {
                SetXhrBreakpointParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetXhrBreakpointParamsBuilder {
            url: Option<String>,
        }
        impl SetXhrBreakpointParamsBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn build(self) -> Result<SetXhrBreakpointParams, String> {
                Ok(SetXhrBreakpointParams {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                })
            }
        }
        impl SetXhrBreakpointParams {
            pub const IDENTIFIER: &'static str = "DOMDebugger.setXHRBreakpoint";
        }
        impl chromiumoxide_types::Method for SetXhrBreakpointParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetXhrBreakpointParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets breakpoint on XMLHttpRequest.\n[setXHRBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setXHRBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetXhrBreakpointReturns {}
        impl chromiumoxide_types::Command for SetXhrBreakpointParams {
            type Response = SetXhrBreakpointReturns;
        }
    }
    #[doc = "EventBreakpoints permits setting breakpoints on particular operations and\nevents in targets that run JavaScript but do not have a DOM.\nJavaScript execution will stop on these operations as if there was a regular\nbreakpoint set."]
    pub mod event_breakpoints {
        use serde::{Deserialize, Serialize};
        #[doc = "Sets breakpoint on particular native event.\n[setInstrumentationBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/EventBreakpoints/#method-setInstrumentationBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetInstrumentationBreakpointParams {
            #[doc = "Instrumentation name to stop on."]
            #[serde(rename = "eventName")]
            pub event_name: String,
        }
        impl SetInstrumentationBreakpointParams {
            pub fn new(event_name: impl Into<String>) -> Self {
                Self {
                    event_name: event_name.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for SetInstrumentationBreakpointParams {
            fn from(url: T) -> Self {
                SetInstrumentationBreakpointParams::new(url)
            }
        }
        impl SetInstrumentationBreakpointParams {
            pub fn builder() -> SetInstrumentationBreakpointParamsBuilder {
                SetInstrumentationBreakpointParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetInstrumentationBreakpointParamsBuilder {
            event_name: Option<String>,
        }
        impl SetInstrumentationBreakpointParamsBuilder {
            pub fn event_name(mut self, event_name: impl Into<String>) -> Self {
                self.event_name = Some(event_name.into());
                self
            }
            pub fn build(self) -> Result<SetInstrumentationBreakpointParams, String> {
                Ok(SetInstrumentationBreakpointParams {
                    event_name: self.event_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(event_name))
                    })?,
                })
            }
        }
        impl SetInstrumentationBreakpointParams {
            pub const IDENTIFIER: &'static str = "EventBreakpoints.setInstrumentationBreakpoint";
        }
        impl chromiumoxide_types::Method for SetInstrumentationBreakpointParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetInstrumentationBreakpointParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets breakpoint on particular native event.\n[setInstrumentationBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/EventBreakpoints/#method-setInstrumentationBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetInstrumentationBreakpointReturns {}
        impl chromiumoxide_types::Command for SetInstrumentationBreakpointParams {
            type Response = SetInstrumentationBreakpointReturns;
        }
        #[doc = "Removes breakpoint on particular native event.\n[removeInstrumentationBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/EventBreakpoints/#method-removeInstrumentationBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoveInstrumentationBreakpointParams {
            #[doc = "Instrumentation name to stop on."]
            #[serde(rename = "eventName")]
            pub event_name: String,
        }
        impl RemoveInstrumentationBreakpointParams {
            pub fn new(event_name: impl Into<String>) -> Self {
                Self {
                    event_name: event_name.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for RemoveInstrumentationBreakpointParams {
            fn from(url: T) -> Self {
                RemoveInstrumentationBreakpointParams::new(url)
            }
        }
        impl RemoveInstrumentationBreakpointParams {
            pub fn builder() -> RemoveInstrumentationBreakpointParamsBuilder {
                RemoveInstrumentationBreakpointParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoveInstrumentationBreakpointParamsBuilder {
            event_name: Option<String>,
        }
        impl RemoveInstrumentationBreakpointParamsBuilder {
            pub fn event_name(mut self, event_name: impl Into<String>) -> Self {
                self.event_name = Some(event_name.into());
                self
            }
            pub fn build(self) -> Result<RemoveInstrumentationBreakpointParams, String> {
                Ok(RemoveInstrumentationBreakpointParams {
                    event_name: self.event_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(event_name))
                    })?,
                })
            }
        }
        impl RemoveInstrumentationBreakpointParams {
            pub const IDENTIFIER: &'static str = "EventBreakpoints.removeInstrumentationBreakpoint";
        }
        impl chromiumoxide_types::Method for RemoveInstrumentationBreakpointParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RemoveInstrumentationBreakpointParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Removes breakpoint on particular native event.\n[removeInstrumentationBreakpoint](https://chromedevtools.github.io/devtools-protocol/tot/EventBreakpoints/#method-removeInstrumentationBreakpoint)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RemoveInstrumentationBreakpointReturns {}
        impl chromiumoxide_types::Command for RemoveInstrumentationBreakpointParams {
            type Response = RemoveInstrumentationBreakpointReturns;
        }
    }
    #[doc = "This domain facilitates obtaining document snapshots with DOM, layout, and style information."]
    pub mod dom_snapshot {
        use serde::{Deserialize, Serialize};
        #[doc = "A Node in the DOM tree.\n[DOMNode](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#type-DOMNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DomNode {
            #[doc = "`Node`'s nodeType."]
            #[serde(rename = "nodeType")]
            pub node_type: i64,
            #[doc = "`Node`'s nodeName."]
            #[serde(rename = "nodeName")]
            pub node_name: String,
            #[doc = "`Node`'s nodeValue."]
            #[serde(rename = "nodeValue")]
            pub node_value: String,
            #[doc = "Only set for textarea elements, contains the text value."]
            #[serde(rename = "textValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub text_value: Option<String>,
            #[doc = "Only set for input elements, contains the input's associated text value."]
            #[serde(rename = "inputValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub input_value: Option<String>,
            #[doc = "Only set for radio and checkbox input elements, indicates if the element has been checked"]
            #[serde(rename = "inputChecked")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub input_checked: Option<bool>,
            #[doc = "Only set for option elements, indicates if the element has been selected"]
            #[serde(rename = "optionSelected")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub option_selected: Option<bool>,
            #[doc = "`Node`'s id, corresponds to DOM.Node.backendNodeId."]
            #[serde(rename = "backendNodeId")]
            pub backend_node_id: super::dom::BackendNodeId,
            #[doc = "The indexes of the node's child nodes in the `domNodes` array returned by `getSnapshot`, if\nany."]
            #[serde(rename = "childNodeIndexes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub child_node_indexes: Option<Vec<i64>>,
            #[doc = "Attributes of an `Element` node."]
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub attributes: Option<Vec<NameValue>>,
            #[doc = "Indexes of pseudo elements associated with this node in the `domNodes` array returned by\n`getSnapshot`, if any."]
            #[serde(rename = "pseudoElementIndexes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pseudo_element_indexes: Option<Vec<i64>>,
            #[doc = "The index of the node's related layout tree node in the `layoutTreeNodes` array returned by\n`getSnapshot`, if any."]
            #[serde(rename = "layoutNodeIndex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub layout_node_index: Option<i64>,
            #[doc = "Document URL that `Document` or `FrameOwner` node points to."]
            #[serde(rename = "documentURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub document_url: Option<String>,
            #[doc = "Base URL that `Document` or `FrameOwner` node uses for URL completion."]
            #[serde(rename = "baseURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub base_url: Option<String>,
            #[doc = "Only set for documents, contains the document's content language."]
            #[serde(rename = "contentLanguage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub content_language: Option<String>,
            #[doc = "Only set for documents, contains the document's character set encoding."]
            #[serde(rename = "documentEncoding")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub document_encoding: Option<String>,
            #[doc = "`DocumentType` node's publicId."]
            #[serde(rename = "publicId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub public_id: Option<String>,
            #[doc = "`DocumentType` node's systemId."]
            #[serde(rename = "systemId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub system_id: Option<String>,
            #[doc = "Frame ID for frame owner elements and also for the document node."]
            #[serde(rename = "frameId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_id: Option<super::page::FrameId>,
            #[doc = "The index of a frame owner element's content document in the `domNodes` array returned by\n`getSnapshot`, if any."]
            #[serde(rename = "contentDocumentIndex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub content_document_index: Option<i64>,
            #[doc = "Type of a pseudo element node."]
            #[serde(rename = "pseudoType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub pseudo_type: Option<super::dom::PseudoType>,
            #[doc = "Shadow root type."]
            #[serde(rename = "shadowRootType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub shadow_root_type: Option<super::dom::ShadowRootType>,
            #[doc = "Whether this DOM node responds to mouse clicks. This includes nodes that have had click\nevent listeners attached via JavaScript as well as anchor tags that naturally navigate when\nclicked."]
            #[serde(rename = "isClickable")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_clickable: Option<bool>,
            #[doc = "Details of the node's event listeners, if any."]
            #[serde(rename = "eventListeners")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub event_listeners: Option<Vec<super::dom_debugger::EventListener>>,
            #[doc = "The selected url for nodes with a srcset attribute."]
            #[serde(rename = "currentSourceURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub current_source_url: Option<String>,
            #[doc = "The url of the script (if any) that generates this node."]
            #[serde(rename = "originURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub origin_url: Option<String>,
            #[doc = "Scroll offsets, set when this node is a Document."]
            #[serde(rename = "scrollOffsetX")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub scroll_offset_x: Option<f64>,
            #[serde(rename = "scrollOffsetY")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub scroll_offset_y: Option<f64>,
        }
        impl DomNode {
            pub fn new(
                node_type: impl Into<i64>,
                node_name: impl Into<String>,
                node_value: impl Into<String>,
                backend_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                Self {
                    node_type: node_type.into(),
                    node_name: node_name.into(),
                    node_value: node_value.into(),
                    backend_node_id: backend_node_id.into(),
                    text_value: None,
                    input_value: None,
                    input_checked: None,
                    option_selected: None,
                    child_node_indexes: None,
                    attributes: None,
                    pseudo_element_indexes: None,
                    layout_node_index: None,
                    document_url: None,
                    base_url: None,
                    content_language: None,
                    document_encoding: None,
                    public_id: None,
                    system_id: None,
                    frame_id: None,
                    content_document_index: None,
                    pseudo_type: None,
                    shadow_root_type: None,
                    is_clickable: None,
                    event_listeners: None,
                    current_source_url: None,
                    origin_url: None,
                    scroll_offset_x: None,
                    scroll_offset_y: None,
                }
            }
        }
        impl DomNode {
            pub fn builder() -> DomNodeBuilder {
                DomNodeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DomNodeBuilder {
            node_type: Option<i64>,
            node_name: Option<String>,
            node_value: Option<String>,
            text_value: Option<String>,
            input_value: Option<String>,
            input_checked: Option<bool>,
            option_selected: Option<bool>,
            backend_node_id: Option<super::dom::BackendNodeId>,
            child_node_indexes: Option<Vec<i64>>,
            attributes: Option<Vec<NameValue>>,
            pseudo_element_indexes: Option<Vec<i64>>,
            layout_node_index: Option<i64>,
            document_url: Option<String>,
            base_url: Option<String>,
            content_language: Option<String>,
            document_encoding: Option<String>,
            public_id: Option<String>,
            system_id: Option<String>,
            frame_id: Option<super::page::FrameId>,
            content_document_index: Option<i64>,
            pseudo_type: Option<super::dom::PseudoType>,
            shadow_root_type: Option<super::dom::ShadowRootType>,
            is_clickable: Option<bool>,
            event_listeners: Option<Vec<super::dom_debugger::EventListener>>,
            current_source_url: Option<String>,
            origin_url: Option<String>,
            scroll_offset_x: Option<f64>,
            scroll_offset_y: Option<f64>,
        }
        impl DomNodeBuilder {
            pub fn node_type(mut self, node_type: impl Into<i64>) -> Self {
                self.node_type = Some(node_type.into());
                self
            }
            pub fn node_name(mut self, node_name: impl Into<String>) -> Self {
                self.node_name = Some(node_name.into());
                self
            }
            pub fn node_value(mut self, node_value: impl Into<String>) -> Self {
                self.node_value = Some(node_value.into());
                self
            }
            pub fn text_value(mut self, text_value: impl Into<String>) -> Self {
                self.text_value = Some(text_value.into());
                self
            }
            pub fn input_value(mut self, input_value: impl Into<String>) -> Self {
                self.input_value = Some(input_value.into());
                self
            }
            pub fn input_checked(mut self, input_checked: impl Into<bool>) -> Self {
                self.input_checked = Some(input_checked.into());
                self
            }
            pub fn option_selected(mut self, option_selected: impl Into<bool>) -> Self {
                self.option_selected = Some(option_selected.into());
                self
            }
            pub fn backend_node_id(
                mut self,
                backend_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn child_node_indexe(mut self, child_node_indexe: impl Into<i64>) -> Self {
                let v = self.child_node_indexes.get_or_insert(Vec::new());
                v.push(child_node_indexe.into());
                self
            }
            pub fn child_node_indexes<I, S>(mut self, child_node_indexes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.child_node_indexes.get_or_insert(Vec::new());
                for val in child_node_indexes {
                    v.push(val.into());
                }
                self
            }
            pub fn attribute(mut self, attribute: impl Into<NameValue>) -> Self {
                let v = self.attributes.get_or_insert(Vec::new());
                v.push(attribute.into());
                self
            }
            pub fn attributes<I, S>(mut self, attributes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<NameValue>,
            {
                let v = self.attributes.get_or_insert(Vec::new());
                for val in attributes {
                    v.push(val.into());
                }
                self
            }
            pub fn pseudo_element_indexe(mut self, pseudo_element_indexe: impl Into<i64>) -> Self {
                let v = self.pseudo_element_indexes.get_or_insert(Vec::new());
                v.push(pseudo_element_indexe.into());
                self
            }
            pub fn pseudo_element_indexes<I, S>(mut self, pseudo_element_indexes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.pseudo_element_indexes.get_or_insert(Vec::new());
                for val in pseudo_element_indexes {
                    v.push(val.into());
                }
                self
            }
            pub fn layout_node_index(mut self, layout_node_index: impl Into<i64>) -> Self {
                self.layout_node_index = Some(layout_node_index.into());
                self
            }
            pub fn document_url(mut self, document_url: impl Into<String>) -> Self {
                self.document_url = Some(document_url.into());
                self
            }
            pub fn base_url(mut self, base_url: impl Into<String>) -> Self {
                self.base_url = Some(base_url.into());
                self
            }
            pub fn content_language(mut self, content_language: impl Into<String>) -> Self {
                self.content_language = Some(content_language.into());
                self
            }
            pub fn document_encoding(mut self, document_encoding: impl Into<String>) -> Self {
                self.document_encoding = Some(document_encoding.into());
                self
            }
            pub fn public_id(mut self, public_id: impl Into<String>) -> Self {
                self.public_id = Some(public_id.into());
                self
            }
            pub fn system_id(mut self, system_id: impl Into<String>) -> Self {
                self.system_id = Some(system_id.into());
                self
            }
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn content_document_index(
                mut self,
                content_document_index: impl Into<i64>,
            ) -> Self {
                self.content_document_index = Some(content_document_index.into());
                self
            }
            pub fn pseudo_type(mut self, pseudo_type: impl Into<super::dom::PseudoType>) -> Self {
                self.pseudo_type = Some(pseudo_type.into());
                self
            }
            pub fn shadow_root_type(
                mut self,
                shadow_root_type: impl Into<super::dom::ShadowRootType>,
            ) -> Self {
                self.shadow_root_type = Some(shadow_root_type.into());
                self
            }
            pub fn is_clickable(mut self, is_clickable: impl Into<bool>) -> Self {
                self.is_clickable = Some(is_clickable.into());
                self
            }
            pub fn event_listener(
                mut self,
                event_listener: impl Into<super::dom_debugger::EventListener>,
            ) -> Self {
                let v = self.event_listeners.get_or_insert(Vec::new());
                v.push(event_listener.into());
                self
            }
            pub fn event_listeners<I, S>(mut self, event_listeners: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<super::dom_debugger::EventListener>,
            {
                let v = self.event_listeners.get_or_insert(Vec::new());
                for val in event_listeners {
                    v.push(val.into());
                }
                self
            }
            pub fn current_source_url(mut self, current_source_url: impl Into<String>) -> Self {
                self.current_source_url = Some(current_source_url.into());
                self
            }
            pub fn origin_url(mut self, origin_url: impl Into<String>) -> Self {
                self.origin_url = Some(origin_url.into());
                self
            }
            pub fn scroll_offset_x(mut self, scroll_offset_x: impl Into<f64>) -> Self {
                self.scroll_offset_x = Some(scroll_offset_x.into());
                self
            }
            pub fn scroll_offset_y(mut self, scroll_offset_y: impl Into<f64>) -> Self {
                self.scroll_offset_y = Some(scroll_offset_y.into());
                self
            }
            pub fn build(self) -> Result<DomNode, String> {
                Ok(DomNode {
                    node_type: self.node_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_type))
                    })?,
                    node_name: self.node_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_name))
                    })?,
                    node_value: self.node_value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_value))
                    })?,
                    text_value: self.text_value,
                    input_value: self.input_value,
                    input_checked: self.input_checked,
                    option_selected: self.option_selected,
                    backend_node_id: self.backend_node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(backend_node_id))
                    })?,
                    child_node_indexes: self.child_node_indexes,
                    attributes: self.attributes,
                    pseudo_element_indexes: self.pseudo_element_indexes,
                    layout_node_index: self.layout_node_index,
                    document_url: self.document_url,
                    base_url: self.base_url,
                    content_language: self.content_language,
                    document_encoding: self.document_encoding,
                    public_id: self.public_id,
                    system_id: self.system_id,
                    frame_id: self.frame_id,
                    content_document_index: self.content_document_index,
                    pseudo_type: self.pseudo_type,
                    shadow_root_type: self.shadow_root_type,
                    is_clickable: self.is_clickable,
                    event_listeners: self.event_listeners,
                    current_source_url: self.current_source_url,
                    origin_url: self.origin_url,
                    scroll_offset_x: self.scroll_offset_x,
                    scroll_offset_y: self.scroll_offset_y,
                })
            }
        }
        impl DomNode {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.DOMNode";
        }
        #[doc = "Details of post layout rendered text positions. The exact layout should not be regarded as\nstable and may change between versions.\n[InlineTextBox](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#type-InlineTextBox)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InlineTextBox {
            #[doc = "The bounding box in document coordinates. Note that scroll offset of the document is ignored."]
            #[serde(rename = "boundingBox")]
            pub bounding_box: super::dom::Rect,
            #[doc = "The starting index in characters, for this post layout textbox substring. Characters that\nwould be represented as a surrogate pair in UTF-16 have length 2."]
            #[serde(rename = "startCharacterIndex")]
            pub start_character_index: i64,
            #[doc = "The number of characters in this post layout textbox substring. Characters that would be\nrepresented as a surrogate pair in UTF-16 have length 2."]
            #[serde(rename = "numCharacters")]
            pub num_characters: i64,
        }
        impl InlineTextBox {
            pub fn new(
                bounding_box: impl Into<super::dom::Rect>,
                start_character_index: impl Into<i64>,
                num_characters: impl Into<i64>,
            ) -> Self {
                Self {
                    bounding_box: bounding_box.into(),
                    start_character_index: start_character_index.into(),
                    num_characters: num_characters.into(),
                }
            }
        }
        impl InlineTextBox {
            pub fn builder() -> InlineTextBoxBuilder {
                InlineTextBoxBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct InlineTextBoxBuilder {
            bounding_box: Option<super::dom::Rect>,
            start_character_index: Option<i64>,
            num_characters: Option<i64>,
        }
        impl InlineTextBoxBuilder {
            pub fn bounding_box(mut self, bounding_box: impl Into<super::dom::Rect>) -> Self {
                self.bounding_box = Some(bounding_box.into());
                self
            }
            pub fn start_character_index(mut self, start_character_index: impl Into<i64>) -> Self {
                self.start_character_index = Some(start_character_index.into());
                self
            }
            pub fn num_characters(mut self, num_characters: impl Into<i64>) -> Self {
                self.num_characters = Some(num_characters.into());
                self
            }
            pub fn build(self) -> Result<InlineTextBox, String> {
                Ok(InlineTextBox {
                    bounding_box: self.bounding_box.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(bounding_box))
                    })?,
                    start_character_index: self.start_character_index.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(start_character_index)
                        )
                    })?,
                    num_characters: self.num_characters.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(num_characters))
                    })?,
                })
            }
        }
        impl InlineTextBox {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.InlineTextBox";
        }
        #[doc = "Details of an element in the DOM tree with a LayoutObject.\n[LayoutTreeNode](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#type-LayoutTreeNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LayoutTreeNode {
            #[doc = "The index of the related DOM node in the `domNodes` array returned by `getSnapshot`."]
            #[serde(rename = "domNodeIndex")]
            pub dom_node_index: i64,
            #[doc = "The bounding box in document coordinates. Note that scroll offset of the document is ignored."]
            #[serde(rename = "boundingBox")]
            pub bounding_box: super::dom::Rect,
            #[doc = "Contents of the LayoutText, if any."]
            #[serde(rename = "layoutText")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub layout_text: Option<String>,
            #[doc = "The post-layout inline text nodes, if any."]
            #[serde(rename = "inlineTextNodes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub inline_text_nodes: Option<Vec<InlineTextBox>>,
            #[doc = "Index into the `computedStyles` array returned by `getSnapshot`."]
            #[serde(rename = "styleIndex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub style_index: Option<i64>,
            #[doc = "Global paint order index, which is determined by the stacking order of the nodes. Nodes\nthat are painted together will have the same index. Only provided if includePaintOrder in\ngetSnapshot was true."]
            #[serde(rename = "paintOrder")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub paint_order: Option<i64>,
            #[doc = "Set to true to indicate the element begins a new stacking context."]
            #[serde(rename = "isStackingContext")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_stacking_context: Option<bool>,
        }
        impl LayoutTreeNode {
            pub fn new(
                dom_node_index: impl Into<i64>,
                bounding_box: impl Into<super::dom::Rect>,
            ) -> Self {
                Self {
                    dom_node_index: dom_node_index.into(),
                    bounding_box: bounding_box.into(),
                    layout_text: None,
                    inline_text_nodes: None,
                    style_index: None,
                    paint_order: None,
                    is_stacking_context: None,
                }
            }
        }
        impl LayoutTreeNode {
            pub fn builder() -> LayoutTreeNodeBuilder {
                LayoutTreeNodeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LayoutTreeNodeBuilder {
            dom_node_index: Option<i64>,
            bounding_box: Option<super::dom::Rect>,
            layout_text: Option<String>,
            inline_text_nodes: Option<Vec<InlineTextBox>>,
            style_index: Option<i64>,
            paint_order: Option<i64>,
            is_stacking_context: Option<bool>,
        }
        impl LayoutTreeNodeBuilder {
            pub fn dom_node_index(mut self, dom_node_index: impl Into<i64>) -> Self {
                self.dom_node_index = Some(dom_node_index.into());
                self
            }
            pub fn bounding_box(mut self, bounding_box: impl Into<super::dom::Rect>) -> Self {
                self.bounding_box = Some(bounding_box.into());
                self
            }
            pub fn layout_text(mut self, layout_text: impl Into<String>) -> Self {
                self.layout_text = Some(layout_text.into());
                self
            }
            pub fn inline_text_node(mut self, inline_text_node: impl Into<InlineTextBox>) -> Self {
                let v = self.inline_text_nodes.get_or_insert(Vec::new());
                v.push(inline_text_node.into());
                self
            }
            pub fn inline_text_nodes<I, S>(mut self, inline_text_nodes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<InlineTextBox>,
            {
                let v = self.inline_text_nodes.get_or_insert(Vec::new());
                for val in inline_text_nodes {
                    v.push(val.into());
                }
                self
            }
            pub fn style_index(mut self, style_index: impl Into<i64>) -> Self {
                self.style_index = Some(style_index.into());
                self
            }
            pub fn paint_order(mut self, paint_order: impl Into<i64>) -> Self {
                self.paint_order = Some(paint_order.into());
                self
            }
            pub fn is_stacking_context(mut self, is_stacking_context: impl Into<bool>) -> Self {
                self.is_stacking_context = Some(is_stacking_context.into());
                self
            }
            pub fn build(self) -> Result<LayoutTreeNode, String> {
                Ok(LayoutTreeNode {
                    dom_node_index: self.dom_node_index.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(dom_node_index))
                    })?,
                    bounding_box: self.bounding_box.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(bounding_box))
                    })?,
                    layout_text: self.layout_text,
                    inline_text_nodes: self.inline_text_nodes,
                    style_index: self.style_index,
                    paint_order: self.paint_order,
                    is_stacking_context: self.is_stacking_context,
                })
            }
        }
        impl LayoutTreeNode {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.LayoutTreeNode";
        }
        #[doc = "A subset of the full ComputedStyle as defined by the request whitelist.\n[ComputedStyle](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#type-ComputedStyle)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ComputedStyle {
            #[doc = "Name/value pairs of computed style properties."]
            #[serde(rename = "properties")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub properties: Vec<NameValue>,
        }
        impl ComputedStyle {
            pub fn new(properties: Vec<NameValue>) -> Self {
                Self { properties }
            }
        }
        impl ComputedStyle {
            pub fn builder() -> ComputedStyleBuilder {
                ComputedStyleBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ComputedStyleBuilder {
            properties: Option<Vec<NameValue>>,
        }
        impl ComputedStyleBuilder {
            pub fn propertie(mut self, propertie: impl Into<NameValue>) -> Self {
                let v = self.properties.get_or_insert(Vec::new());
                v.push(propertie.into());
                self
            }
            pub fn properties<I, S>(mut self, properties: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<NameValue>,
            {
                let v = self.properties.get_or_insert(Vec::new());
                for val in properties {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<ComputedStyle, String> {
                Ok(ComputedStyle {
                    properties: self.properties.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(properties))
                    })?,
                })
            }
        }
        impl ComputedStyle {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.ComputedStyle";
        }
        #[doc = "A name/value pair.\n[NameValue](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#type-NameValue)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct NameValue {
            #[doc = "Attribute/property name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Attribute/property value."]
            #[serde(rename = "value")]
            pub value: String,
        }
        impl NameValue {
            pub fn new(name: impl Into<String>, value: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                }
            }
        }
        impl NameValue {
            pub fn builder() -> NameValueBuilder {
                NameValueBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct NameValueBuilder {
            name: Option<String>,
            value: Option<String>,
        }
        impl NameValueBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<NameValue, String> {
                Ok(NameValue {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl NameValue {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.NameValue";
        }
        #[doc = "Index of the string in the strings table.\n[StringIndex](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#type-StringIndex)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Copy, Hash)]
        pub struct StringIndex(i64);
        impl StringIndex {
            pub fn new(val: impl Into<i64>) -> Self {
                StringIndex(val.into())
            }
            pub fn inner(&self) -> &i64 {
                &self.0
            }
        }
        impl StringIndex {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.StringIndex";
        }
        #[doc = "Index of the string in the strings table.\n[ArrayOfStrings](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#type-ArrayOfStrings)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ArrayOfStrings(Vec<StringIndex>);
        impl ArrayOfStrings {
            pub fn new(val: impl Into<Vec<StringIndex>>) -> Self {
                ArrayOfStrings(val.into())
            }
            pub fn inner(&self) -> &Vec<StringIndex> {
                &self.0
            }
        }
        impl ArrayOfStrings {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.ArrayOfStrings";
        }
        #[doc = "Data that is only present on rare nodes.\n[RareStringData](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#type-RareStringData)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RareStringData {
            #[serde(rename = "index")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub index: Vec<i64>,
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub value: Vec<StringIndex>,
        }
        impl RareStringData {
            pub fn new(index: Vec<i64>, value: Vec<StringIndex>) -> Self {
                Self { index, value }
            }
        }
        impl RareStringData {
            pub fn builder() -> RareStringDataBuilder {
                RareStringDataBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RareStringDataBuilder {
            index: Option<Vec<i64>>,
            value: Option<Vec<StringIndex>>,
        }
        impl RareStringDataBuilder {
            pub fn index(mut self, index: impl Into<i64>) -> Self {
                let v = self.index.get_or_insert(Vec::new());
                v.push(index.into());
                self
            }
            pub fn indexs<I, S>(mut self, indexs: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.index.get_or_insert(Vec::new());
                for val in indexs {
                    v.push(val.into());
                }
                self
            }
            pub fn value(mut self, value: impl Into<StringIndex>) -> Self {
                let v = self.value.get_or_insert(Vec::new());
                v.push(value.into());
                self
            }
            pub fn values<I, S>(mut self, values: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<StringIndex>,
            {
                let v = self.value.get_or_insert(Vec::new());
                for val in values {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<RareStringData, String> {
                Ok(RareStringData {
                    index: self.index.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(index))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl RareStringData {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.RareStringData";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RareBooleanData {
            #[serde(rename = "index")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub index: Vec<i64>,
        }
        impl RareBooleanData {
            pub fn new(index: Vec<i64>) -> Self {
                Self { index }
            }
        }
        impl RareBooleanData {
            pub fn builder() -> RareBooleanDataBuilder {
                RareBooleanDataBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RareBooleanDataBuilder {
            index: Option<Vec<i64>>,
        }
        impl RareBooleanDataBuilder {
            pub fn index(mut self, index: impl Into<i64>) -> Self {
                let v = self.index.get_or_insert(Vec::new());
                v.push(index.into());
                self
            }
            pub fn indexs<I, S>(mut self, indexs: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.index.get_or_insert(Vec::new());
                for val in indexs {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<RareBooleanData, String> {
                Ok(RareBooleanData {
                    index: self.index.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(index))
                    })?,
                })
            }
        }
        impl RareBooleanData {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.RareBooleanData";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RareIntegerData {
            #[serde(rename = "index")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub index: Vec<i64>,
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub value: Vec<i64>,
        }
        impl RareIntegerData {
            pub fn new(index: Vec<i64>, value: Vec<i64>) -> Self {
                Self { index, value }
            }
        }
        impl RareIntegerData {
            pub fn builder() -> RareIntegerDataBuilder {
                RareIntegerDataBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RareIntegerDataBuilder {
            index: Option<Vec<i64>>,
            value: Option<Vec<i64>>,
        }
        impl RareIntegerDataBuilder {
            pub fn index(mut self, index: impl Into<i64>) -> Self {
                let v = self.index.get_or_insert(Vec::new());
                v.push(index.into());
                self
            }
            pub fn indexs<I, S>(mut self, indexs: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.index.get_or_insert(Vec::new());
                for val in indexs {
                    v.push(val.into());
                }
                self
            }
            pub fn value(mut self, value: impl Into<i64>) -> Self {
                let v = self.value.get_or_insert(Vec::new());
                v.push(value.into());
                self
            }
            pub fn values<I, S>(mut self, values: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.value.get_or_insert(Vec::new());
                for val in values {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<RareIntegerData, String> {
                Ok(RareIntegerData {
                    index: self.index.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(index))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl RareIntegerData {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.RareIntegerData";
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct Rectangle(Vec<f64>);
        impl Rectangle {
            pub fn new(val: impl Into<Vec<f64>>) -> Self {
                Rectangle(val.into())
            }
            pub fn inner(&self) -> &Vec<f64> {
                &self.0
            }
        }
        impl Rectangle {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.Rectangle";
        }
        #[doc = "Document snapshot.\n[DocumentSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#type-DocumentSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DocumentSnapshot {
            #[doc = "Document URL that `Document` or `FrameOwner` node points to."]
            #[serde(rename = "documentURL")]
            pub document_url: StringIndex,
            #[doc = "Document title."]
            #[serde(rename = "title")]
            pub title: StringIndex,
            #[doc = "Base URL that `Document` or `FrameOwner` node uses for URL completion."]
            #[serde(rename = "baseURL")]
            pub base_url: StringIndex,
            #[doc = "Contains the document's content language."]
            #[serde(rename = "contentLanguage")]
            pub content_language: StringIndex,
            #[doc = "Contains the document's character set encoding."]
            #[serde(rename = "encodingName")]
            pub encoding_name: StringIndex,
            #[doc = "`DocumentType` node's publicId."]
            #[serde(rename = "publicId")]
            pub public_id: StringIndex,
            #[doc = "`DocumentType` node's systemId."]
            #[serde(rename = "systemId")]
            pub system_id: StringIndex,
            #[doc = "Frame ID for frame owner elements and also for the document node."]
            #[serde(rename = "frameId")]
            pub frame_id: StringIndex,
            #[doc = "A table with dom nodes."]
            #[serde(rename = "nodes")]
            pub nodes: NodeTreeSnapshot,
            #[doc = "The nodes in the layout tree."]
            #[serde(rename = "layout")]
            pub layout: LayoutTreeSnapshot,
            #[doc = "The post-layout inline text nodes."]
            #[serde(rename = "textBoxes")]
            pub text_boxes: TextBoxSnapshot,
            #[doc = "Horizontal scroll offset."]
            #[serde(rename = "scrollOffsetX")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub scroll_offset_x: Option<f64>,
            #[doc = "Vertical scroll offset."]
            #[serde(rename = "scrollOffsetY")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub scroll_offset_y: Option<f64>,
            #[doc = "Document content width."]
            #[serde(rename = "contentWidth")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub content_width: Option<f64>,
            #[doc = "Document content height."]
            #[serde(rename = "contentHeight")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub content_height: Option<f64>,
        }
        impl DocumentSnapshot {
            pub fn builder() -> DocumentSnapshotBuilder {
                DocumentSnapshotBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DocumentSnapshotBuilder {
            document_url: Option<StringIndex>,
            title: Option<StringIndex>,
            base_url: Option<StringIndex>,
            content_language: Option<StringIndex>,
            encoding_name: Option<StringIndex>,
            public_id: Option<StringIndex>,
            system_id: Option<StringIndex>,
            frame_id: Option<StringIndex>,
            nodes: Option<NodeTreeSnapshot>,
            layout: Option<LayoutTreeSnapshot>,
            text_boxes: Option<TextBoxSnapshot>,
            scroll_offset_x: Option<f64>,
            scroll_offset_y: Option<f64>,
            content_width: Option<f64>,
            content_height: Option<f64>,
        }
        impl DocumentSnapshotBuilder {
            pub fn document_url(mut self, document_url: impl Into<StringIndex>) -> Self {
                self.document_url = Some(document_url.into());
                self
            }
            pub fn title(mut self, title: impl Into<StringIndex>) -> Self {
                self.title = Some(title.into());
                self
            }
            pub fn base_url(mut self, base_url: impl Into<StringIndex>) -> Self {
                self.base_url = Some(base_url.into());
                self
            }
            pub fn content_language(mut self, content_language: impl Into<StringIndex>) -> Self {
                self.content_language = Some(content_language.into());
                self
            }
            pub fn encoding_name(mut self, encoding_name: impl Into<StringIndex>) -> Self {
                self.encoding_name = Some(encoding_name.into());
                self
            }
            pub fn public_id(mut self, public_id: impl Into<StringIndex>) -> Self {
                self.public_id = Some(public_id.into());
                self
            }
            pub fn system_id(mut self, system_id: impl Into<StringIndex>) -> Self {
                self.system_id = Some(system_id.into());
                self
            }
            pub fn frame_id(mut self, frame_id: impl Into<StringIndex>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn nodes(mut self, nodes: impl Into<NodeTreeSnapshot>) -> Self {
                self.nodes = Some(nodes.into());
                self
            }
            pub fn layout(mut self, layout: impl Into<LayoutTreeSnapshot>) -> Self {
                self.layout = Some(layout.into());
                self
            }
            pub fn text_boxes(mut self, text_boxes: impl Into<TextBoxSnapshot>) -> Self {
                self.text_boxes = Some(text_boxes.into());
                self
            }
            pub fn scroll_offset_x(mut self, scroll_offset_x: impl Into<f64>) -> Self {
                self.scroll_offset_x = Some(scroll_offset_x.into());
                self
            }
            pub fn scroll_offset_y(mut self, scroll_offset_y: impl Into<f64>) -> Self {
                self.scroll_offset_y = Some(scroll_offset_y.into());
                self
            }
            pub fn content_width(mut self, content_width: impl Into<f64>) -> Self {
                self.content_width = Some(content_width.into());
                self
            }
            pub fn content_height(mut self, content_height: impl Into<f64>) -> Self {
                self.content_height = Some(content_height.into());
                self
            }
            pub fn build(self) -> Result<DocumentSnapshot, String> {
                Ok(DocumentSnapshot {
                    document_url: self.document_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(document_url))
                    })?,
                    title: self.title.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(title))
                    })?,
                    base_url: self.base_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(base_url))
                    })?,
                    content_language: self.content_language.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(content_language)
                        )
                    })?,
                    encoding_name: self.encoding_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(encoding_name))
                    })?,
                    public_id: self.public_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(public_id))
                    })?,
                    system_id: self.system_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(system_id))
                    })?,
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                    nodes: self.nodes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(nodes))
                    })?,
                    layout: self.layout.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(layout))
                    })?,
                    text_boxes: self.text_boxes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text_boxes))
                    })?,
                    scroll_offset_x: self.scroll_offset_x,
                    scroll_offset_y: self.scroll_offset_y,
                    content_width: self.content_width,
                    content_height: self.content_height,
                })
            }
        }
        impl DocumentSnapshot {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.DocumentSnapshot";
        }
        #[doc = "Table containing nodes.\n[NodeTreeSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#type-NodeTreeSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct NodeTreeSnapshot {
            #[doc = "Parent node index."]
            #[serde(rename = "parentIndex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub parent_index: Option<Vec<i64>>,
            #[doc = "`Node`'s nodeType."]
            #[serde(rename = "nodeType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_type: Option<Vec<i64>>,
            #[doc = "Type of the shadow root the `Node` is in. String values are equal to the `ShadowRootType` enum."]
            #[serde(rename = "shadowRootType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub shadow_root_type: Option<RareStringData>,
            #[doc = "`Node`'s nodeName."]
            #[serde(rename = "nodeName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_name: Option<Vec<StringIndex>>,
            #[doc = "`Node`'s nodeValue."]
            #[serde(rename = "nodeValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_value: Option<Vec<StringIndex>>,
            #[doc = "`Node`'s id, corresponds to DOM.Node.backendNodeId."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<Vec<super::dom::BackendNodeId>>,
            #[doc = "Attributes of an `Element` node. Flatten name, value pairs."]
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub attributes: Option<Vec<ArrayOfStrings>>,
            #[doc = "Only set for textarea elements, contains the text value."]
            #[serde(rename = "textValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub text_value: Option<RareStringData>,
            #[doc = "Only set for input elements, contains the input's associated text value."]
            #[serde(rename = "inputValue")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub input_value: Option<RareStringData>,
            #[doc = "Only set for radio and checkbox input elements, indicates if the element has been checked"]
            #[serde(rename = "inputChecked")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub input_checked: Option<RareBooleanData>,
            #[doc = "Only set for option elements, indicates if the element has been selected"]
            #[serde(rename = "optionSelected")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub option_selected: Option<RareBooleanData>,
            #[doc = "The index of the document in the list of the snapshot documents."]
            #[serde(rename = "contentDocumentIndex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub content_document_index: Option<RareIntegerData>,
            #[doc = "Type of a pseudo element node."]
            #[serde(rename = "pseudoType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pseudo_type: Option<RareStringData>,
            #[doc = "Pseudo element identifier for this node. Only present if there is a\nvalid pseudoType."]
            #[serde(rename = "pseudoIdentifier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pseudo_identifier: Option<RareStringData>,
            #[doc = "Whether this DOM node responds to mouse clicks. This includes nodes that have had click\nevent listeners attached via JavaScript as well as anchor tags that naturally navigate when\nclicked."]
            #[serde(rename = "isClickable")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_clickable: Option<RareBooleanData>,
            #[doc = "The selected url for nodes with a srcset attribute."]
            #[serde(rename = "currentSourceURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub current_source_url: Option<RareStringData>,
            #[doc = "The url of the script (if any) that generates this node."]
            #[serde(rename = "originURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub origin_url: Option<RareStringData>,
        }
        impl NodeTreeSnapshot {
            pub fn builder() -> NodeTreeSnapshotBuilder {
                NodeTreeSnapshotBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct NodeTreeSnapshotBuilder {
            parent_index: Option<Vec<i64>>,
            node_type: Option<Vec<i64>>,
            shadow_root_type: Option<RareStringData>,
            node_name: Option<Vec<StringIndex>>,
            node_value: Option<Vec<StringIndex>>,
            backend_node_id: Option<Vec<super::dom::BackendNodeId>>,
            attributes: Option<Vec<ArrayOfStrings>>,
            text_value: Option<RareStringData>,
            input_value: Option<RareStringData>,
            input_checked: Option<RareBooleanData>,
            option_selected: Option<RareBooleanData>,
            content_document_index: Option<RareIntegerData>,
            pseudo_type: Option<RareStringData>,
            pseudo_identifier: Option<RareStringData>,
            is_clickable: Option<RareBooleanData>,
            current_source_url: Option<RareStringData>,
            origin_url: Option<RareStringData>,
        }
        impl NodeTreeSnapshotBuilder {
            pub fn parent_index(mut self, parent_index: impl Into<i64>) -> Self {
                let v = self.parent_index.get_or_insert(Vec::new());
                v.push(parent_index.into());
                self
            }
            pub fn parent_indexs<I, S>(mut self, parent_indexs: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.parent_index.get_or_insert(Vec::new());
                for val in parent_indexs {
                    v.push(val.into());
                }
                self
            }
            pub fn node_type(mut self, node_type: impl Into<i64>) -> Self {
                let v = self.node_type.get_or_insert(Vec::new());
                v.push(node_type.into());
                self
            }
            pub fn node_types<I, S>(mut self, node_types: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.node_type.get_or_insert(Vec::new());
                for val in node_types {
                    v.push(val.into());
                }
                self
            }
            pub fn shadow_root_type(mut self, shadow_root_type: impl Into<RareStringData>) -> Self {
                self.shadow_root_type = Some(shadow_root_type.into());
                self
            }
            pub fn node_name(mut self, node_name: impl Into<StringIndex>) -> Self {
                let v = self.node_name.get_or_insert(Vec::new());
                v.push(node_name.into());
                self
            }
            pub fn node_names<I, S>(mut self, node_names: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<StringIndex>,
            {
                let v = self.node_name.get_or_insert(Vec::new());
                for val in node_names {
                    v.push(val.into());
                }
                self
            }
            pub fn node_value(mut self, node_value: impl Into<StringIndex>) -> Self {
                let v = self.node_value.get_or_insert(Vec::new());
                v.push(node_value.into());
                self
            }
            pub fn node_values<I, S>(mut self, node_values: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<StringIndex>,
            {
                let v = self.node_value.get_or_insert(Vec::new());
                for val in node_values {
                    v.push(val.into());
                }
                self
            }
            pub fn backend_node_id(
                mut self,
                backend_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                let v = self.backend_node_id.get_or_insert(Vec::new());
                v.push(backend_node_id.into());
                self
            }
            pub fn backend_node_ids<I, S>(mut self, backend_node_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<super::dom::BackendNodeId>,
            {
                let v = self.backend_node_id.get_or_insert(Vec::new());
                for val in backend_node_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn attribute(mut self, attribute: impl Into<ArrayOfStrings>) -> Self {
                let v = self.attributes.get_or_insert(Vec::new());
                v.push(attribute.into());
                self
            }
            pub fn attributes<I, S>(mut self, attributes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ArrayOfStrings>,
            {
                let v = self.attributes.get_or_insert(Vec::new());
                for val in attributes {
                    v.push(val.into());
                }
                self
            }
            pub fn text_value(mut self, text_value: impl Into<RareStringData>) -> Self {
                self.text_value = Some(text_value.into());
                self
            }
            pub fn input_value(mut self, input_value: impl Into<RareStringData>) -> Self {
                self.input_value = Some(input_value.into());
                self
            }
            pub fn input_checked(mut self, input_checked: impl Into<RareBooleanData>) -> Self {
                self.input_checked = Some(input_checked.into());
                self
            }
            pub fn option_selected(mut self, option_selected: impl Into<RareBooleanData>) -> Self {
                self.option_selected = Some(option_selected.into());
                self
            }
            pub fn content_document_index(
                mut self,
                content_document_index: impl Into<RareIntegerData>,
            ) -> Self {
                self.content_document_index = Some(content_document_index.into());
                self
            }
            pub fn pseudo_type(mut self, pseudo_type: impl Into<RareStringData>) -> Self {
                self.pseudo_type = Some(pseudo_type.into());
                self
            }
            pub fn pseudo_identifier(
                mut self,
                pseudo_identifier: impl Into<RareStringData>,
            ) -> Self {
                self.pseudo_identifier = Some(pseudo_identifier.into());
                self
            }
            pub fn is_clickable(mut self, is_clickable: impl Into<RareBooleanData>) -> Self {
                self.is_clickable = Some(is_clickable.into());
                self
            }
            pub fn current_source_url(
                mut self,
                current_source_url: impl Into<RareStringData>,
            ) -> Self {
                self.current_source_url = Some(current_source_url.into());
                self
            }
            pub fn origin_url(mut self, origin_url: impl Into<RareStringData>) -> Self {
                self.origin_url = Some(origin_url.into());
                self
            }
            pub fn build(self) -> NodeTreeSnapshot {
                NodeTreeSnapshot {
                    parent_index: self.parent_index,
                    node_type: self.node_type,
                    shadow_root_type: self.shadow_root_type,
                    node_name: self.node_name,
                    node_value: self.node_value,
                    backend_node_id: self.backend_node_id,
                    attributes: self.attributes,
                    text_value: self.text_value,
                    input_value: self.input_value,
                    input_checked: self.input_checked,
                    option_selected: self.option_selected,
                    content_document_index: self.content_document_index,
                    pseudo_type: self.pseudo_type,
                    pseudo_identifier: self.pseudo_identifier,
                    is_clickable: self.is_clickable,
                    current_source_url: self.current_source_url,
                    origin_url: self.origin_url,
                }
            }
        }
        impl NodeTreeSnapshot {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.NodeTreeSnapshot";
        }
        #[doc = "Table of details of an element in the DOM tree with a LayoutObject.\n[LayoutTreeSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#type-LayoutTreeSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LayoutTreeSnapshot {
            #[doc = "Index of the corresponding node in the `NodeTreeSnapshot` array returned by `captureSnapshot`."]
            #[serde(rename = "nodeIndex")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub node_index: Vec<i64>,
            #[doc = "Array of indexes specifying computed style strings, filtered according to the `computedStyles` parameter passed to `captureSnapshot`."]
            #[serde(rename = "styles")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub styles: Vec<ArrayOfStrings>,
            #[doc = "The absolute position bounding box."]
            #[serde(rename = "bounds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub bounds: Vec<Rectangle>,
            #[doc = "Contents of the LayoutText, if any."]
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub text: Vec<StringIndex>,
            #[doc = "Stacking context information."]
            #[serde(rename = "stackingContexts")]
            pub stacking_contexts: RareBooleanData,
            #[doc = "Global paint order index, which is determined by the stacking order of the nodes. Nodes\nthat are painted together will have the same index. Only provided if includePaintOrder in\ncaptureSnapshot was true."]
            #[serde(rename = "paintOrders")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub paint_orders: Option<Vec<i64>>,
            #[doc = "The offset rect of nodes. Only available when includeDOMRects is set to true"]
            #[serde(rename = "offsetRects")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub offset_rects: Option<Vec<Rectangle>>,
            #[doc = "The scroll rect of nodes. Only available when includeDOMRects is set to true"]
            #[serde(rename = "scrollRects")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub scroll_rects: Option<Vec<Rectangle>>,
            #[doc = "The client rect of nodes. Only available when includeDOMRects is set to true"]
            #[serde(rename = "clientRects")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub client_rects: Option<Vec<Rectangle>>,
            #[doc = "The list of background colors that are blended with colors of overlapping elements."]
            #[serde(rename = "blendedBackgroundColors")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub blended_background_colors: Option<Vec<StringIndex>>,
            #[doc = "The list of computed text opacities."]
            #[serde(rename = "textColorOpacities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub text_color_opacities: Option<Vec<f64>>,
        }
        impl LayoutTreeSnapshot {
            pub fn builder() -> LayoutTreeSnapshotBuilder {
                LayoutTreeSnapshotBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LayoutTreeSnapshotBuilder {
            node_index: Option<Vec<i64>>,
            styles: Option<Vec<ArrayOfStrings>>,
            bounds: Option<Vec<Rectangle>>,
            text: Option<Vec<StringIndex>>,
            stacking_contexts: Option<RareBooleanData>,
            paint_orders: Option<Vec<i64>>,
            offset_rects: Option<Vec<Rectangle>>,
            scroll_rects: Option<Vec<Rectangle>>,
            client_rects: Option<Vec<Rectangle>>,
            blended_background_colors: Option<Vec<StringIndex>>,
            text_color_opacities: Option<Vec<f64>>,
        }
        impl LayoutTreeSnapshotBuilder {
            pub fn node_index(mut self, node_index: impl Into<i64>) -> Self {
                let v = self.node_index.get_or_insert(Vec::new());
                v.push(node_index.into());
                self
            }
            pub fn node_indexs<I, S>(mut self, node_indexs: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.node_index.get_or_insert(Vec::new());
                for val in node_indexs {
                    v.push(val.into());
                }
                self
            }
            pub fn style(mut self, style: impl Into<ArrayOfStrings>) -> Self {
                let v = self.styles.get_or_insert(Vec::new());
                v.push(style.into());
                self
            }
            pub fn styles<I, S>(mut self, styles: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ArrayOfStrings>,
            {
                let v = self.styles.get_or_insert(Vec::new());
                for val in styles {
                    v.push(val.into());
                }
                self
            }
            pub fn bound(mut self, bound: impl Into<Rectangle>) -> Self {
                let v = self.bounds.get_or_insert(Vec::new());
                v.push(bound.into());
                self
            }
            pub fn bounds<I, S>(mut self, bounds: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Rectangle>,
            {
                let v = self.bounds.get_or_insert(Vec::new());
                for val in bounds {
                    v.push(val.into());
                }
                self
            }
            pub fn text(mut self, text: impl Into<StringIndex>) -> Self {
                let v = self.text.get_or_insert(Vec::new());
                v.push(text.into());
                self
            }
            pub fn texts<I, S>(mut self, texts: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<StringIndex>,
            {
                let v = self.text.get_or_insert(Vec::new());
                for val in texts {
                    v.push(val.into());
                }
                self
            }
            pub fn stacking_contexts(
                mut self,
                stacking_contexts: impl Into<RareBooleanData>,
            ) -> Self {
                self.stacking_contexts = Some(stacking_contexts.into());
                self
            }
            pub fn paint_order(mut self, paint_order: impl Into<i64>) -> Self {
                let v = self.paint_orders.get_or_insert(Vec::new());
                v.push(paint_order.into());
                self
            }
            pub fn paint_orders<I, S>(mut self, paint_orders: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.paint_orders.get_or_insert(Vec::new());
                for val in paint_orders {
                    v.push(val.into());
                }
                self
            }
            pub fn offset_rect(mut self, offset_rect: impl Into<Rectangle>) -> Self {
                let v = self.offset_rects.get_or_insert(Vec::new());
                v.push(offset_rect.into());
                self
            }
            pub fn offset_rects<I, S>(mut self, offset_rects: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Rectangle>,
            {
                let v = self.offset_rects.get_or_insert(Vec::new());
                for val in offset_rects {
                    v.push(val.into());
                }
                self
            }
            pub fn scroll_rect(mut self, scroll_rect: impl Into<Rectangle>) -> Self {
                let v = self.scroll_rects.get_or_insert(Vec::new());
                v.push(scroll_rect.into());
                self
            }
            pub fn scroll_rects<I, S>(mut self, scroll_rects: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Rectangle>,
            {
                let v = self.scroll_rects.get_or_insert(Vec::new());
                for val in scroll_rects {
                    v.push(val.into());
                }
                self
            }
            pub fn client_rect(mut self, client_rect: impl Into<Rectangle>) -> Self {
                let v = self.client_rects.get_or_insert(Vec::new());
                v.push(client_rect.into());
                self
            }
            pub fn client_rects<I, S>(mut self, client_rects: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Rectangle>,
            {
                let v = self.client_rects.get_or_insert(Vec::new());
                for val in client_rects {
                    v.push(val.into());
                }
                self
            }
            pub fn blended_background_color(
                mut self,
                blended_background_color: impl Into<StringIndex>,
            ) -> Self {
                let v = self.blended_background_colors.get_or_insert(Vec::new());
                v.push(blended_background_color.into());
                self
            }
            pub fn blended_background_colors<I, S>(mut self, blended_background_colors: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<StringIndex>,
            {
                let v = self.blended_background_colors.get_or_insert(Vec::new());
                for val in blended_background_colors {
                    v.push(val.into());
                }
                self
            }
            pub fn text_color_opacitie(mut self, text_color_opacitie: impl Into<f64>) -> Self {
                let v = self.text_color_opacities.get_or_insert(Vec::new());
                v.push(text_color_opacitie.into());
                self
            }
            pub fn text_color_opacities<I, S>(mut self, text_color_opacities: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<f64>,
            {
                let v = self.text_color_opacities.get_or_insert(Vec::new());
                for val in text_color_opacities {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<LayoutTreeSnapshot, String> {
                Ok(LayoutTreeSnapshot {
                    node_index: self.node_index.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_index))
                    })?,
                    styles: self.styles.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(styles))
                    })?,
                    bounds: self.bounds.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(bounds))
                    })?,
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                    stacking_contexts: self.stacking_contexts.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(stacking_contexts)
                        )
                    })?,
                    paint_orders: self.paint_orders,
                    offset_rects: self.offset_rects,
                    scroll_rects: self.scroll_rects,
                    client_rects: self.client_rects,
                    blended_background_colors: self.blended_background_colors,
                    text_color_opacities: self.text_color_opacities,
                })
            }
        }
        impl LayoutTreeSnapshot {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.LayoutTreeSnapshot";
        }
        #[doc = "Table of details of the post layout rendered text positions. The exact layout should not be regarded as\nstable and may change between versions.\n[TextBoxSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#type-TextBoxSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TextBoxSnapshot {
            #[doc = "Index of the layout tree node that owns this box collection."]
            #[serde(rename = "layoutIndex")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub layout_index: Vec<i64>,
            #[doc = "The absolute position bounding box."]
            #[serde(rename = "bounds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub bounds: Vec<Rectangle>,
            #[doc = "The starting index in characters, for this post layout textbox substring. Characters that\nwould be represented as a surrogate pair in UTF-16 have length 2."]
            #[serde(rename = "start")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub start: Vec<i64>,
            #[doc = "The number of characters in this post layout textbox substring. Characters that would be\nrepresented as a surrogate pair in UTF-16 have length 2."]
            #[serde(rename = "length")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub length: Vec<i64>,
        }
        impl TextBoxSnapshot {
            pub fn new(
                layout_index: Vec<i64>,
                bounds: Vec<Rectangle>,
                start: Vec<i64>,
                length: Vec<i64>,
            ) -> Self {
                Self {
                    layout_index,
                    bounds,
                    start,
                    length,
                }
            }
        }
        impl TextBoxSnapshot {
            pub fn builder() -> TextBoxSnapshotBuilder {
                TextBoxSnapshotBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TextBoxSnapshotBuilder {
            layout_index: Option<Vec<i64>>,
            bounds: Option<Vec<Rectangle>>,
            start: Option<Vec<i64>>,
            length: Option<Vec<i64>>,
        }
        impl TextBoxSnapshotBuilder {
            pub fn layout_index(mut self, layout_index: impl Into<i64>) -> Self {
                let v = self.layout_index.get_or_insert(Vec::new());
                v.push(layout_index.into());
                self
            }
            pub fn layout_indexs<I, S>(mut self, layout_indexs: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.layout_index.get_or_insert(Vec::new());
                for val in layout_indexs {
                    v.push(val.into());
                }
                self
            }
            pub fn bound(mut self, bound: impl Into<Rectangle>) -> Self {
                let v = self.bounds.get_or_insert(Vec::new());
                v.push(bound.into());
                self
            }
            pub fn bounds<I, S>(mut self, bounds: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Rectangle>,
            {
                let v = self.bounds.get_or_insert(Vec::new());
                for val in bounds {
                    v.push(val.into());
                }
                self
            }
            pub fn start(mut self, start: impl Into<i64>) -> Self {
                let v = self.start.get_or_insert(Vec::new());
                v.push(start.into());
                self
            }
            pub fn starts<I, S>(mut self, starts: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.start.get_or_insert(Vec::new());
                for val in starts {
                    v.push(val.into());
                }
                self
            }
            pub fn length(mut self, length: impl Into<i64>) -> Self {
                let v = self.length.get_or_insert(Vec::new());
                v.push(length.into());
                self
            }
            pub fn lengths<I, S>(mut self, lengths: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<i64>,
            {
                let v = self.length.get_or_insert(Vec::new());
                for val in lengths {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<TextBoxSnapshot, String> {
                Ok(TextBoxSnapshot {
                    layout_index: self.layout_index.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(layout_index))
                    })?,
                    bounds: self.bounds.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(bounds))
                    })?,
                    start: self.start.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(start))
                    })?,
                    length: self.length.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(length))
                    })?,
                })
            }
        }
        impl TextBoxSnapshot {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.TextBoxSnapshot";
        }
        #[doc = "Disables DOM snapshot agent for the given page.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables DOM snapshot agent for the given page.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables DOM snapshot agent for the given page.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables DOM snapshot agent for the given page.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Returns a document snapshot, including the full DOM tree of the root node (including iframes,\ntemplate contents, and imported documents) in a flattened array, as well as layout and\nwhite-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is\nflattened.\n[captureSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#method-captureSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CaptureSnapshotParams {
            #[doc = "Whitelist of computed styles to return."]
            #[serde(rename = "computedStyles")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub computed_styles: Vec<String>,
            #[doc = "Whether to include layout object paint orders into the snapshot."]
            #[serde(rename = "includePaintOrder")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub include_paint_order: Option<bool>,
            #[doc = "Whether to include DOM rectangles (offsetRects, clientRects, scrollRects) into the snapshot"]
            #[serde(rename = "includeDOMRects")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub include_dom_rects: Option<bool>,
            #[doc = "Whether to include blended background colors in the snapshot (default: false).\nBlended background color is achieved by blending background colors of all elements\nthat overlap with the current element."]
            #[serde(rename = "includeBlendedBackgroundColors")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub include_blended_background_colors: Option<bool>,
            #[doc = "Whether to include text color opacity in the snapshot (default: false).\nAn element might have the opacity property set that affects the text color of the element.\nThe final text color opacity is computed based on the opacity of all overlapping elements."]
            #[serde(rename = "includeTextColorOpacities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub include_text_color_opacities: Option<bool>,
        }
        impl CaptureSnapshotParams {
            pub fn new(computed_styles: Vec<String>) -> Self {
                Self {
                    computed_styles,
                    include_paint_order: None,
                    include_dom_rects: None,
                    include_blended_background_colors: None,
                    include_text_color_opacities: None,
                }
            }
        }
        impl CaptureSnapshotParams {
            pub fn builder() -> CaptureSnapshotParamsBuilder {
                CaptureSnapshotParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CaptureSnapshotParamsBuilder {
            computed_styles: Option<Vec<String>>,
            include_paint_order: Option<bool>,
            include_dom_rects: Option<bool>,
            include_blended_background_colors: Option<bool>,
            include_text_color_opacities: Option<bool>,
        }
        impl CaptureSnapshotParamsBuilder {
            pub fn computed_style(mut self, computed_style: impl Into<String>) -> Self {
                let v = self.computed_styles.get_or_insert(Vec::new());
                v.push(computed_style.into());
                self
            }
            pub fn computed_styles<I, S>(mut self, computed_styles: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.computed_styles.get_or_insert(Vec::new());
                for val in computed_styles {
                    v.push(val.into());
                }
                self
            }
            pub fn include_paint_order(mut self, include_paint_order: impl Into<bool>) -> Self {
                self.include_paint_order = Some(include_paint_order.into());
                self
            }
            pub fn include_dom_rects(mut self, include_dom_rects: impl Into<bool>) -> Self {
                self.include_dom_rects = Some(include_dom_rects.into());
                self
            }
            pub fn include_blended_background_colors(
                mut self,
                include_blended_background_colors: impl Into<bool>,
            ) -> Self {
                self.include_blended_background_colors =
                    Some(include_blended_background_colors.into());
                self
            }
            pub fn include_text_color_opacities(
                mut self,
                include_text_color_opacities: impl Into<bool>,
            ) -> Self {
                self.include_text_color_opacities = Some(include_text_color_opacities.into());
                self
            }
            pub fn build(self) -> Result<CaptureSnapshotParams, String> {
                Ok(CaptureSnapshotParams {
                    computed_styles: self.computed_styles.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(computed_styles))
                    })?,
                    include_paint_order: self.include_paint_order,
                    include_dom_rects: self.include_dom_rects,
                    include_blended_background_colors: self.include_blended_background_colors,
                    include_text_color_opacities: self.include_text_color_opacities,
                })
            }
        }
        impl CaptureSnapshotParams {
            pub const IDENTIFIER: &'static str = "DOMSnapshot.captureSnapshot";
        }
        impl chromiumoxide_types::Method for CaptureSnapshotParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CaptureSnapshotParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns a document snapshot, including the full DOM tree of the root node (including iframes,\ntemplate contents, and imported documents) in a flattened array, as well as layout and\nwhite-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is\nflattened.\n[captureSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#method-captureSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CaptureSnapshotReturns {
            #[doc = "The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document."]
            #[serde(rename = "documents")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub documents: Vec<DocumentSnapshot>,
            #[doc = "Shared string table that all string properties refer to with indexes."]
            #[serde(rename = "strings")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub strings: Vec<String>,
        }
        impl CaptureSnapshotReturns {
            pub fn new(documents: Vec<DocumentSnapshot>, strings: Vec<String>) -> Self {
                Self { documents, strings }
            }
        }
        impl CaptureSnapshotReturns {
            pub fn builder() -> CaptureSnapshotReturnsBuilder {
                CaptureSnapshotReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CaptureSnapshotReturnsBuilder {
            documents: Option<Vec<DocumentSnapshot>>,
            strings: Option<Vec<String>>,
        }
        impl CaptureSnapshotReturnsBuilder {
            pub fn document(mut self, document: impl Into<DocumentSnapshot>) -> Self {
                let v = self.documents.get_or_insert(Vec::new());
                v.push(document.into());
                self
            }
            pub fn documents<I, S>(mut self, documents: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<DocumentSnapshot>,
            {
                let v = self.documents.get_or_insert(Vec::new());
                for val in documents {
                    v.push(val.into());
                }
                self
            }
            pub fn string(mut self, string: impl Into<String>) -> Self {
                let v = self.strings.get_or_insert(Vec::new());
                v.push(string.into());
                self
            }
            pub fn strings<I, S>(mut self, strings: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.strings.get_or_insert(Vec::new());
                for val in strings {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<CaptureSnapshotReturns, String> {
                Ok(CaptureSnapshotReturns {
                    documents: self.documents.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(documents))
                    })?,
                    strings: self.strings.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(strings))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for CaptureSnapshotParams {
            type Response = CaptureSnapshotReturns;
        }
    }
    #[doc = "Query and modify DOM storage."]
    pub mod dom_storage {
        use serde::{Deserialize, Serialize};
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct SerializedStorageKey(String);
        impl SerializedStorageKey {
            pub fn new(val: impl Into<String>) -> Self {
                SerializedStorageKey(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for SerializedStorageKey {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<SerializedStorageKey> for String {
            fn from(el: SerializedStorageKey) -> String {
                el.0
            }
        }
        impl From<String> for SerializedStorageKey {
            fn from(expr: String) -> Self {
                SerializedStorageKey(expr)
            }
        }
        impl SerializedStorageKey {
            pub const IDENTIFIER: &'static str = "DOMStorage.SerializedStorageKey";
        }
        #[doc = "DOM Storage identifier.\n[StorageId](https://chromedevtools.github.io/devtools-protocol/tot/DOMStorage/#type-StorageId)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StorageId {
            #[doc = "Security origin for the storage."]
            #[serde(rename = "securityOrigin")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub security_origin: Option<String>,
            #[doc = "Represents a key by which DOM Storage keys its CachedStorageAreas"]
            #[serde(rename = "storageKey")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub storage_key: Option<SerializedStorageKey>,
            #[doc = "Whether the storage is local storage (not session storage)."]
            #[serde(rename = "isLocalStorage")]
            pub is_local_storage: bool,
        }
        impl StorageId {
            pub fn new(is_local_storage: impl Into<bool>) -> Self {
                Self {
                    is_local_storage: is_local_storage.into(),
                    security_origin: None,
                    storage_key: None,
                }
            }
        }
        impl StorageId {
            pub fn builder() -> StorageIdBuilder {
                StorageIdBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StorageIdBuilder {
            security_origin: Option<String>,
            storage_key: Option<SerializedStorageKey>,
            is_local_storage: Option<bool>,
        }
        impl StorageIdBuilder {
            pub fn security_origin(mut self, security_origin: impl Into<String>) -> Self {
                self.security_origin = Some(security_origin.into());
                self
            }
            pub fn storage_key(mut self, storage_key: impl Into<SerializedStorageKey>) -> Self {
                self.storage_key = Some(storage_key.into());
                self
            }
            pub fn is_local_storage(mut self, is_local_storage: impl Into<bool>) -> Self {
                self.is_local_storage = Some(is_local_storage.into());
                self
            }
            pub fn build(self) -> Result<StorageId, String> {
                Ok(StorageId {
                    security_origin: self.security_origin,
                    storage_key: self.storage_key,
                    is_local_storage: self.is_local_storage.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(is_local_storage)
                        )
                    })?,
                })
            }
        }
        impl StorageId {
            pub const IDENTIFIER: &'static str = "DOMStorage.StorageId";
        }
        #[doc = "DOM Storage item.\n[Item](https://chromedevtools.github.io/devtools-protocol/tot/DOMStorage/#type-Item)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct Item(Vec<String>);
        impl Item {
            pub fn new(val: impl Into<Vec<String>>) -> Self {
                Item(val.into())
            }
            pub fn inner(&self) -> &Vec<String> {
                &self.0
            }
        }
        impl Item {
            pub const IDENTIFIER: &'static str = "DOMStorage.Item";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ClearParams {
            #[serde(rename = "storageId")]
            pub storage_id: StorageId,
        }
        impl ClearParams {
            pub fn new(storage_id: impl Into<StorageId>) -> Self {
                Self {
                    storage_id: storage_id.into(),
                }
            }
        }
        impl ClearParams {
            pub fn builder() -> ClearParamsBuilder {
                ClearParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ClearParamsBuilder {
            storage_id: Option<StorageId>,
        }
        impl ClearParamsBuilder {
            pub fn storage_id(mut self, storage_id: impl Into<StorageId>) -> Self {
                self.storage_id = Some(storage_id.into());
                self
            }
            pub fn build(self) -> Result<ClearParams, String> {
                Ok(ClearParams {
                    storage_id: self.storage_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(storage_id))
                    })?,
                })
            }
        }
        impl ClearParams {
            pub const IDENTIFIER: &'static str = "DOMStorage.clear";
        }
        impl chromiumoxide_types::Method for ClearParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearReturns {}
        impl chromiumoxide_types::Command for ClearParams {
            type Response = ClearReturns;
        }
        #[doc = "Disables storage tracking, prevents storage events from being sent to the client.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/DOMStorage/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "DOMStorage.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables storage tracking, prevents storage events from being sent to the client.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/DOMStorage/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables storage tracking, storage events will now be delivered to the client.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/DOMStorage/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "DOMStorage.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables storage tracking, storage events will now be delivered to the client.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/DOMStorage/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetDomStorageItemsParams {
            #[serde(rename = "storageId")]
            pub storage_id: StorageId,
        }
        impl GetDomStorageItemsParams {
            pub fn new(storage_id: impl Into<StorageId>) -> Self {
                Self {
                    storage_id: storage_id.into(),
                }
            }
        }
        impl GetDomStorageItemsParams {
            pub fn builder() -> GetDomStorageItemsParamsBuilder {
                GetDomStorageItemsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetDomStorageItemsParamsBuilder {
            storage_id: Option<StorageId>,
        }
        impl GetDomStorageItemsParamsBuilder {
            pub fn storage_id(mut self, storage_id: impl Into<StorageId>) -> Self {
                self.storage_id = Some(storage_id.into());
                self
            }
            pub fn build(self) -> Result<GetDomStorageItemsParams, String> {
                Ok(GetDomStorageItemsParams {
                    storage_id: self.storage_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(storage_id))
                    })?,
                })
            }
        }
        impl GetDomStorageItemsParams {
            pub const IDENTIFIER: &'static str = "DOMStorage.getDOMStorageItems";
        }
        impl chromiumoxide_types::Method for GetDomStorageItemsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetDomStorageItemsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetDomStorageItemsReturns {
            #[serde(rename = "entries")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub entries: Vec<Item>,
        }
        impl GetDomStorageItemsReturns {
            pub fn new(entries: Vec<Item>) -> Self {
                Self { entries }
            }
        }
        impl GetDomStorageItemsReturns {
            pub fn builder() -> GetDomStorageItemsReturnsBuilder {
                GetDomStorageItemsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetDomStorageItemsReturnsBuilder {
            entries: Option<Vec<Item>>,
        }
        impl GetDomStorageItemsReturnsBuilder {
            pub fn entrie(mut self, entrie: impl Into<Item>) -> Self {
                let v = self.entries.get_or_insert(Vec::new());
                v.push(entrie.into());
                self
            }
            pub fn entries<I, S>(mut self, entries: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Item>,
            {
                let v = self.entries.get_or_insert(Vec::new());
                for val in entries {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetDomStorageItemsReturns, String> {
                Ok(GetDomStorageItemsReturns {
                    entries: self.entries.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(entries))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetDomStorageItemsParams {
            type Response = GetDomStorageItemsReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoveDomStorageItemParams {
            #[serde(rename = "storageId")]
            pub storage_id: StorageId,
            #[serde(rename = "key")]
            pub key: String,
        }
        impl RemoveDomStorageItemParams {
            pub fn new(storage_id: impl Into<StorageId>, key: impl Into<String>) -> Self {
                Self {
                    storage_id: storage_id.into(),
                    key: key.into(),
                }
            }
        }
        impl RemoveDomStorageItemParams {
            pub fn builder() -> RemoveDomStorageItemParamsBuilder {
                RemoveDomStorageItemParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoveDomStorageItemParamsBuilder {
            storage_id: Option<StorageId>,
            key: Option<String>,
        }
        impl RemoveDomStorageItemParamsBuilder {
            pub fn storage_id(mut self, storage_id: impl Into<StorageId>) -> Self {
                self.storage_id = Some(storage_id.into());
                self
            }
            pub fn key(mut self, key: impl Into<String>) -> Self {
                self.key = Some(key.into());
                self
            }
            pub fn build(self) -> Result<RemoveDomStorageItemParams, String> {
                Ok(RemoveDomStorageItemParams {
                    storage_id: self.storage_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(storage_id))
                    })?,
                    key: self
                        .key
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(key)))?,
                })
            }
        }
        impl RemoveDomStorageItemParams {
            pub const IDENTIFIER: &'static str = "DOMStorage.removeDOMStorageItem";
        }
        impl chromiumoxide_types::Method for RemoveDomStorageItemParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RemoveDomStorageItemParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RemoveDomStorageItemReturns {}
        impl chromiumoxide_types::Command for RemoveDomStorageItemParams {
            type Response = RemoveDomStorageItemReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetDomStorageItemParams {
            #[serde(rename = "storageId")]
            pub storage_id: StorageId,
            #[serde(rename = "key")]
            pub key: String,
            #[serde(rename = "value")]
            pub value: String,
        }
        impl SetDomStorageItemParams {
            pub fn new(
                storage_id: impl Into<StorageId>,
                key: impl Into<String>,
                value: impl Into<String>,
            ) -> Self {
                Self {
                    storage_id: storage_id.into(),
                    key: key.into(),
                    value: value.into(),
                }
            }
        }
        impl SetDomStorageItemParams {
            pub fn builder() -> SetDomStorageItemParamsBuilder {
                SetDomStorageItemParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetDomStorageItemParamsBuilder {
            storage_id: Option<StorageId>,
            key: Option<String>,
            value: Option<String>,
        }
        impl SetDomStorageItemParamsBuilder {
            pub fn storage_id(mut self, storage_id: impl Into<StorageId>) -> Self {
                self.storage_id = Some(storage_id.into());
                self
            }
            pub fn key(mut self, key: impl Into<String>) -> Self {
                self.key = Some(key.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<SetDomStorageItemParams, String> {
                Ok(SetDomStorageItemParams {
                    storage_id: self.storage_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(storage_id))
                    })?,
                    key: self
                        .key
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(key)))?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl SetDomStorageItemParams {
            pub const IDENTIFIER: &'static str = "DOMStorage.setDOMStorageItem";
        }
        impl chromiumoxide_types::Method for SetDomStorageItemParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetDomStorageItemParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetDomStorageItemReturns {}
        impl chromiumoxide_types::Command for SetDomStorageItemParams {
            type Response = SetDomStorageItemReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDomStorageItemAdded {
            #[serde(rename = "storageId")]
            pub storage_id: StorageId,
            #[serde(rename = "key")]
            pub key: String,
            #[serde(rename = "newValue")]
            pub new_value: String,
        }
        impl EventDomStorageItemAdded {
            pub const IDENTIFIER: &'static str = "DOMStorage.domStorageItemAdded";
        }
        impl chromiumoxide_types::Method for EventDomStorageItemAdded {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDomStorageItemAdded {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDomStorageItemRemoved {
            #[serde(rename = "storageId")]
            pub storage_id: StorageId,
            #[serde(rename = "key")]
            pub key: String,
        }
        impl EventDomStorageItemRemoved {
            pub const IDENTIFIER: &'static str = "DOMStorage.domStorageItemRemoved";
        }
        impl chromiumoxide_types::Method for EventDomStorageItemRemoved {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDomStorageItemRemoved {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDomStorageItemUpdated {
            #[serde(rename = "storageId")]
            pub storage_id: StorageId,
            #[serde(rename = "key")]
            pub key: String,
            #[serde(rename = "oldValue")]
            pub old_value: String,
            #[serde(rename = "newValue")]
            pub new_value: String,
        }
        impl EventDomStorageItemUpdated {
            pub const IDENTIFIER: &'static str = "DOMStorage.domStorageItemUpdated";
        }
        impl chromiumoxide_types::Method for EventDomStorageItemUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDomStorageItemUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDomStorageItemsCleared {
            #[serde(rename = "storageId")]
            pub storage_id: StorageId,
        }
        impl EventDomStorageItemsCleared {
            pub const IDENTIFIER: &'static str = "DOMStorage.domStorageItemsCleared";
        }
        impl chromiumoxide_types::Method for EventDomStorageItemsCleared {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDomStorageItemsCleared {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    pub mod database {
        use serde::{Deserialize, Serialize};
        #[doc = "Unique identifier of Database object.\n[DatabaseId](https://chromedevtools.github.io/devtools-protocol/tot/Database/#type-DatabaseId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct DatabaseId(String);
        impl DatabaseId {
            pub fn new(val: impl Into<String>) -> Self {
                DatabaseId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for DatabaseId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<DatabaseId> for String {
            fn from(el: DatabaseId) -> String {
                el.0
            }
        }
        impl From<String> for DatabaseId {
            fn from(expr: String) -> Self {
                DatabaseId(expr)
            }
        }
        impl std::borrow::Borrow<str> for DatabaseId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl DatabaseId {
            pub const IDENTIFIER: &'static str = "Database.DatabaseId";
        }
        #[doc = "Database object.\n[Database](https://chromedevtools.github.io/devtools-protocol/tot/Database/#type-Database)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Database {
            #[doc = "Database ID."]
            #[serde(rename = "id")]
            pub id: DatabaseId,
            #[doc = "Database domain."]
            #[serde(rename = "domain")]
            pub domain: String,
            #[doc = "Database name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Database version."]
            #[serde(rename = "version")]
            pub version: String,
        }
        impl Database {
            pub fn new(
                id: impl Into<DatabaseId>,
                domain: impl Into<String>,
                name: impl Into<String>,
                version: impl Into<String>,
            ) -> Self {
                Self {
                    id: id.into(),
                    domain: domain.into(),
                    name: name.into(),
                    version: version.into(),
                }
            }
        }
        impl Database {
            pub fn builder() -> DatabaseBuilder {
                DatabaseBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DatabaseBuilder {
            id: Option<DatabaseId>,
            domain: Option<String>,
            name: Option<String>,
            version: Option<String>,
        }
        impl DatabaseBuilder {
            pub fn id(mut self, id: impl Into<DatabaseId>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn domain(mut self, domain: impl Into<String>) -> Self {
                self.domain = Some(domain.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn version(mut self, version: impl Into<String>) -> Self {
                self.version = Some(version.into());
                self
            }
            pub fn build(self) -> Result<Database, String> {
                Ok(Database {
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                    domain: self.domain.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(domain))
                    })?,
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    version: self.version.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(version))
                    })?,
                })
            }
        }
        impl Database {
            pub const IDENTIFIER: &'static str = "Database.Database";
        }
        #[doc = "Database error.\n[Error](https://chromedevtools.github.io/devtools-protocol/tot/Database/#type-Error)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Error {
            #[doc = "Error message."]
            #[serde(rename = "message")]
            pub message: String,
            #[doc = "Error code."]
            #[serde(rename = "code")]
            pub code: i64,
        }
        impl Error {
            pub fn new(message: impl Into<String>, code: impl Into<i64>) -> Self {
                Self {
                    message: message.into(),
                    code: code.into(),
                }
            }
        }
        impl Error {
            pub fn builder() -> ErrorBuilder {
                ErrorBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ErrorBuilder {
            message: Option<String>,
            code: Option<i64>,
        }
        impl ErrorBuilder {
            pub fn message(mut self, message: impl Into<String>) -> Self {
                self.message = Some(message.into());
                self
            }
            pub fn code(mut self, code: impl Into<i64>) -> Self {
                self.code = Some(code.into());
                self
            }
            pub fn build(self) -> Result<Error, String> {
                Ok(Error {
                    message: self.message.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(message))
                    })?,
                    code: self.code.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(code))
                    })?,
                })
            }
        }
        impl Error {
            pub const IDENTIFIER: &'static str = "Database.Error";
        }
        #[doc = "Disables database tracking, prevents database events from being sent to the client.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Database/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Database.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables database tracking, prevents database events from being sent to the client.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Database/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables database tracking, database events will now be delivered to the client.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Database/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Database.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables database tracking, database events will now be delivered to the client.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Database/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ExecuteSqlParams {
            #[serde(rename = "databaseId")]
            pub database_id: DatabaseId,
            #[serde(rename = "query")]
            pub query: String,
        }
        impl ExecuteSqlParams {
            pub fn new(database_id: impl Into<DatabaseId>, query: impl Into<String>) -> Self {
                Self {
                    database_id: database_id.into(),
                    query: query.into(),
                }
            }
        }
        impl ExecuteSqlParams {
            pub fn builder() -> ExecuteSqlParamsBuilder {
                ExecuteSqlParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ExecuteSqlParamsBuilder {
            database_id: Option<DatabaseId>,
            query: Option<String>,
        }
        impl ExecuteSqlParamsBuilder {
            pub fn database_id(mut self, database_id: impl Into<DatabaseId>) -> Self {
                self.database_id = Some(database_id.into());
                self
            }
            pub fn query(mut self, query: impl Into<String>) -> Self {
                self.query = Some(query.into());
                self
            }
            pub fn build(self) -> Result<ExecuteSqlParams, String> {
                Ok(ExecuteSqlParams {
                    database_id: self.database_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(database_id))
                    })?,
                    query: self.query.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(query))
                    })?,
                })
            }
        }
        impl ExecuteSqlParams {
            pub const IDENTIFIER: &'static str = "Database.executeSQL";
        }
        impl chromiumoxide_types::Method for ExecuteSqlParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ExecuteSqlParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ExecuteSqlReturns {
            #[serde(rename = "columnNames")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub column_names: Option<Vec<String>>,
            #[serde(rename = "values")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub values: Option<Vec<serde_json::Value>>,
            #[serde(rename = "sqlError")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub sql_error: Option<Error>,
        }
        impl ExecuteSqlReturns {
            pub fn builder() -> ExecuteSqlReturnsBuilder {
                ExecuteSqlReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ExecuteSqlReturnsBuilder {
            column_names: Option<Vec<String>>,
            values: Option<Vec<serde_json::Value>>,
            sql_error: Option<Error>,
        }
        impl ExecuteSqlReturnsBuilder {
            pub fn column_name(mut self, column_name: impl Into<String>) -> Self {
                let v = self.column_names.get_or_insert(Vec::new());
                v.push(column_name.into());
                self
            }
            pub fn column_names<I, S>(mut self, column_names: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.column_names.get_or_insert(Vec::new());
                for val in column_names {
                    v.push(val.into());
                }
                self
            }
            pub fn value(mut self, value: impl Into<serde_json::Value>) -> Self {
                let v = self.values.get_or_insert(Vec::new());
                v.push(value.into());
                self
            }
            pub fn values<I, S>(mut self, values: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<serde_json::Value>,
            {
                let v = self.values.get_or_insert(Vec::new());
                for val in values {
                    v.push(val.into());
                }
                self
            }
            pub fn sql_error(mut self, sql_error: impl Into<Error>) -> Self {
                self.sql_error = Some(sql_error.into());
                self
            }
            pub fn build(self) -> ExecuteSqlReturns {
                ExecuteSqlReturns {
                    column_names: self.column_names,
                    values: self.values,
                    sql_error: self.sql_error,
                }
            }
        }
        impl chromiumoxide_types::Command for ExecuteSqlParams {
            type Response = ExecuteSqlReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetDatabaseTableNamesParams {
            #[serde(rename = "databaseId")]
            pub database_id: DatabaseId,
        }
        impl GetDatabaseTableNamesParams {
            pub fn new(database_id: impl Into<DatabaseId>) -> Self {
                Self {
                    database_id: database_id.into(),
                }
            }
        }
        impl GetDatabaseTableNamesParams {
            pub fn builder() -> GetDatabaseTableNamesParamsBuilder {
                GetDatabaseTableNamesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetDatabaseTableNamesParamsBuilder {
            database_id: Option<DatabaseId>,
        }
        impl GetDatabaseTableNamesParamsBuilder {
            pub fn database_id(mut self, database_id: impl Into<DatabaseId>) -> Self {
                self.database_id = Some(database_id.into());
                self
            }
            pub fn build(self) -> Result<GetDatabaseTableNamesParams, String> {
                Ok(GetDatabaseTableNamesParams {
                    database_id: self.database_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(database_id))
                    })?,
                })
            }
        }
        impl GetDatabaseTableNamesParams {
            pub const IDENTIFIER: &'static str = "Database.getDatabaseTableNames";
        }
        impl chromiumoxide_types::Method for GetDatabaseTableNamesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetDatabaseTableNamesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetDatabaseTableNamesReturns {
            #[serde(rename = "tableNames")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub table_names: Vec<String>,
        }
        impl GetDatabaseTableNamesReturns {
            pub fn new(table_names: Vec<String>) -> Self {
                Self { table_names }
            }
        }
        impl GetDatabaseTableNamesReturns {
            pub fn builder() -> GetDatabaseTableNamesReturnsBuilder {
                GetDatabaseTableNamesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetDatabaseTableNamesReturnsBuilder {
            table_names: Option<Vec<String>>,
        }
        impl GetDatabaseTableNamesReturnsBuilder {
            pub fn table_name(mut self, table_name: impl Into<String>) -> Self {
                let v = self.table_names.get_or_insert(Vec::new());
                v.push(table_name.into());
                self
            }
            pub fn table_names<I, S>(mut self, table_names: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.table_names.get_or_insert(Vec::new());
                for val in table_names {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetDatabaseTableNamesReturns, String> {
                Ok(GetDatabaseTableNamesReturns {
                    table_names: self.table_names.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(table_names))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetDatabaseTableNamesParams {
            type Response = GetDatabaseTableNamesReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAddDatabase {
            #[serde(rename = "database")]
            pub database: Database,
        }
        impl EventAddDatabase {
            pub const IDENTIFIER: &'static str = "Database.addDatabase";
        }
        impl chromiumoxide_types::Method for EventAddDatabase {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAddDatabase {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    pub mod device_orientation {
        use serde::{Deserialize, Serialize};
        #[doc = "Clears the overridden Device Orientation.\n[clearDeviceOrientationOverride](https://chromedevtools.github.io/devtools-protocol/tot/DeviceOrientation/#method-clearDeviceOrientationOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearDeviceOrientationOverrideParams {}
        impl ClearDeviceOrientationOverrideParams {
            pub const IDENTIFIER: &'static str = "DeviceOrientation.clearDeviceOrientationOverride";
        }
        impl chromiumoxide_types::Method for ClearDeviceOrientationOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearDeviceOrientationOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears the overridden Device Orientation.\n[clearDeviceOrientationOverride](https://chromedevtools.github.io/devtools-protocol/tot/DeviceOrientation/#method-clearDeviceOrientationOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearDeviceOrientationOverrideReturns {}
        impl chromiumoxide_types::Command for ClearDeviceOrientationOverrideParams {
            type Response = ClearDeviceOrientationOverrideReturns;
        }
        #[doc = "Overrides the Device Orientation.\n[setDeviceOrientationOverride](https://chromedevtools.github.io/devtools-protocol/tot/DeviceOrientation/#method-setDeviceOrientationOverride)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetDeviceOrientationOverrideParams {
            #[doc = "Mock alpha"]
            #[serde(rename = "alpha")]
            pub alpha: f64,
            #[doc = "Mock beta"]
            #[serde(rename = "beta")]
            pub beta: f64,
            #[doc = "Mock gamma"]
            #[serde(rename = "gamma")]
            pub gamma: f64,
        }
        impl SetDeviceOrientationOverrideParams {
            pub fn new(alpha: impl Into<f64>, beta: impl Into<f64>, gamma: impl Into<f64>) -> Self {
                Self {
                    alpha: alpha.into(),
                    beta: beta.into(),
                    gamma: gamma.into(),
                }
            }
        }
        impl SetDeviceOrientationOverrideParams {
            pub fn builder() -> SetDeviceOrientationOverrideParamsBuilder {
                SetDeviceOrientationOverrideParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetDeviceOrientationOverrideParamsBuilder {
            alpha: Option<f64>,
            beta: Option<f64>,
            gamma: Option<f64>,
        }
        impl SetDeviceOrientationOverrideParamsBuilder {
            pub fn alpha(mut self, alpha: impl Into<f64>) -> Self {
                self.alpha = Some(alpha.into());
                self
            }
            pub fn beta(mut self, beta: impl Into<f64>) -> Self {
                self.beta = Some(beta.into());
                self
            }
            pub fn gamma(mut self, gamma: impl Into<f64>) -> Self {
                self.gamma = Some(gamma.into());
                self
            }
            pub fn build(self) -> Result<SetDeviceOrientationOverrideParams, String> {
                Ok(SetDeviceOrientationOverrideParams {
                    alpha: self.alpha.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(alpha))
                    })?,
                    beta: self.beta.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(beta))
                    })?,
                    gamma: self.gamma.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(gamma))
                    })?,
                })
            }
        }
        impl SetDeviceOrientationOverrideParams {
            pub const IDENTIFIER: &'static str = "DeviceOrientation.setDeviceOrientationOverride";
        }
        impl chromiumoxide_types::Method for SetDeviceOrientationOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetDeviceOrientationOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Overrides the Device Orientation.\n[setDeviceOrientationOverride](https://chromedevtools.github.io/devtools-protocol/tot/DeviceOrientation/#method-setDeviceOrientationOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetDeviceOrientationOverrideReturns {}
        impl chromiumoxide_types::Command for SetDeviceOrientationOverrideParams {
            type Response = SetDeviceOrientationOverrideReturns;
        }
    }
    #[doc = "This domain emulates different environments for the page."]
    pub mod emulation {
        use serde::{Deserialize, Serialize};
        #[doc = "Screen orientation.\n[ScreenOrientation](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#type-ScreenOrientation)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ScreenOrientation {
            #[doc = "Orientation type."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: ScreenOrientationType,
            #[doc = "Orientation angle."]
            #[serde(rename = "angle")]
            pub angle: i64,
        }
        #[doc = "Orientation type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ScreenOrientationType {
            #[serde(rename = "portraitPrimary")]
            PortraitPrimary,
            #[serde(rename = "portraitSecondary")]
            PortraitSecondary,
            #[serde(rename = "landscapePrimary")]
            LandscapePrimary,
            #[serde(rename = "landscapeSecondary")]
            LandscapeSecondary,
        }
        impl AsRef<str> for ScreenOrientationType {
            fn as_ref(&self) -> &str {
                match self {
                    ScreenOrientationType::PortraitPrimary => "portraitPrimary",
                    ScreenOrientationType::PortraitSecondary => "portraitSecondary",
                    ScreenOrientationType::LandscapePrimary => "landscapePrimary",
                    ScreenOrientationType::LandscapeSecondary => "landscapeSecondary",
                }
            }
        }
        impl ::std::str::FromStr for ScreenOrientationType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "portraitPrimary" | "PortraitPrimary" | "portraitprimary" => {
                        Ok(ScreenOrientationType::PortraitPrimary)
                    }
                    "portraitSecondary" | "PortraitSecondary" | "portraitsecondary" => {
                        Ok(ScreenOrientationType::PortraitSecondary)
                    }
                    "landscapePrimary" | "LandscapePrimary" | "landscapeprimary" => {
                        Ok(ScreenOrientationType::LandscapePrimary)
                    }
                    "landscapeSecondary" | "LandscapeSecondary" | "landscapesecondary" => {
                        Ok(ScreenOrientationType::LandscapeSecondary)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl ScreenOrientation {
            pub fn new(r#type: impl Into<ScreenOrientationType>, angle: impl Into<i64>) -> Self {
                Self {
                    r#type: r#type.into(),
                    angle: angle.into(),
                }
            }
        }
        impl ScreenOrientation {
            pub fn builder() -> ScreenOrientationBuilder {
                ScreenOrientationBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ScreenOrientationBuilder {
            r#type: Option<ScreenOrientationType>,
            angle: Option<i64>,
        }
        impl ScreenOrientationBuilder {
            pub fn r#type(mut self, r#type: impl Into<ScreenOrientationType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn angle(mut self, angle: impl Into<i64>) -> Self {
                self.angle = Some(angle.into());
                self
            }
            pub fn build(self) -> Result<ScreenOrientation, String> {
                Ok(ScreenOrientation {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    angle: self.angle.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(angle))
                    })?,
                })
            }
        }
        impl ScreenOrientation {
            pub const IDENTIFIER: &'static str = "Emulation.ScreenOrientation";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DisplayFeature {
            #[doc = "Orientation of a display feature in relation to screen"]
            #[serde(rename = "orientation")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub orientation: DisplayFeatureOrientation,
            #[doc = "The offset from the screen origin in either the x (for vertical\norientation) or y (for horizontal orientation) direction."]
            #[serde(rename = "offset")]
            pub offset: i64,
            #[doc = "A display feature may mask content such that it is not physically\ndisplayed - this length along with the offset describes this area.\nA display feature that only splits content will have a 0 mask_length."]
            #[serde(rename = "maskLength")]
            pub mask_length: i64,
        }
        #[doc = "Orientation of a display feature in relation to screen"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum DisplayFeatureOrientation {
            #[serde(rename = "vertical")]
            Vertical,
            #[serde(rename = "horizontal")]
            Horizontal,
        }
        impl AsRef<str> for DisplayFeatureOrientation {
            fn as_ref(&self) -> &str {
                match self {
                    DisplayFeatureOrientation::Vertical => "vertical",
                    DisplayFeatureOrientation::Horizontal => "horizontal",
                }
            }
        }
        impl ::std::str::FromStr for DisplayFeatureOrientation {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "vertical" | "Vertical" => Ok(DisplayFeatureOrientation::Vertical),
                    "horizontal" | "Horizontal" => Ok(DisplayFeatureOrientation::Horizontal),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl DisplayFeature {
            pub fn new(
                orientation: impl Into<DisplayFeatureOrientation>,
                offset: impl Into<i64>,
                mask_length: impl Into<i64>,
            ) -> Self {
                Self {
                    orientation: orientation.into(),
                    offset: offset.into(),
                    mask_length: mask_length.into(),
                }
            }
        }
        impl DisplayFeature {
            pub fn builder() -> DisplayFeatureBuilder {
                DisplayFeatureBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DisplayFeatureBuilder {
            orientation: Option<DisplayFeatureOrientation>,
            offset: Option<i64>,
            mask_length: Option<i64>,
        }
        impl DisplayFeatureBuilder {
            pub fn orientation(
                mut self,
                orientation: impl Into<DisplayFeatureOrientation>,
            ) -> Self {
                self.orientation = Some(orientation.into());
                self
            }
            pub fn offset(mut self, offset: impl Into<i64>) -> Self {
                self.offset = Some(offset.into());
                self
            }
            pub fn mask_length(mut self, mask_length: impl Into<i64>) -> Self {
                self.mask_length = Some(mask_length.into());
                self
            }
            pub fn build(self) -> Result<DisplayFeature, String> {
                Ok(DisplayFeature {
                    orientation: self.orientation.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(orientation))
                    })?,
                    offset: self.offset.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(offset))
                    })?,
                    mask_length: self.mask_length.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(mask_length))
                    })?,
                })
            }
        }
        impl DisplayFeature {
            pub const IDENTIFIER: &'static str = "Emulation.DisplayFeature";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct MediaFeature {
            #[serde(rename = "name")]
            pub name: String,
            #[serde(rename = "value")]
            pub value: String,
        }
        impl MediaFeature {
            pub fn new(name: impl Into<String>, value: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                }
            }
        }
        impl MediaFeature {
            pub fn builder() -> MediaFeatureBuilder {
                MediaFeatureBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct MediaFeatureBuilder {
            name: Option<String>,
            value: Option<String>,
        }
        impl MediaFeatureBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<MediaFeature, String> {
                Ok(MediaFeature {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl MediaFeature {
            pub const IDENTIFIER: &'static str = "Emulation.MediaFeature";
        }
        #[doc = "advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to\nallow the next delayed task (if any) to run; pause: The virtual time base may not advance;\npauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending\nresource fetches."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum VirtualTimePolicy {
            #[serde(rename = "advance")]
            Advance,
            #[serde(rename = "pause")]
            Pause,
            #[serde(rename = "pauseIfNetworkFetchesPending")]
            PauseIfNetworkFetchesPending,
        }
        impl AsRef<str> for VirtualTimePolicy {
            fn as_ref(&self) -> &str {
                match self {
                    VirtualTimePolicy::Advance => "advance",
                    VirtualTimePolicy::Pause => "pause",
                    VirtualTimePolicy::PauseIfNetworkFetchesPending => {
                        "pauseIfNetworkFetchesPending"
                    }
                }
            }
        }
        impl ::std::str::FromStr for VirtualTimePolicy {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "advance" | "Advance" => Ok(VirtualTimePolicy::Advance),
                    "pause" | "Pause" => Ok(VirtualTimePolicy::Pause),
                    "pauseIfNetworkFetchesPending"
                    | "PauseIfNetworkFetchesPending"
                    | "pauseifnetworkfetchespending" => {
                        Ok(VirtualTimePolicy::PauseIfNetworkFetchesPending)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints\n[UserAgentBrandVersion](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#type-UserAgentBrandVersion)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct UserAgentBrandVersion {
            #[serde(rename = "brand")]
            pub brand: String,
            #[serde(rename = "version")]
            pub version: String,
        }
        impl UserAgentBrandVersion {
            pub fn new(brand: impl Into<String>, version: impl Into<String>) -> Self {
                Self {
                    brand: brand.into(),
                    version: version.into(),
                }
            }
        }
        impl UserAgentBrandVersion {
            pub fn builder() -> UserAgentBrandVersionBuilder {
                UserAgentBrandVersionBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct UserAgentBrandVersionBuilder {
            brand: Option<String>,
            version: Option<String>,
        }
        impl UserAgentBrandVersionBuilder {
            pub fn brand(mut self, brand: impl Into<String>) -> Self {
                self.brand = Some(brand.into());
                self
            }
            pub fn version(mut self, version: impl Into<String>) -> Self {
                self.version = Some(version.into());
                self
            }
            pub fn build(self) -> Result<UserAgentBrandVersion, String> {
                Ok(UserAgentBrandVersion {
                    brand: self.brand.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(brand))
                    })?,
                    version: self.version.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(version))
                    })?,
                })
            }
        }
        impl UserAgentBrandVersion {
            pub const IDENTIFIER: &'static str = "Emulation.UserAgentBrandVersion";
        }
        #[doc = "Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints\nMissing optional values will be filled in by the target with what it would normally use.\n[UserAgentMetadata](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#type-UserAgentMetadata)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct UserAgentMetadata {
            #[serde(rename = "brands")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub brands: Option<Vec<UserAgentBrandVersion>>,
            #[serde(rename = "fullVersionList")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub full_version_list: Option<Vec<UserAgentBrandVersion>>,
            #[serde(rename = "platform")]
            pub platform: String,
            #[serde(rename = "platformVersion")]
            pub platform_version: String,
            #[serde(rename = "architecture")]
            pub architecture: String,
            #[serde(rename = "model")]
            pub model: String,
            #[serde(rename = "mobile")]
            pub mobile: bool,
            #[serde(rename = "bitness")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub bitness: Option<String>,
            #[serde(rename = "wow64")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub wow64: Option<bool>,
        }
        impl UserAgentMetadata {
            pub fn builder() -> UserAgentMetadataBuilder {
                UserAgentMetadataBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct UserAgentMetadataBuilder {
            brands: Option<Vec<UserAgentBrandVersion>>,
            full_version_list: Option<Vec<UserAgentBrandVersion>>,
            platform: Option<String>,
            platform_version: Option<String>,
            architecture: Option<String>,
            model: Option<String>,
            mobile: Option<bool>,
            bitness: Option<String>,
            wow64: Option<bool>,
        }
        impl UserAgentMetadataBuilder {
            pub fn brand(mut self, brand: impl Into<UserAgentBrandVersion>) -> Self {
                let v = self.brands.get_or_insert(Vec::new());
                v.push(brand.into());
                self
            }
            pub fn brands<I, S>(mut self, brands: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<UserAgentBrandVersion>,
            {
                let v = self.brands.get_or_insert(Vec::new());
                for val in brands {
                    v.push(val.into());
                }
                self
            }
            pub fn full_version_list(
                mut self,
                full_version_list: impl Into<UserAgentBrandVersion>,
            ) -> Self {
                let v = self.full_version_list.get_or_insert(Vec::new());
                v.push(full_version_list.into());
                self
            }
            pub fn full_version_lists<I, S>(mut self, full_version_lists: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<UserAgentBrandVersion>,
            {
                let v = self.full_version_list.get_or_insert(Vec::new());
                for val in full_version_lists {
                    v.push(val.into());
                }
                self
            }
            pub fn platform(mut self, platform: impl Into<String>) -> Self {
                self.platform = Some(platform.into());
                self
            }
            pub fn platform_version(mut self, platform_version: impl Into<String>) -> Self {
                self.platform_version = Some(platform_version.into());
                self
            }
            pub fn architecture(mut self, architecture: impl Into<String>) -> Self {
                self.architecture = Some(architecture.into());
                self
            }
            pub fn model(mut self, model: impl Into<String>) -> Self {
                self.model = Some(model.into());
                self
            }
            pub fn mobile(mut self, mobile: impl Into<bool>) -> Self {
                self.mobile = Some(mobile.into());
                self
            }
            pub fn bitness(mut self, bitness: impl Into<String>) -> Self {
                self.bitness = Some(bitness.into());
                self
            }
            pub fn wow64(mut self, wow64: impl Into<bool>) -> Self {
                self.wow64 = Some(wow64.into());
                self
            }
            pub fn build(self) -> Result<UserAgentMetadata, String> {
                Ok(UserAgentMetadata {
                    brands: self.brands,
                    full_version_list: self.full_version_list,
                    platform: self.platform.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(platform))
                    })?,
                    platform_version: self.platform_version.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(platform_version)
                        )
                    })?,
                    architecture: self.architecture.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(architecture))
                    })?,
                    model: self.model.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(model))
                    })?,
                    mobile: self.mobile.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(mobile))
                    })?,
                    bitness: self.bitness,
                    wow64: self.wow64,
                })
            }
        }
        impl UserAgentMetadata {
            pub const IDENTIFIER: &'static str = "Emulation.UserAgentMetadata";
        }
        #[doc = "Enum of image types that can be disabled."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum DisabledImageType {
            #[serde(rename = "avif")]
            Avif,
            #[serde(rename = "jxl")]
            Jxl,
            #[serde(rename = "webp")]
            Webp,
        }
        impl AsRef<str> for DisabledImageType {
            fn as_ref(&self) -> &str {
                match self {
                    DisabledImageType::Avif => "avif",
                    DisabledImageType::Jxl => "jxl",
                    DisabledImageType::Webp => "webp",
                }
            }
        }
        impl ::std::str::FromStr for DisabledImageType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "avif" | "Avif" => Ok(DisabledImageType::Avif),
                    "jxl" | "Jxl" => Ok(DisabledImageType::Jxl),
                    "webp" | "Webp" => Ok(DisabledImageType::Webp),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Tells whether emulation is supported.\n[canEmulate](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-canEmulate)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CanEmulateParams {}
        impl CanEmulateParams {
            pub const IDENTIFIER: &'static str = "Emulation.canEmulate";
        }
        impl chromiumoxide_types::Method for CanEmulateParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CanEmulateParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Tells whether emulation is supported.\n[canEmulate](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-canEmulate)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CanEmulateReturns {
            #[doc = "True if emulation is supported."]
            #[serde(rename = "result")]
            pub result: bool,
        }
        impl CanEmulateReturns {
            pub fn new(result: impl Into<bool>) -> Self {
                Self {
                    result: result.into(),
                }
            }
        }
        impl CanEmulateReturns {
            pub fn builder() -> CanEmulateReturnsBuilder {
                CanEmulateReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CanEmulateReturnsBuilder {
            result: Option<bool>,
        }
        impl CanEmulateReturnsBuilder {
            pub fn result(mut self, result: impl Into<bool>) -> Self {
                self.result = Some(result.into());
                self
            }
            pub fn build(self) -> Result<CanEmulateReturns, String> {
                Ok(CanEmulateReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for CanEmulateParams {
            type Response = CanEmulateReturns;
        }
        #[doc = "Clears the overridden device metrics.\n[clearDeviceMetricsOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-clearDeviceMetricsOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearDeviceMetricsOverrideParams {}
        impl ClearDeviceMetricsOverrideParams {
            pub const IDENTIFIER: &'static str = "Emulation.clearDeviceMetricsOverride";
        }
        impl chromiumoxide_types::Method for ClearDeviceMetricsOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearDeviceMetricsOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears the overridden device metrics.\n[clearDeviceMetricsOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-clearDeviceMetricsOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearDeviceMetricsOverrideReturns {}
        impl chromiumoxide_types::Command for ClearDeviceMetricsOverrideParams {
            type Response = ClearDeviceMetricsOverrideReturns;
        }
        #[doc = "Clears the overridden Geolocation Position and Error.\n[clearGeolocationOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-clearGeolocationOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearGeolocationOverrideParams {}
        impl ClearGeolocationOverrideParams {
            pub const IDENTIFIER: &'static str = "Emulation.clearGeolocationOverride";
        }
        impl chromiumoxide_types::Method for ClearGeolocationOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearGeolocationOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears the overridden Geolocation Position and Error.\n[clearGeolocationOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-clearGeolocationOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearGeolocationOverrideReturns {}
        impl chromiumoxide_types::Command for ClearGeolocationOverrideParams {
            type Response = ClearGeolocationOverrideReturns;
        }
        #[doc = "Requests that page scale factor is reset to initial values.\n[resetPageScaleFactor](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-resetPageScaleFactor)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ResetPageScaleFactorParams {}
        impl ResetPageScaleFactorParams {
            pub const IDENTIFIER: &'static str = "Emulation.resetPageScaleFactor";
        }
        impl chromiumoxide_types::Method for ResetPageScaleFactorParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ResetPageScaleFactorParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests that page scale factor is reset to initial values.\n[resetPageScaleFactor](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-resetPageScaleFactor)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ResetPageScaleFactorReturns {}
        impl chromiumoxide_types::Command for ResetPageScaleFactorParams {
            type Response = ResetPageScaleFactorReturns;
        }
        #[doc = "Enables or disables simulating a focused and active page.\n[setFocusEmulationEnabled](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setFocusEmulationEnabled)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetFocusEmulationEnabledParams {
            #[doc = "Whether to enable to disable focus emulation."]
            #[serde(rename = "enabled")]
            pub enabled: bool,
        }
        impl SetFocusEmulationEnabledParams {
            pub fn new(enabled: impl Into<bool>) -> Self {
                Self {
                    enabled: enabled.into(),
                }
            }
        }
        impl SetFocusEmulationEnabledParams {
            pub fn builder() -> SetFocusEmulationEnabledParamsBuilder {
                SetFocusEmulationEnabledParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetFocusEmulationEnabledParamsBuilder {
            enabled: Option<bool>,
        }
        impl SetFocusEmulationEnabledParamsBuilder {
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn build(self) -> Result<SetFocusEmulationEnabledParams, String> {
                Ok(SetFocusEmulationEnabledParams {
                    enabled: self.enabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enabled))
                    })?,
                })
            }
        }
        impl SetFocusEmulationEnabledParams {
            pub const IDENTIFIER: &'static str = "Emulation.setFocusEmulationEnabled";
        }
        impl chromiumoxide_types::Method for SetFocusEmulationEnabledParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetFocusEmulationEnabledParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables or disables simulating a focused and active page.\n[setFocusEmulationEnabled](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setFocusEmulationEnabled)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetFocusEmulationEnabledReturns {}
        impl chromiumoxide_types::Command for SetFocusEmulationEnabledParams {
            type Response = SetFocusEmulationEnabledReturns;
        }
        #[doc = "Automatically render all web contents using a dark theme.\n[setAutoDarkModeOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setAutoDarkModeOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetAutoDarkModeOverrideParams {
            #[doc = "Whether to enable or disable automatic dark mode.\nIf not specified, any existing override will be cleared."]
            #[serde(rename = "enabled")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub enabled: Option<bool>,
        }
        impl SetAutoDarkModeOverrideParams {
            pub fn builder() -> SetAutoDarkModeOverrideParamsBuilder {
                SetAutoDarkModeOverrideParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetAutoDarkModeOverrideParamsBuilder {
            enabled: Option<bool>,
        }
        impl SetAutoDarkModeOverrideParamsBuilder {
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn build(self) -> SetAutoDarkModeOverrideParams {
                SetAutoDarkModeOverrideParams {
                    enabled: self.enabled,
                }
            }
        }
        impl SetAutoDarkModeOverrideParams {
            pub const IDENTIFIER: &'static str = "Emulation.setAutoDarkModeOverride";
        }
        impl chromiumoxide_types::Method for SetAutoDarkModeOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetAutoDarkModeOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Automatically render all web contents using a dark theme.\n[setAutoDarkModeOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setAutoDarkModeOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetAutoDarkModeOverrideReturns {}
        impl chromiumoxide_types::Command for SetAutoDarkModeOverrideParams {
            type Response = SetAutoDarkModeOverrideReturns;
        }
        #[doc = "Enables CPU throttling to emulate slow CPUs.\n[setCPUThrottlingRate](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setCPUThrottlingRate)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetCpuThrottlingRateParams {
            #[doc = "Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc)."]
            #[serde(rename = "rate")]
            pub rate: f64,
        }
        impl SetCpuThrottlingRateParams {
            pub fn new(rate: impl Into<f64>) -> Self {
                Self { rate: rate.into() }
            }
        }
        impl SetCpuThrottlingRateParams {
            pub fn builder() -> SetCpuThrottlingRateParamsBuilder {
                SetCpuThrottlingRateParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetCpuThrottlingRateParamsBuilder {
            rate: Option<f64>,
        }
        impl SetCpuThrottlingRateParamsBuilder {
            pub fn rate(mut self, rate: impl Into<f64>) -> Self {
                self.rate = Some(rate.into());
                self
            }
            pub fn build(self) -> Result<SetCpuThrottlingRateParams, String> {
                Ok(SetCpuThrottlingRateParams {
                    rate: self.rate.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(rate))
                    })?,
                })
            }
        }
        impl SetCpuThrottlingRateParams {
            pub const IDENTIFIER: &'static str = "Emulation.setCPUThrottlingRate";
        }
        impl chromiumoxide_types::Method for SetCpuThrottlingRateParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetCpuThrottlingRateParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables CPU throttling to emulate slow CPUs.\n[setCPUThrottlingRate](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setCPUThrottlingRate)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetCpuThrottlingRateReturns {}
        impl chromiumoxide_types::Command for SetCpuThrottlingRateParams {
            type Response = SetCpuThrottlingRateReturns;
        }
        #[doc = "Sets or clears an override of the default background color of the frame. This override is used\nif the content does not specify one.\n[setDefaultBackgroundColorOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setDefaultBackgroundColorOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetDefaultBackgroundColorOverrideParams {
            #[doc = "RGBA of the default background color. If not specified, any existing override will be\ncleared."]
            #[serde(rename = "color")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub color: Option<super::dom::Rgba>,
        }
        impl SetDefaultBackgroundColorOverrideParams {
            pub fn builder() -> SetDefaultBackgroundColorOverrideParamsBuilder {
                SetDefaultBackgroundColorOverrideParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetDefaultBackgroundColorOverrideParamsBuilder {
            color: Option<super::dom::Rgba>,
        }
        impl SetDefaultBackgroundColorOverrideParamsBuilder {
            pub fn color(mut self, color: impl Into<super::dom::Rgba>) -> Self {
                self.color = Some(color.into());
                self
            }
            pub fn build(self) -> SetDefaultBackgroundColorOverrideParams {
                SetDefaultBackgroundColorOverrideParams { color: self.color }
            }
        }
        impl SetDefaultBackgroundColorOverrideParams {
            pub const IDENTIFIER: &'static str = "Emulation.setDefaultBackgroundColorOverride";
        }
        impl chromiumoxide_types::Method for SetDefaultBackgroundColorOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetDefaultBackgroundColorOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets or clears an override of the default background color of the frame. This override is used\nif the content does not specify one.\n[setDefaultBackgroundColorOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setDefaultBackgroundColorOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetDefaultBackgroundColorOverrideReturns {}
        impl chromiumoxide_types::Command for SetDefaultBackgroundColorOverrideParams {
            type Response = SetDefaultBackgroundColorOverrideReturns;
        }
        #[doc = "Overrides the values of device screen dimensions (window.screen.width, window.screen.height,\nwindow.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media\nquery results).\n[setDeviceMetricsOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setDeviceMetricsOverride)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetDeviceMetricsOverrideParams {
            #[doc = "Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override."]
            #[serde(rename = "width")]
            pub width: i64,
            #[doc = "Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override."]
            #[serde(rename = "height")]
            pub height: i64,
            #[doc = "Overriding device scale factor value. 0 disables the override."]
            #[serde(rename = "deviceScaleFactor")]
            pub device_scale_factor: f64,
            #[doc = "Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text\nautosizing and more."]
            #[serde(rename = "mobile")]
            pub mobile: bool,
            #[doc = "Scale to apply to resulting view image."]
            #[serde(rename = "scale")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub scale: Option<f64>,
            #[doc = "Overriding screen width value in pixels (minimum 0, maximum 10000000)."]
            #[serde(rename = "screenWidth")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub screen_width: Option<i64>,
            #[doc = "Overriding screen height value in pixels (minimum 0, maximum 10000000)."]
            #[serde(rename = "screenHeight")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub screen_height: Option<i64>,
            #[doc = "Overriding view X position on screen in pixels (minimum 0, maximum 10000000)."]
            #[serde(rename = "positionX")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub position_x: Option<i64>,
            #[doc = "Overriding view Y position on screen in pixels (minimum 0, maximum 10000000)."]
            #[serde(rename = "positionY")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub position_y: Option<i64>,
            #[doc = "Do not set visible view size, rely upon explicit setVisibleSize call."]
            #[serde(rename = "dontSetVisibleSize")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub dont_set_visible_size: Option<bool>,
            #[doc = "Screen orientation override."]
            #[serde(rename = "screenOrientation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub screen_orientation: Option<ScreenOrientation>,
            #[doc = "If set, the visible area of the page will be overridden to this viewport. This viewport\nchange is not observed by the page, e.g. viewport-relative elements do not change positions."]
            #[serde(rename = "viewport")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub viewport: Option<super::page::Viewport>,
            #[doc = "If set, the display feature of a multi-segment screen. If not set, multi-segment support\nis turned-off."]
            #[serde(rename = "displayFeature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub display_feature: Option<DisplayFeature>,
        }
        impl SetDeviceMetricsOverrideParams {
            pub fn new(
                width: impl Into<i64>,
                height: impl Into<i64>,
                device_scale_factor: impl Into<f64>,
                mobile: impl Into<bool>,
            ) -> Self {
                Self {
                    width: width.into(),
                    height: height.into(),
                    device_scale_factor: device_scale_factor.into(),
                    mobile: mobile.into(),
                    scale: None,
                    screen_width: None,
                    screen_height: None,
                    position_x: None,
                    position_y: None,
                    dont_set_visible_size: None,
                    screen_orientation: None,
                    viewport: None,
                    display_feature: None,
                }
            }
        }
        impl SetDeviceMetricsOverrideParams {
            pub fn builder() -> SetDeviceMetricsOverrideParamsBuilder {
                SetDeviceMetricsOverrideParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetDeviceMetricsOverrideParamsBuilder {
            width: Option<i64>,
            height: Option<i64>,
            device_scale_factor: Option<f64>,
            mobile: Option<bool>,
            scale: Option<f64>,
            screen_width: Option<i64>,
            screen_height: Option<i64>,
            position_x: Option<i64>,
            position_y: Option<i64>,
            dont_set_visible_size: Option<bool>,
            screen_orientation: Option<ScreenOrientation>,
            viewport: Option<super::page::Viewport>,
            display_feature: Option<DisplayFeature>,
        }
        impl SetDeviceMetricsOverrideParamsBuilder {
            pub fn width(mut self, width: impl Into<i64>) -> Self {
                self.width = Some(width.into());
                self
            }
            pub fn height(mut self, height: impl Into<i64>) -> Self {
                self.height = Some(height.into());
                self
            }
            pub fn device_scale_factor(mut self, device_scale_factor: impl Into<f64>) -> Self {
                self.device_scale_factor = Some(device_scale_factor.into());
                self
            }
            pub fn mobile(mut self, mobile: impl Into<bool>) -> Self {
                self.mobile = Some(mobile.into());
                self
            }
            pub fn scale(mut self, scale: impl Into<f64>) -> Self {
                self.scale = Some(scale.into());
                self
            }
            pub fn screen_width(mut self, screen_width: impl Into<i64>) -> Self {
                self.screen_width = Some(screen_width.into());
                self
            }
            pub fn screen_height(mut self, screen_height: impl Into<i64>) -> Self {
                self.screen_height = Some(screen_height.into());
                self
            }
            pub fn position_x(mut self, position_x: impl Into<i64>) -> Self {
                self.position_x = Some(position_x.into());
                self
            }
            pub fn position_y(mut self, position_y: impl Into<i64>) -> Self {
                self.position_y = Some(position_y.into());
                self
            }
            pub fn dont_set_visible_size(mut self, dont_set_visible_size: impl Into<bool>) -> Self {
                self.dont_set_visible_size = Some(dont_set_visible_size.into());
                self
            }
            pub fn screen_orientation(
                mut self,
                screen_orientation: impl Into<ScreenOrientation>,
            ) -> Self {
                self.screen_orientation = Some(screen_orientation.into());
                self
            }
            pub fn viewport(mut self, viewport: impl Into<super::page::Viewport>) -> Self {
                self.viewport = Some(viewport.into());
                self
            }
            pub fn display_feature(mut self, display_feature: impl Into<DisplayFeature>) -> Self {
                self.display_feature = Some(display_feature.into());
                self
            }
            pub fn build(self) -> Result<SetDeviceMetricsOverrideParams, String> {
                Ok(SetDeviceMetricsOverrideParams {
                    width: self.width.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(width))
                    })?,
                    height: self.height.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(height))
                    })?,
                    device_scale_factor: self.device_scale_factor.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(device_scale_factor)
                        )
                    })?,
                    mobile: self.mobile.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(mobile))
                    })?,
                    scale: self.scale,
                    screen_width: self.screen_width,
                    screen_height: self.screen_height,
                    position_x: self.position_x,
                    position_y: self.position_y,
                    dont_set_visible_size: self.dont_set_visible_size,
                    screen_orientation: self.screen_orientation,
                    viewport: self.viewport,
                    display_feature: self.display_feature,
                })
            }
        }
        impl SetDeviceMetricsOverrideParams {
            pub const IDENTIFIER: &'static str = "Emulation.setDeviceMetricsOverride";
        }
        impl chromiumoxide_types::Method for SetDeviceMetricsOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetDeviceMetricsOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Overrides the values of device screen dimensions (window.screen.width, window.screen.height,\nwindow.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media\nquery results).\n[setDeviceMetricsOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setDeviceMetricsOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetDeviceMetricsOverrideReturns {}
        impl chromiumoxide_types::Command for SetDeviceMetricsOverrideParams {
            type Response = SetDeviceMetricsOverrideReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetScrollbarsHiddenParams {
            #[doc = "Whether scrollbars should be always hidden."]
            #[serde(rename = "hidden")]
            pub hidden: bool,
        }
        impl SetScrollbarsHiddenParams {
            pub fn new(hidden: impl Into<bool>) -> Self {
                Self {
                    hidden: hidden.into(),
                }
            }
        }
        impl SetScrollbarsHiddenParams {
            pub fn builder() -> SetScrollbarsHiddenParamsBuilder {
                SetScrollbarsHiddenParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetScrollbarsHiddenParamsBuilder {
            hidden: Option<bool>,
        }
        impl SetScrollbarsHiddenParamsBuilder {
            pub fn hidden(mut self, hidden: impl Into<bool>) -> Self {
                self.hidden = Some(hidden.into());
                self
            }
            pub fn build(self) -> Result<SetScrollbarsHiddenParams, String> {
                Ok(SetScrollbarsHiddenParams {
                    hidden: self.hidden.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(hidden))
                    })?,
                })
            }
        }
        impl SetScrollbarsHiddenParams {
            pub const IDENTIFIER: &'static str = "Emulation.setScrollbarsHidden";
        }
        impl chromiumoxide_types::Method for SetScrollbarsHiddenParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetScrollbarsHiddenParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetScrollbarsHiddenReturns {}
        impl chromiumoxide_types::Command for SetScrollbarsHiddenParams {
            type Response = SetScrollbarsHiddenReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetDocumentCookieDisabledParams {
            #[doc = "Whether document.coookie API should be disabled."]
            #[serde(rename = "disabled")]
            pub disabled: bool,
        }
        impl SetDocumentCookieDisabledParams {
            pub fn new(disabled: impl Into<bool>) -> Self {
                Self {
                    disabled: disabled.into(),
                }
            }
        }
        impl SetDocumentCookieDisabledParams {
            pub fn builder() -> SetDocumentCookieDisabledParamsBuilder {
                SetDocumentCookieDisabledParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetDocumentCookieDisabledParamsBuilder {
            disabled: Option<bool>,
        }
        impl SetDocumentCookieDisabledParamsBuilder {
            pub fn disabled(mut self, disabled: impl Into<bool>) -> Self {
                self.disabled = Some(disabled.into());
                self
            }
            pub fn build(self) -> Result<SetDocumentCookieDisabledParams, String> {
                Ok(SetDocumentCookieDisabledParams {
                    disabled: self.disabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(disabled))
                    })?,
                })
            }
        }
        impl SetDocumentCookieDisabledParams {
            pub const IDENTIFIER: &'static str = "Emulation.setDocumentCookieDisabled";
        }
        impl chromiumoxide_types::Method for SetDocumentCookieDisabledParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetDocumentCookieDisabledParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetDocumentCookieDisabledReturns {}
        impl chromiumoxide_types::Command for SetDocumentCookieDisabledParams {
            type Response = SetDocumentCookieDisabledReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetEmitTouchEventsForMouseParams {
            #[doc = "Whether touch emulation based on mouse input should be enabled."]
            #[serde(rename = "enabled")]
            pub enabled: bool,
            #[doc = "Touch/gesture events configuration. Default: current platform."]
            #[serde(rename = "configuration")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub configuration: Option<SetEmitTouchEventsForMouseConfiguration>,
        }
        #[doc = "Touch/gesture events configuration. Default: current platform."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SetEmitTouchEventsForMouseConfiguration {
            #[serde(rename = "mobile")]
            Mobile,
            #[serde(rename = "desktop")]
            Desktop,
        }
        impl AsRef<str> for SetEmitTouchEventsForMouseConfiguration {
            fn as_ref(&self) -> &str {
                match self {
                    SetEmitTouchEventsForMouseConfiguration::Mobile => "mobile",
                    SetEmitTouchEventsForMouseConfiguration::Desktop => "desktop",
                }
            }
        }
        impl ::std::str::FromStr for SetEmitTouchEventsForMouseConfiguration {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "mobile" | "Mobile" => Ok(SetEmitTouchEventsForMouseConfiguration::Mobile),
                    "desktop" | "Desktop" => Ok(SetEmitTouchEventsForMouseConfiguration::Desktop),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl SetEmitTouchEventsForMouseParams {
            pub fn new(enabled: impl Into<bool>) -> Self {
                Self {
                    enabled: enabled.into(),
                    configuration: None,
                }
            }
        }
        impl SetEmitTouchEventsForMouseParams {
            pub fn builder() -> SetEmitTouchEventsForMouseParamsBuilder {
                SetEmitTouchEventsForMouseParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetEmitTouchEventsForMouseParamsBuilder {
            enabled: Option<bool>,
            configuration: Option<SetEmitTouchEventsForMouseConfiguration>,
        }
        impl SetEmitTouchEventsForMouseParamsBuilder {
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn configuration(
                mut self,
                configuration: impl Into<SetEmitTouchEventsForMouseConfiguration>,
            ) -> Self {
                self.configuration = Some(configuration.into());
                self
            }
            pub fn build(self) -> Result<SetEmitTouchEventsForMouseParams, String> {
                Ok(SetEmitTouchEventsForMouseParams {
                    enabled: self.enabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enabled))
                    })?,
                    configuration: self.configuration,
                })
            }
        }
        impl SetEmitTouchEventsForMouseParams {
            pub const IDENTIFIER: &'static str = "Emulation.setEmitTouchEventsForMouse";
        }
        impl chromiumoxide_types::Method for SetEmitTouchEventsForMouseParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetEmitTouchEventsForMouseParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetEmitTouchEventsForMouseReturns {}
        impl chromiumoxide_types::Command for SetEmitTouchEventsForMouseParams {
            type Response = SetEmitTouchEventsForMouseReturns;
        }
        #[doc = "Emulates the given media type or media feature for CSS media queries.\n[setEmulatedMedia](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setEmulatedMedia)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetEmulatedMediaParams {
            #[doc = "Media type to emulate. Empty string disables the override."]
            #[serde(rename = "media")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub media: Option<String>,
            #[doc = "Media features to emulate."]
            #[serde(rename = "features")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub features: Option<Vec<MediaFeature>>,
        }
        impl SetEmulatedMediaParams {
            pub fn builder() -> SetEmulatedMediaParamsBuilder {
                SetEmulatedMediaParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetEmulatedMediaParamsBuilder {
            media: Option<String>,
            features: Option<Vec<MediaFeature>>,
        }
        impl SetEmulatedMediaParamsBuilder {
            pub fn media(mut self, media: impl Into<String>) -> Self {
                self.media = Some(media.into());
                self
            }
            pub fn feature(mut self, feature: impl Into<MediaFeature>) -> Self {
                let v = self.features.get_or_insert(Vec::new());
                v.push(feature.into());
                self
            }
            pub fn features<I, S>(mut self, features: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<MediaFeature>,
            {
                let v = self.features.get_or_insert(Vec::new());
                for val in features {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> SetEmulatedMediaParams {
                SetEmulatedMediaParams {
                    media: self.media,
                    features: self.features,
                }
            }
        }
        impl SetEmulatedMediaParams {
            pub const IDENTIFIER: &'static str = "Emulation.setEmulatedMedia";
        }
        impl chromiumoxide_types::Method for SetEmulatedMediaParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetEmulatedMediaParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Emulates the given media type or media feature for CSS media queries.\n[setEmulatedMedia](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setEmulatedMedia)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetEmulatedMediaReturns {}
        impl chromiumoxide_types::Command for SetEmulatedMediaParams {
            type Response = SetEmulatedMediaReturns;
        }
        #[doc = "Emulates the given vision deficiency.\n[setEmulatedVisionDeficiency](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setEmulatedVisionDeficiency)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetEmulatedVisionDeficiencyParams {
            #[doc = "Vision deficiency to emulate."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: SetEmulatedVisionDeficiencyType,
        }
        #[doc = "Vision deficiency to emulate."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SetEmulatedVisionDeficiencyType {
            #[serde(rename = "none")]
            None,
            #[serde(rename = "achromatopsia")]
            Achromatopsia,
            #[serde(rename = "blurredVision")]
            BlurredVision,
            #[serde(rename = "deuteranopia")]
            Deuteranopia,
            #[serde(rename = "protanopia")]
            Protanopia,
            #[serde(rename = "tritanopia")]
            Tritanopia,
        }
        impl AsRef<str> for SetEmulatedVisionDeficiencyType {
            fn as_ref(&self) -> &str {
                match self {
                    SetEmulatedVisionDeficiencyType::None => "none",
                    SetEmulatedVisionDeficiencyType::Achromatopsia => "achromatopsia",
                    SetEmulatedVisionDeficiencyType::BlurredVision => "blurredVision",
                    SetEmulatedVisionDeficiencyType::Deuteranopia => "deuteranopia",
                    SetEmulatedVisionDeficiencyType::Protanopia => "protanopia",
                    SetEmulatedVisionDeficiencyType::Tritanopia => "tritanopia",
                }
            }
        }
        impl ::std::str::FromStr for SetEmulatedVisionDeficiencyType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "none" | "None" => Ok(SetEmulatedVisionDeficiencyType::None),
                    "achromatopsia" | "Achromatopsia" => {
                        Ok(SetEmulatedVisionDeficiencyType::Achromatopsia)
                    }
                    "blurredVision" | "BlurredVision" | "blurredvision" => {
                        Ok(SetEmulatedVisionDeficiencyType::BlurredVision)
                    }
                    "deuteranopia" | "Deuteranopia" => {
                        Ok(SetEmulatedVisionDeficiencyType::Deuteranopia)
                    }
                    "protanopia" | "Protanopia" => Ok(SetEmulatedVisionDeficiencyType::Protanopia),
                    "tritanopia" | "Tritanopia" => Ok(SetEmulatedVisionDeficiencyType::Tritanopia),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl SetEmulatedVisionDeficiencyParams {
            pub fn new(r#type: impl Into<SetEmulatedVisionDeficiencyType>) -> Self {
                Self {
                    r#type: r#type.into(),
                }
            }
        }
        impl SetEmulatedVisionDeficiencyParams {
            pub fn builder() -> SetEmulatedVisionDeficiencyParamsBuilder {
                SetEmulatedVisionDeficiencyParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetEmulatedVisionDeficiencyParamsBuilder {
            r#type: Option<SetEmulatedVisionDeficiencyType>,
        }
        impl SetEmulatedVisionDeficiencyParamsBuilder {
            pub fn r#type(mut self, r#type: impl Into<SetEmulatedVisionDeficiencyType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn build(self) -> Result<SetEmulatedVisionDeficiencyParams, String> {
                Ok(SetEmulatedVisionDeficiencyParams {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                })
            }
        }
        impl SetEmulatedVisionDeficiencyParams {
            pub const IDENTIFIER: &'static str = "Emulation.setEmulatedVisionDeficiency";
        }
        impl chromiumoxide_types::Method for SetEmulatedVisionDeficiencyParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetEmulatedVisionDeficiencyParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Emulates the given vision deficiency.\n[setEmulatedVisionDeficiency](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setEmulatedVisionDeficiency)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetEmulatedVisionDeficiencyReturns {}
        impl chromiumoxide_types::Command for SetEmulatedVisionDeficiencyParams {
            type Response = SetEmulatedVisionDeficiencyReturns;
        }
        #[doc = "Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position\nunavailable.\n[setGeolocationOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setGeolocationOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetGeolocationOverrideParams {
            #[doc = "Mock latitude"]
            #[serde(rename = "latitude")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub latitude: Option<f64>,
            #[doc = "Mock longitude"]
            #[serde(rename = "longitude")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub longitude: Option<f64>,
            #[doc = "Mock accuracy"]
            #[serde(rename = "accuracy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub accuracy: Option<f64>,
        }
        impl SetGeolocationOverrideParams {
            pub fn builder() -> SetGeolocationOverrideParamsBuilder {
                SetGeolocationOverrideParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetGeolocationOverrideParamsBuilder {
            latitude: Option<f64>,
            longitude: Option<f64>,
            accuracy: Option<f64>,
        }
        impl SetGeolocationOverrideParamsBuilder {
            pub fn latitude(mut self, latitude: impl Into<f64>) -> Self {
                self.latitude = Some(latitude.into());
                self
            }
            pub fn longitude(mut self, longitude: impl Into<f64>) -> Self {
                self.longitude = Some(longitude.into());
                self
            }
            pub fn accuracy(mut self, accuracy: impl Into<f64>) -> Self {
                self.accuracy = Some(accuracy.into());
                self
            }
            pub fn build(self) -> SetGeolocationOverrideParams {
                SetGeolocationOverrideParams {
                    latitude: self.latitude,
                    longitude: self.longitude,
                    accuracy: self.accuracy,
                }
            }
        }
        impl SetGeolocationOverrideParams {
            pub const IDENTIFIER: &'static str = "Emulation.setGeolocationOverride";
        }
        impl chromiumoxide_types::Method for SetGeolocationOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetGeolocationOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position\nunavailable.\n[setGeolocationOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setGeolocationOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetGeolocationOverrideReturns {}
        impl chromiumoxide_types::Command for SetGeolocationOverrideParams {
            type Response = SetGeolocationOverrideReturns;
        }
        #[doc = "Overrides the Idle state.\n[setIdleOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setIdleOverride)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetIdleOverrideParams {
            #[doc = "Mock isUserActive"]
            #[serde(rename = "isUserActive")]
            pub is_user_active: bool,
            #[doc = "Mock isScreenUnlocked"]
            #[serde(rename = "isScreenUnlocked")]
            pub is_screen_unlocked: bool,
        }
        impl SetIdleOverrideParams {
            pub fn new(
                is_user_active: impl Into<bool>,
                is_screen_unlocked: impl Into<bool>,
            ) -> Self {
                Self {
                    is_user_active: is_user_active.into(),
                    is_screen_unlocked: is_screen_unlocked.into(),
                }
            }
        }
        impl SetIdleOverrideParams {
            pub fn builder() -> SetIdleOverrideParamsBuilder {
                SetIdleOverrideParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetIdleOverrideParamsBuilder {
            is_user_active: Option<bool>,
            is_screen_unlocked: Option<bool>,
        }
        impl SetIdleOverrideParamsBuilder {
            pub fn is_user_active(mut self, is_user_active: impl Into<bool>) -> Self {
                self.is_user_active = Some(is_user_active.into());
                self
            }
            pub fn is_screen_unlocked(mut self, is_screen_unlocked: impl Into<bool>) -> Self {
                self.is_screen_unlocked = Some(is_screen_unlocked.into());
                self
            }
            pub fn build(self) -> Result<SetIdleOverrideParams, String> {
                Ok(SetIdleOverrideParams {
                    is_user_active: self.is_user_active.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(is_user_active))
                    })?,
                    is_screen_unlocked: self.is_screen_unlocked.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(is_screen_unlocked)
                        )
                    })?,
                })
            }
        }
        impl SetIdleOverrideParams {
            pub const IDENTIFIER: &'static str = "Emulation.setIdleOverride";
        }
        impl chromiumoxide_types::Method for SetIdleOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetIdleOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Overrides the Idle state.\n[setIdleOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setIdleOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetIdleOverrideReturns {}
        impl chromiumoxide_types::Command for SetIdleOverrideParams {
            type Response = SetIdleOverrideReturns;
        }
        #[doc = "Clears Idle state overrides.\n[clearIdleOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-clearIdleOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearIdleOverrideParams {}
        impl ClearIdleOverrideParams {
            pub const IDENTIFIER: &'static str = "Emulation.clearIdleOverride";
        }
        impl chromiumoxide_types::Method for ClearIdleOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearIdleOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears Idle state overrides.\n[clearIdleOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-clearIdleOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearIdleOverrideReturns {}
        impl chromiumoxide_types::Command for ClearIdleOverrideParams {
            type Response = ClearIdleOverrideReturns;
        }
        #[doc = "Sets a specified page scale factor.\n[setPageScaleFactor](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setPageScaleFactor)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetPageScaleFactorParams {
            #[doc = "Page scale factor."]
            #[serde(rename = "pageScaleFactor")]
            pub page_scale_factor: f64,
        }
        impl SetPageScaleFactorParams {
            pub fn new(page_scale_factor: impl Into<f64>) -> Self {
                Self {
                    page_scale_factor: page_scale_factor.into(),
                }
            }
        }
        impl SetPageScaleFactorParams {
            pub fn builder() -> SetPageScaleFactorParamsBuilder {
                SetPageScaleFactorParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetPageScaleFactorParamsBuilder {
            page_scale_factor: Option<f64>,
        }
        impl SetPageScaleFactorParamsBuilder {
            pub fn page_scale_factor(mut self, page_scale_factor: impl Into<f64>) -> Self {
                self.page_scale_factor = Some(page_scale_factor.into());
                self
            }
            pub fn build(self) -> Result<SetPageScaleFactorParams, String> {
                Ok(SetPageScaleFactorParams {
                    page_scale_factor: self.page_scale_factor.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(page_scale_factor)
                        )
                    })?,
                })
            }
        }
        impl SetPageScaleFactorParams {
            pub const IDENTIFIER: &'static str = "Emulation.setPageScaleFactor";
        }
        impl chromiumoxide_types::Method for SetPageScaleFactorParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetPageScaleFactorParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets a specified page scale factor.\n[setPageScaleFactor](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setPageScaleFactor)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetPageScaleFactorReturns {}
        impl chromiumoxide_types::Command for SetPageScaleFactorParams {
            type Response = SetPageScaleFactorReturns;
        }
        #[doc = "Switches script execution in the page.\n[setScriptExecutionDisabled](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setScriptExecutionDisabled)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetScriptExecutionDisabledParams {
            #[doc = "Whether script execution should be disabled in the page."]
            #[serde(rename = "value")]
            pub value: bool,
        }
        impl SetScriptExecutionDisabledParams {
            pub fn new(value: impl Into<bool>) -> Self {
                Self {
                    value: value.into(),
                }
            }
        }
        impl SetScriptExecutionDisabledParams {
            pub fn builder() -> SetScriptExecutionDisabledParamsBuilder {
                SetScriptExecutionDisabledParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetScriptExecutionDisabledParamsBuilder {
            value: Option<bool>,
        }
        impl SetScriptExecutionDisabledParamsBuilder {
            pub fn value(mut self, value: impl Into<bool>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<SetScriptExecutionDisabledParams, String> {
                Ok(SetScriptExecutionDisabledParams {
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl SetScriptExecutionDisabledParams {
            pub const IDENTIFIER: &'static str = "Emulation.setScriptExecutionDisabled";
        }
        impl chromiumoxide_types::Method for SetScriptExecutionDisabledParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetScriptExecutionDisabledParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Switches script execution in the page.\n[setScriptExecutionDisabled](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setScriptExecutionDisabled)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetScriptExecutionDisabledReturns {}
        impl chromiumoxide_types::Command for SetScriptExecutionDisabledParams {
            type Response = SetScriptExecutionDisabledReturns;
        }
        #[doc = "Enables touch on platforms which do not support them.\n[setTouchEmulationEnabled](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setTouchEmulationEnabled)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetTouchEmulationEnabledParams {
            #[doc = "Whether the touch event emulation should be enabled."]
            #[serde(rename = "enabled")]
            pub enabled: bool,
            #[doc = "Maximum touch points supported. Defaults to one."]
            #[serde(rename = "maxTouchPoints")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub max_touch_points: Option<i64>,
        }
        impl SetTouchEmulationEnabledParams {
            pub fn new(enabled: impl Into<bool>) -> Self {
                Self {
                    enabled: enabled.into(),
                    max_touch_points: None,
                }
            }
        }
        impl SetTouchEmulationEnabledParams {
            pub fn builder() -> SetTouchEmulationEnabledParamsBuilder {
                SetTouchEmulationEnabledParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetTouchEmulationEnabledParamsBuilder {
            enabled: Option<bool>,
            max_touch_points: Option<i64>,
        }
        impl SetTouchEmulationEnabledParamsBuilder {
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn max_touch_points(mut self, max_touch_points: impl Into<i64>) -> Self {
                self.max_touch_points = Some(max_touch_points.into());
                self
            }
            pub fn build(self) -> Result<SetTouchEmulationEnabledParams, String> {
                Ok(SetTouchEmulationEnabledParams {
                    enabled: self.enabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enabled))
                    })?,
                    max_touch_points: self.max_touch_points,
                })
            }
        }
        impl SetTouchEmulationEnabledParams {
            pub const IDENTIFIER: &'static str = "Emulation.setTouchEmulationEnabled";
        }
        impl chromiumoxide_types::Method for SetTouchEmulationEnabledParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetTouchEmulationEnabledParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables touch on platforms which do not support them.\n[setTouchEmulationEnabled](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setTouchEmulationEnabled)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetTouchEmulationEnabledReturns {}
        impl chromiumoxide_types::Command for SetTouchEmulationEnabledParams {
            type Response = SetTouchEmulationEnabledReturns;
        }
        #[doc = "Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets\nthe current virtual time policy.  Note this supersedes any previous time budget.\n[setVirtualTimePolicy](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setVirtualTimePolicy)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetVirtualTimePolicyParams {
            #[serde(rename = "policy")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub policy: VirtualTimePolicy,
            #[doc = "If set, after this many virtual milliseconds have elapsed virtual time will be paused and a\nvirtualTimeBudgetExpired event is sent."]
            #[serde(rename = "budget")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub budget: Option<f64>,
            #[doc = "If set this specifies the maximum number of tasks that can be run before virtual is forced\nforwards to prevent deadlock."]
            #[serde(rename = "maxVirtualTimeTaskStarvationCount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub max_virtual_time_task_starvation_count: Option<i64>,
            #[doc = "If set, base::Time::Now will be overridden to initially return this value."]
            #[serde(rename = "initialVirtualTime")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub initial_virtual_time: Option<super::network::TimeSinceEpoch>,
        }
        impl SetVirtualTimePolicyParams {
            pub fn new(policy: impl Into<VirtualTimePolicy>) -> Self {
                Self {
                    policy: policy.into(),
                    budget: None,
                    max_virtual_time_task_starvation_count: None,
                    initial_virtual_time: None,
                }
            }
        }
        impl SetVirtualTimePolicyParams {
            pub fn builder() -> SetVirtualTimePolicyParamsBuilder {
                SetVirtualTimePolicyParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetVirtualTimePolicyParamsBuilder {
            policy: Option<VirtualTimePolicy>,
            budget: Option<f64>,
            max_virtual_time_task_starvation_count: Option<i64>,
            initial_virtual_time: Option<super::network::TimeSinceEpoch>,
        }
        impl SetVirtualTimePolicyParamsBuilder {
            pub fn policy(mut self, policy: impl Into<VirtualTimePolicy>) -> Self {
                self.policy = Some(policy.into());
                self
            }
            pub fn budget(mut self, budget: impl Into<f64>) -> Self {
                self.budget = Some(budget.into());
                self
            }
            pub fn max_virtual_time_task_starvation_count(
                mut self,
                max_virtual_time_task_starvation_count: impl Into<i64>,
            ) -> Self {
                self.max_virtual_time_task_starvation_count =
                    Some(max_virtual_time_task_starvation_count.into());
                self
            }
            pub fn initial_virtual_time(
                mut self,
                initial_virtual_time: impl Into<super::network::TimeSinceEpoch>,
            ) -> Self {
                self.initial_virtual_time = Some(initial_virtual_time.into());
                self
            }
            pub fn build(self) -> Result<SetVirtualTimePolicyParams, String> {
                Ok(SetVirtualTimePolicyParams {
                    policy: self.policy.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(policy))
                    })?,
                    budget: self.budget,
                    max_virtual_time_task_starvation_count: self
                        .max_virtual_time_task_starvation_count,
                    initial_virtual_time: self.initial_virtual_time,
                })
            }
        }
        impl SetVirtualTimePolicyParams {
            pub const IDENTIFIER: &'static str = "Emulation.setVirtualTimePolicy";
        }
        impl chromiumoxide_types::Method for SetVirtualTimePolicyParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetVirtualTimePolicyParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets\nthe current virtual time policy.  Note this supersedes any previous time budget.\n[setVirtualTimePolicy](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setVirtualTimePolicy)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetVirtualTimePolicyReturns {
            #[doc = "Absolute timestamp at which virtual time was first enabled (up time in milliseconds)."]
            #[serde(rename = "virtualTimeTicksBase")]
            pub virtual_time_ticks_base: f64,
        }
        impl SetVirtualTimePolicyReturns {
            pub fn new(virtual_time_ticks_base: impl Into<f64>) -> Self {
                Self {
                    virtual_time_ticks_base: virtual_time_ticks_base.into(),
                }
            }
        }
        impl SetVirtualTimePolicyReturns {
            pub fn builder() -> SetVirtualTimePolicyReturnsBuilder {
                SetVirtualTimePolicyReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetVirtualTimePolicyReturnsBuilder {
            virtual_time_ticks_base: Option<f64>,
        }
        impl SetVirtualTimePolicyReturnsBuilder {
            pub fn virtual_time_ticks_base(
                mut self,
                virtual_time_ticks_base: impl Into<f64>,
            ) -> Self {
                self.virtual_time_ticks_base = Some(virtual_time_ticks_base.into());
                self
            }
            pub fn build(self) -> Result<SetVirtualTimePolicyReturns, String> {
                Ok(SetVirtualTimePolicyReturns {
                    virtual_time_ticks_base: self.virtual_time_ticks_base.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(virtual_time_ticks_base)
                        )
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SetVirtualTimePolicyParams {
            type Response = SetVirtualTimePolicyReturns;
        }
        #[doc = "Overrides default host system locale with the specified one.\n[setLocaleOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setLocaleOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetLocaleOverrideParams {
            #[doc = "ICU style C locale (e.g. \"en_US\"). If not specified or empty, disables the override and\nrestores default host system locale."]
            #[serde(rename = "locale")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub locale: Option<String>,
        }
        impl SetLocaleOverrideParams {
            pub fn builder() -> SetLocaleOverrideParamsBuilder {
                SetLocaleOverrideParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetLocaleOverrideParamsBuilder {
            locale: Option<String>,
        }
        impl SetLocaleOverrideParamsBuilder {
            pub fn locale(mut self, locale: impl Into<String>) -> Self {
                self.locale = Some(locale.into());
                self
            }
            pub fn build(self) -> SetLocaleOverrideParams {
                SetLocaleOverrideParams {
                    locale: self.locale,
                }
            }
        }
        impl SetLocaleOverrideParams {
            pub const IDENTIFIER: &'static str = "Emulation.setLocaleOverride";
        }
        impl chromiumoxide_types::Method for SetLocaleOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetLocaleOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Overrides default host system locale with the specified one.\n[setLocaleOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setLocaleOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetLocaleOverrideReturns {}
        impl chromiumoxide_types::Command for SetLocaleOverrideParams {
            type Response = SetLocaleOverrideReturns;
        }
        #[doc = "Overrides default host system timezone with the specified one.\n[setTimezoneOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setTimezoneOverride)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetTimezoneOverrideParams {
            #[doc = "The timezone identifier. If empty, disables the override and\nrestores default host system timezone."]
            #[serde(rename = "timezoneId")]
            pub timezone_id: String,
        }
        impl SetTimezoneOverrideParams {
            pub fn new(timezone_id: impl Into<String>) -> Self {
                Self {
                    timezone_id: timezone_id.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for SetTimezoneOverrideParams {
            fn from(url: T) -> Self {
                SetTimezoneOverrideParams::new(url)
            }
        }
        impl SetTimezoneOverrideParams {
            pub fn builder() -> SetTimezoneOverrideParamsBuilder {
                SetTimezoneOverrideParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetTimezoneOverrideParamsBuilder {
            timezone_id: Option<String>,
        }
        impl SetTimezoneOverrideParamsBuilder {
            pub fn timezone_id(mut self, timezone_id: impl Into<String>) -> Self {
                self.timezone_id = Some(timezone_id.into());
                self
            }
            pub fn build(self) -> Result<SetTimezoneOverrideParams, String> {
                Ok(SetTimezoneOverrideParams {
                    timezone_id: self.timezone_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(timezone_id))
                    })?,
                })
            }
        }
        impl SetTimezoneOverrideParams {
            pub const IDENTIFIER: &'static str = "Emulation.setTimezoneOverride";
        }
        impl chromiumoxide_types::Method for SetTimezoneOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetTimezoneOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Overrides default host system timezone with the specified one.\n[setTimezoneOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setTimezoneOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetTimezoneOverrideReturns {}
        impl chromiumoxide_types::Command for SetTimezoneOverrideParams {
            type Response = SetTimezoneOverrideReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetDisabledImageTypesParams {
            #[doc = "Image types to disable."]
            #[serde(rename = "imageTypes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub image_types: Vec<DisabledImageType>,
        }
        impl SetDisabledImageTypesParams {
            pub fn new(image_types: Vec<DisabledImageType>) -> Self {
                Self { image_types }
            }
        }
        impl SetDisabledImageTypesParams {
            pub fn builder() -> SetDisabledImageTypesParamsBuilder {
                SetDisabledImageTypesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetDisabledImageTypesParamsBuilder {
            image_types: Option<Vec<DisabledImageType>>,
        }
        impl SetDisabledImageTypesParamsBuilder {
            pub fn image_type(mut self, image_type: impl Into<DisabledImageType>) -> Self {
                let v = self.image_types.get_or_insert(Vec::new());
                v.push(image_type.into());
                self
            }
            pub fn image_types<I, S>(mut self, image_types: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<DisabledImageType>,
            {
                let v = self.image_types.get_or_insert(Vec::new());
                for val in image_types {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetDisabledImageTypesParams, String> {
                Ok(SetDisabledImageTypesParams {
                    image_types: self.image_types.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(image_types))
                    })?,
                })
            }
        }
        impl SetDisabledImageTypesParams {
            pub const IDENTIFIER: &'static str = "Emulation.setDisabledImageTypes";
        }
        impl chromiumoxide_types::Method for SetDisabledImageTypesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetDisabledImageTypesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetDisabledImageTypesReturns {}
        impl chromiumoxide_types::Command for SetDisabledImageTypesParams {
            type Response = SetDisabledImageTypesReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetHardwareConcurrencyOverrideParams {
            #[doc = "Hardware concurrency to report"]
            #[serde(rename = "hardwareConcurrency")]
            pub hardware_concurrency: i64,
        }
        impl SetHardwareConcurrencyOverrideParams {
            pub fn new(hardware_concurrency: impl Into<i64>) -> Self {
                Self {
                    hardware_concurrency: hardware_concurrency.into(),
                }
            }
        }
        impl SetHardwareConcurrencyOverrideParams {
            pub fn builder() -> SetHardwareConcurrencyOverrideParamsBuilder {
                SetHardwareConcurrencyOverrideParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetHardwareConcurrencyOverrideParamsBuilder {
            hardware_concurrency: Option<i64>,
        }
        impl SetHardwareConcurrencyOverrideParamsBuilder {
            pub fn hardware_concurrency(mut self, hardware_concurrency: impl Into<i64>) -> Self {
                self.hardware_concurrency = Some(hardware_concurrency.into());
                self
            }
            pub fn build(self) -> Result<SetHardwareConcurrencyOverrideParams, String> {
                Ok(SetHardwareConcurrencyOverrideParams {
                    hardware_concurrency: self.hardware_concurrency.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(hardware_concurrency)
                        )
                    })?,
                })
            }
        }
        impl SetHardwareConcurrencyOverrideParams {
            pub const IDENTIFIER: &'static str = "Emulation.setHardwareConcurrencyOverride";
        }
        impl chromiumoxide_types::Method for SetHardwareConcurrencyOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetHardwareConcurrencyOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetHardwareConcurrencyOverrideReturns {}
        impl chromiumoxide_types::Command for SetHardwareConcurrencyOverrideParams {
            type Response = SetHardwareConcurrencyOverrideReturns;
        }
        #[doc = "Allows overriding user agent with the given string.\n[setUserAgentOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setUserAgentOverride)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetUserAgentOverrideParams {
            #[doc = "User agent to use."]
            #[serde(rename = "userAgent")]
            pub user_agent: String,
            #[doc = "Browser langugage to emulate."]
            #[serde(rename = "acceptLanguage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub accept_language: Option<String>,
            #[doc = "The platform navigator.platform should return."]
            #[serde(rename = "platform")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub platform: Option<String>,
            #[doc = "To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData"]
            #[serde(rename = "userAgentMetadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub user_agent_metadata: Option<UserAgentMetadata>,
        }
        impl SetUserAgentOverrideParams {
            pub fn new(user_agent: impl Into<String>) -> Self {
                Self {
                    user_agent: user_agent.into(),
                    accept_language: None,
                    platform: None,
                    user_agent_metadata: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for SetUserAgentOverrideParams {
            fn from(url: T) -> Self {
                SetUserAgentOverrideParams::new(url)
            }
        }
        impl SetUserAgentOverrideParams {
            pub fn builder() -> SetUserAgentOverrideParamsBuilder {
                SetUserAgentOverrideParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetUserAgentOverrideParamsBuilder {
            user_agent: Option<String>,
            accept_language: Option<String>,
            platform: Option<String>,
            user_agent_metadata: Option<UserAgentMetadata>,
        }
        impl SetUserAgentOverrideParamsBuilder {
            pub fn user_agent(mut self, user_agent: impl Into<String>) -> Self {
                self.user_agent = Some(user_agent.into());
                self
            }
            pub fn accept_language(mut self, accept_language: impl Into<String>) -> Self {
                self.accept_language = Some(accept_language.into());
                self
            }
            pub fn platform(mut self, platform: impl Into<String>) -> Self {
                self.platform = Some(platform.into());
                self
            }
            pub fn user_agent_metadata(
                mut self,
                user_agent_metadata: impl Into<UserAgentMetadata>,
            ) -> Self {
                self.user_agent_metadata = Some(user_agent_metadata.into());
                self
            }
            pub fn build(self) -> Result<SetUserAgentOverrideParams, String> {
                Ok(SetUserAgentOverrideParams {
                    user_agent: self.user_agent.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(user_agent))
                    })?,
                    accept_language: self.accept_language,
                    platform: self.platform,
                    user_agent_metadata: self.user_agent_metadata,
                })
            }
        }
        impl SetUserAgentOverrideParams {
            pub const IDENTIFIER: &'static str = "Emulation.setUserAgentOverride";
        }
        impl chromiumoxide_types::Method for SetUserAgentOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetUserAgentOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Allows overriding user agent with the given string.\n[setUserAgentOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setUserAgentOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetUserAgentOverrideReturns {}
        impl chromiumoxide_types::Command for SetUserAgentOverrideParams {
            type Response = SetUserAgentOverrideReturns;
        }
        #[doc = "Allows overriding the automation flag.\n[setAutomationOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setAutomationOverride)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetAutomationOverrideParams {
            #[doc = "Whether the override should be enabled."]
            #[serde(rename = "enabled")]
            pub enabled: bool,
        }
        impl SetAutomationOverrideParams {
            pub fn new(enabled: impl Into<bool>) -> Self {
                Self {
                    enabled: enabled.into(),
                }
            }
        }
        impl SetAutomationOverrideParams {
            pub fn builder() -> SetAutomationOverrideParamsBuilder {
                SetAutomationOverrideParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetAutomationOverrideParamsBuilder {
            enabled: Option<bool>,
        }
        impl SetAutomationOverrideParamsBuilder {
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn build(self) -> Result<SetAutomationOverrideParams, String> {
                Ok(SetAutomationOverrideParams {
                    enabled: self.enabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enabled))
                    })?,
                })
            }
        }
        impl SetAutomationOverrideParams {
            pub const IDENTIFIER: &'static str = "Emulation.setAutomationOverride";
        }
        impl chromiumoxide_types::Method for SetAutomationOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetAutomationOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Allows overriding the automation flag.\n[setAutomationOverride](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setAutomationOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetAutomationOverrideReturns {}
        impl chromiumoxide_types::Command for SetAutomationOverrideParams {
            type Response = SetAutomationOverrideReturns;
        }
        #[doc = "Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.\n[virtualTimeBudgetExpired](https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#event-virtualTimeBudgetExpired)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventVirtualTimeBudgetExpired {}
        impl EventVirtualTimeBudgetExpired {
            pub const IDENTIFIER: &'static str = "Emulation.virtualTimeBudgetExpired";
        }
        impl chromiumoxide_types::Method for EventVirtualTimeBudgetExpired {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventVirtualTimeBudgetExpired {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "This domain provides experimental commands only supported in headless mode."]
    pub mod headless_experimental {
        use serde::{Deserialize, Serialize};
        #[doc = "Encoding options for a screenshot.\n[ScreenshotParams](https://chromedevtools.github.io/devtools-protocol/tot/HeadlessExperimental/#type-ScreenshotParams)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ScreenshotParams {
            #[doc = "Image compression format (defaults to png)."]
            #[serde(rename = "format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub format: Option<ScreenshotParamsFormat>,
            #[doc = "Compression quality from range [0..100] (jpeg only)."]
            #[serde(rename = "quality")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub quality: Option<i64>,
        }
        #[doc = "Image compression format (defaults to png)."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ScreenshotParamsFormat {
            #[serde(rename = "jpeg")]
            Jpeg,
            #[serde(rename = "png")]
            Png,
        }
        impl AsRef<str> for ScreenshotParamsFormat {
            fn as_ref(&self) -> &str {
                match self {
                    ScreenshotParamsFormat::Jpeg => "jpeg",
                    ScreenshotParamsFormat::Png => "png",
                }
            }
        }
        impl ::std::str::FromStr for ScreenshotParamsFormat {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "jpeg" | "Jpeg" => Ok(ScreenshotParamsFormat::Jpeg),
                    "png" | "Png" => Ok(ScreenshotParamsFormat::Png),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl ScreenshotParams {
            pub fn builder() -> ScreenshotParamsBuilder {
                ScreenshotParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ScreenshotParamsBuilder {
            format: Option<ScreenshotParamsFormat>,
            quality: Option<i64>,
        }
        impl ScreenshotParamsBuilder {
            pub fn format(mut self, format: impl Into<ScreenshotParamsFormat>) -> Self {
                self.format = Some(format.into());
                self
            }
            pub fn quality(mut self, quality: impl Into<i64>) -> Self {
                self.quality = Some(quality.into());
                self
            }
            pub fn build(self) -> ScreenshotParams {
                ScreenshotParams {
                    format: self.format,
                    quality: self.quality,
                }
            }
        }
        impl ScreenshotParams {
            pub const IDENTIFIER: &'static str = "HeadlessExperimental.ScreenshotParams";
        }
        #[doc = "Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a\nscreenshot from the resulting frame. Requires that the target was created with enabled\nBeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also\nhttps://goo.gle/chrome-headless-rendering for more background.\n[beginFrame](https://chromedevtools.github.io/devtools-protocol/tot/HeadlessExperimental/#method-beginFrame)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct BeginFrameParams {
            #[doc = "Timestamp of this BeginFrame in Renderer TimeTicks (milliseconds of uptime). If not set,\nthe current time will be used."]
            #[serde(rename = "frameTimeTicks")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_time_ticks: Option<f64>,
            #[doc = "The interval between BeginFrames that is reported to the compositor, in milliseconds.\nDefaults to a 60 frames/second interval, i.e. about 16.666 milliseconds."]
            #[serde(rename = "interval")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub interval: Option<f64>,
            #[doc = "Whether updates should not be committed and drawn onto the display. False by default. If\ntrue, only side effects of the BeginFrame will be run, such as layout and animations, but\nany visual updates may not be visible on the display or in screenshots."]
            #[serde(rename = "noDisplayUpdates")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub no_display_updates: Option<bool>,
            #[doc = "If set, a screenshot of the frame will be captured and returned in the response. Otherwise,\nno screenshot will be captured. Note that capturing a screenshot can fail, for example,\nduring renderer initialization. In such a case, no screenshot data will be returned."]
            #[serde(rename = "screenshot")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub screenshot: Option<ScreenshotParams>,
        }
        impl BeginFrameParams {
            pub fn builder() -> BeginFrameParamsBuilder {
                BeginFrameParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BeginFrameParamsBuilder {
            frame_time_ticks: Option<f64>,
            interval: Option<f64>,
            no_display_updates: Option<bool>,
            screenshot: Option<ScreenshotParams>,
        }
        impl BeginFrameParamsBuilder {
            pub fn frame_time_ticks(mut self, frame_time_ticks: impl Into<f64>) -> Self {
                self.frame_time_ticks = Some(frame_time_ticks.into());
                self
            }
            pub fn interval(mut self, interval: impl Into<f64>) -> Self {
                self.interval = Some(interval.into());
                self
            }
            pub fn no_display_updates(mut self, no_display_updates: impl Into<bool>) -> Self {
                self.no_display_updates = Some(no_display_updates.into());
                self
            }
            pub fn screenshot(mut self, screenshot: impl Into<ScreenshotParams>) -> Self {
                self.screenshot = Some(screenshot.into());
                self
            }
            pub fn build(self) -> BeginFrameParams {
                BeginFrameParams {
                    frame_time_ticks: self.frame_time_ticks,
                    interval: self.interval,
                    no_display_updates: self.no_display_updates,
                    screenshot: self.screenshot,
                }
            }
        }
        impl BeginFrameParams {
            pub const IDENTIFIER: &'static str = "HeadlessExperimental.beginFrame";
        }
        impl chromiumoxide_types::Method for BeginFrameParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for BeginFrameParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a\nscreenshot from the resulting frame. Requires that the target was created with enabled\nBeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also\nhttps://goo.gle/chrome-headless-rendering for more background.\n[beginFrame](https://chromedevtools.github.io/devtools-protocol/tot/HeadlessExperimental/#method-beginFrame)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct BeginFrameReturns {
            #[doc = "Whether the BeginFrame resulted in damage and, thus, a new frame was committed to the\ndisplay. Reported for diagnostic uses, may be removed in the future."]
            #[serde(rename = "hasDamage")]
            pub has_damage: bool,
            #[doc = "Base64-encoded image data of the screenshot, if one was requested and successfully taken."]
            #[serde(rename = "screenshotData")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub screenshot_data: Option<chromiumoxide_types::Binary>,
        }
        impl BeginFrameReturns {
            pub fn new(has_damage: impl Into<bool>) -> Self {
                Self {
                    has_damage: has_damage.into(),
                    screenshot_data: None,
                }
            }
        }
        impl BeginFrameReturns {
            pub fn builder() -> BeginFrameReturnsBuilder {
                BeginFrameReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BeginFrameReturnsBuilder {
            has_damage: Option<bool>,
            screenshot_data: Option<chromiumoxide_types::Binary>,
        }
        impl BeginFrameReturnsBuilder {
            pub fn has_damage(mut self, has_damage: impl Into<bool>) -> Self {
                self.has_damage = Some(has_damage.into());
                self
            }
            pub fn screenshot_data(
                mut self,
                screenshot_data: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                self.screenshot_data = Some(screenshot_data.into());
                self
            }
            pub fn build(self) -> Result<BeginFrameReturns, String> {
                Ok(BeginFrameReturns {
                    has_damage: self.has_damage.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(has_damage))
                    })?,
                    screenshot_data: self.screenshot_data,
                })
            }
        }
        impl chromiumoxide_types::Command for BeginFrameParams {
            type Response = BeginFrameReturns;
        }
        #[doc = "Disables headless events for the target.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/HeadlessExperimental/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "HeadlessExperimental.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables headless events for the target.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/HeadlessExperimental/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables headless events for the target.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/HeadlessExperimental/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "HeadlessExperimental.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables headless events for the target.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/HeadlessExperimental/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
    }
    #[doc = "Input/Output operations for streams produced by DevTools."]
    pub mod io {
        use serde::{Deserialize, Serialize};
        #[doc = "This is either obtained from another method or specified as `blob:&lt;uuid&gt;` where\n`&lt;uuid&gt` is an UUID of a Blob.\n[StreamHandle](https://chromedevtools.github.io/devtools-protocol/tot/IO/#type-StreamHandle)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct StreamHandle(String);
        impl StreamHandle {
            pub fn new(val: impl Into<String>) -> Self {
                StreamHandle(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for StreamHandle {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<StreamHandle> for String {
            fn from(el: StreamHandle) -> String {
                el.0
            }
        }
        impl From<String> for StreamHandle {
            fn from(expr: String) -> Self {
                StreamHandle(expr)
            }
        }
        impl StreamHandle {
            pub const IDENTIFIER: &'static str = "IO.StreamHandle";
        }
        #[doc = "Close the stream, discard any temporary backing storage.\n[close](https://chromedevtools.github.io/devtools-protocol/tot/IO/#method-close)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CloseParams {
            #[doc = "Handle of the stream to close."]
            #[serde(rename = "handle")]
            pub handle: StreamHandle,
        }
        impl CloseParams {
            pub fn new(handle: impl Into<StreamHandle>) -> Self {
                Self {
                    handle: handle.into(),
                }
            }
        }
        impl CloseParams {
            pub fn builder() -> CloseParamsBuilder {
                CloseParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CloseParamsBuilder {
            handle: Option<StreamHandle>,
        }
        impl CloseParamsBuilder {
            pub fn handle(mut self, handle: impl Into<StreamHandle>) -> Self {
                self.handle = Some(handle.into());
                self
            }
            pub fn build(self) -> Result<CloseParams, String> {
                Ok(CloseParams {
                    handle: self.handle.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(handle))
                    })?,
                })
            }
        }
        impl CloseParams {
            pub const IDENTIFIER: &'static str = "IO.close";
        }
        impl chromiumoxide_types::Method for CloseParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CloseParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Close the stream, discard any temporary backing storage.\n[close](https://chromedevtools.github.io/devtools-protocol/tot/IO/#method-close)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CloseReturns {}
        impl chromiumoxide_types::Command for CloseParams {
            type Response = CloseReturns;
        }
        #[doc = "Read a chunk of the stream\n[read](https://chromedevtools.github.io/devtools-protocol/tot/IO/#method-read)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ReadParams {
            #[doc = "Handle of the stream to read."]
            #[serde(rename = "handle")]
            pub handle: StreamHandle,
            #[doc = "Seek to the specified offset before reading (if not specificed, proceed with offset\nfollowing the last read). Some types of streams may only support sequential reads."]
            #[serde(rename = "offset")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub offset: Option<i64>,
            #[doc = "Maximum number of bytes to read (left upon the agent discretion if not specified)."]
            #[serde(rename = "size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub size: Option<i64>,
        }
        impl ReadParams {
            pub fn new(handle: impl Into<StreamHandle>) -> Self {
                Self {
                    handle: handle.into(),
                    offset: None,
                    size: None,
                }
            }
        }
        impl ReadParams {
            pub fn builder() -> ReadParamsBuilder {
                ReadParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ReadParamsBuilder {
            handle: Option<StreamHandle>,
            offset: Option<i64>,
            size: Option<i64>,
        }
        impl ReadParamsBuilder {
            pub fn handle(mut self, handle: impl Into<StreamHandle>) -> Self {
                self.handle = Some(handle.into());
                self
            }
            pub fn offset(mut self, offset: impl Into<i64>) -> Self {
                self.offset = Some(offset.into());
                self
            }
            pub fn size(mut self, size: impl Into<i64>) -> Self {
                self.size = Some(size.into());
                self
            }
            pub fn build(self) -> Result<ReadParams, String> {
                Ok(ReadParams {
                    handle: self.handle.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(handle))
                    })?,
                    offset: self.offset,
                    size: self.size,
                })
            }
        }
        impl ReadParams {
            pub const IDENTIFIER: &'static str = "IO.read";
        }
        impl chromiumoxide_types::Method for ReadParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ReadParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Read a chunk of the stream\n[read](https://chromedevtools.github.io/devtools-protocol/tot/IO/#method-read)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ReadReturns {
            #[doc = "Set if the data is base64-encoded"]
            #[serde(rename = "base64Encoded")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub base64_encoded: Option<bool>,
            #[doc = "Data that were read."]
            #[serde(rename = "data")]
            pub data: String,
            #[doc = "Set if the end-of-file condition occurred while reading."]
            #[serde(rename = "eof")]
            pub eof: bool,
        }
        impl ReadReturns {
            pub fn new(data: impl Into<String>, eof: impl Into<bool>) -> Self {
                Self {
                    data: data.into(),
                    eof: eof.into(),
                    base64_encoded: None,
                }
            }
        }
        impl ReadReturns {
            pub fn builder() -> ReadReturnsBuilder {
                ReadReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ReadReturnsBuilder {
            base64_encoded: Option<bool>,
            data: Option<String>,
            eof: Option<bool>,
        }
        impl ReadReturnsBuilder {
            pub fn base64_encoded(mut self, base64_encoded: impl Into<bool>) -> Self {
                self.base64_encoded = Some(base64_encoded.into());
                self
            }
            pub fn data(mut self, data: impl Into<String>) -> Self {
                self.data = Some(data.into());
                self
            }
            pub fn eof(mut self, eof: impl Into<bool>) -> Self {
                self.eof = Some(eof.into());
                self
            }
            pub fn build(self) -> Result<ReadReturns, String> {
                Ok(ReadReturns {
                    base64_encoded: self.base64_encoded,
                    data: self.data.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(data))
                    })?,
                    eof: self
                        .eof
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(eof)))?,
                })
            }
        }
        impl chromiumoxide_types::Command for ReadParams {
            type Response = ReadReturns;
        }
        #[doc = "Return UUID of Blob object specified by a remote object id.\n[resolveBlob](https://chromedevtools.github.io/devtools-protocol/tot/IO/#method-resolveBlob)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ResolveBlobParams {
            #[doc = "Object id of a Blob object wrapper."]
            #[serde(rename = "objectId")]
            pub object_id: super::super::js_protocol::runtime::RemoteObjectId,
        }
        impl ResolveBlobParams {
            pub fn new(
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                Self {
                    object_id: object_id.into(),
                }
            }
        }
        impl ResolveBlobParams {
            pub fn builder() -> ResolveBlobParamsBuilder {
                ResolveBlobParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ResolveBlobParamsBuilder {
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl ResolveBlobParamsBuilder {
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> Result<ResolveBlobParams, String> {
                Ok(ResolveBlobParams {
                    object_id: self.object_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(object_id))
                    })?,
                })
            }
        }
        impl ResolveBlobParams {
            pub const IDENTIFIER: &'static str = "IO.resolveBlob";
        }
        impl chromiumoxide_types::Method for ResolveBlobParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ResolveBlobParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Return UUID of Blob object specified by a remote object id.\n[resolveBlob](https://chromedevtools.github.io/devtools-protocol/tot/IO/#method-resolveBlob)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ResolveBlobReturns {
            #[doc = "UUID of the specified Blob."]
            #[serde(rename = "uuid")]
            pub uuid: String,
        }
        impl ResolveBlobReturns {
            pub fn new(uuid: impl Into<String>) -> Self {
                Self { uuid: uuid.into() }
            }
        }
        impl<T: Into<String>> From<T> for ResolveBlobReturns {
            fn from(url: T) -> Self {
                ResolveBlobReturns::new(url)
            }
        }
        impl ResolveBlobReturns {
            pub fn builder() -> ResolveBlobReturnsBuilder {
                ResolveBlobReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ResolveBlobReturnsBuilder {
            uuid: Option<String>,
        }
        impl ResolveBlobReturnsBuilder {
            pub fn uuid(mut self, uuid: impl Into<String>) -> Self {
                self.uuid = Some(uuid.into());
                self
            }
            pub fn build(self) -> Result<ResolveBlobReturns, String> {
                Ok(ResolveBlobReturns {
                    uuid: self.uuid.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(uuid))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for ResolveBlobParams {
            type Response = ResolveBlobReturns;
        }
    }
    pub mod indexed_db {
        use serde::{Deserialize, Serialize};
        #[doc = "Database with an array of object stores.\n[DatabaseWithObjectStores](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#type-DatabaseWithObjectStores)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DatabaseWithObjectStores {
            #[doc = "Database name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Database version (type is not 'integer', as the standard\nrequires the version number to be 'unsigned long long')"]
            #[serde(rename = "version")]
            pub version: f64,
            #[doc = "Object stores in this database."]
            #[serde(rename = "objectStores")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub object_stores: Vec<ObjectStore>,
        }
        impl DatabaseWithObjectStores {
            pub fn new(
                name: impl Into<String>,
                version: impl Into<f64>,
                object_stores: Vec<ObjectStore>,
            ) -> Self {
                Self {
                    name: name.into(),
                    version: version.into(),
                    object_stores,
                }
            }
        }
        impl DatabaseWithObjectStores {
            pub fn builder() -> DatabaseWithObjectStoresBuilder {
                DatabaseWithObjectStoresBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DatabaseWithObjectStoresBuilder {
            name: Option<String>,
            version: Option<f64>,
            object_stores: Option<Vec<ObjectStore>>,
        }
        impl DatabaseWithObjectStoresBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn version(mut self, version: impl Into<f64>) -> Self {
                self.version = Some(version.into());
                self
            }
            pub fn object_store(mut self, object_store: impl Into<ObjectStore>) -> Self {
                let v = self.object_stores.get_or_insert(Vec::new());
                v.push(object_store.into());
                self
            }
            pub fn object_stores<I, S>(mut self, object_stores: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ObjectStore>,
            {
                let v = self.object_stores.get_or_insert(Vec::new());
                for val in object_stores {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<DatabaseWithObjectStores, String> {
                Ok(DatabaseWithObjectStores {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    version: self.version.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(version))
                    })?,
                    object_stores: self.object_stores.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(object_stores))
                    })?,
                })
            }
        }
        impl DatabaseWithObjectStores {
            pub const IDENTIFIER: &'static str = "IndexedDB.DatabaseWithObjectStores";
        }
        #[doc = "Object store.\n[ObjectStore](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#type-ObjectStore)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ObjectStore {
            #[doc = "Object store name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Object store key path."]
            #[serde(rename = "keyPath")]
            pub key_path: KeyPath,
            #[doc = "If true, object store has auto increment flag set."]
            #[serde(rename = "autoIncrement")]
            pub auto_increment: bool,
            #[doc = "Indexes in this object store."]
            #[serde(rename = "indexes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub indexes: Vec<ObjectStoreIndex>,
        }
        impl ObjectStore {
            pub fn new(
                name: impl Into<String>,
                key_path: impl Into<KeyPath>,
                auto_increment: impl Into<bool>,
                indexes: Vec<ObjectStoreIndex>,
            ) -> Self {
                Self {
                    name: name.into(),
                    key_path: key_path.into(),
                    auto_increment: auto_increment.into(),
                    indexes,
                }
            }
        }
        impl ObjectStore {
            pub fn builder() -> ObjectStoreBuilder {
                ObjectStoreBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ObjectStoreBuilder {
            name: Option<String>,
            key_path: Option<KeyPath>,
            auto_increment: Option<bool>,
            indexes: Option<Vec<ObjectStoreIndex>>,
        }
        impl ObjectStoreBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn key_path(mut self, key_path: impl Into<KeyPath>) -> Self {
                self.key_path = Some(key_path.into());
                self
            }
            pub fn auto_increment(mut self, auto_increment: impl Into<bool>) -> Self {
                self.auto_increment = Some(auto_increment.into());
                self
            }
            pub fn indexe(mut self, indexe: impl Into<ObjectStoreIndex>) -> Self {
                let v = self.indexes.get_or_insert(Vec::new());
                v.push(indexe.into());
                self
            }
            pub fn indexes<I, S>(mut self, indexes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ObjectStoreIndex>,
            {
                let v = self.indexes.get_or_insert(Vec::new());
                for val in indexes {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<ObjectStore, String> {
                Ok(ObjectStore {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    key_path: self.key_path.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(key_path))
                    })?,
                    auto_increment: self.auto_increment.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(auto_increment))
                    })?,
                    indexes: self.indexes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(indexes))
                    })?,
                })
            }
        }
        impl ObjectStore {
            pub const IDENTIFIER: &'static str = "IndexedDB.ObjectStore";
        }
        #[doc = "Object store index.\n[ObjectStoreIndex](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#type-ObjectStoreIndex)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ObjectStoreIndex {
            #[doc = "Index name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Index key path."]
            #[serde(rename = "keyPath")]
            pub key_path: KeyPath,
            #[doc = "If true, index is unique."]
            #[serde(rename = "unique")]
            pub unique: bool,
            #[doc = "If true, index allows multiple entries for a key."]
            #[serde(rename = "multiEntry")]
            pub multi_entry: bool,
        }
        impl ObjectStoreIndex {
            pub fn new(
                name: impl Into<String>,
                key_path: impl Into<KeyPath>,
                unique: impl Into<bool>,
                multi_entry: impl Into<bool>,
            ) -> Self {
                Self {
                    name: name.into(),
                    key_path: key_path.into(),
                    unique: unique.into(),
                    multi_entry: multi_entry.into(),
                }
            }
        }
        impl ObjectStoreIndex {
            pub fn builder() -> ObjectStoreIndexBuilder {
                ObjectStoreIndexBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ObjectStoreIndexBuilder {
            name: Option<String>,
            key_path: Option<KeyPath>,
            unique: Option<bool>,
            multi_entry: Option<bool>,
        }
        impl ObjectStoreIndexBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn key_path(mut self, key_path: impl Into<KeyPath>) -> Self {
                self.key_path = Some(key_path.into());
                self
            }
            pub fn unique(mut self, unique: impl Into<bool>) -> Self {
                self.unique = Some(unique.into());
                self
            }
            pub fn multi_entry(mut self, multi_entry: impl Into<bool>) -> Self {
                self.multi_entry = Some(multi_entry.into());
                self
            }
            pub fn build(self) -> Result<ObjectStoreIndex, String> {
                Ok(ObjectStoreIndex {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    key_path: self.key_path.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(key_path))
                    })?,
                    unique: self.unique.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(unique))
                    })?,
                    multi_entry: self.multi_entry.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(multi_entry))
                    })?,
                })
            }
        }
        impl ObjectStoreIndex {
            pub const IDENTIFIER: &'static str = "IndexedDB.ObjectStoreIndex";
        }
        #[doc = "Key.\n[Key](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#type-Key)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Key {
            #[doc = "Key type."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: KeyType,
            #[doc = "Number value."]
            #[serde(rename = "number")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub number: Option<f64>,
            #[doc = "String value."]
            #[serde(rename = "string")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub string: Option<String>,
            #[doc = "Date value."]
            #[serde(rename = "date")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub date: Option<f64>,
            #[doc = "Array value."]
            #[serde(rename = "array")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub array: Option<Vec<Key>>,
        }
        #[doc = "Key type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum KeyType {
            #[serde(rename = "number")]
            Number,
            #[serde(rename = "string")]
            String,
            #[serde(rename = "date")]
            Date,
            #[serde(rename = "array")]
            Array,
        }
        impl AsRef<str> for KeyType {
            fn as_ref(&self) -> &str {
                match self {
                    KeyType::Number => "number",
                    KeyType::String => "string",
                    KeyType::Date => "date",
                    KeyType::Array => "array",
                }
            }
        }
        impl ::std::str::FromStr for KeyType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "number" | "Number" => Ok(KeyType::Number),
                    "string" | "String" => Ok(KeyType::String),
                    "date" | "Date" => Ok(KeyType::Date),
                    "array" | "Array" => Ok(KeyType::Array),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl Key {
            pub fn new(r#type: impl Into<KeyType>) -> Self {
                Self {
                    r#type: r#type.into(),
                    number: None,
                    string: None,
                    date: None,
                    array: None,
                }
            }
        }
        impl Key {
            pub fn builder() -> KeyBuilder {
                KeyBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct KeyBuilder {
            r#type: Option<KeyType>,
            number: Option<f64>,
            string: Option<String>,
            date: Option<f64>,
            array: Option<Vec<Key>>,
        }
        impl KeyBuilder {
            pub fn r#type(mut self, r#type: impl Into<KeyType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn number(mut self, number: impl Into<f64>) -> Self {
                self.number = Some(number.into());
                self
            }
            pub fn string(mut self, string: impl Into<String>) -> Self {
                self.string = Some(string.into());
                self
            }
            pub fn date(mut self, date: impl Into<f64>) -> Self {
                self.date = Some(date.into());
                self
            }
            pub fn array(mut self, array: impl Into<Key>) -> Self {
                let v = self.array.get_or_insert(Vec::new());
                v.push(array.into());
                self
            }
            pub fn arrays<I, S>(mut self, arrays: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Key>,
            {
                let v = self.array.get_or_insert(Vec::new());
                for val in arrays {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<Key, String> {
                Ok(Key {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    number: self.number,
                    string: self.string,
                    date: self.date,
                    array: self.array,
                })
            }
        }
        impl Key {
            pub const IDENTIFIER: &'static str = "IndexedDB.Key";
        }
        #[doc = "Key range.\n[KeyRange](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#type-KeyRange)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct KeyRange {
            #[doc = "Lower bound."]
            #[serde(rename = "lower")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub lower: Option<Key>,
            #[doc = "Upper bound."]
            #[serde(rename = "upper")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub upper: Option<Key>,
            #[doc = "If true lower bound is open."]
            #[serde(rename = "lowerOpen")]
            pub lower_open: bool,
            #[doc = "If true upper bound is open."]
            #[serde(rename = "upperOpen")]
            pub upper_open: bool,
        }
        impl KeyRange {
            pub fn new(lower_open: impl Into<bool>, upper_open: impl Into<bool>) -> Self {
                Self {
                    lower_open: lower_open.into(),
                    upper_open: upper_open.into(),
                    lower: None,
                    upper: None,
                }
            }
        }
        impl KeyRange {
            pub fn builder() -> KeyRangeBuilder {
                KeyRangeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct KeyRangeBuilder {
            lower: Option<Key>,
            upper: Option<Key>,
            lower_open: Option<bool>,
            upper_open: Option<bool>,
        }
        impl KeyRangeBuilder {
            pub fn lower(mut self, lower: impl Into<Key>) -> Self {
                self.lower = Some(lower.into());
                self
            }
            pub fn upper(mut self, upper: impl Into<Key>) -> Self {
                self.upper = Some(upper.into());
                self
            }
            pub fn lower_open(mut self, lower_open: impl Into<bool>) -> Self {
                self.lower_open = Some(lower_open.into());
                self
            }
            pub fn upper_open(mut self, upper_open: impl Into<bool>) -> Self {
                self.upper_open = Some(upper_open.into());
                self
            }
            pub fn build(self) -> Result<KeyRange, String> {
                Ok(KeyRange {
                    lower: self.lower,
                    upper: self.upper,
                    lower_open: self.lower_open.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(lower_open))
                    })?,
                    upper_open: self.upper_open.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(upper_open))
                    })?,
                })
            }
        }
        impl KeyRange {
            pub const IDENTIFIER: &'static str = "IndexedDB.KeyRange";
        }
        #[doc = "Data entry.\n[DataEntry](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#type-DataEntry)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DataEntry {
            #[doc = "Key object."]
            #[serde(rename = "key")]
            pub key: super::super::js_protocol::runtime::RemoteObject,
            #[doc = "Primary key object."]
            #[serde(rename = "primaryKey")]
            pub primary_key: super::super::js_protocol::runtime::RemoteObject,
            #[doc = "Value object."]
            #[serde(rename = "value")]
            pub value: super::super::js_protocol::runtime::RemoteObject,
        }
        impl DataEntry {
            pub fn new(
                key: impl Into<super::super::js_protocol::runtime::RemoteObject>,
                primary_key: impl Into<super::super::js_protocol::runtime::RemoteObject>,
                value: impl Into<super::super::js_protocol::runtime::RemoteObject>,
            ) -> Self {
                Self {
                    key: key.into(),
                    primary_key: primary_key.into(),
                    value: value.into(),
                }
            }
        }
        impl DataEntry {
            pub fn builder() -> DataEntryBuilder {
                DataEntryBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DataEntryBuilder {
            key: Option<super::super::js_protocol::runtime::RemoteObject>,
            primary_key: Option<super::super::js_protocol::runtime::RemoteObject>,
            value: Option<super::super::js_protocol::runtime::RemoteObject>,
        }
        impl DataEntryBuilder {
            pub fn key(
                mut self,
                key: impl Into<super::super::js_protocol::runtime::RemoteObject>,
            ) -> Self {
                self.key = Some(key.into());
                self
            }
            pub fn primary_key(
                mut self,
                primary_key: impl Into<super::super::js_protocol::runtime::RemoteObject>,
            ) -> Self {
                self.primary_key = Some(primary_key.into());
                self
            }
            pub fn value(
                mut self,
                value: impl Into<super::super::js_protocol::runtime::RemoteObject>,
            ) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<DataEntry, String> {
                Ok(DataEntry {
                    key: self
                        .key
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(key)))?,
                    primary_key: self.primary_key.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(primary_key))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl DataEntry {
            pub const IDENTIFIER: &'static str = "IndexedDB.DataEntry";
        }
        #[doc = "Key path.\n[KeyPath](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#type-KeyPath)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct KeyPath {
            #[doc = "Key path type."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: KeyPathType,
            #[doc = "String value."]
            #[serde(rename = "string")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub string: Option<String>,
            #[doc = "Array value."]
            #[serde(rename = "array")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub array: Option<Vec<String>>,
        }
        #[doc = "Key path type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum KeyPathType {
            #[serde(rename = "null")]
            Null,
            #[serde(rename = "string")]
            String,
            #[serde(rename = "array")]
            Array,
        }
        impl AsRef<str> for KeyPathType {
            fn as_ref(&self) -> &str {
                match self {
                    KeyPathType::Null => "null",
                    KeyPathType::String => "string",
                    KeyPathType::Array => "array",
                }
            }
        }
        impl ::std::str::FromStr for KeyPathType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "null" | "Null" => Ok(KeyPathType::Null),
                    "string" | "String" => Ok(KeyPathType::String),
                    "array" | "Array" => Ok(KeyPathType::Array),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl KeyPath {
            pub fn new(r#type: impl Into<KeyPathType>) -> Self {
                Self {
                    r#type: r#type.into(),
                    string: None,
                    array: None,
                }
            }
        }
        impl KeyPath {
            pub fn builder() -> KeyPathBuilder {
                KeyPathBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct KeyPathBuilder {
            r#type: Option<KeyPathType>,
            string: Option<String>,
            array: Option<Vec<String>>,
        }
        impl KeyPathBuilder {
            pub fn r#type(mut self, r#type: impl Into<KeyPathType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn string(mut self, string: impl Into<String>) -> Self {
                self.string = Some(string.into());
                self
            }
            pub fn array(mut self, array: impl Into<String>) -> Self {
                let v = self.array.get_or_insert(Vec::new());
                v.push(array.into());
                self
            }
            pub fn arrays<I, S>(mut self, arrays: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.array.get_or_insert(Vec::new());
                for val in arrays {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<KeyPath, String> {
                Ok(KeyPath {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    string: self.string,
                    array: self.array,
                })
            }
        }
        impl KeyPath {
            pub const IDENTIFIER: &'static str = "IndexedDB.KeyPath";
        }
        #[doc = "Clears all entries from an object store.\n[clearObjectStore](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-clearObjectStore)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ClearObjectStoreParams {
            #[doc = "At least and at most one of securityOrigin, storageKey must be specified.\nSecurity origin."]
            #[serde(rename = "securityOrigin")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub security_origin: Option<String>,
            #[doc = "Storage key."]
            #[serde(rename = "storageKey")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub storage_key: Option<String>,
            #[doc = "Database name."]
            #[serde(rename = "databaseName")]
            pub database_name: String,
            #[doc = "Object store name."]
            #[serde(rename = "objectStoreName")]
            pub object_store_name: String,
        }
        impl ClearObjectStoreParams {
            pub fn new(
                database_name: impl Into<String>,
                object_store_name: impl Into<String>,
            ) -> Self {
                Self {
                    database_name: database_name.into(),
                    object_store_name: object_store_name.into(),
                    security_origin: None,
                    storage_key: None,
                }
            }
        }
        impl ClearObjectStoreParams {
            pub fn builder() -> ClearObjectStoreParamsBuilder {
                ClearObjectStoreParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ClearObjectStoreParamsBuilder {
            security_origin: Option<String>,
            storage_key: Option<String>,
            database_name: Option<String>,
            object_store_name: Option<String>,
        }
        impl ClearObjectStoreParamsBuilder {
            pub fn security_origin(mut self, security_origin: impl Into<String>) -> Self {
                self.security_origin = Some(security_origin.into());
                self
            }
            pub fn storage_key(mut self, storage_key: impl Into<String>) -> Self {
                self.storage_key = Some(storage_key.into());
                self
            }
            pub fn database_name(mut self, database_name: impl Into<String>) -> Self {
                self.database_name = Some(database_name.into());
                self
            }
            pub fn object_store_name(mut self, object_store_name: impl Into<String>) -> Self {
                self.object_store_name = Some(object_store_name.into());
                self
            }
            pub fn build(self) -> Result<ClearObjectStoreParams, String> {
                Ok(ClearObjectStoreParams {
                    security_origin: self.security_origin,
                    storage_key: self.storage_key,
                    database_name: self.database_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(database_name))
                    })?,
                    object_store_name: self.object_store_name.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(object_store_name)
                        )
                    })?,
                })
            }
        }
        impl ClearObjectStoreParams {
            pub const IDENTIFIER: &'static str = "IndexedDB.clearObjectStore";
        }
        impl chromiumoxide_types::Method for ClearObjectStoreParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearObjectStoreParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears all entries from an object store.\n[clearObjectStore](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-clearObjectStore)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearObjectStoreReturns {}
        impl chromiumoxide_types::Command for ClearObjectStoreParams {
            type Response = ClearObjectStoreReturns;
        }
        #[doc = "Deletes a database.\n[deleteDatabase](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-deleteDatabase)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DeleteDatabaseParams {
            #[doc = "At least and at most one of securityOrigin, storageKey must be specified.\nSecurity origin."]
            #[serde(rename = "securityOrigin")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub security_origin: Option<String>,
            #[doc = "Storage key."]
            #[serde(rename = "storageKey")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub storage_key: Option<String>,
            #[doc = "Database name."]
            #[serde(rename = "databaseName")]
            pub database_name: String,
        }
        impl DeleteDatabaseParams {
            pub fn new(database_name: impl Into<String>) -> Self {
                Self {
                    database_name: database_name.into(),
                    security_origin: None,
                    storage_key: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for DeleteDatabaseParams {
            fn from(url: T) -> Self {
                DeleteDatabaseParams::new(url)
            }
        }
        impl DeleteDatabaseParams {
            pub fn builder() -> DeleteDatabaseParamsBuilder {
                DeleteDatabaseParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DeleteDatabaseParamsBuilder {
            security_origin: Option<String>,
            storage_key: Option<String>,
            database_name: Option<String>,
        }
        impl DeleteDatabaseParamsBuilder {
            pub fn security_origin(mut self, security_origin: impl Into<String>) -> Self {
                self.security_origin = Some(security_origin.into());
                self
            }
            pub fn storage_key(mut self, storage_key: impl Into<String>) -> Self {
                self.storage_key = Some(storage_key.into());
                self
            }
            pub fn database_name(mut self, database_name: impl Into<String>) -> Self {
                self.database_name = Some(database_name.into());
                self
            }
            pub fn build(self) -> Result<DeleteDatabaseParams, String> {
                Ok(DeleteDatabaseParams {
                    security_origin: self.security_origin,
                    storage_key: self.storage_key,
                    database_name: self.database_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(database_name))
                    })?,
                })
            }
        }
        impl DeleteDatabaseParams {
            pub const IDENTIFIER: &'static str = "IndexedDB.deleteDatabase";
        }
        impl chromiumoxide_types::Method for DeleteDatabaseParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DeleteDatabaseParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Deletes a database.\n[deleteDatabase](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-deleteDatabase)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DeleteDatabaseReturns {}
        impl chromiumoxide_types::Command for DeleteDatabaseParams {
            type Response = DeleteDatabaseReturns;
        }
        #[doc = "Delete a range of entries from an object store\n[deleteObjectStoreEntries](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-deleteObjectStoreEntries)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DeleteObjectStoreEntriesParams {
            #[doc = "At least and at most one of securityOrigin, storageKey must be specified.\nSecurity origin."]
            #[serde(rename = "securityOrigin")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub security_origin: Option<String>,
            #[doc = "Storage key."]
            #[serde(rename = "storageKey")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub storage_key: Option<String>,
            #[serde(rename = "databaseName")]
            pub database_name: String,
            #[serde(rename = "objectStoreName")]
            pub object_store_name: String,
            #[doc = "Range of entry keys to delete"]
            #[serde(rename = "keyRange")]
            pub key_range: KeyRange,
        }
        impl DeleteObjectStoreEntriesParams {
            pub fn new(
                database_name: impl Into<String>,
                object_store_name: impl Into<String>,
                key_range: impl Into<KeyRange>,
            ) -> Self {
                Self {
                    database_name: database_name.into(),
                    object_store_name: object_store_name.into(),
                    key_range: key_range.into(),
                    security_origin: None,
                    storage_key: None,
                }
            }
        }
        impl DeleteObjectStoreEntriesParams {
            pub fn builder() -> DeleteObjectStoreEntriesParamsBuilder {
                DeleteObjectStoreEntriesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DeleteObjectStoreEntriesParamsBuilder {
            security_origin: Option<String>,
            storage_key: Option<String>,
            database_name: Option<String>,
            object_store_name: Option<String>,
            key_range: Option<KeyRange>,
        }
        impl DeleteObjectStoreEntriesParamsBuilder {
            pub fn security_origin(mut self, security_origin: impl Into<String>) -> Self {
                self.security_origin = Some(security_origin.into());
                self
            }
            pub fn storage_key(mut self, storage_key: impl Into<String>) -> Self {
                self.storage_key = Some(storage_key.into());
                self
            }
            pub fn database_name(mut self, database_name: impl Into<String>) -> Self {
                self.database_name = Some(database_name.into());
                self
            }
            pub fn object_store_name(mut self, object_store_name: impl Into<String>) -> Self {
                self.object_store_name = Some(object_store_name.into());
                self
            }
            pub fn key_range(mut self, key_range: impl Into<KeyRange>) -> Self {
                self.key_range = Some(key_range.into());
                self
            }
            pub fn build(self) -> Result<DeleteObjectStoreEntriesParams, String> {
                Ok(DeleteObjectStoreEntriesParams {
                    security_origin: self.security_origin,
                    storage_key: self.storage_key,
                    database_name: self.database_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(database_name))
                    })?,
                    object_store_name: self.object_store_name.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(object_store_name)
                        )
                    })?,
                    key_range: self.key_range.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(key_range))
                    })?,
                })
            }
        }
        impl DeleteObjectStoreEntriesParams {
            pub const IDENTIFIER: &'static str = "IndexedDB.deleteObjectStoreEntries";
        }
        impl chromiumoxide_types::Method for DeleteObjectStoreEntriesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DeleteObjectStoreEntriesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Delete a range of entries from an object store\n[deleteObjectStoreEntries](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-deleteObjectStoreEntries)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DeleteObjectStoreEntriesReturns {}
        impl chromiumoxide_types::Command for DeleteObjectStoreEntriesParams {
            type Response = DeleteObjectStoreEntriesReturns;
        }
        #[doc = "Disables events from backend.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "IndexedDB.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables events from backend.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables events from backend.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "IndexedDB.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables events from backend.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Requests data from object store or index.\n[requestData](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-requestData)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestDataParams {
            #[doc = "At least and at most one of securityOrigin, storageKey must be specified.\nSecurity origin."]
            #[serde(rename = "securityOrigin")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub security_origin: Option<String>,
            #[doc = "Storage key."]
            #[serde(rename = "storageKey")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub storage_key: Option<String>,
            #[doc = "Database name."]
            #[serde(rename = "databaseName")]
            pub database_name: String,
            #[doc = "Object store name."]
            #[serde(rename = "objectStoreName")]
            pub object_store_name: String,
            #[doc = "Index name, empty string for object store data requests."]
            #[serde(rename = "indexName")]
            pub index_name: String,
            #[doc = "Number of records to skip."]
            #[serde(rename = "skipCount")]
            pub skip_count: i64,
            #[doc = "Number of records to fetch."]
            #[serde(rename = "pageSize")]
            pub page_size: i64,
            #[doc = "Key range."]
            #[serde(rename = "keyRange")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub key_range: Option<KeyRange>,
        }
        impl RequestDataParams {
            pub fn builder() -> RequestDataParamsBuilder {
                RequestDataParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestDataParamsBuilder {
            security_origin: Option<String>,
            storage_key: Option<String>,
            database_name: Option<String>,
            object_store_name: Option<String>,
            index_name: Option<String>,
            skip_count: Option<i64>,
            page_size: Option<i64>,
            key_range: Option<KeyRange>,
        }
        impl RequestDataParamsBuilder {
            pub fn security_origin(mut self, security_origin: impl Into<String>) -> Self {
                self.security_origin = Some(security_origin.into());
                self
            }
            pub fn storage_key(mut self, storage_key: impl Into<String>) -> Self {
                self.storage_key = Some(storage_key.into());
                self
            }
            pub fn database_name(mut self, database_name: impl Into<String>) -> Self {
                self.database_name = Some(database_name.into());
                self
            }
            pub fn object_store_name(mut self, object_store_name: impl Into<String>) -> Self {
                self.object_store_name = Some(object_store_name.into());
                self
            }
            pub fn index_name(mut self, index_name: impl Into<String>) -> Self {
                self.index_name = Some(index_name.into());
                self
            }
            pub fn skip_count(mut self, skip_count: impl Into<i64>) -> Self {
                self.skip_count = Some(skip_count.into());
                self
            }
            pub fn page_size(mut self, page_size: impl Into<i64>) -> Self {
                self.page_size = Some(page_size.into());
                self
            }
            pub fn key_range(mut self, key_range: impl Into<KeyRange>) -> Self {
                self.key_range = Some(key_range.into());
                self
            }
            pub fn build(self) -> Result<RequestDataParams, String> {
                Ok(RequestDataParams {
                    security_origin: self.security_origin,
                    storage_key: self.storage_key,
                    database_name: self.database_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(database_name))
                    })?,
                    object_store_name: self.object_store_name.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(object_store_name)
                        )
                    })?,
                    index_name: self.index_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(index_name))
                    })?,
                    skip_count: self.skip_count.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(skip_count))
                    })?,
                    page_size: self.page_size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(page_size))
                    })?,
                    key_range: self.key_range,
                })
            }
        }
        impl RequestDataParams {
            pub const IDENTIFIER: &'static str = "IndexedDB.requestData";
        }
        impl chromiumoxide_types::Method for RequestDataParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RequestDataParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests data from object store or index.\n[requestData](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-requestData)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestDataReturns {
            #[doc = "Array of object store data entries."]
            #[serde(rename = "objectStoreDataEntries")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub object_store_data_entries: Vec<DataEntry>,
            #[doc = "If true, there are more entries to fetch in the given range."]
            #[serde(rename = "hasMore")]
            pub has_more: bool,
        }
        impl RequestDataReturns {
            pub fn new(
                object_store_data_entries: Vec<DataEntry>,
                has_more: impl Into<bool>,
            ) -> Self {
                Self {
                    object_store_data_entries,
                    has_more: has_more.into(),
                }
            }
        }
        impl RequestDataReturns {
            pub fn builder() -> RequestDataReturnsBuilder {
                RequestDataReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestDataReturnsBuilder {
            object_store_data_entries: Option<Vec<DataEntry>>,
            has_more: Option<bool>,
        }
        impl RequestDataReturnsBuilder {
            pub fn object_store_data_entrie(
                mut self,
                object_store_data_entrie: impl Into<DataEntry>,
            ) -> Self {
                let v = self.object_store_data_entries.get_or_insert(Vec::new());
                v.push(object_store_data_entrie.into());
                self
            }
            pub fn object_store_data_entries<I, S>(mut self, object_store_data_entries: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<DataEntry>,
            {
                let v = self.object_store_data_entries.get_or_insert(Vec::new());
                for val in object_store_data_entries {
                    v.push(val.into());
                }
                self
            }
            pub fn has_more(mut self, has_more: impl Into<bool>) -> Self {
                self.has_more = Some(has_more.into());
                self
            }
            pub fn build(self) -> Result<RequestDataReturns, String> {
                Ok(RequestDataReturns {
                    object_store_data_entries: self.object_store_data_entries.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(object_store_data_entries)
                        )
                    })?,
                    has_more: self.has_more.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(has_more))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for RequestDataParams {
            type Response = RequestDataReturns;
        }
        #[doc = "Gets metadata of an object store\n[getMetadata](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-getMetadata)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetMetadataParams {
            #[doc = "At least and at most one of securityOrigin, storageKey must be specified.\nSecurity origin."]
            #[serde(rename = "securityOrigin")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub security_origin: Option<String>,
            #[doc = "Storage key."]
            #[serde(rename = "storageKey")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub storage_key: Option<String>,
            #[doc = "Database name."]
            #[serde(rename = "databaseName")]
            pub database_name: String,
            #[doc = "Object store name."]
            #[serde(rename = "objectStoreName")]
            pub object_store_name: String,
        }
        impl GetMetadataParams {
            pub fn new(
                database_name: impl Into<String>,
                object_store_name: impl Into<String>,
            ) -> Self {
                Self {
                    database_name: database_name.into(),
                    object_store_name: object_store_name.into(),
                    security_origin: None,
                    storage_key: None,
                }
            }
        }
        impl GetMetadataParams {
            pub fn builder() -> GetMetadataParamsBuilder {
                GetMetadataParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetMetadataParamsBuilder {
            security_origin: Option<String>,
            storage_key: Option<String>,
            database_name: Option<String>,
            object_store_name: Option<String>,
        }
        impl GetMetadataParamsBuilder {
            pub fn security_origin(mut self, security_origin: impl Into<String>) -> Self {
                self.security_origin = Some(security_origin.into());
                self
            }
            pub fn storage_key(mut self, storage_key: impl Into<String>) -> Self {
                self.storage_key = Some(storage_key.into());
                self
            }
            pub fn database_name(mut self, database_name: impl Into<String>) -> Self {
                self.database_name = Some(database_name.into());
                self
            }
            pub fn object_store_name(mut self, object_store_name: impl Into<String>) -> Self {
                self.object_store_name = Some(object_store_name.into());
                self
            }
            pub fn build(self) -> Result<GetMetadataParams, String> {
                Ok(GetMetadataParams {
                    security_origin: self.security_origin,
                    storage_key: self.storage_key,
                    database_name: self.database_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(database_name))
                    })?,
                    object_store_name: self.object_store_name.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(object_store_name)
                        )
                    })?,
                })
            }
        }
        impl GetMetadataParams {
            pub const IDENTIFIER: &'static str = "IndexedDB.getMetadata";
        }
        impl chromiumoxide_types::Method for GetMetadataParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetMetadataParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Gets metadata of an object store\n[getMetadata](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-getMetadata)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetMetadataReturns {
            #[doc = "the entries count"]
            #[serde(rename = "entriesCount")]
            pub entries_count: f64,
            #[doc = "the current value of key generator, to become the next inserted\nkey into the object store. Valid if objectStore.autoIncrement\nis true."]
            #[serde(rename = "keyGeneratorValue")]
            pub key_generator_value: f64,
        }
        impl GetMetadataReturns {
            pub fn new(entries_count: impl Into<f64>, key_generator_value: impl Into<f64>) -> Self {
                Self {
                    entries_count: entries_count.into(),
                    key_generator_value: key_generator_value.into(),
                }
            }
        }
        impl GetMetadataReturns {
            pub fn builder() -> GetMetadataReturnsBuilder {
                GetMetadataReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetMetadataReturnsBuilder {
            entries_count: Option<f64>,
            key_generator_value: Option<f64>,
        }
        impl GetMetadataReturnsBuilder {
            pub fn entries_count(mut self, entries_count: impl Into<f64>) -> Self {
                self.entries_count = Some(entries_count.into());
                self
            }
            pub fn key_generator_value(mut self, key_generator_value: impl Into<f64>) -> Self {
                self.key_generator_value = Some(key_generator_value.into());
                self
            }
            pub fn build(self) -> Result<GetMetadataReturns, String> {
                Ok(GetMetadataReturns {
                    entries_count: self.entries_count.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(entries_count))
                    })?,
                    key_generator_value: self.key_generator_value.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(key_generator_value)
                        )
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetMetadataParams {
            type Response = GetMetadataReturns;
        }
        #[doc = "Requests database with given name in given frame.\n[requestDatabase](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-requestDatabase)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestDatabaseParams {
            #[doc = "At least and at most one of securityOrigin, storageKey must be specified.\nSecurity origin."]
            #[serde(rename = "securityOrigin")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub security_origin: Option<String>,
            #[doc = "Storage key."]
            #[serde(rename = "storageKey")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub storage_key: Option<String>,
            #[doc = "Database name."]
            #[serde(rename = "databaseName")]
            pub database_name: String,
        }
        impl RequestDatabaseParams {
            pub fn new(database_name: impl Into<String>) -> Self {
                Self {
                    database_name: database_name.into(),
                    security_origin: None,
                    storage_key: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for RequestDatabaseParams {
            fn from(url: T) -> Self {
                RequestDatabaseParams::new(url)
            }
        }
        impl RequestDatabaseParams {
            pub fn builder() -> RequestDatabaseParamsBuilder {
                RequestDatabaseParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestDatabaseParamsBuilder {
            security_origin: Option<String>,
            storage_key: Option<String>,
            database_name: Option<String>,
        }
        impl RequestDatabaseParamsBuilder {
            pub fn security_origin(mut self, security_origin: impl Into<String>) -> Self {
                self.security_origin = Some(security_origin.into());
                self
            }
            pub fn storage_key(mut self, storage_key: impl Into<String>) -> Self {
                self.storage_key = Some(storage_key.into());
                self
            }
            pub fn database_name(mut self, database_name: impl Into<String>) -> Self {
                self.database_name = Some(database_name.into());
                self
            }
            pub fn build(self) -> Result<RequestDatabaseParams, String> {
                Ok(RequestDatabaseParams {
                    security_origin: self.security_origin,
                    storage_key: self.storage_key,
                    database_name: self.database_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(database_name))
                    })?,
                })
            }
        }
        impl RequestDatabaseParams {
            pub const IDENTIFIER: &'static str = "IndexedDB.requestDatabase";
        }
        impl chromiumoxide_types::Method for RequestDatabaseParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RequestDatabaseParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests database with given name in given frame.\n[requestDatabase](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-requestDatabase)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestDatabaseReturns {
            #[doc = "Database with an array of object stores."]
            #[serde(rename = "databaseWithObjectStores")]
            pub database_with_object_stores: DatabaseWithObjectStores,
        }
        impl RequestDatabaseReturns {
            pub fn new(database_with_object_stores: impl Into<DatabaseWithObjectStores>) -> Self {
                Self {
                    database_with_object_stores: database_with_object_stores.into(),
                }
            }
        }
        impl RequestDatabaseReturns {
            pub fn builder() -> RequestDatabaseReturnsBuilder {
                RequestDatabaseReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestDatabaseReturnsBuilder {
            database_with_object_stores: Option<DatabaseWithObjectStores>,
        }
        impl RequestDatabaseReturnsBuilder {
            pub fn database_with_object_stores(
                mut self,
                database_with_object_stores: impl Into<DatabaseWithObjectStores>,
            ) -> Self {
                self.database_with_object_stores = Some(database_with_object_stores.into());
                self
            }
            pub fn build(self) -> Result<RequestDatabaseReturns, String> {
                Ok(RequestDatabaseReturns {
                    database_with_object_stores: self.database_with_object_stores.ok_or_else(
                        || {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(database_with_object_stores)
                            )
                        },
                    )?,
                })
            }
        }
        impl chromiumoxide_types::Command for RequestDatabaseParams {
            type Response = RequestDatabaseReturns;
        }
        #[doc = "Requests database names for given security origin.\n[requestDatabaseNames](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-requestDatabaseNames)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RequestDatabaseNamesParams {
            #[doc = "At least and at most one of securityOrigin, storageKey must be specified.\nSecurity origin."]
            #[serde(rename = "securityOrigin")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub security_origin: Option<String>,
            #[doc = "Storage key."]
            #[serde(rename = "storageKey")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub storage_key: Option<String>,
        }
        impl RequestDatabaseNamesParams {
            pub fn builder() -> RequestDatabaseNamesParamsBuilder {
                RequestDatabaseNamesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestDatabaseNamesParamsBuilder {
            security_origin: Option<String>,
            storage_key: Option<String>,
        }
        impl RequestDatabaseNamesParamsBuilder {
            pub fn security_origin(mut self, security_origin: impl Into<String>) -> Self {
                self.security_origin = Some(security_origin.into());
                self
            }
            pub fn storage_key(mut self, storage_key: impl Into<String>) -> Self {
                self.storage_key = Some(storage_key.into());
                self
            }
            pub fn build(self) -> RequestDatabaseNamesParams {
                RequestDatabaseNamesParams {
                    security_origin: self.security_origin,
                    storage_key: self.storage_key,
                }
            }
        }
        impl RequestDatabaseNamesParams {
            pub const IDENTIFIER: &'static str = "IndexedDB.requestDatabaseNames";
        }
        impl chromiumoxide_types::Method for RequestDatabaseNamesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RequestDatabaseNamesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests database names for given security origin.\n[requestDatabaseNames](https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-requestDatabaseNames)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestDatabaseNamesReturns {
            #[doc = "Database names for origin."]
            #[serde(rename = "databaseNames")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub database_names: Vec<String>,
        }
        impl RequestDatabaseNamesReturns {
            pub fn new(database_names: Vec<String>) -> Self {
                Self { database_names }
            }
        }
        impl RequestDatabaseNamesReturns {
            pub fn builder() -> RequestDatabaseNamesReturnsBuilder {
                RequestDatabaseNamesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestDatabaseNamesReturnsBuilder {
            database_names: Option<Vec<String>>,
        }
        impl RequestDatabaseNamesReturnsBuilder {
            pub fn database_name(mut self, database_name: impl Into<String>) -> Self {
                let v = self.database_names.get_or_insert(Vec::new());
                v.push(database_name.into());
                self
            }
            pub fn database_names<I, S>(mut self, database_names: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.database_names.get_or_insert(Vec::new());
                for val in database_names {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<RequestDatabaseNamesReturns, String> {
                Ok(RequestDatabaseNamesReturns {
                    database_names: self.database_names.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(database_names))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for RequestDatabaseNamesParams {
            type Response = RequestDatabaseNamesReturns;
        }
    }
    pub mod input {
        use serde::{Deserialize, Serialize};
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TouchPoint {
            #[doc = "X coordinate of the event relative to the main frame's viewport in CSS pixels."]
            #[serde(rename = "x")]
            pub x: f64,
            #[doc = "Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to\nthe top of the viewport and Y increases as it proceeds towards the bottom of the viewport."]
            #[serde(rename = "y")]
            pub y: f64,
            #[doc = "X radius of the touch area (default: 1.0)."]
            #[serde(rename = "radiusX")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub radius_x: Option<f64>,
            #[doc = "Y radius of the touch area (default: 1.0)."]
            #[serde(rename = "radiusY")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub radius_y: Option<f64>,
            #[doc = "Rotation angle (default: 0.0)."]
            #[serde(rename = "rotationAngle")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub rotation_angle: Option<f64>,
            #[doc = "Force (default: 1.0)."]
            #[serde(rename = "force")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub force: Option<f64>,
            #[doc = "The normalized tangential pressure, which has a range of [-1,1] (default: 0)."]
            #[serde(rename = "tangentialPressure")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub tangential_pressure: Option<f64>,
            #[doc = "The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0)"]
            #[serde(rename = "tiltX")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub tilt_x: Option<i64>,
            #[doc = "The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0)."]
            #[serde(rename = "tiltY")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub tilt_y: Option<i64>,
            #[doc = "The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0)."]
            #[serde(rename = "twist")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub twist: Option<i64>,
            #[doc = "Identifier used to track touch sources between events, must be unique within an event."]
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub id: Option<f64>,
        }
        impl TouchPoint {
            pub fn new(x: impl Into<f64>, y: impl Into<f64>) -> Self {
                Self {
                    x: x.into(),
                    y: y.into(),
                    radius_x: None,
                    radius_y: None,
                    rotation_angle: None,
                    force: None,
                    tangential_pressure: None,
                    tilt_x: None,
                    tilt_y: None,
                    twist: None,
                    id: None,
                }
            }
        }
        impl TouchPoint {
            pub fn builder() -> TouchPointBuilder {
                TouchPointBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TouchPointBuilder {
            x: Option<f64>,
            y: Option<f64>,
            radius_x: Option<f64>,
            radius_y: Option<f64>,
            rotation_angle: Option<f64>,
            force: Option<f64>,
            tangential_pressure: Option<f64>,
            tilt_x: Option<i64>,
            tilt_y: Option<i64>,
            twist: Option<i64>,
            id: Option<f64>,
        }
        impl TouchPointBuilder {
            pub fn x(mut self, x: impl Into<f64>) -> Self {
                self.x = Some(x.into());
                self
            }
            pub fn y(mut self, y: impl Into<f64>) -> Self {
                self.y = Some(y.into());
                self
            }
            pub fn radius_x(mut self, radius_x: impl Into<f64>) -> Self {
                self.radius_x = Some(radius_x.into());
                self
            }
            pub fn radius_y(mut self, radius_y: impl Into<f64>) -> Self {
                self.radius_y = Some(radius_y.into());
                self
            }
            pub fn rotation_angle(mut self, rotation_angle: impl Into<f64>) -> Self {
                self.rotation_angle = Some(rotation_angle.into());
                self
            }
            pub fn force(mut self, force: impl Into<f64>) -> Self {
                self.force = Some(force.into());
                self
            }
            pub fn tangential_pressure(mut self, tangential_pressure: impl Into<f64>) -> Self {
                self.tangential_pressure = Some(tangential_pressure.into());
                self
            }
            pub fn tilt_x(mut self, tilt_x: impl Into<i64>) -> Self {
                self.tilt_x = Some(tilt_x.into());
                self
            }
            pub fn tilt_y(mut self, tilt_y: impl Into<i64>) -> Self {
                self.tilt_y = Some(tilt_y.into());
                self
            }
            pub fn twist(mut self, twist: impl Into<i64>) -> Self {
                self.twist = Some(twist.into());
                self
            }
            pub fn id(mut self, id: impl Into<f64>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn build(self) -> Result<TouchPoint, String> {
                Ok(TouchPoint {
                    x: self
                        .x
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(x)))?,
                    y: self
                        .y
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(y)))?,
                    radius_x: self.radius_x,
                    radius_y: self.radius_y,
                    rotation_angle: self.rotation_angle,
                    force: self.force,
                    tangential_pressure: self.tangential_pressure,
                    tilt_x: self.tilt_x,
                    tilt_y: self.tilt_y,
                    twist: self.twist,
                    id: self.id,
                })
            }
        }
        impl TouchPoint {
            pub const IDENTIFIER: &'static str = "Input.TouchPoint";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum GestureSourceType {
            #[serde(rename = "default")]
            Default,
            #[serde(rename = "touch")]
            Touch,
            #[serde(rename = "mouse")]
            Mouse,
        }
        impl AsRef<str> for GestureSourceType {
            fn as_ref(&self) -> &str {
                match self {
                    GestureSourceType::Default => "default",
                    GestureSourceType::Touch => "touch",
                    GestureSourceType::Mouse => "mouse",
                }
            }
        }
        impl ::std::str::FromStr for GestureSourceType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "default" | "Default" => Ok(GestureSourceType::Default),
                    "touch" | "Touch" => Ok(GestureSourceType::Touch),
                    "mouse" | "Mouse" => Ok(GestureSourceType::Mouse),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum MouseButton {
            #[serde(rename = "none")]
            None,
            #[serde(rename = "left")]
            Left,
            #[serde(rename = "middle")]
            Middle,
            #[serde(rename = "right")]
            Right,
            #[serde(rename = "back")]
            Back,
            #[serde(rename = "forward")]
            Forward,
        }
        impl AsRef<str> for MouseButton {
            fn as_ref(&self) -> &str {
                match self {
                    MouseButton::None => "none",
                    MouseButton::Left => "left",
                    MouseButton::Middle => "middle",
                    MouseButton::Right => "right",
                    MouseButton::Back => "back",
                    MouseButton::Forward => "forward",
                }
            }
        }
        impl ::std::str::FromStr for MouseButton {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "none" | "None" => Ok(MouseButton::None),
                    "left" | "Left" => Ok(MouseButton::Left),
                    "middle" | "Middle" => Ok(MouseButton::Middle),
                    "right" | "Right" => Ok(MouseButton::Right),
                    "back" | "Back" => Ok(MouseButton::Back),
                    "forward" | "Forward" => Ok(MouseButton::Forward),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "UTC time in seconds, counted from January 1, 1970.\n[TimeSinceEpoch](https://chromedevtools.github.io/devtools-protocol/tot/Input/#type-TimeSinceEpoch)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TimeSinceEpoch(f64);
        impl TimeSinceEpoch {
            pub fn new(val: impl Into<f64>) -> Self {
                TimeSinceEpoch(val.into())
            }
            pub fn inner(&self) -> &f64 {
                &self.0
            }
        }
        impl TimeSinceEpoch {
            pub const IDENTIFIER: &'static str = "Input.TimeSinceEpoch";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DragDataItem {
            #[doc = "Mime type of the dragged data."]
            #[serde(rename = "mimeType")]
            pub mime_type: String,
            #[doc = "Depending of the value of `mimeType`, it contains the dragged link,\ntext, HTML markup or any other data."]
            #[serde(rename = "data")]
            pub data: String,
            #[doc = "Title associated with a link. Only valid when `mimeType` == \"text/uri-list\"."]
            #[serde(rename = "title")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub title: Option<String>,
            #[doc = "Stores the base URL for the contained markup. Only valid when `mimeType`\n== \"text/html\"."]
            #[serde(rename = "baseURL")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub base_url: Option<String>,
        }
        impl DragDataItem {
            pub fn new(mime_type: impl Into<String>, data: impl Into<String>) -> Self {
                Self {
                    mime_type: mime_type.into(),
                    data: data.into(),
                    title: None,
                    base_url: None,
                }
            }
        }
        impl DragDataItem {
            pub fn builder() -> DragDataItemBuilder {
                DragDataItemBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DragDataItemBuilder {
            mime_type: Option<String>,
            data: Option<String>,
            title: Option<String>,
            base_url: Option<String>,
        }
        impl DragDataItemBuilder {
            pub fn mime_type(mut self, mime_type: impl Into<String>) -> Self {
                self.mime_type = Some(mime_type.into());
                self
            }
            pub fn data(mut self, data: impl Into<String>) -> Self {
                self.data = Some(data.into());
                self
            }
            pub fn title(mut self, title: impl Into<String>) -> Self {
                self.title = Some(title.into());
                self
            }
            pub fn base_url(mut self, base_url: impl Into<String>) -> Self {
                self.base_url = Some(base_url.into());
                self
            }
            pub fn build(self) -> Result<DragDataItem, String> {
                Ok(DragDataItem {
                    mime_type: self.mime_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(mime_type))
                    })?,
                    data: self.data.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(data))
                    })?,
                    title: self.title,
                    base_url: self.base_url,
                })
            }
        }
        impl DragDataItem {
            pub const IDENTIFIER: &'static str = "Input.DragDataItem";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DragData {
            #[serde(rename = "items")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub items: Vec<DragDataItem>,
            #[doc = "List of filenames that should be included when dropping"]
            #[serde(rename = "files")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub files: Option<Vec<String>>,
            #[doc = "Bit field representing allowed drag operations. Copy = 1, Link = 2, Move = 16"]
            #[serde(rename = "dragOperationsMask")]
            pub drag_operations_mask: i64,
        }
        impl DragData {
            pub fn new(items: Vec<DragDataItem>, drag_operations_mask: impl Into<i64>) -> Self {
                Self {
                    items,
                    drag_operations_mask: drag_operations_mask.into(),
                    files: None,
                }
            }
        }
        impl DragData {
            pub fn builder() -> DragDataBuilder {
                DragDataBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DragDataBuilder {
            items: Option<Vec<DragDataItem>>,
            files: Option<Vec<String>>,
            drag_operations_mask: Option<i64>,
        }
        impl DragDataBuilder {
            pub fn item(mut self, item: impl Into<DragDataItem>) -> Self {
                let v = self.items.get_or_insert(Vec::new());
                v.push(item.into());
                self
            }
            pub fn items<I, S>(mut self, items: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<DragDataItem>,
            {
                let v = self.items.get_or_insert(Vec::new());
                for val in items {
                    v.push(val.into());
                }
                self
            }
            pub fn file(mut self, file: impl Into<String>) -> Self {
                let v = self.files.get_or_insert(Vec::new());
                v.push(file.into());
                self
            }
            pub fn files<I, S>(mut self, files: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.files.get_or_insert(Vec::new());
                for val in files {
                    v.push(val.into());
                }
                self
            }
            pub fn drag_operations_mask(mut self, drag_operations_mask: impl Into<i64>) -> Self {
                self.drag_operations_mask = Some(drag_operations_mask.into());
                self
            }
            pub fn build(self) -> Result<DragData, String> {
                Ok(DragData {
                    items: self.items.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(items))
                    })?,
                    files: self.files,
                    drag_operations_mask: self.drag_operations_mask.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(drag_operations_mask)
                        )
                    })?,
                })
            }
        }
        impl DragData {
            pub const IDENTIFIER: &'static str = "Input.DragData";
        }
        #[doc = "Dispatches a drag event into the page.\n[dispatchDragEvent](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchDragEvent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DispatchDragEventParams {
            #[doc = "Type of the drag event."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: DispatchDragEventType,
            #[doc = "X coordinate of the event relative to the main frame's viewport in CSS pixels."]
            #[serde(rename = "x")]
            pub x: f64,
            #[doc = "Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to\nthe top of the viewport and Y increases as it proceeds towards the bottom of the viewport."]
            #[serde(rename = "y")]
            pub y: f64,
            #[serde(rename = "data")]
            pub data: DragData,
            #[doc = "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8\n(default: 0)."]
            #[serde(rename = "modifiers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub modifiers: Option<i64>,
        }
        #[doc = "Type of the drag event."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum DispatchDragEventType {
            #[serde(rename = "dragEnter")]
            DragEnter,
            #[serde(rename = "dragOver")]
            DragOver,
            #[serde(rename = "drop")]
            Drop,
            #[serde(rename = "dragCancel")]
            DragCancel,
        }
        impl AsRef<str> for DispatchDragEventType {
            fn as_ref(&self) -> &str {
                match self {
                    DispatchDragEventType::DragEnter => "dragEnter",
                    DispatchDragEventType::DragOver => "dragOver",
                    DispatchDragEventType::Drop => "drop",
                    DispatchDragEventType::DragCancel => "dragCancel",
                }
            }
        }
        impl ::std::str::FromStr for DispatchDragEventType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "dragEnter" | "DragEnter" | "dragenter" => Ok(DispatchDragEventType::DragEnter),
                    "dragOver" | "DragOver" | "dragover" => Ok(DispatchDragEventType::DragOver),
                    "drop" | "Drop" => Ok(DispatchDragEventType::Drop),
                    "dragCancel" | "DragCancel" | "dragcancel" => {
                        Ok(DispatchDragEventType::DragCancel)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl DispatchDragEventParams {
            pub fn new(
                r#type: impl Into<DispatchDragEventType>,
                x: impl Into<f64>,
                y: impl Into<f64>,
                data: impl Into<DragData>,
            ) -> Self {
                Self {
                    r#type: r#type.into(),
                    x: x.into(),
                    y: y.into(),
                    data: data.into(),
                    modifiers: None,
                }
            }
        }
        impl DispatchDragEventParams {
            pub fn builder() -> DispatchDragEventParamsBuilder {
                DispatchDragEventParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DispatchDragEventParamsBuilder {
            r#type: Option<DispatchDragEventType>,
            x: Option<f64>,
            y: Option<f64>,
            data: Option<DragData>,
            modifiers: Option<i64>,
        }
        impl DispatchDragEventParamsBuilder {
            pub fn r#type(mut self, r#type: impl Into<DispatchDragEventType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn x(mut self, x: impl Into<f64>) -> Self {
                self.x = Some(x.into());
                self
            }
            pub fn y(mut self, y: impl Into<f64>) -> Self {
                self.y = Some(y.into());
                self
            }
            pub fn data(mut self, data: impl Into<DragData>) -> Self {
                self.data = Some(data.into());
                self
            }
            pub fn modifiers(mut self, modifiers: impl Into<i64>) -> Self {
                self.modifiers = Some(modifiers.into());
                self
            }
            pub fn build(self) -> Result<DispatchDragEventParams, String> {
                Ok(DispatchDragEventParams {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    x: self
                        .x
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(x)))?,
                    y: self
                        .y
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(y)))?,
                    data: self.data.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(data))
                    })?,
                    modifiers: self.modifiers,
                })
            }
        }
        impl DispatchDragEventParams {
            pub const IDENTIFIER: &'static str = "Input.dispatchDragEvent";
        }
        impl chromiumoxide_types::Method for DispatchDragEventParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DispatchDragEventParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Dispatches a drag event into the page.\n[dispatchDragEvent](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchDragEvent)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DispatchDragEventReturns {}
        impl chromiumoxide_types::Command for DispatchDragEventParams {
            type Response = DispatchDragEventReturns;
        }
        #[doc = "Dispatches a key event to the page.\n[dispatchKeyEvent](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchKeyEvent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DispatchKeyEventParams {
            #[doc = "Type of the key event."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: DispatchKeyEventType,
            #[doc = "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8\n(default: 0)."]
            #[serde(rename = "modifiers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub modifiers: Option<i64>,
            #[doc = "Time at which the event occurred."]
            #[serde(rename = "timestamp")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub timestamp: Option<TimeSinceEpoch>,
            #[doc = "Text as generated by processing a virtual key code with a keyboard layout. Not needed for\nfor `keyUp` and `rawKeyDown` events (default: \"\")"]
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub text: Option<String>,
            #[doc = "Text that would have been generated by the keyboard if no modifiers were pressed (except for\nshift). Useful for shortcut (accelerator) key handling (default: \"\")."]
            #[serde(rename = "unmodifiedText")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub unmodified_text: Option<String>,
            #[doc = "Unique key identifier (e.g., 'U+0041') (default: \"\")."]
            #[serde(rename = "keyIdentifier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub key_identifier: Option<String>,
            #[doc = "Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: \"\")."]
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub code: Option<String>,
            #[doc = "Unique DOM defined string value describing the meaning of the key in the context of active\nmodifiers, keyboard layout, etc (e.g., 'AltGr') (default: \"\")."]
            #[serde(rename = "key")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub key: Option<String>,
            #[doc = "Windows virtual key code (default: 0)."]
            #[serde(rename = "windowsVirtualKeyCode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub windows_virtual_key_code: Option<i64>,
            #[doc = "Native virtual key code (default: 0)."]
            #[serde(rename = "nativeVirtualKeyCode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub native_virtual_key_code: Option<i64>,
            #[doc = "Whether the event was generated from auto repeat (default: false)."]
            #[serde(rename = "autoRepeat")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub auto_repeat: Option<bool>,
            #[doc = "Whether the event was generated from the keypad (default: false)."]
            #[serde(rename = "isKeypad")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_keypad: Option<bool>,
            #[doc = "Whether the event was a system key event (default: false)."]
            #[serde(rename = "isSystemKey")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_system_key: Option<bool>,
            #[doc = "Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:\n0)."]
            #[serde(rename = "location")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub location: Option<i64>,
            #[doc = "Editing commands to send with the key event (e.g., 'selectAll') (default: []).\nThese are related to but not equal the command names used in `document.execCommand` and NSStandardKeyBindingResponding.\nSee https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names."]
            #[serde(rename = "commands")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub commands: Option<Vec<String>>,
        }
        #[doc = "Type of the key event."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum DispatchKeyEventType {
            #[serde(rename = "keyDown")]
            KeyDown,
            #[serde(rename = "keyUp")]
            KeyUp,
            #[serde(rename = "rawKeyDown")]
            RawKeyDown,
            #[serde(rename = "char")]
            Char,
        }
        impl AsRef<str> for DispatchKeyEventType {
            fn as_ref(&self) -> &str {
                match self {
                    DispatchKeyEventType::KeyDown => "keyDown",
                    DispatchKeyEventType::KeyUp => "keyUp",
                    DispatchKeyEventType::RawKeyDown => "rawKeyDown",
                    DispatchKeyEventType::Char => "char",
                }
            }
        }
        impl ::std::str::FromStr for DispatchKeyEventType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "keyDown" | "KeyDown" | "keydown" => Ok(DispatchKeyEventType::KeyDown),
                    "keyUp" | "KeyUp" | "keyup" => Ok(DispatchKeyEventType::KeyUp),
                    "rawKeyDown" | "RawKeyDown" | "rawkeydown" => {
                        Ok(DispatchKeyEventType::RawKeyDown)
                    }
                    "char" | "Char" => Ok(DispatchKeyEventType::Char),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl DispatchKeyEventParams {
            pub fn new(r#type: impl Into<DispatchKeyEventType>) -> Self {
                Self {
                    r#type: r#type.into(),
                    modifiers: None,
                    timestamp: None,
                    text: None,
                    unmodified_text: None,
                    key_identifier: None,
                    code: None,
                    key: None,
                    windows_virtual_key_code: None,
                    native_virtual_key_code: None,
                    auto_repeat: None,
                    is_keypad: None,
                    is_system_key: None,
                    location: None,
                    commands: None,
                }
            }
        }
        impl DispatchKeyEventParams {
            pub fn builder() -> DispatchKeyEventParamsBuilder {
                DispatchKeyEventParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DispatchKeyEventParamsBuilder {
            r#type: Option<DispatchKeyEventType>,
            modifiers: Option<i64>,
            timestamp: Option<TimeSinceEpoch>,
            text: Option<String>,
            unmodified_text: Option<String>,
            key_identifier: Option<String>,
            code: Option<String>,
            key: Option<String>,
            windows_virtual_key_code: Option<i64>,
            native_virtual_key_code: Option<i64>,
            auto_repeat: Option<bool>,
            is_keypad: Option<bool>,
            is_system_key: Option<bool>,
            location: Option<i64>,
            commands: Option<Vec<String>>,
        }
        impl DispatchKeyEventParamsBuilder {
            pub fn r#type(mut self, r#type: impl Into<DispatchKeyEventType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn modifiers(mut self, modifiers: impl Into<i64>) -> Self {
                self.modifiers = Some(modifiers.into());
                self
            }
            pub fn timestamp(mut self, timestamp: impl Into<TimeSinceEpoch>) -> Self {
                self.timestamp = Some(timestamp.into());
                self
            }
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn unmodified_text(mut self, unmodified_text: impl Into<String>) -> Self {
                self.unmodified_text = Some(unmodified_text.into());
                self
            }
            pub fn key_identifier(mut self, key_identifier: impl Into<String>) -> Self {
                self.key_identifier = Some(key_identifier.into());
                self
            }
            pub fn code(mut self, code: impl Into<String>) -> Self {
                self.code = Some(code.into());
                self
            }
            pub fn key(mut self, key: impl Into<String>) -> Self {
                self.key = Some(key.into());
                self
            }
            pub fn windows_virtual_key_code(
                mut self,
                windows_virtual_key_code: impl Into<i64>,
            ) -> Self {
                self.windows_virtual_key_code = Some(windows_virtual_key_code.into());
                self
            }
            pub fn native_virtual_key_code(
                mut self,
                native_virtual_key_code: impl Into<i64>,
            ) -> Self {
                self.native_virtual_key_code = Some(native_virtual_key_code.into());
                self
            }
            pub fn auto_repeat(mut self, auto_repeat: impl Into<bool>) -> Self {
                self.auto_repeat = Some(auto_repeat.into());
                self
            }
            pub fn is_keypad(mut self, is_keypad: impl Into<bool>) -> Self {
                self.is_keypad = Some(is_keypad.into());
                self
            }
            pub fn is_system_key(mut self, is_system_key: impl Into<bool>) -> Self {
                self.is_system_key = Some(is_system_key.into());
                self
            }
            pub fn location(mut self, location: impl Into<i64>) -> Self {
                self.location = Some(location.into());
                self
            }
            pub fn command(mut self, command: impl Into<String>) -> Self {
                let v = self.commands.get_or_insert(Vec::new());
                v.push(command.into());
                self
            }
            pub fn commands<I, S>(mut self, commands: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.commands.get_or_insert(Vec::new());
                for val in commands {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<DispatchKeyEventParams, String> {
                Ok(DispatchKeyEventParams {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    modifiers: self.modifiers,
                    timestamp: self.timestamp,
                    text: self.text,
                    unmodified_text: self.unmodified_text,
                    key_identifier: self.key_identifier,
                    code: self.code,
                    key: self.key,
                    windows_virtual_key_code: self.windows_virtual_key_code,
                    native_virtual_key_code: self.native_virtual_key_code,
                    auto_repeat: self.auto_repeat,
                    is_keypad: self.is_keypad,
                    is_system_key: self.is_system_key,
                    location: self.location,
                    commands: self.commands,
                })
            }
        }
        impl DispatchKeyEventParams {
            pub const IDENTIFIER: &'static str = "Input.dispatchKeyEvent";
        }
        impl chromiumoxide_types::Method for DispatchKeyEventParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DispatchKeyEventParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Dispatches a key event to the page.\n[dispatchKeyEvent](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchKeyEvent)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DispatchKeyEventReturns {}
        impl chromiumoxide_types::Command for DispatchKeyEventParams {
            type Response = DispatchKeyEventReturns;
        }
        #[doc = "This method emulates inserting text that doesn't come from a key press,\nfor example an emoji keyboard or an IME.\n[insertText](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-insertText)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InsertTextParams {
            #[doc = "The text to insert."]
            #[serde(rename = "text")]
            pub text: String,
        }
        impl InsertTextParams {
            pub fn new(text: impl Into<String>) -> Self {
                Self { text: text.into() }
            }
        }
        impl<T: Into<String>> From<T> for InsertTextParams {
            fn from(url: T) -> Self {
                InsertTextParams::new(url)
            }
        }
        impl InsertTextParams {
            pub fn builder() -> InsertTextParamsBuilder {
                InsertTextParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct InsertTextParamsBuilder {
            text: Option<String>,
        }
        impl InsertTextParamsBuilder {
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn build(self) -> Result<InsertTextParams, String> {
                Ok(InsertTextParams {
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                })
            }
        }
        impl InsertTextParams {
            pub const IDENTIFIER: &'static str = "Input.insertText";
        }
        impl chromiumoxide_types::Method for InsertTextParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for InsertTextParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "This method emulates inserting text that doesn't come from a key press,\nfor example an emoji keyboard or an IME.\n[insertText](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-insertText)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct InsertTextReturns {}
        impl chromiumoxide_types::Command for InsertTextParams {
            type Response = InsertTextReturns;
        }
        #[doc = "This method sets the current candidate text for ime.\nUse imeCommitComposition to commit the final text.\nUse imeSetComposition with empty string as text to cancel composition.\n[imeSetComposition](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-imeSetComposition)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ImeSetCompositionParams {
            #[doc = "The text to insert"]
            #[serde(rename = "text")]
            pub text: String,
            #[doc = "selection start"]
            #[serde(rename = "selectionStart")]
            pub selection_start: i64,
            #[doc = "selection end"]
            #[serde(rename = "selectionEnd")]
            pub selection_end: i64,
            #[doc = "replacement start"]
            #[serde(rename = "replacementStart")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub replacement_start: Option<i64>,
            #[doc = "replacement end"]
            #[serde(rename = "replacementEnd")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub replacement_end: Option<i64>,
        }
        impl ImeSetCompositionParams {
            pub fn new(
                text: impl Into<String>,
                selection_start: impl Into<i64>,
                selection_end: impl Into<i64>,
            ) -> Self {
                Self {
                    text: text.into(),
                    selection_start: selection_start.into(),
                    selection_end: selection_end.into(),
                    replacement_start: None,
                    replacement_end: None,
                }
            }
        }
        impl ImeSetCompositionParams {
            pub fn builder() -> ImeSetCompositionParamsBuilder {
                ImeSetCompositionParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ImeSetCompositionParamsBuilder {
            text: Option<String>,
            selection_start: Option<i64>,
            selection_end: Option<i64>,
            replacement_start: Option<i64>,
            replacement_end: Option<i64>,
        }
        impl ImeSetCompositionParamsBuilder {
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn selection_start(mut self, selection_start: impl Into<i64>) -> Self {
                self.selection_start = Some(selection_start.into());
                self
            }
            pub fn selection_end(mut self, selection_end: impl Into<i64>) -> Self {
                self.selection_end = Some(selection_end.into());
                self
            }
            pub fn replacement_start(mut self, replacement_start: impl Into<i64>) -> Self {
                self.replacement_start = Some(replacement_start.into());
                self
            }
            pub fn replacement_end(mut self, replacement_end: impl Into<i64>) -> Self {
                self.replacement_end = Some(replacement_end.into());
                self
            }
            pub fn build(self) -> Result<ImeSetCompositionParams, String> {
                Ok(ImeSetCompositionParams {
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                    selection_start: self.selection_start.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(selection_start))
                    })?,
                    selection_end: self.selection_end.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(selection_end))
                    })?,
                    replacement_start: self.replacement_start,
                    replacement_end: self.replacement_end,
                })
            }
        }
        impl ImeSetCompositionParams {
            pub const IDENTIFIER: &'static str = "Input.imeSetComposition";
        }
        impl chromiumoxide_types::Method for ImeSetCompositionParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ImeSetCompositionParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "This method sets the current candidate text for ime.\nUse imeCommitComposition to commit the final text.\nUse imeSetComposition with empty string as text to cancel composition.\n[imeSetComposition](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-imeSetComposition)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ImeSetCompositionReturns {}
        impl chromiumoxide_types::Command for ImeSetCompositionParams {
            type Response = ImeSetCompositionReturns;
        }
        #[doc = "Dispatches a mouse event to the page.\n[dispatchMouseEvent](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchMouseEvent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DispatchMouseEventParams {
            #[doc = "Type of the mouse event."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: DispatchMouseEventType,
            #[doc = "X coordinate of the event relative to the main frame's viewport in CSS pixels."]
            #[serde(rename = "x")]
            pub x: f64,
            #[doc = "Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to\nthe top of the viewport and Y increases as it proceeds towards the bottom of the viewport."]
            #[serde(rename = "y")]
            pub y: f64,
            #[doc = "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8\n(default: 0)."]
            #[serde(rename = "modifiers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub modifiers: Option<i64>,
            #[doc = "Time at which the event occurred."]
            #[serde(rename = "timestamp")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub timestamp: Option<TimeSinceEpoch>,
            #[doc = "Mouse button (default: \"none\")."]
            #[serde(rename = "button")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub button: Option<MouseButton>,
            #[doc = "A number indicating which buttons are pressed on the mouse when a mouse event is triggered.\nLeft=1, Right=2, Middle=4, Back=8, Forward=16, None=0."]
            #[serde(rename = "buttons")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub buttons: Option<i64>,
            #[doc = "Number of times the mouse button was clicked (default: 0)."]
            #[serde(rename = "clickCount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub click_count: Option<i64>,
            #[doc = "The normalized pressure, which has a range of [0,1] (default: 0)."]
            #[serde(rename = "force")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub force: Option<f64>,
            #[doc = "The normalized tangential pressure, which has a range of [-1,1] (default: 0)."]
            #[serde(rename = "tangentialPressure")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub tangential_pressure: Option<f64>,
            #[doc = "The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0)."]
            #[serde(rename = "tiltX")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub tilt_x: Option<i64>,
            #[doc = "The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0)."]
            #[serde(rename = "tiltY")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub tilt_y: Option<i64>,
            #[doc = "The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0)."]
            #[serde(rename = "twist")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub twist: Option<i64>,
            #[doc = "X delta in CSS pixels for mouse wheel event (default: 0)."]
            #[serde(rename = "deltaX")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub delta_x: Option<f64>,
            #[doc = "Y delta in CSS pixels for mouse wheel event (default: 0)."]
            #[serde(rename = "deltaY")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub delta_y: Option<f64>,
            #[doc = "Pointer type (default: \"mouse\")."]
            #[serde(rename = "pointerType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub pointer_type: Option<DispatchMouseEventPointerType>,
        }
        #[doc = "Type of the mouse event."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum DispatchMouseEventType {
            #[serde(rename = "mousePressed")]
            MousePressed,
            #[serde(rename = "mouseReleased")]
            MouseReleased,
            #[serde(rename = "mouseMoved")]
            MouseMoved,
            #[serde(rename = "mouseWheel")]
            MouseWheel,
        }
        impl AsRef<str> for DispatchMouseEventType {
            fn as_ref(&self) -> &str {
                match self {
                    DispatchMouseEventType::MousePressed => "mousePressed",
                    DispatchMouseEventType::MouseReleased => "mouseReleased",
                    DispatchMouseEventType::MouseMoved => "mouseMoved",
                    DispatchMouseEventType::MouseWheel => "mouseWheel",
                }
            }
        }
        impl ::std::str::FromStr for DispatchMouseEventType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "mousePressed" | "MousePressed" | "mousepressed" => {
                        Ok(DispatchMouseEventType::MousePressed)
                    }
                    "mouseReleased" | "MouseReleased" | "mousereleased" => {
                        Ok(DispatchMouseEventType::MouseReleased)
                    }
                    "mouseMoved" | "MouseMoved" | "mousemoved" => {
                        Ok(DispatchMouseEventType::MouseMoved)
                    }
                    "mouseWheel" | "MouseWheel" | "mousewheel" => {
                        Ok(DispatchMouseEventType::MouseWheel)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Pointer type (default: \"mouse\")."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum DispatchMouseEventPointerType {
            #[serde(rename = "mouse")]
            Mouse,
            #[serde(rename = "pen")]
            Pen,
        }
        impl AsRef<str> for DispatchMouseEventPointerType {
            fn as_ref(&self) -> &str {
                match self {
                    DispatchMouseEventPointerType::Mouse => "mouse",
                    DispatchMouseEventPointerType::Pen => "pen",
                }
            }
        }
        impl ::std::str::FromStr for DispatchMouseEventPointerType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "mouse" | "Mouse" => Ok(DispatchMouseEventPointerType::Mouse),
                    "pen" | "Pen" => Ok(DispatchMouseEventPointerType::Pen),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl DispatchMouseEventParams {
            pub fn new(
                r#type: impl Into<DispatchMouseEventType>,
                x: impl Into<f64>,
                y: impl Into<f64>,
            ) -> Self {
                Self {
                    r#type: r#type.into(),
                    x: x.into(),
                    y: y.into(),
                    modifiers: None,
                    timestamp: None,
                    button: None,
                    buttons: None,
                    click_count: None,
                    force: None,
                    tangential_pressure: None,
                    tilt_x: None,
                    tilt_y: None,
                    twist: None,
                    delta_x: None,
                    delta_y: None,
                    pointer_type: None,
                }
            }
        }
        impl DispatchMouseEventParams {
            pub fn builder() -> DispatchMouseEventParamsBuilder {
                DispatchMouseEventParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DispatchMouseEventParamsBuilder {
            r#type: Option<DispatchMouseEventType>,
            x: Option<f64>,
            y: Option<f64>,
            modifiers: Option<i64>,
            timestamp: Option<TimeSinceEpoch>,
            button: Option<MouseButton>,
            buttons: Option<i64>,
            click_count: Option<i64>,
            force: Option<f64>,
            tangential_pressure: Option<f64>,
            tilt_x: Option<i64>,
            tilt_y: Option<i64>,
            twist: Option<i64>,
            delta_x: Option<f64>,
            delta_y: Option<f64>,
            pointer_type: Option<DispatchMouseEventPointerType>,
        }
        impl DispatchMouseEventParamsBuilder {
            pub fn r#type(mut self, r#type: impl Into<DispatchMouseEventType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn x(mut self, x: impl Into<f64>) -> Self {
                self.x = Some(x.into());
                self
            }
            pub fn y(mut self, y: impl Into<f64>) -> Self {
                self.y = Some(y.into());
                self
            }
            pub fn modifiers(mut self, modifiers: impl Into<i64>) -> Self {
                self.modifiers = Some(modifiers.into());
                self
            }
            pub fn timestamp(mut self, timestamp: impl Into<TimeSinceEpoch>) -> Self {
                self.timestamp = Some(timestamp.into());
                self
            }
            pub fn button(mut self, button: impl Into<MouseButton>) -> Self {
                self.button = Some(button.into());
                self
            }
            pub fn buttons(mut self, buttons: impl Into<i64>) -> Self {
                self.buttons = Some(buttons.into());
                self
            }
            pub fn click_count(mut self, click_count: impl Into<i64>) -> Self {
                self.click_count = Some(click_count.into());
                self
            }
            pub fn force(mut self, force: impl Into<f64>) -> Self {
                self.force = Some(force.into());
                self
            }
            pub fn tangential_pressure(mut self, tangential_pressure: impl Into<f64>) -> Self {
                self.tangential_pressure = Some(tangential_pressure.into());
                self
            }
            pub fn tilt_x(mut self, tilt_x: impl Into<i64>) -> Self {
                self.tilt_x = Some(tilt_x.into());
                self
            }
            pub fn tilt_y(mut self, tilt_y: impl Into<i64>) -> Self {
                self.tilt_y = Some(tilt_y.into());
                self
            }
            pub fn twist(mut self, twist: impl Into<i64>) -> Self {
                self.twist = Some(twist.into());
                self
            }
            pub fn delta_x(mut self, delta_x: impl Into<f64>) -> Self {
                self.delta_x = Some(delta_x.into());
                self
            }
            pub fn delta_y(mut self, delta_y: impl Into<f64>) -> Self {
                self.delta_y = Some(delta_y.into());
                self
            }
            pub fn pointer_type(
                mut self,
                pointer_type: impl Into<DispatchMouseEventPointerType>,
            ) -> Self {
                self.pointer_type = Some(pointer_type.into());
                self
            }
            pub fn build(self) -> Result<DispatchMouseEventParams, String> {
                Ok(DispatchMouseEventParams {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    x: self
                        .x
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(x)))?,
                    y: self
                        .y
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(y)))?,
                    modifiers: self.modifiers,
                    timestamp: self.timestamp,
                    button: self.button,
                    buttons: self.buttons,
                    click_count: self.click_count,
                    force: self.force,
                    tangential_pressure: self.tangential_pressure,
                    tilt_x: self.tilt_x,
                    tilt_y: self.tilt_y,
                    twist: self.twist,
                    delta_x: self.delta_x,
                    delta_y: self.delta_y,
                    pointer_type: self.pointer_type,
                })
            }
        }
        impl DispatchMouseEventParams {
            pub const IDENTIFIER: &'static str = "Input.dispatchMouseEvent";
        }
        impl chromiumoxide_types::Method for DispatchMouseEventParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DispatchMouseEventParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Dispatches a mouse event to the page.\n[dispatchMouseEvent](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchMouseEvent)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DispatchMouseEventReturns {}
        impl chromiumoxide_types::Command for DispatchMouseEventParams {
            type Response = DispatchMouseEventReturns;
        }
        #[doc = "Dispatches a touch event to the page.\n[dispatchTouchEvent](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchTouchEvent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DispatchTouchEventParams {
            #[doc = "Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while\nTouchStart and TouchMove must contains at least one."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: DispatchTouchEventType,
            #[doc = "Active touch points on the touch device. One event per any changed point (compared to\nprevious touch event in a sequence) is generated, emulating pressing/moving/releasing points\none by one."]
            #[serde(rename = "touchPoints")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub touch_points: Vec<TouchPoint>,
            #[doc = "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8\n(default: 0)."]
            #[serde(rename = "modifiers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub modifiers: Option<i64>,
            #[doc = "Time at which the event occurred."]
            #[serde(rename = "timestamp")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub timestamp: Option<TimeSinceEpoch>,
        }
        #[doc = "Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while\nTouchStart and TouchMove must contains at least one."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum DispatchTouchEventType {
            #[serde(rename = "touchStart")]
            TouchStart,
            #[serde(rename = "touchEnd")]
            TouchEnd,
            #[serde(rename = "touchMove")]
            TouchMove,
            #[serde(rename = "touchCancel")]
            TouchCancel,
        }
        impl AsRef<str> for DispatchTouchEventType {
            fn as_ref(&self) -> &str {
                match self {
                    DispatchTouchEventType::TouchStart => "touchStart",
                    DispatchTouchEventType::TouchEnd => "touchEnd",
                    DispatchTouchEventType::TouchMove => "touchMove",
                    DispatchTouchEventType::TouchCancel => "touchCancel",
                }
            }
        }
        impl ::std::str::FromStr for DispatchTouchEventType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "touchStart" | "TouchStart" | "touchstart" => {
                        Ok(DispatchTouchEventType::TouchStart)
                    }
                    "touchEnd" | "TouchEnd" | "touchend" => Ok(DispatchTouchEventType::TouchEnd),
                    "touchMove" | "TouchMove" | "touchmove" => {
                        Ok(DispatchTouchEventType::TouchMove)
                    }
                    "touchCancel" | "TouchCancel" | "touchcancel" => {
                        Ok(DispatchTouchEventType::TouchCancel)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl DispatchTouchEventParams {
            pub fn new(
                r#type: impl Into<DispatchTouchEventType>,
                touch_points: Vec<TouchPoint>,
            ) -> Self {
                Self {
                    r#type: r#type.into(),
                    touch_points,
                    modifiers: None,
                    timestamp: None,
                }
            }
        }
        impl DispatchTouchEventParams {
            pub fn builder() -> DispatchTouchEventParamsBuilder {
                DispatchTouchEventParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DispatchTouchEventParamsBuilder {
            r#type: Option<DispatchTouchEventType>,
            touch_points: Option<Vec<TouchPoint>>,
            modifiers: Option<i64>,
            timestamp: Option<TimeSinceEpoch>,
        }
        impl DispatchTouchEventParamsBuilder {
            pub fn r#type(mut self, r#type: impl Into<DispatchTouchEventType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn touch_point(mut self, touch_point: impl Into<TouchPoint>) -> Self {
                let v = self.touch_points.get_or_insert(Vec::new());
                v.push(touch_point.into());
                self
            }
            pub fn touch_points<I, S>(mut self, touch_points: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<TouchPoint>,
            {
                let v = self.touch_points.get_or_insert(Vec::new());
                for val in touch_points {
                    v.push(val.into());
                }
                self
            }
            pub fn modifiers(mut self, modifiers: impl Into<i64>) -> Self {
                self.modifiers = Some(modifiers.into());
                self
            }
            pub fn timestamp(mut self, timestamp: impl Into<TimeSinceEpoch>) -> Self {
                self.timestamp = Some(timestamp.into());
                self
            }
            pub fn build(self) -> Result<DispatchTouchEventParams, String> {
                Ok(DispatchTouchEventParams {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    touch_points: self.touch_points.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(touch_points))
                    })?,
                    modifiers: self.modifiers,
                    timestamp: self.timestamp,
                })
            }
        }
        impl DispatchTouchEventParams {
            pub const IDENTIFIER: &'static str = "Input.dispatchTouchEvent";
        }
        impl chromiumoxide_types::Method for DispatchTouchEventParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DispatchTouchEventParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Dispatches a touch event to the page.\n[dispatchTouchEvent](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchTouchEvent)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DispatchTouchEventReturns {}
        impl chromiumoxide_types::Command for DispatchTouchEventParams {
            type Response = DispatchTouchEventReturns;
        }
        #[doc = "Emulates touch event from the mouse event parameters.\n[emulateTouchFromMouseEvent](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-emulateTouchFromMouseEvent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EmulateTouchFromMouseEventParams {
            #[doc = "Type of the mouse event."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: EmulateTouchFromMouseEventType,
            #[doc = "X coordinate of the mouse pointer in DIP."]
            #[serde(rename = "x")]
            pub x: i64,
            #[doc = "Y coordinate of the mouse pointer in DIP."]
            #[serde(rename = "y")]
            pub y: i64,
            #[doc = "Mouse button. Only \"none\", \"left\", \"right\" are supported."]
            #[serde(rename = "button")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub button: MouseButton,
            #[doc = "Time at which the event occurred (default: current time)."]
            #[serde(rename = "timestamp")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub timestamp: Option<TimeSinceEpoch>,
            #[doc = "X delta in DIP for mouse wheel event (default: 0)."]
            #[serde(rename = "deltaX")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub delta_x: Option<f64>,
            #[doc = "Y delta in DIP for mouse wheel event (default: 0)."]
            #[serde(rename = "deltaY")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub delta_y: Option<f64>,
            #[doc = "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8\n(default: 0)."]
            #[serde(rename = "modifiers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub modifiers: Option<i64>,
            #[doc = "Number of times the mouse button was clicked (default: 0)."]
            #[serde(rename = "clickCount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub click_count: Option<i64>,
        }
        #[doc = "Type of the mouse event."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum EmulateTouchFromMouseEventType {
            #[serde(rename = "mousePressed")]
            MousePressed,
            #[serde(rename = "mouseReleased")]
            MouseReleased,
            #[serde(rename = "mouseMoved")]
            MouseMoved,
            #[serde(rename = "mouseWheel")]
            MouseWheel,
        }
        impl AsRef<str> for EmulateTouchFromMouseEventType {
            fn as_ref(&self) -> &str {
                match self {
                    EmulateTouchFromMouseEventType::MousePressed => "mousePressed",
                    EmulateTouchFromMouseEventType::MouseReleased => "mouseReleased",
                    EmulateTouchFromMouseEventType::MouseMoved => "mouseMoved",
                    EmulateTouchFromMouseEventType::MouseWheel => "mouseWheel",
                }
            }
        }
        impl ::std::str::FromStr for EmulateTouchFromMouseEventType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "mousePressed" | "MousePressed" | "mousepressed" => {
                        Ok(EmulateTouchFromMouseEventType::MousePressed)
                    }
                    "mouseReleased" | "MouseReleased" | "mousereleased" => {
                        Ok(EmulateTouchFromMouseEventType::MouseReleased)
                    }
                    "mouseMoved" | "MouseMoved" | "mousemoved" => {
                        Ok(EmulateTouchFromMouseEventType::MouseMoved)
                    }
                    "mouseWheel" | "MouseWheel" | "mousewheel" => {
                        Ok(EmulateTouchFromMouseEventType::MouseWheel)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl EmulateTouchFromMouseEventParams {
            pub fn new(
                r#type: impl Into<EmulateTouchFromMouseEventType>,
                x: impl Into<i64>,
                y: impl Into<i64>,
                button: impl Into<MouseButton>,
            ) -> Self {
                Self {
                    r#type: r#type.into(),
                    x: x.into(),
                    y: y.into(),
                    button: button.into(),
                    timestamp: None,
                    delta_x: None,
                    delta_y: None,
                    modifiers: None,
                    click_count: None,
                }
            }
        }
        impl EmulateTouchFromMouseEventParams {
            pub fn builder() -> EmulateTouchFromMouseEventParamsBuilder {
                EmulateTouchFromMouseEventParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EmulateTouchFromMouseEventParamsBuilder {
            r#type: Option<EmulateTouchFromMouseEventType>,
            x: Option<i64>,
            y: Option<i64>,
            button: Option<MouseButton>,
            timestamp: Option<TimeSinceEpoch>,
            delta_x: Option<f64>,
            delta_y: Option<f64>,
            modifiers: Option<i64>,
            click_count: Option<i64>,
        }
        impl EmulateTouchFromMouseEventParamsBuilder {
            pub fn r#type(mut self, r#type: impl Into<EmulateTouchFromMouseEventType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn x(mut self, x: impl Into<i64>) -> Self {
                self.x = Some(x.into());
                self
            }
            pub fn y(mut self, y: impl Into<i64>) -> Self {
                self.y = Some(y.into());
                self
            }
            pub fn button(mut self, button: impl Into<MouseButton>) -> Self {
                self.button = Some(button.into());
                self
            }
            pub fn timestamp(mut self, timestamp: impl Into<TimeSinceEpoch>) -> Self {
                self.timestamp = Some(timestamp.into());
                self
            }
            pub fn delta_x(mut self, delta_x: impl Into<f64>) -> Self {
                self.delta_x = Some(delta_x.into());
                self
            }
            pub fn delta_y(mut self, delta_y: impl Into<f64>) -> Self {
                self.delta_y = Some(delta_y.into());
                self
            }
            pub fn modifiers(mut self, modifiers: impl Into<i64>) -> Self {
                self.modifiers = Some(modifiers.into());
                self
            }
            pub fn click_count(mut self, click_count: impl Into<i64>) -> Self {
                self.click_count = Some(click_count.into());
                self
            }
            pub fn build(self) -> Result<EmulateTouchFromMouseEventParams, String> {
                Ok(EmulateTouchFromMouseEventParams {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    x: self
                        .x
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(x)))?,
                    y: self
                        .y
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(y)))?,
                    button: self.button.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(button))
                    })?,
                    timestamp: self.timestamp,
                    delta_x: self.delta_x,
                    delta_y: self.delta_y,
                    modifiers: self.modifiers,
                    click_count: self.click_count,
                })
            }
        }
        impl EmulateTouchFromMouseEventParams {
            pub const IDENTIFIER: &'static str = "Input.emulateTouchFromMouseEvent";
        }
        impl chromiumoxide_types::Method for EmulateTouchFromMouseEventParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EmulateTouchFromMouseEventParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Emulates touch event from the mouse event parameters.\n[emulateTouchFromMouseEvent](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-emulateTouchFromMouseEvent)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EmulateTouchFromMouseEventReturns {}
        impl chromiumoxide_types::Command for EmulateTouchFromMouseEventParams {
            type Response = EmulateTouchFromMouseEventReturns;
        }
        #[doc = "Ignores input events (useful while auditing page).\n[setIgnoreInputEvents](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-setIgnoreInputEvents)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetIgnoreInputEventsParams {
            #[doc = "Ignores input events processing when set to true."]
            #[serde(rename = "ignore")]
            pub ignore: bool,
        }
        impl SetIgnoreInputEventsParams {
            pub fn new(ignore: impl Into<bool>) -> Self {
                Self {
                    ignore: ignore.into(),
                }
            }
        }
        impl SetIgnoreInputEventsParams {
            pub fn builder() -> SetIgnoreInputEventsParamsBuilder {
                SetIgnoreInputEventsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetIgnoreInputEventsParamsBuilder {
            ignore: Option<bool>,
        }
        impl SetIgnoreInputEventsParamsBuilder {
            pub fn ignore(mut self, ignore: impl Into<bool>) -> Self {
                self.ignore = Some(ignore.into());
                self
            }
            pub fn build(self) -> Result<SetIgnoreInputEventsParams, String> {
                Ok(SetIgnoreInputEventsParams {
                    ignore: self.ignore.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(ignore))
                    })?,
                })
            }
        }
        impl SetIgnoreInputEventsParams {
            pub const IDENTIFIER: &'static str = "Input.setIgnoreInputEvents";
        }
        impl chromiumoxide_types::Method for SetIgnoreInputEventsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetIgnoreInputEventsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Ignores input events (useful while auditing page).\n[setIgnoreInputEvents](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-setIgnoreInputEvents)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetIgnoreInputEventsReturns {}
        impl chromiumoxide_types::Command for SetIgnoreInputEventsParams {
            type Response = SetIgnoreInputEventsReturns;
        }
        #[doc = "Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.\nDrag and drop behavior can be directly controlled via `Input.dispatchDragEvent`.\n[setInterceptDrags](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-setInterceptDrags)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetInterceptDragsParams {
            #[serde(rename = "enabled")]
            pub enabled: bool,
        }
        impl SetInterceptDragsParams {
            pub fn new(enabled: impl Into<bool>) -> Self {
                Self {
                    enabled: enabled.into(),
                }
            }
        }
        impl SetInterceptDragsParams {
            pub fn builder() -> SetInterceptDragsParamsBuilder {
                SetInterceptDragsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetInterceptDragsParamsBuilder {
            enabled: Option<bool>,
        }
        impl SetInterceptDragsParamsBuilder {
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn build(self) -> Result<SetInterceptDragsParams, String> {
                Ok(SetInterceptDragsParams {
                    enabled: self.enabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enabled))
                    })?,
                })
            }
        }
        impl SetInterceptDragsParams {
            pub const IDENTIFIER: &'static str = "Input.setInterceptDrags";
        }
        impl chromiumoxide_types::Method for SetInterceptDragsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetInterceptDragsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.\nDrag and drop behavior can be directly controlled via `Input.dispatchDragEvent`.\n[setInterceptDrags](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-setInterceptDrags)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetInterceptDragsReturns {}
        impl chromiumoxide_types::Command for SetInterceptDragsParams {
            type Response = SetInterceptDragsReturns;
        }
        #[doc = "Synthesizes a pinch gesture over a time period by issuing appropriate touch events.\n[synthesizePinchGesture](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-synthesizePinchGesture)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SynthesizePinchGestureParams {
            #[doc = "X coordinate of the start of the gesture in CSS pixels."]
            #[serde(rename = "x")]
            pub x: f64,
            #[doc = "Y coordinate of the start of the gesture in CSS pixels."]
            #[serde(rename = "y")]
            pub y: f64,
            #[doc = "Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out)."]
            #[serde(rename = "scaleFactor")]
            pub scale_factor: f64,
            #[doc = "Relative pointer speed in pixels per second (default: 800)."]
            #[serde(rename = "relativeSpeed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub relative_speed: Option<i64>,
            #[doc = "Which type of input events to be generated (default: 'default', which queries the platform\nfor the preferred input type)."]
            #[serde(rename = "gestureSourceType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub gesture_source_type: Option<GestureSourceType>,
        }
        impl SynthesizePinchGestureParams {
            pub fn new(x: impl Into<f64>, y: impl Into<f64>, scale_factor: impl Into<f64>) -> Self {
                Self {
                    x: x.into(),
                    y: y.into(),
                    scale_factor: scale_factor.into(),
                    relative_speed: None,
                    gesture_source_type: None,
                }
            }
        }
        impl SynthesizePinchGestureParams {
            pub fn builder() -> SynthesizePinchGestureParamsBuilder {
                SynthesizePinchGestureParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SynthesizePinchGestureParamsBuilder {
            x: Option<f64>,
            y: Option<f64>,
            scale_factor: Option<f64>,
            relative_speed: Option<i64>,
            gesture_source_type: Option<GestureSourceType>,
        }
        impl SynthesizePinchGestureParamsBuilder {
            pub fn x(mut self, x: impl Into<f64>) -> Self {
                self.x = Some(x.into());
                self
            }
            pub fn y(mut self, y: impl Into<f64>) -> Self {
                self.y = Some(y.into());
                self
            }
            pub fn scale_factor(mut self, scale_factor: impl Into<f64>) -> Self {
                self.scale_factor = Some(scale_factor.into());
                self
            }
            pub fn relative_speed(mut self, relative_speed: impl Into<i64>) -> Self {
                self.relative_speed = Some(relative_speed.into());
                self
            }
            pub fn gesture_source_type(
                mut self,
                gesture_source_type: impl Into<GestureSourceType>,
            ) -> Self {
                self.gesture_source_type = Some(gesture_source_type.into());
                self
            }
            pub fn build(self) -> Result<SynthesizePinchGestureParams, String> {
                Ok(SynthesizePinchGestureParams {
                    x: self
                        .x
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(x)))?,
                    y: self
                        .y
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(y)))?,
                    scale_factor: self.scale_factor.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scale_factor))
                    })?,
                    relative_speed: self.relative_speed,
                    gesture_source_type: self.gesture_source_type,
                })
            }
        }
        impl SynthesizePinchGestureParams {
            pub const IDENTIFIER: &'static str = "Input.synthesizePinchGesture";
        }
        impl chromiumoxide_types::Method for SynthesizePinchGestureParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SynthesizePinchGestureParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Synthesizes a pinch gesture over a time period by issuing appropriate touch events.\n[synthesizePinchGesture](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-synthesizePinchGesture)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SynthesizePinchGestureReturns {}
        impl chromiumoxide_types::Command for SynthesizePinchGestureParams {
            type Response = SynthesizePinchGestureReturns;
        }
        #[doc = "Synthesizes a scroll gesture over a time period by issuing appropriate touch events.\n[synthesizeScrollGesture](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-synthesizeScrollGesture)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SynthesizeScrollGestureParams {
            #[doc = "X coordinate of the start of the gesture in CSS pixels."]
            #[serde(rename = "x")]
            pub x: f64,
            #[doc = "Y coordinate of the start of the gesture in CSS pixels."]
            #[serde(rename = "y")]
            pub y: f64,
            #[doc = "The distance to scroll along the X axis (positive to scroll left)."]
            #[serde(rename = "xDistance")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub x_distance: Option<f64>,
            #[doc = "The distance to scroll along the Y axis (positive to scroll up)."]
            #[serde(rename = "yDistance")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub y_distance: Option<f64>,
            #[doc = "The number of additional pixels to scroll back along the X axis, in addition to the given\ndistance."]
            #[serde(rename = "xOverscroll")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub x_overscroll: Option<f64>,
            #[doc = "The number of additional pixels to scroll back along the Y axis, in addition to the given\ndistance."]
            #[serde(rename = "yOverscroll")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub y_overscroll: Option<f64>,
            #[doc = "Prevent fling (default: true)."]
            #[serde(rename = "preventFling")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub prevent_fling: Option<bool>,
            #[doc = "Swipe speed in pixels per second (default: 800)."]
            #[serde(rename = "speed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub speed: Option<i64>,
            #[doc = "Which type of input events to be generated (default: 'default', which queries the platform\nfor the preferred input type)."]
            #[serde(rename = "gestureSourceType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub gesture_source_type: Option<GestureSourceType>,
            #[doc = "The number of times to repeat the gesture (default: 0)."]
            #[serde(rename = "repeatCount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub repeat_count: Option<i64>,
            #[doc = "The number of milliseconds delay between each repeat. (default: 250)."]
            #[serde(rename = "repeatDelayMs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub repeat_delay_ms: Option<i64>,
            #[doc = "The name of the interaction markers to generate, if not empty (default: \"\")."]
            #[serde(rename = "interactionMarkerName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub interaction_marker_name: Option<String>,
        }
        impl SynthesizeScrollGestureParams {
            pub fn new(x: impl Into<f64>, y: impl Into<f64>) -> Self {
                Self {
                    x: x.into(),
                    y: y.into(),
                    x_distance: None,
                    y_distance: None,
                    x_overscroll: None,
                    y_overscroll: None,
                    prevent_fling: None,
                    speed: None,
                    gesture_source_type: None,
                    repeat_count: None,
                    repeat_delay_ms: None,
                    interaction_marker_name: None,
                }
            }
        }
        impl SynthesizeScrollGestureParams {
            pub fn builder() -> SynthesizeScrollGestureParamsBuilder {
                SynthesizeScrollGestureParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SynthesizeScrollGestureParamsBuilder {
            x: Option<f64>,
            y: Option<f64>,
            x_distance: Option<f64>,
            y_distance: Option<f64>,
            x_overscroll: Option<f64>,
            y_overscroll: Option<f64>,
            prevent_fling: Option<bool>,
            speed: Option<i64>,
            gesture_source_type: Option<GestureSourceType>,
            repeat_count: Option<i64>,
            repeat_delay_ms: Option<i64>,
            interaction_marker_name: Option<String>,
        }
        impl SynthesizeScrollGestureParamsBuilder {
            pub fn x(mut self, x: impl Into<f64>) -> Self {
                self.x = Some(x.into());
                self
            }
            pub fn y(mut self, y: impl Into<f64>) -> Self {
                self.y = Some(y.into());
                self
            }
            pub fn x_distance(mut self, x_distance: impl Into<f64>) -> Self {
                self.x_distance = Some(x_distance.into());
                self
            }
            pub fn y_distance(mut self, y_distance: impl Into<f64>) -> Self {
                self.y_distance = Some(y_distance.into());
                self
            }
            pub fn x_overscroll(mut self, x_overscroll: impl Into<f64>) -> Self {
                self.x_overscroll = Some(x_overscroll.into());
                self
            }
            pub fn y_overscroll(mut self, y_overscroll: impl Into<f64>) -> Self {
                self.y_overscroll = Some(y_overscroll.into());
                self
            }
            pub fn prevent_fling(mut self, prevent_fling: impl Into<bool>) -> Self {
                self.prevent_fling = Some(prevent_fling.into());
                self
            }
            pub fn speed(mut self, speed: impl Into<i64>) -> Self {
                self.speed = Some(speed.into());
                self
            }
            pub fn gesture_source_type(
                mut self,
                gesture_source_type: impl Into<GestureSourceType>,
            ) -> Self {
                self.gesture_source_type = Some(gesture_source_type.into());
                self
            }
            pub fn repeat_count(mut self, repeat_count: impl Into<i64>) -> Self {
                self.repeat_count = Some(repeat_count.into());
                self
            }
            pub fn repeat_delay_ms(mut self, repeat_delay_ms: impl Into<i64>) -> Self {
                self.repeat_delay_ms = Some(repeat_delay_ms.into());
                self
            }
            pub fn interaction_marker_name(
                mut self,
                interaction_marker_name: impl Into<String>,
            ) -> Self {
                self.interaction_marker_name = Some(interaction_marker_name.into());
                self
            }
            pub fn build(self) -> Result<SynthesizeScrollGestureParams, String> {
                Ok(SynthesizeScrollGestureParams {
                    x: self
                        .x
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(x)))?,
                    y: self
                        .y
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(y)))?,
                    x_distance: self.x_distance,
                    y_distance: self.y_distance,
                    x_overscroll: self.x_overscroll,
                    y_overscroll: self.y_overscroll,
                    prevent_fling: self.prevent_fling,
                    speed: self.speed,
                    gesture_source_type: self.gesture_source_type,
                    repeat_count: self.repeat_count,
                    repeat_delay_ms: self.repeat_delay_ms,
                    interaction_marker_name: self.interaction_marker_name,
                })
            }
        }
        impl SynthesizeScrollGestureParams {
            pub const IDENTIFIER: &'static str = "Input.synthesizeScrollGesture";
        }
        impl chromiumoxide_types::Method for SynthesizeScrollGestureParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SynthesizeScrollGestureParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Synthesizes a scroll gesture over a time period by issuing appropriate touch events.\n[synthesizeScrollGesture](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-synthesizeScrollGesture)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SynthesizeScrollGestureReturns {}
        impl chromiumoxide_types::Command for SynthesizeScrollGestureParams {
            type Response = SynthesizeScrollGestureReturns;
        }
        #[doc = "Synthesizes a tap gesture over a time period by issuing appropriate touch events.\n[synthesizeTapGesture](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-synthesizeTapGesture)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SynthesizeTapGestureParams {
            #[doc = "X coordinate of the start of the gesture in CSS pixels."]
            #[serde(rename = "x")]
            pub x: f64,
            #[doc = "Y coordinate of the start of the gesture in CSS pixels."]
            #[serde(rename = "y")]
            pub y: f64,
            #[doc = "Duration between touchdown and touchup events in ms (default: 50)."]
            #[serde(rename = "duration")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub duration: Option<i64>,
            #[doc = "Number of times to perform the tap (e.g. 2 for double tap, default: 1)."]
            #[serde(rename = "tapCount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub tap_count: Option<i64>,
            #[doc = "Which type of input events to be generated (default: 'default', which queries the platform\nfor the preferred input type)."]
            #[serde(rename = "gestureSourceType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub gesture_source_type: Option<GestureSourceType>,
        }
        impl SynthesizeTapGestureParams {
            pub fn new(x: impl Into<f64>, y: impl Into<f64>) -> Self {
                Self {
                    x: x.into(),
                    y: y.into(),
                    duration: None,
                    tap_count: None,
                    gesture_source_type: None,
                }
            }
        }
        impl SynthesizeTapGestureParams {
            pub fn builder() -> SynthesizeTapGestureParamsBuilder {
                SynthesizeTapGestureParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SynthesizeTapGestureParamsBuilder {
            x: Option<f64>,
            y: Option<f64>,
            duration: Option<i64>,
            tap_count: Option<i64>,
            gesture_source_type: Option<GestureSourceType>,
        }
        impl SynthesizeTapGestureParamsBuilder {
            pub fn x(mut self, x: impl Into<f64>) -> Self {
                self.x = Some(x.into());
                self
            }
            pub fn y(mut self, y: impl Into<f64>) -> Self {
                self.y = Some(y.into());
                self
            }
            pub fn duration(mut self, duration: impl Into<i64>) -> Self {
                self.duration = Some(duration.into());
                self
            }
            pub fn tap_count(mut self, tap_count: impl Into<i64>) -> Self {
                self.tap_count = Some(tap_count.into());
                self
            }
            pub fn gesture_source_type(
                mut self,
                gesture_source_type: impl Into<GestureSourceType>,
            ) -> Self {
                self.gesture_source_type = Some(gesture_source_type.into());
                self
            }
            pub fn build(self) -> Result<SynthesizeTapGestureParams, String> {
                Ok(SynthesizeTapGestureParams {
                    x: self
                        .x
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(x)))?,
                    y: self
                        .y
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(y)))?,
                    duration: self.duration,
                    tap_count: self.tap_count,
                    gesture_source_type: self.gesture_source_type,
                })
            }
        }
        impl SynthesizeTapGestureParams {
            pub const IDENTIFIER: &'static str = "Input.synthesizeTapGesture";
        }
        impl chromiumoxide_types::Method for SynthesizeTapGestureParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SynthesizeTapGestureParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Synthesizes a tap gesture over a time period by issuing appropriate touch events.\n[synthesizeTapGesture](https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-synthesizeTapGesture)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SynthesizeTapGestureReturns {}
        impl chromiumoxide_types::Command for SynthesizeTapGestureParams {
            type Response = SynthesizeTapGestureReturns;
        }
        #[doc = "Emitted only when `Input.setInterceptDrags` is enabled. Use this data with `Input.dispatchDragEvent` to\nrestore normal drag and drop behavior.\n[dragIntercepted](https://chromedevtools.github.io/devtools-protocol/tot/Input/#event-dragIntercepted)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDragIntercepted {
            #[serde(rename = "data")]
            pub data: DragData,
        }
        impl EventDragIntercepted {
            pub const IDENTIFIER: &'static str = "Input.dragIntercepted";
        }
        impl chromiumoxide_types::Method for EventDragIntercepted {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDragIntercepted {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    pub mod inspector {
        use serde::{Deserialize, Serialize};
        #[doc = "Disables inspector domain notifications.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Inspector/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Inspector.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables inspector domain notifications.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Inspector/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables inspector domain notifications.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Inspector/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Inspector.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables inspector domain notifications.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Inspector/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Fired when remote debugging connection is about to be terminated. Contains detach reason.\n[detached](https://chromedevtools.github.io/devtools-protocol/tot/Inspector/#event-detached)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDetached {
            #[doc = "The reason why connection has been terminated."]
            #[serde(rename = "reason")]
            pub reason: String,
        }
        impl EventDetached {
            pub const IDENTIFIER: &'static str = "Inspector.detached";
        }
        impl chromiumoxide_types::Method for EventDetached {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDetached {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when debugging target has crashed\n[targetCrashed](https://chromedevtools.github.io/devtools-protocol/tot/Inspector/#event-targetCrashed)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventTargetCrashed {}
        impl EventTargetCrashed {
            pub const IDENTIFIER: &'static str = "Inspector.targetCrashed";
        }
        impl chromiumoxide_types::Method for EventTargetCrashed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventTargetCrashed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when debugging target has reloaded after crash\n[targetReloadedAfterCrash](https://chromedevtools.github.io/devtools-protocol/tot/Inspector/#event-targetReloadedAfterCrash)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventTargetReloadedAfterCrash {}
        impl EventTargetReloadedAfterCrash {
            pub const IDENTIFIER: &'static str = "Inspector.targetReloadedAfterCrash";
        }
        impl chromiumoxide_types::Method for EventTargetReloadedAfterCrash {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventTargetReloadedAfterCrash {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    pub mod layer_tree {
        use serde::{Deserialize, Serialize};
        #[doc = "Unique Layer identifier.\n[LayerId](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#type-LayerId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct LayerId(String);
        impl LayerId {
            pub fn new(val: impl Into<String>) -> Self {
                LayerId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for LayerId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<LayerId> for String {
            fn from(el: LayerId) -> String {
                el.0
            }
        }
        impl From<String> for LayerId {
            fn from(expr: String) -> Self {
                LayerId(expr)
            }
        }
        impl std::borrow::Borrow<str> for LayerId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl LayerId {
            pub const IDENTIFIER: &'static str = "LayerTree.LayerId";
        }
        #[doc = "Unique snapshot identifier.\n[SnapshotId](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#type-SnapshotId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct SnapshotId(String);
        impl SnapshotId {
            pub fn new(val: impl Into<String>) -> Self {
                SnapshotId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for SnapshotId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<SnapshotId> for String {
            fn from(el: SnapshotId) -> String {
                el.0
            }
        }
        impl From<String> for SnapshotId {
            fn from(expr: String) -> Self {
                SnapshotId(expr)
            }
        }
        impl std::borrow::Borrow<str> for SnapshotId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl SnapshotId {
            pub const IDENTIFIER: &'static str = "LayerTree.SnapshotId";
        }
        #[doc = "Rectangle where scrolling happens on the main thread.\n[ScrollRect](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#type-ScrollRect)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ScrollRect {
            #[doc = "Rectangle itself."]
            #[serde(rename = "rect")]
            pub rect: super::dom::Rect,
            #[doc = "Reason for rectangle to force scrolling on the main thread"]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: ScrollRectType,
        }
        #[doc = "Reason for rectangle to force scrolling on the main thread"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ScrollRectType {
            #[serde(rename = "RepaintsOnScroll")]
            RepaintsOnScroll,
            #[serde(rename = "TouchEventHandler")]
            TouchEventHandler,
            #[serde(rename = "WheelEventHandler")]
            WheelEventHandler,
        }
        impl AsRef<str> for ScrollRectType {
            fn as_ref(&self) -> &str {
                match self {
                    ScrollRectType::RepaintsOnScroll => "RepaintsOnScroll",
                    ScrollRectType::TouchEventHandler => "TouchEventHandler",
                    ScrollRectType::WheelEventHandler => "WheelEventHandler",
                }
            }
        }
        impl ::std::str::FromStr for ScrollRectType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "RepaintsOnScroll" | "repaintsonscroll" => Ok(ScrollRectType::RepaintsOnScroll),
                    "TouchEventHandler" | "toucheventhandler" => {
                        Ok(ScrollRectType::TouchEventHandler)
                    }
                    "WheelEventHandler" | "wheeleventhandler" => {
                        Ok(ScrollRectType::WheelEventHandler)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl ScrollRect {
            pub fn new(
                rect: impl Into<super::dom::Rect>,
                r#type: impl Into<ScrollRectType>,
            ) -> Self {
                Self {
                    rect: rect.into(),
                    r#type: r#type.into(),
                }
            }
        }
        impl ScrollRect {
            pub fn builder() -> ScrollRectBuilder {
                ScrollRectBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ScrollRectBuilder {
            rect: Option<super::dom::Rect>,
            r#type: Option<ScrollRectType>,
        }
        impl ScrollRectBuilder {
            pub fn rect(mut self, rect: impl Into<super::dom::Rect>) -> Self {
                self.rect = Some(rect.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<ScrollRectType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn build(self) -> Result<ScrollRect, String> {
                Ok(ScrollRect {
                    rect: self.rect.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(rect))
                    })?,
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                })
            }
        }
        impl ScrollRect {
            pub const IDENTIFIER: &'static str = "LayerTree.ScrollRect";
        }
        #[doc = "Sticky position constraints.\n[StickyPositionConstraint](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#type-StickyPositionConstraint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StickyPositionConstraint {
            #[doc = "Layout rectangle of the sticky element before being shifted"]
            #[serde(rename = "stickyBoxRect")]
            pub sticky_box_rect: super::dom::Rect,
            #[doc = "Layout rectangle of the containing block of the sticky element"]
            #[serde(rename = "containingBlockRect")]
            pub containing_block_rect: super::dom::Rect,
            #[doc = "The nearest sticky layer that shifts the sticky box"]
            #[serde(rename = "nearestLayerShiftingStickyBox")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub nearest_layer_shifting_sticky_box: Option<LayerId>,
            #[doc = "The nearest sticky layer that shifts the containing block"]
            #[serde(rename = "nearestLayerShiftingContainingBlock")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub nearest_layer_shifting_containing_block: Option<LayerId>,
        }
        impl StickyPositionConstraint {
            pub fn new(
                sticky_box_rect: impl Into<super::dom::Rect>,
                containing_block_rect: impl Into<super::dom::Rect>,
            ) -> Self {
                Self {
                    sticky_box_rect: sticky_box_rect.into(),
                    containing_block_rect: containing_block_rect.into(),
                    nearest_layer_shifting_sticky_box: None,
                    nearest_layer_shifting_containing_block: None,
                }
            }
        }
        impl StickyPositionConstraint {
            pub fn builder() -> StickyPositionConstraintBuilder {
                StickyPositionConstraintBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StickyPositionConstraintBuilder {
            sticky_box_rect: Option<super::dom::Rect>,
            containing_block_rect: Option<super::dom::Rect>,
            nearest_layer_shifting_sticky_box: Option<LayerId>,
            nearest_layer_shifting_containing_block: Option<LayerId>,
        }
        impl StickyPositionConstraintBuilder {
            pub fn sticky_box_rect(mut self, sticky_box_rect: impl Into<super::dom::Rect>) -> Self {
                self.sticky_box_rect = Some(sticky_box_rect.into());
                self
            }
            pub fn containing_block_rect(
                mut self,
                containing_block_rect: impl Into<super::dom::Rect>,
            ) -> Self {
                self.containing_block_rect = Some(containing_block_rect.into());
                self
            }
            pub fn nearest_layer_shifting_sticky_box(
                mut self,
                nearest_layer_shifting_sticky_box: impl Into<LayerId>,
            ) -> Self {
                self.nearest_layer_shifting_sticky_box =
                    Some(nearest_layer_shifting_sticky_box.into());
                self
            }
            pub fn nearest_layer_shifting_containing_block(
                mut self,
                nearest_layer_shifting_containing_block: impl Into<LayerId>,
            ) -> Self {
                self.nearest_layer_shifting_containing_block =
                    Some(nearest_layer_shifting_containing_block.into());
                self
            }
            pub fn build(self) -> Result<StickyPositionConstraint, String> {
                Ok(StickyPositionConstraint {
                    sticky_box_rect: self.sticky_box_rect.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(sticky_box_rect))
                    })?,
                    containing_block_rect: self.containing_block_rect.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(containing_block_rect)
                        )
                    })?,
                    nearest_layer_shifting_sticky_box: self.nearest_layer_shifting_sticky_box,
                    nearest_layer_shifting_containing_block: self
                        .nearest_layer_shifting_containing_block,
                })
            }
        }
        impl StickyPositionConstraint {
            pub const IDENTIFIER: &'static str = "LayerTree.StickyPositionConstraint";
        }
        #[doc = "Serialized fragment of layer picture along with its offset within the layer.\n[PictureTile](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#type-PictureTile)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PictureTile {
            #[doc = "Offset from owning layer left boundary"]
            #[serde(rename = "x")]
            pub x: f64,
            #[doc = "Offset from owning layer top boundary"]
            #[serde(rename = "y")]
            pub y: f64,
            #[doc = "Base64-encoded snapshot data."]
            #[serde(rename = "picture")]
            pub picture: chromiumoxide_types::Binary,
        }
        impl PictureTile {
            pub fn new(
                x: impl Into<f64>,
                y: impl Into<f64>,
                picture: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                Self {
                    x: x.into(),
                    y: y.into(),
                    picture: picture.into(),
                }
            }
        }
        impl PictureTile {
            pub fn builder() -> PictureTileBuilder {
                PictureTileBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PictureTileBuilder {
            x: Option<f64>,
            y: Option<f64>,
            picture: Option<chromiumoxide_types::Binary>,
        }
        impl PictureTileBuilder {
            pub fn x(mut self, x: impl Into<f64>) -> Self {
                self.x = Some(x.into());
                self
            }
            pub fn y(mut self, y: impl Into<f64>) -> Self {
                self.y = Some(y.into());
                self
            }
            pub fn picture(mut self, picture: impl Into<chromiumoxide_types::Binary>) -> Self {
                self.picture = Some(picture.into());
                self
            }
            pub fn build(self) -> Result<PictureTile, String> {
                Ok(PictureTile {
                    x: self
                        .x
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(x)))?,
                    y: self
                        .y
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(y)))?,
                    picture: self.picture.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(picture))
                    })?,
                })
            }
        }
        impl PictureTile {
            pub const IDENTIFIER: &'static str = "LayerTree.PictureTile";
        }
        #[doc = "Information about a compositing layer.\n[Layer](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#type-Layer)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Layer {
            #[doc = "The unique id for this layer."]
            #[serde(rename = "layerId")]
            pub layer_id: LayerId,
            #[doc = "The id of parent (not present for root)."]
            #[serde(rename = "parentLayerId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub parent_layer_id: Option<LayerId>,
            #[doc = "The backend id for the node associated with this layer."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<super::dom::BackendNodeId>,
            #[doc = "Offset from parent layer, X coordinate."]
            #[serde(rename = "offsetX")]
            pub offset_x: f64,
            #[doc = "Offset from parent layer, Y coordinate."]
            #[serde(rename = "offsetY")]
            pub offset_y: f64,
            #[doc = "Layer width."]
            #[serde(rename = "width")]
            pub width: f64,
            #[doc = "Layer height."]
            #[serde(rename = "height")]
            pub height: f64,
            #[doc = "Transformation matrix for layer, default is identity matrix"]
            #[serde(rename = "transform")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub transform: Option<Vec<f64>>,
            #[doc = "Transform anchor point X, absent if no transform specified"]
            #[serde(rename = "anchorX")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub anchor_x: Option<f64>,
            #[doc = "Transform anchor point Y, absent if no transform specified"]
            #[serde(rename = "anchorY")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub anchor_y: Option<f64>,
            #[doc = "Transform anchor point Z, absent if no transform specified"]
            #[serde(rename = "anchorZ")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub anchor_z: Option<f64>,
            #[doc = "Indicates how many time this layer has painted."]
            #[serde(rename = "paintCount")]
            pub paint_count: i64,
            #[doc = "Indicates whether this layer hosts any content, rather than being used for\ntransform/scrolling purposes only."]
            #[serde(rename = "drawsContent")]
            pub draws_content: bool,
            #[doc = "Set if layer is not visible."]
            #[serde(rename = "invisible")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub invisible: Option<bool>,
            #[doc = "Rectangles scrolling on main thread only."]
            #[serde(rename = "scrollRects")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub scroll_rects: Option<Vec<ScrollRect>>,
            #[doc = "Sticky position constraint information"]
            #[serde(rename = "stickyPositionConstraint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub sticky_position_constraint: Option<StickyPositionConstraint>,
        }
        impl Layer {
            pub fn builder() -> LayerBuilder {
                LayerBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LayerBuilder {
            layer_id: Option<LayerId>,
            parent_layer_id: Option<LayerId>,
            backend_node_id: Option<super::dom::BackendNodeId>,
            offset_x: Option<f64>,
            offset_y: Option<f64>,
            width: Option<f64>,
            height: Option<f64>,
            transform: Option<Vec<f64>>,
            anchor_x: Option<f64>,
            anchor_y: Option<f64>,
            anchor_z: Option<f64>,
            paint_count: Option<i64>,
            draws_content: Option<bool>,
            invisible: Option<bool>,
            scroll_rects: Option<Vec<ScrollRect>>,
            sticky_position_constraint: Option<StickyPositionConstraint>,
        }
        impl LayerBuilder {
            pub fn layer_id(mut self, layer_id: impl Into<LayerId>) -> Self {
                self.layer_id = Some(layer_id.into());
                self
            }
            pub fn parent_layer_id(mut self, parent_layer_id: impl Into<LayerId>) -> Self {
                self.parent_layer_id = Some(parent_layer_id.into());
                self
            }
            pub fn backend_node_id(
                mut self,
                backend_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn offset_x(mut self, offset_x: impl Into<f64>) -> Self {
                self.offset_x = Some(offset_x.into());
                self
            }
            pub fn offset_y(mut self, offset_y: impl Into<f64>) -> Self {
                self.offset_y = Some(offset_y.into());
                self
            }
            pub fn width(mut self, width: impl Into<f64>) -> Self {
                self.width = Some(width.into());
                self
            }
            pub fn height(mut self, height: impl Into<f64>) -> Self {
                self.height = Some(height.into());
                self
            }
            pub fn transform(mut self, transform: impl Into<f64>) -> Self {
                let v = self.transform.get_or_insert(Vec::new());
                v.push(transform.into());
                self
            }
            pub fn transforms<I, S>(mut self, transforms: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<f64>,
            {
                let v = self.transform.get_or_insert(Vec::new());
                for val in transforms {
                    v.push(val.into());
                }
                self
            }
            pub fn anchor_x(mut self, anchor_x: impl Into<f64>) -> Self {
                self.anchor_x = Some(anchor_x.into());
                self
            }
            pub fn anchor_y(mut self, anchor_y: impl Into<f64>) -> Self {
                self.anchor_y = Some(anchor_y.into());
                self
            }
            pub fn anchor_z(mut self, anchor_z: impl Into<f64>) -> Self {
                self.anchor_z = Some(anchor_z.into());
                self
            }
            pub fn paint_count(mut self, paint_count: impl Into<i64>) -> Self {
                self.paint_count = Some(paint_count.into());
                self
            }
            pub fn draws_content(mut self, draws_content: impl Into<bool>) -> Self {
                self.draws_content = Some(draws_content.into());
                self
            }
            pub fn invisible(mut self, invisible: impl Into<bool>) -> Self {
                self.invisible = Some(invisible.into());
                self
            }
            pub fn scroll_rect(mut self, scroll_rect: impl Into<ScrollRect>) -> Self {
                let v = self.scroll_rects.get_or_insert(Vec::new());
                v.push(scroll_rect.into());
                self
            }
            pub fn scroll_rects<I, S>(mut self, scroll_rects: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ScrollRect>,
            {
                let v = self.scroll_rects.get_or_insert(Vec::new());
                for val in scroll_rects {
                    v.push(val.into());
                }
                self
            }
            pub fn sticky_position_constraint(
                mut self,
                sticky_position_constraint: impl Into<StickyPositionConstraint>,
            ) -> Self {
                self.sticky_position_constraint = Some(sticky_position_constraint.into());
                self
            }
            pub fn build(self) -> Result<Layer, String> {
                Ok(Layer {
                    layer_id: self.layer_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(layer_id))
                    })?,
                    parent_layer_id: self.parent_layer_id,
                    backend_node_id: self.backend_node_id,
                    offset_x: self.offset_x.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(offset_x))
                    })?,
                    offset_y: self.offset_y.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(offset_y))
                    })?,
                    width: self.width.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(width))
                    })?,
                    height: self.height.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(height))
                    })?,
                    transform: self.transform,
                    anchor_x: self.anchor_x,
                    anchor_y: self.anchor_y,
                    anchor_z: self.anchor_z,
                    paint_count: self.paint_count.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(paint_count))
                    })?,
                    draws_content: self.draws_content.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(draws_content))
                    })?,
                    invisible: self.invisible,
                    scroll_rects: self.scroll_rects,
                    sticky_position_constraint: self.sticky_position_constraint,
                })
            }
        }
        impl Layer {
            pub const IDENTIFIER: &'static str = "LayerTree.Layer";
        }
        #[doc = "Array of timings, one per paint step.\n[PaintProfile](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#type-PaintProfile)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct PaintProfile(Vec<f64>);
        impl PaintProfile {
            pub fn new(val: impl Into<Vec<f64>>) -> Self {
                PaintProfile(val.into())
            }
            pub fn inner(&self) -> &Vec<f64> {
                &self.0
            }
        }
        impl PaintProfile {
            pub const IDENTIFIER: &'static str = "LayerTree.PaintProfile";
        }
        #[doc = "Provides the reasons why the given layer was composited.\n[compositingReasons](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-compositingReasons)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CompositingReasonsParams {
            #[doc = "The id of the layer for which we want to get the reasons it was composited."]
            #[serde(rename = "layerId")]
            pub layer_id: LayerId,
        }
        impl CompositingReasonsParams {
            pub fn new(layer_id: impl Into<LayerId>) -> Self {
                Self {
                    layer_id: layer_id.into(),
                }
            }
        }
        impl CompositingReasonsParams {
            pub fn builder() -> CompositingReasonsParamsBuilder {
                CompositingReasonsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CompositingReasonsParamsBuilder {
            layer_id: Option<LayerId>,
        }
        impl CompositingReasonsParamsBuilder {
            pub fn layer_id(mut self, layer_id: impl Into<LayerId>) -> Self {
                self.layer_id = Some(layer_id.into());
                self
            }
            pub fn build(self) -> Result<CompositingReasonsParams, String> {
                Ok(CompositingReasonsParams {
                    layer_id: self.layer_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(layer_id))
                    })?,
                })
            }
        }
        impl CompositingReasonsParams {
            pub const IDENTIFIER: &'static str = "LayerTree.compositingReasons";
        }
        impl chromiumoxide_types::Method for CompositingReasonsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CompositingReasonsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Provides the reasons why the given layer was composited.\n[compositingReasons](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-compositingReasons)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CompositingReasonsReturns {
            #[doc = "A list of strings specifying reason IDs for the given layer to become composited."]
            #[serde(rename = "compositingReasonIds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub compositing_reason_ids: Vec<String>,
        }
        impl CompositingReasonsReturns {
            pub fn new(compositing_reason_ids: Vec<String>) -> Self {
                Self {
                    compositing_reason_ids,
                }
            }
        }
        impl CompositingReasonsReturns {
            pub fn builder() -> CompositingReasonsReturnsBuilder {
                CompositingReasonsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CompositingReasonsReturnsBuilder {
            compositing_reason_ids: Option<Vec<String>>,
        }
        impl CompositingReasonsReturnsBuilder {
            pub fn compositing_reason_id(
                mut self,
                compositing_reason_id: impl Into<String>,
            ) -> Self {
                let v = self.compositing_reason_ids.get_or_insert(Vec::new());
                v.push(compositing_reason_id.into());
                self
            }
            pub fn compositing_reason_ids<I, S>(mut self, compositing_reason_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.compositing_reason_ids.get_or_insert(Vec::new());
                for val in compositing_reason_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<CompositingReasonsReturns, String> {
                Ok(CompositingReasonsReturns {
                    compositing_reason_ids: self.compositing_reason_ids.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(compositing_reason_ids)
                        )
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for CompositingReasonsParams {
            type Response = CompositingReasonsReturns;
        }
        #[doc = "Disables compositing tree inspection.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "LayerTree.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables compositing tree inspection.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables compositing tree inspection.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "LayerTree.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables compositing tree inspection.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Returns the snapshot identifier.\n[loadSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-loadSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LoadSnapshotParams {
            #[doc = "An array of tiles composing the snapshot."]
            #[serde(rename = "tiles")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub tiles: Vec<PictureTile>,
        }
        impl LoadSnapshotParams {
            pub fn new(tiles: Vec<PictureTile>) -> Self {
                Self { tiles }
            }
        }
        impl LoadSnapshotParams {
            pub fn builder() -> LoadSnapshotParamsBuilder {
                LoadSnapshotParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LoadSnapshotParamsBuilder {
            tiles: Option<Vec<PictureTile>>,
        }
        impl LoadSnapshotParamsBuilder {
            pub fn tile(mut self, tile: impl Into<PictureTile>) -> Self {
                let v = self.tiles.get_or_insert(Vec::new());
                v.push(tile.into());
                self
            }
            pub fn tiles<I, S>(mut self, tiles: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PictureTile>,
            {
                let v = self.tiles.get_or_insert(Vec::new());
                for val in tiles {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<LoadSnapshotParams, String> {
                Ok(LoadSnapshotParams {
                    tiles: self.tiles.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(tiles))
                    })?,
                })
            }
        }
        impl LoadSnapshotParams {
            pub const IDENTIFIER: &'static str = "LayerTree.loadSnapshot";
        }
        impl chromiumoxide_types::Method for LoadSnapshotParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for LoadSnapshotParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the snapshot identifier.\n[loadSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-loadSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LoadSnapshotReturns {
            #[doc = "The id of the snapshot."]
            #[serde(rename = "snapshotId")]
            pub snapshot_id: SnapshotId,
        }
        impl LoadSnapshotReturns {
            pub fn new(snapshot_id: impl Into<SnapshotId>) -> Self {
                Self {
                    snapshot_id: snapshot_id.into(),
                }
            }
        }
        impl LoadSnapshotReturns {
            pub fn builder() -> LoadSnapshotReturnsBuilder {
                LoadSnapshotReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LoadSnapshotReturnsBuilder {
            snapshot_id: Option<SnapshotId>,
        }
        impl LoadSnapshotReturnsBuilder {
            pub fn snapshot_id(mut self, snapshot_id: impl Into<SnapshotId>) -> Self {
                self.snapshot_id = Some(snapshot_id.into());
                self
            }
            pub fn build(self) -> Result<LoadSnapshotReturns, String> {
                Ok(LoadSnapshotReturns {
                    snapshot_id: self.snapshot_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(snapshot_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for LoadSnapshotParams {
            type Response = LoadSnapshotReturns;
        }
        #[doc = "Returns the layer snapshot identifier.\n[makeSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-makeSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct MakeSnapshotParams {
            #[doc = "The id of the layer."]
            #[serde(rename = "layerId")]
            pub layer_id: LayerId,
        }
        impl MakeSnapshotParams {
            pub fn new(layer_id: impl Into<LayerId>) -> Self {
                Self {
                    layer_id: layer_id.into(),
                }
            }
        }
        impl MakeSnapshotParams {
            pub fn builder() -> MakeSnapshotParamsBuilder {
                MakeSnapshotParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct MakeSnapshotParamsBuilder {
            layer_id: Option<LayerId>,
        }
        impl MakeSnapshotParamsBuilder {
            pub fn layer_id(mut self, layer_id: impl Into<LayerId>) -> Self {
                self.layer_id = Some(layer_id.into());
                self
            }
            pub fn build(self) -> Result<MakeSnapshotParams, String> {
                Ok(MakeSnapshotParams {
                    layer_id: self.layer_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(layer_id))
                    })?,
                })
            }
        }
        impl MakeSnapshotParams {
            pub const IDENTIFIER: &'static str = "LayerTree.makeSnapshot";
        }
        impl chromiumoxide_types::Method for MakeSnapshotParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for MakeSnapshotParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the layer snapshot identifier.\n[makeSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-makeSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct MakeSnapshotReturns {
            #[doc = "The id of the layer snapshot."]
            #[serde(rename = "snapshotId")]
            pub snapshot_id: SnapshotId,
        }
        impl MakeSnapshotReturns {
            pub fn new(snapshot_id: impl Into<SnapshotId>) -> Self {
                Self {
                    snapshot_id: snapshot_id.into(),
                }
            }
        }
        impl MakeSnapshotReturns {
            pub fn builder() -> MakeSnapshotReturnsBuilder {
                MakeSnapshotReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct MakeSnapshotReturnsBuilder {
            snapshot_id: Option<SnapshotId>,
        }
        impl MakeSnapshotReturnsBuilder {
            pub fn snapshot_id(mut self, snapshot_id: impl Into<SnapshotId>) -> Self {
                self.snapshot_id = Some(snapshot_id.into());
                self
            }
            pub fn build(self) -> Result<MakeSnapshotReturns, String> {
                Ok(MakeSnapshotReturns {
                    snapshot_id: self.snapshot_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(snapshot_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for MakeSnapshotParams {
            type Response = MakeSnapshotReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ProfileSnapshotParams {
            #[doc = "The id of the layer snapshot."]
            #[serde(rename = "snapshotId")]
            pub snapshot_id: SnapshotId,
            #[doc = "The maximum number of times to replay the snapshot (1, if not specified)."]
            #[serde(rename = "minRepeatCount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub min_repeat_count: Option<i64>,
            #[doc = "The minimum duration (in seconds) to replay the snapshot."]
            #[serde(rename = "minDuration")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub min_duration: Option<f64>,
            #[doc = "The clip rectangle to apply when replaying the snapshot."]
            #[serde(rename = "clipRect")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub clip_rect: Option<super::dom::Rect>,
        }
        impl ProfileSnapshotParams {
            pub fn new(snapshot_id: impl Into<SnapshotId>) -> Self {
                Self {
                    snapshot_id: snapshot_id.into(),
                    min_repeat_count: None,
                    min_duration: None,
                    clip_rect: None,
                }
            }
        }
        impl ProfileSnapshotParams {
            pub fn builder() -> ProfileSnapshotParamsBuilder {
                ProfileSnapshotParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ProfileSnapshotParamsBuilder {
            snapshot_id: Option<SnapshotId>,
            min_repeat_count: Option<i64>,
            min_duration: Option<f64>,
            clip_rect: Option<super::dom::Rect>,
        }
        impl ProfileSnapshotParamsBuilder {
            pub fn snapshot_id(mut self, snapshot_id: impl Into<SnapshotId>) -> Self {
                self.snapshot_id = Some(snapshot_id.into());
                self
            }
            pub fn min_repeat_count(mut self, min_repeat_count: impl Into<i64>) -> Self {
                self.min_repeat_count = Some(min_repeat_count.into());
                self
            }
            pub fn min_duration(mut self, min_duration: impl Into<f64>) -> Self {
                self.min_duration = Some(min_duration.into());
                self
            }
            pub fn clip_rect(mut self, clip_rect: impl Into<super::dom::Rect>) -> Self {
                self.clip_rect = Some(clip_rect.into());
                self
            }
            pub fn build(self) -> Result<ProfileSnapshotParams, String> {
                Ok(ProfileSnapshotParams {
                    snapshot_id: self.snapshot_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(snapshot_id))
                    })?,
                    min_repeat_count: self.min_repeat_count,
                    min_duration: self.min_duration,
                    clip_rect: self.clip_rect,
                })
            }
        }
        impl ProfileSnapshotParams {
            pub const IDENTIFIER: &'static str = "LayerTree.profileSnapshot";
        }
        impl chromiumoxide_types::Method for ProfileSnapshotParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ProfileSnapshotParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ProfileSnapshotReturns {
            #[doc = "The array of paint profiles, one per run."]
            #[serde(rename = "timings")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub timings: Vec<PaintProfile>,
        }
        impl ProfileSnapshotReturns {
            pub fn new(timings: Vec<PaintProfile>) -> Self {
                Self { timings }
            }
        }
        impl ProfileSnapshotReturns {
            pub fn builder() -> ProfileSnapshotReturnsBuilder {
                ProfileSnapshotReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ProfileSnapshotReturnsBuilder {
            timings: Option<Vec<PaintProfile>>,
        }
        impl ProfileSnapshotReturnsBuilder {
            pub fn timing(mut self, timing: impl Into<PaintProfile>) -> Self {
                let v = self.timings.get_or_insert(Vec::new());
                v.push(timing.into());
                self
            }
            pub fn timings<I, S>(mut self, timings: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PaintProfile>,
            {
                let v = self.timings.get_or_insert(Vec::new());
                for val in timings {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<ProfileSnapshotReturns, String> {
                Ok(ProfileSnapshotReturns {
                    timings: self.timings.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(timings))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for ProfileSnapshotParams {
            type Response = ProfileSnapshotReturns;
        }
        #[doc = "Releases layer snapshot captured by the back-end.\n[releaseSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-releaseSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ReleaseSnapshotParams {
            #[doc = "The id of the layer snapshot."]
            #[serde(rename = "snapshotId")]
            pub snapshot_id: SnapshotId,
        }
        impl ReleaseSnapshotParams {
            pub fn new(snapshot_id: impl Into<SnapshotId>) -> Self {
                Self {
                    snapshot_id: snapshot_id.into(),
                }
            }
        }
        impl ReleaseSnapshotParams {
            pub fn builder() -> ReleaseSnapshotParamsBuilder {
                ReleaseSnapshotParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ReleaseSnapshotParamsBuilder {
            snapshot_id: Option<SnapshotId>,
        }
        impl ReleaseSnapshotParamsBuilder {
            pub fn snapshot_id(mut self, snapshot_id: impl Into<SnapshotId>) -> Self {
                self.snapshot_id = Some(snapshot_id.into());
                self
            }
            pub fn build(self) -> Result<ReleaseSnapshotParams, String> {
                Ok(ReleaseSnapshotParams {
                    snapshot_id: self.snapshot_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(snapshot_id))
                    })?,
                })
            }
        }
        impl ReleaseSnapshotParams {
            pub const IDENTIFIER: &'static str = "LayerTree.releaseSnapshot";
        }
        impl chromiumoxide_types::Method for ReleaseSnapshotParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ReleaseSnapshotParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Releases layer snapshot captured by the back-end.\n[releaseSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-releaseSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ReleaseSnapshotReturns {}
        impl chromiumoxide_types::Command for ReleaseSnapshotParams {
            type Response = ReleaseSnapshotReturns;
        }
        #[doc = "Replays the layer snapshot and returns the resulting bitmap.\n[replaySnapshot](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-replaySnapshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ReplaySnapshotParams {
            #[doc = "The id of the layer snapshot."]
            #[serde(rename = "snapshotId")]
            pub snapshot_id: SnapshotId,
            #[doc = "The first step to replay from (replay from the very start if not specified)."]
            #[serde(rename = "fromStep")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub from_step: Option<i64>,
            #[doc = "The last step to replay to (replay till the end if not specified)."]
            #[serde(rename = "toStep")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub to_step: Option<i64>,
            #[doc = "The scale to apply while replaying (defaults to 1)."]
            #[serde(rename = "scale")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub scale: Option<f64>,
        }
        impl ReplaySnapshotParams {
            pub fn new(snapshot_id: impl Into<SnapshotId>) -> Self {
                Self {
                    snapshot_id: snapshot_id.into(),
                    from_step: None,
                    to_step: None,
                    scale: None,
                }
            }
        }
        impl ReplaySnapshotParams {
            pub fn builder() -> ReplaySnapshotParamsBuilder {
                ReplaySnapshotParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ReplaySnapshotParamsBuilder {
            snapshot_id: Option<SnapshotId>,
            from_step: Option<i64>,
            to_step: Option<i64>,
            scale: Option<f64>,
        }
        impl ReplaySnapshotParamsBuilder {
            pub fn snapshot_id(mut self, snapshot_id: impl Into<SnapshotId>) -> Self {
                self.snapshot_id = Some(snapshot_id.into());
                self
            }
            pub fn from_step(mut self, from_step: impl Into<i64>) -> Self {
                self.from_step = Some(from_step.into());
                self
            }
            pub fn to_step(mut self, to_step: impl Into<i64>) -> Self {
                self.to_step = Some(to_step.into());
                self
            }
            pub fn scale(mut self, scale: impl Into<f64>) -> Self {
                self.scale = Some(scale.into());
                self
            }
            pub fn build(self) -> Result<ReplaySnapshotParams, String> {
                Ok(ReplaySnapshotParams {
                    snapshot_id: self.snapshot_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(snapshot_id))
                    })?,
                    from_step: self.from_step,
                    to_step: self.to_step,
                    scale: self.scale,
                })
            }
        }
        impl ReplaySnapshotParams {
            pub const IDENTIFIER: &'static str = "LayerTree.replaySnapshot";
        }
        impl chromiumoxide_types::Method for ReplaySnapshotParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ReplaySnapshotParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Replays the layer snapshot and returns the resulting bitmap.\n[replaySnapshot](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-replaySnapshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ReplaySnapshotReturns {
            #[doc = "A data: URL for resulting image."]
            #[serde(rename = "dataURL")]
            pub data_url: String,
        }
        impl ReplaySnapshotReturns {
            pub fn new(data_url: impl Into<String>) -> Self {
                Self {
                    data_url: data_url.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for ReplaySnapshotReturns {
            fn from(url: T) -> Self {
                ReplaySnapshotReturns::new(url)
            }
        }
        impl ReplaySnapshotReturns {
            pub fn builder() -> ReplaySnapshotReturnsBuilder {
                ReplaySnapshotReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ReplaySnapshotReturnsBuilder {
            data_url: Option<String>,
        }
        impl ReplaySnapshotReturnsBuilder {
            pub fn data_url(mut self, data_url: impl Into<String>) -> Self {
                self.data_url = Some(data_url.into());
                self
            }
            pub fn build(self) -> Result<ReplaySnapshotReturns, String> {
                Ok(ReplaySnapshotReturns {
                    data_url: self.data_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(data_url))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for ReplaySnapshotParams {
            type Response = ReplaySnapshotReturns;
        }
        #[doc = "Replays the layer snapshot and returns canvas log.\n[snapshotCommandLog](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-snapshotCommandLog)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SnapshotCommandLogParams {
            #[doc = "The id of the layer snapshot."]
            #[serde(rename = "snapshotId")]
            pub snapshot_id: SnapshotId,
        }
        impl SnapshotCommandLogParams {
            pub fn new(snapshot_id: impl Into<SnapshotId>) -> Self {
                Self {
                    snapshot_id: snapshot_id.into(),
                }
            }
        }
        impl SnapshotCommandLogParams {
            pub fn builder() -> SnapshotCommandLogParamsBuilder {
                SnapshotCommandLogParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SnapshotCommandLogParamsBuilder {
            snapshot_id: Option<SnapshotId>,
        }
        impl SnapshotCommandLogParamsBuilder {
            pub fn snapshot_id(mut self, snapshot_id: impl Into<SnapshotId>) -> Self {
                self.snapshot_id = Some(snapshot_id.into());
                self
            }
            pub fn build(self) -> Result<SnapshotCommandLogParams, String> {
                Ok(SnapshotCommandLogParams {
                    snapshot_id: self.snapshot_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(snapshot_id))
                    })?,
                })
            }
        }
        impl SnapshotCommandLogParams {
            pub const IDENTIFIER: &'static str = "LayerTree.snapshotCommandLog";
        }
        impl chromiumoxide_types::Method for SnapshotCommandLogParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SnapshotCommandLogParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Replays the layer snapshot and returns canvas log.\n[snapshotCommandLog](https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-snapshotCommandLog)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SnapshotCommandLogReturns {
            #[doc = "The array of canvas function calls."]
            #[serde(rename = "commandLog")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub command_log: Vec<serde_json::Value>,
        }
        impl SnapshotCommandLogReturns {
            pub fn new(command_log: Vec<serde_json::Value>) -> Self {
                Self { command_log }
            }
        }
        impl SnapshotCommandLogReturns {
            pub fn builder() -> SnapshotCommandLogReturnsBuilder {
                SnapshotCommandLogReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SnapshotCommandLogReturnsBuilder {
            command_log: Option<Vec<serde_json::Value>>,
        }
        impl SnapshotCommandLogReturnsBuilder {
            pub fn command_log(mut self, command_log: impl Into<serde_json::Value>) -> Self {
                let v = self.command_log.get_or_insert(Vec::new());
                v.push(command_log.into());
                self
            }
            pub fn command_logs<I, S>(mut self, command_logs: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<serde_json::Value>,
            {
                let v = self.command_log.get_or_insert(Vec::new());
                for val in command_logs {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SnapshotCommandLogReturns, String> {
                Ok(SnapshotCommandLogReturns {
                    command_log: self.command_log.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(command_log))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SnapshotCommandLogParams {
            type Response = SnapshotCommandLogReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventLayerPainted {
            #[doc = "The id of the painted layer."]
            #[serde(rename = "layerId")]
            pub layer_id: LayerId,
            #[doc = "Clip rectangle."]
            #[serde(rename = "clip")]
            pub clip: super::dom::Rect,
        }
        impl EventLayerPainted {
            pub const IDENTIFIER: &'static str = "LayerTree.layerPainted";
        }
        impl chromiumoxide_types::Method for EventLayerPainted {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventLayerPainted {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventLayerTreeDidChange {
            #[doc = "Layer tree, absent if not in the comspositing mode."]
            #[serde(rename = "layers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub layers: Option<Vec<Layer>>,
        }
        impl EventLayerTreeDidChange {
            pub const IDENTIFIER: &'static str = "LayerTree.layerTreeDidChange";
        }
        impl chromiumoxide_types::Method for EventLayerTreeDidChange {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventLayerTreeDidChange {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "Provides access to log entries."]
    pub mod log {
        use serde::{Deserialize, Serialize};
        #[doc = "Log entry.\n[LogEntry](https://chromedevtools.github.io/devtools-protocol/tot/Log/#type-LogEntry)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LogEntry {
            #[doc = "Log entry source."]
            #[serde(rename = "source")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub source: LogEntrySource,
            #[doc = "Log entry severity."]
            #[serde(rename = "level")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub level: LogEntryLevel,
            #[doc = "Logged text."]
            #[serde(rename = "text")]
            pub text: String,
            #[serde(rename = "category")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub category: Option<LogEntryCategory>,
            #[doc = "Timestamp when this entry was added."]
            #[serde(rename = "timestamp")]
            pub timestamp: super::super::js_protocol::runtime::Timestamp,
            #[doc = "URL of the resource if known."]
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url: Option<String>,
            #[doc = "Line number in the resource."]
            #[serde(rename = "lineNumber")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub line_number: Option<i64>,
            #[doc = "JavaScript stack trace."]
            #[serde(rename = "stackTrace")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub stack_trace: Option<super::super::js_protocol::runtime::StackTrace>,
            #[doc = "Identifier of the network request associated with this entry."]
            #[serde(rename = "networkRequestId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub network_request_id: Option<super::network::RequestId>,
            #[doc = "Identifier of the worker associated with this entry."]
            #[serde(rename = "workerId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub worker_id: Option<String>,
            #[doc = "Call arguments."]
            #[serde(rename = "args")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub args: Option<Vec<super::super::js_protocol::runtime::RemoteObject>>,
        }
        #[doc = "Log entry source."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum LogEntrySource {
            #[serde(rename = "xml")]
            Xml,
            #[serde(rename = "javascript")]
            Javascript,
            #[serde(rename = "network")]
            Network,
            #[serde(rename = "storage")]
            Storage,
            #[serde(rename = "appcache")]
            Appcache,
            #[serde(rename = "rendering")]
            Rendering,
            #[serde(rename = "security")]
            Security,
            #[serde(rename = "deprecation")]
            Deprecation,
            #[serde(rename = "worker")]
            Worker,
            #[serde(rename = "violation")]
            Violation,
            #[serde(rename = "intervention")]
            Intervention,
            #[serde(rename = "recommendation")]
            Recommendation,
            #[serde(rename = "other")]
            Other,
        }
        impl AsRef<str> for LogEntrySource {
            fn as_ref(&self) -> &str {
                match self {
                    LogEntrySource::Xml => "xml",
                    LogEntrySource::Javascript => "javascript",
                    LogEntrySource::Network => "network",
                    LogEntrySource::Storage => "storage",
                    LogEntrySource::Appcache => "appcache",
                    LogEntrySource::Rendering => "rendering",
                    LogEntrySource::Security => "security",
                    LogEntrySource::Deprecation => "deprecation",
                    LogEntrySource::Worker => "worker",
                    LogEntrySource::Violation => "violation",
                    LogEntrySource::Intervention => "intervention",
                    LogEntrySource::Recommendation => "recommendation",
                    LogEntrySource::Other => "other",
                }
            }
        }
        impl ::std::str::FromStr for LogEntrySource {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "xml" | "Xml" => Ok(LogEntrySource::Xml),
                    "javascript" | "Javascript" => Ok(LogEntrySource::Javascript),
                    "network" | "Network" => Ok(LogEntrySource::Network),
                    "storage" | "Storage" => Ok(LogEntrySource::Storage),
                    "appcache" | "Appcache" => Ok(LogEntrySource::Appcache),
                    "rendering" | "Rendering" => Ok(LogEntrySource::Rendering),
                    "security" | "Security" => Ok(LogEntrySource::Security),
                    "deprecation" | "Deprecation" => Ok(LogEntrySource::Deprecation),
                    "worker" | "Worker" => Ok(LogEntrySource::Worker),
                    "violation" | "Violation" => Ok(LogEntrySource::Violation),
                    "intervention" | "Intervention" => Ok(LogEntrySource::Intervention),
                    "recommendation" | "Recommendation" => Ok(LogEntrySource::Recommendation),
                    "other" | "Other" => Ok(LogEntrySource::Other),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Log entry severity."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum LogEntryLevel {
            #[serde(rename = "verbose")]
            Verbose,
            #[serde(rename = "info")]
            Info,
            #[serde(rename = "warning")]
            Warning,
            #[serde(rename = "error")]
            Error,
        }
        impl AsRef<str> for LogEntryLevel {
            fn as_ref(&self) -> &str {
                match self {
                    LogEntryLevel::Verbose => "verbose",
                    LogEntryLevel::Info => "info",
                    LogEntryLevel::Warning => "warning",
                    LogEntryLevel::Error => "error",
                }
            }
        }
        impl ::std::str::FromStr for LogEntryLevel {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "verbose" | "Verbose" => Ok(LogEntryLevel::Verbose),
                    "info" | "Info" => Ok(LogEntryLevel::Info),
                    "warning" | "Warning" => Ok(LogEntryLevel::Warning),
                    "error" | "Error" => Ok(LogEntryLevel::Error),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum LogEntryCategory {
            #[serde(rename = "cors")]
            Cors,
        }
        impl AsRef<str> for LogEntryCategory {
            fn as_ref(&self) -> &str {
                match self {
                    LogEntryCategory::Cors => "cors",
                }
            }
        }
        impl ::std::str::FromStr for LogEntryCategory {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "cors" | "Cors" => Ok(LogEntryCategory::Cors),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl LogEntry {
            pub fn new(
                source: impl Into<LogEntrySource>,
                level: impl Into<LogEntryLevel>,
                text: impl Into<String>,
                timestamp: impl Into<super::super::js_protocol::runtime::Timestamp>,
            ) -> Self {
                Self {
                    source: source.into(),
                    level: level.into(),
                    text: text.into(),
                    timestamp: timestamp.into(),
                    category: None,
                    url: None,
                    line_number: None,
                    stack_trace: None,
                    network_request_id: None,
                    worker_id: None,
                    args: None,
                }
            }
        }
        impl LogEntry {
            pub fn builder() -> LogEntryBuilder {
                LogEntryBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LogEntryBuilder {
            source: Option<LogEntrySource>,
            level: Option<LogEntryLevel>,
            text: Option<String>,
            category: Option<LogEntryCategory>,
            timestamp: Option<super::super::js_protocol::runtime::Timestamp>,
            url: Option<String>,
            line_number: Option<i64>,
            stack_trace: Option<super::super::js_protocol::runtime::StackTrace>,
            network_request_id: Option<super::network::RequestId>,
            worker_id: Option<String>,
            args: Option<Vec<super::super::js_protocol::runtime::RemoteObject>>,
        }
        impl LogEntryBuilder {
            pub fn source(mut self, source: impl Into<LogEntrySource>) -> Self {
                self.source = Some(source.into());
                self
            }
            pub fn level(mut self, level: impl Into<LogEntryLevel>) -> Self {
                self.level = Some(level.into());
                self
            }
            pub fn text(mut self, text: impl Into<String>) -> Self {
                self.text = Some(text.into());
                self
            }
            pub fn category(mut self, category: impl Into<LogEntryCategory>) -> Self {
                self.category = Some(category.into());
                self
            }
            pub fn timestamp(
                mut self,
                timestamp: impl Into<super::super::js_protocol::runtime::Timestamp>,
            ) -> Self {
                self.timestamp = Some(timestamp.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn line_number(mut self, line_number: impl Into<i64>) -> Self {
                self.line_number = Some(line_number.into());
                self
            }
            pub fn stack_trace(
                mut self,
                stack_trace: impl Into<super::super::js_protocol::runtime::StackTrace>,
            ) -> Self {
                self.stack_trace = Some(stack_trace.into());
                self
            }
            pub fn network_request_id(
                mut self,
                network_request_id: impl Into<super::network::RequestId>,
            ) -> Self {
                self.network_request_id = Some(network_request_id.into());
                self
            }
            pub fn worker_id(mut self, worker_id: impl Into<String>) -> Self {
                self.worker_id = Some(worker_id.into());
                self
            }
            pub fn arg(
                mut self,
                arg: impl Into<super::super::js_protocol::runtime::RemoteObject>,
            ) -> Self {
                let v = self.args.get_or_insert(Vec::new());
                v.push(arg.into());
                self
            }
            pub fn args<I, S>(mut self, args: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<super::super::js_protocol::runtime::RemoteObject>,
            {
                let v = self.args.get_or_insert(Vec::new());
                for val in args {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<LogEntry, String> {
                Ok(LogEntry {
                    source: self.source.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(source))
                    })?,
                    level: self.level.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(level))
                    })?,
                    text: self.text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(text))
                    })?,
                    category: self.category,
                    timestamp: self.timestamp.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(timestamp))
                    })?,
                    url: self.url,
                    line_number: self.line_number,
                    stack_trace: self.stack_trace,
                    network_request_id: self.network_request_id,
                    worker_id: self.worker_id,
                    args: self.args,
                })
            }
        }
        impl LogEntry {
            pub const IDENTIFIER: &'static str = "Log.LogEntry";
        }
        #[doc = "Violation configuration setting.\n[ViolationSetting](https://chromedevtools.github.io/devtools-protocol/tot/Log/#type-ViolationSetting)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ViolationSetting {
            #[doc = "Violation type."]
            #[serde(rename = "name")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub name: ViolationSettingName,
            #[doc = "Time threshold to trigger upon."]
            #[serde(rename = "threshold")]
            pub threshold: f64,
        }
        #[doc = "Violation type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ViolationSettingName {
            #[serde(rename = "longTask")]
            LongTask,
            #[serde(rename = "longLayout")]
            LongLayout,
            #[serde(rename = "blockedEvent")]
            BlockedEvent,
            #[serde(rename = "blockedParser")]
            BlockedParser,
            #[serde(rename = "discouragedAPIUse")]
            DiscouragedApiUse,
            #[serde(rename = "handler")]
            Handler,
            #[serde(rename = "recurringHandler")]
            RecurringHandler,
        }
        impl AsRef<str> for ViolationSettingName {
            fn as_ref(&self) -> &str {
                match self {
                    ViolationSettingName::LongTask => "longTask",
                    ViolationSettingName::LongLayout => "longLayout",
                    ViolationSettingName::BlockedEvent => "blockedEvent",
                    ViolationSettingName::BlockedParser => "blockedParser",
                    ViolationSettingName::DiscouragedApiUse => "discouragedAPIUse",
                    ViolationSettingName::Handler => "handler",
                    ViolationSettingName::RecurringHandler => "recurringHandler",
                }
            }
        }
        impl ::std::str::FromStr for ViolationSettingName {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "longTask" | "LongTask" | "longtask" => Ok(ViolationSettingName::LongTask),
                    "longLayout" | "LongLayout" | "longlayout" => {
                        Ok(ViolationSettingName::LongLayout)
                    }
                    "blockedEvent" | "BlockedEvent" | "blockedevent" => {
                        Ok(ViolationSettingName::BlockedEvent)
                    }
                    "blockedParser" | "BlockedParser" | "blockedparser" => {
                        Ok(ViolationSettingName::BlockedParser)
                    }
                    "discouragedAPIUse" | "DiscouragedApiUse" | "discouragedapiuse" => {
                        Ok(ViolationSettingName::DiscouragedApiUse)
                    }
                    "handler" | "Handler" => Ok(ViolationSettingName::Handler),
                    "recurringHandler" | "RecurringHandler" | "recurringhandler" => {
                        Ok(ViolationSettingName::RecurringHandler)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl ViolationSetting {
            pub fn new(name: impl Into<ViolationSettingName>, threshold: impl Into<f64>) -> Self {
                Self {
                    name: name.into(),
                    threshold: threshold.into(),
                }
            }
        }
        impl ViolationSetting {
            pub fn builder() -> ViolationSettingBuilder {
                ViolationSettingBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ViolationSettingBuilder {
            name: Option<ViolationSettingName>,
            threshold: Option<f64>,
        }
        impl ViolationSettingBuilder {
            pub fn name(mut self, name: impl Into<ViolationSettingName>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn threshold(mut self, threshold: impl Into<f64>) -> Self {
                self.threshold = Some(threshold.into());
                self
            }
            pub fn build(self) -> Result<ViolationSetting, String> {
                Ok(ViolationSetting {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    threshold: self.threshold.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(threshold))
                    })?,
                })
            }
        }
        impl ViolationSetting {
            pub const IDENTIFIER: &'static str = "Log.ViolationSetting";
        }
        #[doc = "Clears the log.\n[clear](https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-clear)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearParams {}
        impl ClearParams {
            pub const IDENTIFIER: &'static str = "Log.clear";
        }
        impl chromiumoxide_types::Method for ClearParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears the log.\n[clear](https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-clear)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearReturns {}
        impl chromiumoxide_types::Command for ClearParams {
            type Response = ClearReturns;
        }
        #[doc = "Disables log domain, prevents further log entries from being reported to the client.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Log.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables log domain, prevents further log entries from being reported to the client.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables log domain, sends the entries collected so far to the client by means of the\n`entryAdded` notification.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Log.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables log domain, sends the entries collected so far to the client by means of the\n`entryAdded` notification.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "start violation reporting.\n[startViolationsReport](https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-startViolationsReport)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StartViolationsReportParams {
            #[doc = "Configuration for violations."]
            #[serde(rename = "config")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub config: Vec<ViolationSetting>,
        }
        impl StartViolationsReportParams {
            pub fn new(config: Vec<ViolationSetting>) -> Self {
                Self { config }
            }
        }
        impl StartViolationsReportParams {
            pub fn builder() -> StartViolationsReportParamsBuilder {
                StartViolationsReportParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StartViolationsReportParamsBuilder {
            config: Option<Vec<ViolationSetting>>,
        }
        impl StartViolationsReportParamsBuilder {
            pub fn config(mut self, config: impl Into<ViolationSetting>) -> Self {
                let v = self.config.get_or_insert(Vec::new());
                v.push(config.into());
                self
            }
            pub fn configs<I, S>(mut self, configs: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ViolationSetting>,
            {
                let v = self.config.get_or_insert(Vec::new());
                for val in configs {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<StartViolationsReportParams, String> {
                Ok(StartViolationsReportParams {
                    config: self.config.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(config))
                    })?,
                })
            }
        }
        impl StartViolationsReportParams {
            pub const IDENTIFIER: &'static str = "Log.startViolationsReport";
        }
        impl chromiumoxide_types::Method for StartViolationsReportParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartViolationsReportParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "start violation reporting.\n[startViolationsReport](https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-startViolationsReport)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartViolationsReportReturns {}
        impl chromiumoxide_types::Command for StartViolationsReportParams {
            type Response = StartViolationsReportReturns;
        }
        #[doc = "Stop violation reporting.\n[stopViolationsReport](https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-stopViolationsReport)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopViolationsReportParams {}
        impl StopViolationsReportParams {
            pub const IDENTIFIER: &'static str = "Log.stopViolationsReport";
        }
        impl chromiumoxide_types::Method for StopViolationsReportParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopViolationsReportParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Stop violation reporting.\n[stopViolationsReport](https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-stopViolationsReport)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopViolationsReportReturns {}
        impl chromiumoxide_types::Command for StopViolationsReportParams {
            type Response = StopViolationsReportReturns;
        }
        #[doc = "Issued when new message was logged.\n[entryAdded](https://chromedevtools.github.io/devtools-protocol/tot/Log/#event-entryAdded)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventEntryAdded {
            #[doc = "The entry."]
            #[serde(rename = "entry")]
            pub entry: LogEntry,
        }
        impl EventEntryAdded {
            pub const IDENTIFIER: &'static str = "Log.entryAdded";
        }
        impl chromiumoxide_types::Method for EventEntryAdded {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventEntryAdded {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    pub mod memory {
        use serde::{Deserialize, Serialize};
        #[doc = "Memory pressure level."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PressureLevel {
            #[serde(rename = "moderate")]
            Moderate,
            #[serde(rename = "critical")]
            Critical,
        }
        impl AsRef<str> for PressureLevel {
            fn as_ref(&self) -> &str {
                match self {
                    PressureLevel::Moderate => "moderate",
                    PressureLevel::Critical => "critical",
                }
            }
        }
        impl ::std::str::FromStr for PressureLevel {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "moderate" | "Moderate" => Ok(PressureLevel::Moderate),
                    "critical" | "Critical" => Ok(PressureLevel::Critical),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Heap profile sample.\n[SamplingProfileNode](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#type-SamplingProfileNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SamplingProfileNode {
            #[doc = "Size of the sampled allocation."]
            #[serde(rename = "size")]
            pub size: f64,
            #[doc = "Total bytes attributed to this sample."]
            #[serde(rename = "total")]
            pub total: f64,
            #[doc = "Execution stack at the point of allocation."]
            #[serde(rename = "stack")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub stack: Vec<String>,
        }
        impl SamplingProfileNode {
            pub fn new(size: impl Into<f64>, total: impl Into<f64>, stack: Vec<String>) -> Self {
                Self {
                    size: size.into(),
                    total: total.into(),
                    stack,
                }
            }
        }
        impl SamplingProfileNode {
            pub fn builder() -> SamplingProfileNodeBuilder {
                SamplingProfileNodeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SamplingProfileNodeBuilder {
            size: Option<f64>,
            total: Option<f64>,
            stack: Option<Vec<String>>,
        }
        impl SamplingProfileNodeBuilder {
            pub fn size(mut self, size: impl Into<f64>) -> Self {
                self.size = Some(size.into());
                self
            }
            pub fn total(mut self, total: impl Into<f64>) -> Self {
                self.total = Some(total.into());
                self
            }
            pub fn stack(mut self, stack: impl Into<String>) -> Self {
                let v = self.stack.get_or_insert(Vec::new());
                v.push(stack.into());
                self
            }
            pub fn stacks<I, S>(mut self, stacks: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.stack.get_or_insert(Vec::new());
                for val in stacks {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SamplingProfileNode, String> {
                Ok(SamplingProfileNode {
                    size: self.size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(size))
                    })?,
                    total: self.total.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(total))
                    })?,
                    stack: self.stack.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(stack))
                    })?,
                })
            }
        }
        impl SamplingProfileNode {
            pub const IDENTIFIER: &'static str = "Memory.SamplingProfileNode";
        }
        #[doc = "Array of heap profile samples.\n[SamplingProfile](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#type-SamplingProfile)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SamplingProfile {
            #[serde(rename = "samples")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub samples: Vec<SamplingProfileNode>,
            #[serde(rename = "modules")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub modules: Vec<Module>,
        }
        impl SamplingProfile {
            pub fn new(samples: Vec<SamplingProfileNode>, modules: Vec<Module>) -> Self {
                Self { samples, modules }
            }
        }
        impl SamplingProfile {
            pub fn builder() -> SamplingProfileBuilder {
                SamplingProfileBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SamplingProfileBuilder {
            samples: Option<Vec<SamplingProfileNode>>,
            modules: Option<Vec<Module>>,
        }
        impl SamplingProfileBuilder {
            pub fn sample(mut self, sample: impl Into<SamplingProfileNode>) -> Self {
                let v = self.samples.get_or_insert(Vec::new());
                v.push(sample.into());
                self
            }
            pub fn samples<I, S>(mut self, samples: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<SamplingProfileNode>,
            {
                let v = self.samples.get_or_insert(Vec::new());
                for val in samples {
                    v.push(val.into());
                }
                self
            }
            pub fn module(mut self, module: impl Into<Module>) -> Self {
                let v = self.modules.get_or_insert(Vec::new());
                v.push(module.into());
                self
            }
            pub fn modules<I, S>(mut self, modules: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Module>,
            {
                let v = self.modules.get_or_insert(Vec::new());
                for val in modules {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SamplingProfile, String> {
                Ok(SamplingProfile {
                    samples: self.samples.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(samples))
                    })?,
                    modules: self.modules.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(modules))
                    })?,
                })
            }
        }
        impl SamplingProfile {
            pub const IDENTIFIER: &'static str = "Memory.SamplingProfile";
        }
        #[doc = "Executable module information\n[Module](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#type-Module)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Module {
            #[doc = "Name of the module."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "UUID of the module."]
            #[serde(rename = "uuid")]
            pub uuid: String,
            #[doc = "Base address where the module is loaded into memory. Encoded as a decimal\nor hexadecimal (0x prefixed) string."]
            #[serde(rename = "baseAddress")]
            pub base_address: String,
            #[doc = "Size of the module in bytes."]
            #[serde(rename = "size")]
            pub size: f64,
        }
        impl Module {
            pub fn new(
                name: impl Into<String>,
                uuid: impl Into<String>,
                base_address: impl Into<String>,
                size: impl Into<f64>,
            ) -> Self {
                Self {
                    name: name.into(),
                    uuid: uuid.into(),
                    base_address: base_address.into(),
                    size: size.into(),
                }
            }
        }
        impl Module {
            pub fn builder() -> ModuleBuilder {
                ModuleBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ModuleBuilder {
            name: Option<String>,
            uuid: Option<String>,
            base_address: Option<String>,
            size: Option<f64>,
        }
        impl ModuleBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn uuid(mut self, uuid: impl Into<String>) -> Self {
                self.uuid = Some(uuid.into());
                self
            }
            pub fn base_address(mut self, base_address: impl Into<String>) -> Self {
                self.base_address = Some(base_address.into());
                self
            }
            pub fn size(mut self, size: impl Into<f64>) -> Self {
                self.size = Some(size.into());
                self
            }
            pub fn build(self) -> Result<Module, String> {
                Ok(Module {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    uuid: self.uuid.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(uuid))
                    })?,
                    base_address: self.base_address.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(base_address))
                    })?,
                    size: self.size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(size))
                    })?,
                })
            }
        }
        impl Module {
            pub const IDENTIFIER: &'static str = "Memory.Module";
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetDomCountersParams {}
        impl GetDomCountersParams {
            pub const IDENTIFIER: &'static str = "Memory.getDOMCounters";
        }
        impl chromiumoxide_types::Method for GetDomCountersParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetDomCountersParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetDomCountersReturns {
            #[serde(rename = "documents")]
            pub documents: i64,
            #[serde(rename = "nodes")]
            pub nodes: i64,
            #[serde(rename = "jsEventListeners")]
            pub js_event_listeners: i64,
        }
        impl GetDomCountersReturns {
            pub fn new(
                documents: impl Into<i64>,
                nodes: impl Into<i64>,
                js_event_listeners: impl Into<i64>,
            ) -> Self {
                Self {
                    documents: documents.into(),
                    nodes: nodes.into(),
                    js_event_listeners: js_event_listeners.into(),
                }
            }
        }
        impl GetDomCountersReturns {
            pub fn builder() -> GetDomCountersReturnsBuilder {
                GetDomCountersReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetDomCountersReturnsBuilder {
            documents: Option<i64>,
            nodes: Option<i64>,
            js_event_listeners: Option<i64>,
        }
        impl GetDomCountersReturnsBuilder {
            pub fn documents(mut self, documents: impl Into<i64>) -> Self {
                self.documents = Some(documents.into());
                self
            }
            pub fn nodes(mut self, nodes: impl Into<i64>) -> Self {
                self.nodes = Some(nodes.into());
                self
            }
            pub fn js_event_listeners(mut self, js_event_listeners: impl Into<i64>) -> Self {
                self.js_event_listeners = Some(js_event_listeners.into());
                self
            }
            pub fn build(self) -> Result<GetDomCountersReturns, String> {
                Ok(GetDomCountersReturns {
                    documents: self.documents.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(documents))
                    })?,
                    nodes: self.nodes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(nodes))
                    })?,
                    js_event_listeners: self.js_event_listeners.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(js_event_listeners)
                        )
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetDomCountersParams {
            type Response = GetDomCountersReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct PrepareForLeakDetectionParams {}
        impl PrepareForLeakDetectionParams {
            pub const IDENTIFIER: &'static str = "Memory.prepareForLeakDetection";
        }
        impl chromiumoxide_types::Method for PrepareForLeakDetectionParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for PrepareForLeakDetectionParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct PrepareForLeakDetectionReturns {}
        impl chromiumoxide_types::Command for PrepareForLeakDetectionParams {
            type Response = PrepareForLeakDetectionReturns;
        }
        #[doc = "Simulate OomIntervention by purging V8 memory.\n[forciblyPurgeJavaScriptMemory](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-forciblyPurgeJavaScriptMemory)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ForciblyPurgeJavaScriptMemoryParams {}
        impl ForciblyPurgeJavaScriptMemoryParams {
            pub const IDENTIFIER: &'static str = "Memory.forciblyPurgeJavaScriptMemory";
        }
        impl chromiumoxide_types::Method for ForciblyPurgeJavaScriptMemoryParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ForciblyPurgeJavaScriptMemoryParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Simulate OomIntervention by purging V8 memory.\n[forciblyPurgeJavaScriptMemory](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-forciblyPurgeJavaScriptMemory)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ForciblyPurgeJavaScriptMemoryReturns {}
        impl chromiumoxide_types::Command for ForciblyPurgeJavaScriptMemoryParams {
            type Response = ForciblyPurgeJavaScriptMemoryReturns;
        }
        #[doc = "Enable/disable suppressing memory pressure notifications in all processes.\n[setPressureNotificationsSuppressed](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-setPressureNotificationsSuppressed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetPressureNotificationsSuppressedParams {
            #[doc = "If true, memory pressure notifications will be suppressed."]
            #[serde(rename = "suppressed")]
            pub suppressed: bool,
        }
        impl SetPressureNotificationsSuppressedParams {
            pub fn new(suppressed: impl Into<bool>) -> Self {
                Self {
                    suppressed: suppressed.into(),
                }
            }
        }
        impl SetPressureNotificationsSuppressedParams {
            pub fn builder() -> SetPressureNotificationsSuppressedParamsBuilder {
                SetPressureNotificationsSuppressedParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetPressureNotificationsSuppressedParamsBuilder {
            suppressed: Option<bool>,
        }
        impl SetPressureNotificationsSuppressedParamsBuilder {
            pub fn suppressed(mut self, suppressed: impl Into<bool>) -> Self {
                self.suppressed = Some(suppressed.into());
                self
            }
            pub fn build(self) -> Result<SetPressureNotificationsSuppressedParams, String> {
                Ok(SetPressureNotificationsSuppressedParams {
                    suppressed: self.suppressed.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(suppressed))
                    })?,
                })
            }
        }
        impl SetPressureNotificationsSuppressedParams {
            pub const IDENTIFIER: &'static str = "Memory.setPressureNotificationsSuppressed";
        }
        impl chromiumoxide_types::Method for SetPressureNotificationsSuppressedParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetPressureNotificationsSuppressedParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enable/disable suppressing memory pressure notifications in all processes.\n[setPressureNotificationsSuppressed](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-setPressureNotificationsSuppressed)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetPressureNotificationsSuppressedReturns {}
        impl chromiumoxide_types::Command for SetPressureNotificationsSuppressedParams {
            type Response = SetPressureNotificationsSuppressedReturns;
        }
        #[doc = "Simulate a memory pressure notification in all processes.\n[simulatePressureNotification](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-simulatePressureNotification)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SimulatePressureNotificationParams {
            #[doc = "Memory pressure level of the notification."]
            #[serde(rename = "level")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub level: PressureLevel,
        }
        impl SimulatePressureNotificationParams {
            pub fn new(level: impl Into<PressureLevel>) -> Self {
                Self {
                    level: level.into(),
                }
            }
        }
        impl SimulatePressureNotificationParams {
            pub fn builder() -> SimulatePressureNotificationParamsBuilder {
                SimulatePressureNotificationParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SimulatePressureNotificationParamsBuilder {
            level: Option<PressureLevel>,
        }
        impl SimulatePressureNotificationParamsBuilder {
            pub fn level(mut self, level: impl Into<PressureLevel>) -> Self {
                self.level = Some(level.into());
                self
            }
            pub fn build(self) -> Result<SimulatePressureNotificationParams, String> {
                Ok(SimulatePressureNotificationParams {
                    level: self.level.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(level))
                    })?,
                })
            }
        }
        impl SimulatePressureNotificationParams {
            pub const IDENTIFIER: &'static str = "Memory.simulatePressureNotification";
        }
        impl chromiumoxide_types::Method for SimulatePressureNotificationParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SimulatePressureNotificationParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Simulate a memory pressure notification in all processes.\n[simulatePressureNotification](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-simulatePressureNotification)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SimulatePressureNotificationReturns {}
        impl chromiumoxide_types::Command for SimulatePressureNotificationParams {
            type Response = SimulatePressureNotificationReturns;
        }
        #[doc = "Start collecting native memory profile.\n[startSampling](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-startSampling)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartSamplingParams {
            #[doc = "Average number of bytes between samples."]
            #[serde(rename = "samplingInterval")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub sampling_interval: Option<i64>,
            #[doc = "Do not randomize intervals between samples."]
            #[serde(rename = "suppressRandomness")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub suppress_randomness: Option<bool>,
        }
        impl StartSamplingParams {
            pub fn builder() -> StartSamplingParamsBuilder {
                StartSamplingParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StartSamplingParamsBuilder {
            sampling_interval: Option<i64>,
            suppress_randomness: Option<bool>,
        }
        impl StartSamplingParamsBuilder {
            pub fn sampling_interval(mut self, sampling_interval: impl Into<i64>) -> Self {
                self.sampling_interval = Some(sampling_interval.into());
                self
            }
            pub fn suppress_randomness(mut self, suppress_randomness: impl Into<bool>) -> Self {
                self.suppress_randomness = Some(suppress_randomness.into());
                self
            }
            pub fn build(self) -> StartSamplingParams {
                StartSamplingParams {
                    sampling_interval: self.sampling_interval,
                    suppress_randomness: self.suppress_randomness,
                }
            }
        }
        impl StartSamplingParams {
            pub const IDENTIFIER: &'static str = "Memory.startSampling";
        }
        impl chromiumoxide_types::Method for StartSamplingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartSamplingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Start collecting native memory profile.\n[startSampling](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-startSampling)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartSamplingReturns {}
        impl chromiumoxide_types::Command for StartSamplingParams {
            type Response = StartSamplingReturns;
        }
        #[doc = "Stop collecting native memory profile.\n[stopSampling](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-stopSampling)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopSamplingParams {}
        impl StopSamplingParams {
            pub const IDENTIFIER: &'static str = "Memory.stopSampling";
        }
        impl chromiumoxide_types::Method for StopSamplingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopSamplingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Stop collecting native memory profile.\n[stopSampling](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-stopSampling)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopSamplingReturns {}
        impl chromiumoxide_types::Command for StopSamplingParams {
            type Response = StopSamplingReturns;
        }
        #[doc = "Retrieve native memory allocations profile\ncollected since renderer process startup.\n[getAllTimeSamplingProfile](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-getAllTimeSamplingProfile)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetAllTimeSamplingProfileParams {}
        impl GetAllTimeSamplingProfileParams {
            pub const IDENTIFIER: &'static str = "Memory.getAllTimeSamplingProfile";
        }
        impl chromiumoxide_types::Method for GetAllTimeSamplingProfileParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetAllTimeSamplingProfileParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Retrieve native memory allocations profile\ncollected since renderer process startup.\n[getAllTimeSamplingProfile](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-getAllTimeSamplingProfile)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetAllTimeSamplingProfileReturns {
            #[serde(rename = "profile")]
            pub profile: SamplingProfile,
        }
        impl GetAllTimeSamplingProfileReturns {
            pub fn new(profile: impl Into<SamplingProfile>) -> Self {
                Self {
                    profile: profile.into(),
                }
            }
        }
        impl GetAllTimeSamplingProfileReturns {
            pub fn builder() -> GetAllTimeSamplingProfileReturnsBuilder {
                GetAllTimeSamplingProfileReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetAllTimeSamplingProfileReturnsBuilder {
            profile: Option<SamplingProfile>,
        }
        impl GetAllTimeSamplingProfileReturnsBuilder {
            pub fn profile(mut self, profile: impl Into<SamplingProfile>) -> Self {
                self.profile = Some(profile.into());
                self
            }
            pub fn build(self) -> Result<GetAllTimeSamplingProfileReturns, String> {
                Ok(GetAllTimeSamplingProfileReturns {
                    profile: self.profile.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(profile))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetAllTimeSamplingProfileParams {
            type Response = GetAllTimeSamplingProfileReturns;
        }
        #[doc = "Retrieve native memory allocations profile\ncollected since browser process startup.\n[getBrowserSamplingProfile](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-getBrowserSamplingProfile)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetBrowserSamplingProfileParams {}
        impl GetBrowserSamplingProfileParams {
            pub const IDENTIFIER: &'static str = "Memory.getBrowserSamplingProfile";
        }
        impl chromiumoxide_types::Method for GetBrowserSamplingProfileParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetBrowserSamplingProfileParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Retrieve native memory allocations profile\ncollected since browser process startup.\n[getBrowserSamplingProfile](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-getBrowserSamplingProfile)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetBrowserSamplingProfileReturns {
            #[serde(rename = "profile")]
            pub profile: SamplingProfile,
        }
        impl GetBrowserSamplingProfileReturns {
            pub fn new(profile: impl Into<SamplingProfile>) -> Self {
                Self {
                    profile: profile.into(),
                }
            }
        }
        impl GetBrowserSamplingProfileReturns {
            pub fn builder() -> GetBrowserSamplingProfileReturnsBuilder {
                GetBrowserSamplingProfileReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetBrowserSamplingProfileReturnsBuilder {
            profile: Option<SamplingProfile>,
        }
        impl GetBrowserSamplingProfileReturnsBuilder {
            pub fn profile(mut self, profile: impl Into<SamplingProfile>) -> Self {
                self.profile = Some(profile.into());
                self
            }
            pub fn build(self) -> Result<GetBrowserSamplingProfileReturns, String> {
                Ok(GetBrowserSamplingProfileReturns {
                    profile: self.profile.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(profile))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetBrowserSamplingProfileParams {
            type Response = GetBrowserSamplingProfileReturns;
        }
        #[doc = "Retrieve native memory allocations profile collected since last\n`startSampling` call.\n[getSamplingProfile](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-getSamplingProfile)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetSamplingProfileParams {}
        impl GetSamplingProfileParams {
            pub const IDENTIFIER: &'static str = "Memory.getSamplingProfile";
        }
        impl chromiumoxide_types::Method for GetSamplingProfileParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetSamplingProfileParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Retrieve native memory allocations profile collected since last\n`startSampling` call.\n[getSamplingProfile](https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-getSamplingProfile)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetSamplingProfileReturns {
            #[serde(rename = "profile")]
            pub profile: SamplingProfile,
        }
        impl GetSamplingProfileReturns {
            pub fn new(profile: impl Into<SamplingProfile>) -> Self {
                Self {
                    profile: profile.into(),
                }
            }
        }
        impl GetSamplingProfileReturns {
            pub fn builder() -> GetSamplingProfileReturnsBuilder {
                GetSamplingProfileReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetSamplingProfileReturnsBuilder {
            profile: Option<SamplingProfile>,
        }
        impl GetSamplingProfileReturnsBuilder {
            pub fn profile(mut self, profile: impl Into<SamplingProfile>) -> Self {
                self.profile = Some(profile.into());
                self
            }
            pub fn build(self) -> Result<GetSamplingProfileReturns, String> {
                Ok(GetSamplingProfileReturns {
                    profile: self.profile.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(profile))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetSamplingProfileParams {
            type Response = GetSamplingProfileReturns;
        }
    }
    #[doc = "Network domain allows tracking network activities of the page. It exposes information about http,\nfile, data and other requests and responses, their headers, bodies, timing, etc."]
    pub mod network {
        use serde::{Deserialize, Serialize};
        #[doc = "Resource type as it was perceived by the rendering engine."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ResourceType {
            #[serde(rename = "Document")]
            Document,
            #[serde(rename = "Stylesheet")]
            Stylesheet,
            #[serde(rename = "Image")]
            Image,
            #[serde(rename = "Media")]
            Media,
            #[serde(rename = "Font")]
            Font,
            #[serde(rename = "Script")]
            Script,
            #[serde(rename = "TextTrack")]
            TextTrack,
            #[serde(rename = "XHR")]
            Xhr,
            #[serde(rename = "Fetch")]
            Fetch,
            #[serde(rename = "Prefetch")]
            Prefetch,
            #[serde(rename = "EventSource")]
            EventSource,
            #[serde(rename = "WebSocket")]
            WebSocket,
            #[serde(rename = "Manifest")]
            Manifest,
            #[serde(rename = "SignedExchange")]
            SignedExchange,
            #[serde(rename = "Ping")]
            Ping,
            #[serde(rename = "CSPViolationReport")]
            CspViolationReport,
            #[serde(rename = "Preflight")]
            Preflight,
            #[serde(rename = "Other")]
            Other,
        }
        impl AsRef<str> for ResourceType {
            fn as_ref(&self) -> &str {
                match self {
                    ResourceType::Document => "Document",
                    ResourceType::Stylesheet => "Stylesheet",
                    ResourceType::Image => "Image",
                    ResourceType::Media => "Media",
                    ResourceType::Font => "Font",
                    ResourceType::Script => "Script",
                    ResourceType::TextTrack => "TextTrack",
                    ResourceType::Xhr => "XHR",
                    ResourceType::Fetch => "Fetch",
                    ResourceType::Prefetch => "Prefetch",
                    ResourceType::EventSource => "EventSource",
                    ResourceType::WebSocket => "WebSocket",
                    ResourceType::Manifest => "Manifest",
                    ResourceType::SignedExchange => "SignedExchange",
                    ResourceType::Ping => "Ping",
                    ResourceType::CspViolationReport => "CSPViolationReport",
                    ResourceType::Preflight => "Preflight",
                    ResourceType::Other => "Other",
                }
            }
        }
        impl ::std::str::FromStr for ResourceType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Document" | "document" => Ok(ResourceType::Document),
                    "Stylesheet" | "stylesheet" => Ok(ResourceType::Stylesheet),
                    "Image" | "image" => Ok(ResourceType::Image),
                    "Media" | "media" => Ok(ResourceType::Media),
                    "Font" | "font" => Ok(ResourceType::Font),
                    "Script" | "script" => Ok(ResourceType::Script),
                    "TextTrack" | "texttrack" => Ok(ResourceType::TextTrack),
                    "XHR" | "Xhr" | "xhr" => Ok(ResourceType::Xhr),
                    "Fetch" | "fetch" => Ok(ResourceType::Fetch),
                    "Prefetch" | "prefetch" => Ok(ResourceType::Prefetch),
                    "EventSource" | "eventsource" => Ok(ResourceType::EventSource),
                    "WebSocket" | "websocket" => Ok(ResourceType::WebSocket),
                    "Manifest" | "manifest" => Ok(ResourceType::Manifest),
                    "SignedExchange" | "signedexchange" => Ok(ResourceType::SignedExchange),
                    "Ping" | "ping" => Ok(ResourceType::Ping),
                    "CSPViolationReport" | "CspViolationReport" | "cspviolationreport" => {
                        Ok(ResourceType::CspViolationReport)
                    }
                    "Preflight" | "preflight" => Ok(ResourceType::Preflight),
                    "Other" | "other" => Ok(ResourceType::Other),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Unique loader identifier.\n[LoaderId](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-LoaderId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct LoaderId(String);
        impl LoaderId {
            pub fn new(val: impl Into<String>) -> Self {
                LoaderId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for LoaderId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<LoaderId> for String {
            fn from(el: LoaderId) -> String {
                el.0
            }
        }
        impl From<String> for LoaderId {
            fn from(expr: String) -> Self {
                LoaderId(expr)
            }
        }
        impl std::borrow::Borrow<str> for LoaderId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl LoaderId {
            pub const IDENTIFIER: &'static str = "Network.LoaderId";
        }
        #[doc = "Unique request identifier.\n[RequestId](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-RequestId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct RequestId(String);
        impl RequestId {
            pub fn new(val: impl Into<String>) -> Self {
                RequestId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for RequestId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<RequestId> for String {
            fn from(el: RequestId) -> String {
                el.0
            }
        }
        impl From<String> for RequestId {
            fn from(expr: String) -> Self {
                RequestId(expr)
            }
        }
        impl std::borrow::Borrow<str> for RequestId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl RequestId {
            pub const IDENTIFIER: &'static str = "Network.RequestId";
        }
        #[doc = "Unique intercepted request identifier.\n[InterceptionId](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-InterceptionId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct InterceptionId(String);
        impl InterceptionId {
            pub fn new(val: impl Into<String>) -> Self {
                InterceptionId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for InterceptionId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<InterceptionId> for String {
            fn from(el: InterceptionId) -> String {
                el.0
            }
        }
        impl From<String> for InterceptionId {
            fn from(expr: String) -> Self {
                InterceptionId(expr)
            }
        }
        impl std::borrow::Borrow<str> for InterceptionId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl InterceptionId {
            pub const IDENTIFIER: &'static str = "Network.InterceptionId";
        }
        #[doc = "Network level fetch failure reason."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ErrorReason {
            #[serde(rename = "Failed")]
            Failed,
            #[serde(rename = "Aborted")]
            Aborted,
            #[serde(rename = "TimedOut")]
            TimedOut,
            #[serde(rename = "AccessDenied")]
            AccessDenied,
            #[serde(rename = "ConnectionClosed")]
            ConnectionClosed,
            #[serde(rename = "ConnectionReset")]
            ConnectionReset,
            #[serde(rename = "ConnectionRefused")]
            ConnectionRefused,
            #[serde(rename = "ConnectionAborted")]
            ConnectionAborted,
            #[serde(rename = "ConnectionFailed")]
            ConnectionFailed,
            #[serde(rename = "NameNotResolved")]
            NameNotResolved,
            #[serde(rename = "InternetDisconnected")]
            InternetDisconnected,
            #[serde(rename = "AddressUnreachable")]
            AddressUnreachable,
            #[serde(rename = "BlockedByClient")]
            BlockedByClient,
            #[serde(rename = "BlockedByResponse")]
            BlockedByResponse,
        }
        impl AsRef<str> for ErrorReason {
            fn as_ref(&self) -> &str {
                match self {
                    ErrorReason::Failed => "Failed",
                    ErrorReason::Aborted => "Aborted",
                    ErrorReason::TimedOut => "TimedOut",
                    ErrorReason::AccessDenied => "AccessDenied",
                    ErrorReason::ConnectionClosed => "ConnectionClosed",
                    ErrorReason::ConnectionReset => "ConnectionReset",
                    ErrorReason::ConnectionRefused => "ConnectionRefused",
                    ErrorReason::ConnectionAborted => "ConnectionAborted",
                    ErrorReason::ConnectionFailed => "ConnectionFailed",
                    ErrorReason::NameNotResolved => "NameNotResolved",
                    ErrorReason::InternetDisconnected => "InternetDisconnected",
                    ErrorReason::AddressUnreachable => "AddressUnreachable",
                    ErrorReason::BlockedByClient => "BlockedByClient",
                    ErrorReason::BlockedByResponse => "BlockedByResponse",
                }
            }
        }
        impl ::std::str::FromStr for ErrorReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Failed" | "failed" => Ok(ErrorReason::Failed),
                    "Aborted" | "aborted" => Ok(ErrorReason::Aborted),
                    "TimedOut" | "timedout" => Ok(ErrorReason::TimedOut),
                    "AccessDenied" | "accessdenied" => Ok(ErrorReason::AccessDenied),
                    "ConnectionClosed" | "connectionclosed" => Ok(ErrorReason::ConnectionClosed),
                    "ConnectionReset" | "connectionreset" => Ok(ErrorReason::ConnectionReset),
                    "ConnectionRefused" | "connectionrefused" => Ok(ErrorReason::ConnectionRefused),
                    "ConnectionAborted" | "connectionaborted" => Ok(ErrorReason::ConnectionAborted),
                    "ConnectionFailed" | "connectionfailed" => Ok(ErrorReason::ConnectionFailed),
                    "NameNotResolved" | "namenotresolved" => Ok(ErrorReason::NameNotResolved),
                    "InternetDisconnected" | "internetdisconnected" => {
                        Ok(ErrorReason::InternetDisconnected)
                    }
                    "AddressUnreachable" | "addressunreachable" => {
                        Ok(ErrorReason::AddressUnreachable)
                    }
                    "BlockedByClient" | "blockedbyclient" => Ok(ErrorReason::BlockedByClient),
                    "BlockedByResponse" | "blockedbyresponse" => Ok(ErrorReason::BlockedByResponse),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "UTC time in seconds, counted from January 1, 1970.\n[TimeSinceEpoch](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-TimeSinceEpoch)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TimeSinceEpoch(f64);
        impl TimeSinceEpoch {
            pub fn new(val: impl Into<f64>) -> Self {
                TimeSinceEpoch(val.into())
            }
            pub fn inner(&self) -> &f64 {
                &self.0
            }
        }
        impl TimeSinceEpoch {
            pub const IDENTIFIER: &'static str = "Network.TimeSinceEpoch";
        }
        #[doc = "Monotonically increasing time in seconds since an arbitrary point in the past.\n[MonotonicTime](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-MonotonicTime)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct MonotonicTime(f64);
        impl MonotonicTime {
            pub fn new(val: impl Into<f64>) -> Self {
                MonotonicTime(val.into())
            }
            pub fn inner(&self) -> &f64 {
                &self.0
            }
        }
        impl MonotonicTime {
            pub const IDENTIFIER: &'static str = "Network.MonotonicTime";
        }
        #[doc = "Request / response headers as keys / values of JSON object.\n[Headers](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-Headers)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct Headers(serde_json::Value);
        impl Headers {
            pub fn new(val: impl Into<serde_json::Value>) -> Self {
                Headers(val.into())
            }
            pub fn inner(&self) -> &serde_json::Value {
                &self.0
            }
        }
        impl Headers {
            pub const IDENTIFIER: &'static str = "Network.Headers";
        }
        #[doc = "The underlying connection technology that the browser is supposedly using."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ConnectionType {
            #[serde(rename = "none")]
            None,
            #[serde(rename = "cellular2g")]
            Cellular2g,
            #[serde(rename = "cellular3g")]
            Cellular3g,
            #[serde(rename = "cellular4g")]
            Cellular4g,
            #[serde(rename = "bluetooth")]
            Bluetooth,
            #[serde(rename = "ethernet")]
            Ethernet,
            #[serde(rename = "wifi")]
            Wifi,
            #[serde(rename = "wimax")]
            Wimax,
            #[serde(rename = "other")]
            Other,
        }
        impl AsRef<str> for ConnectionType {
            fn as_ref(&self) -> &str {
                match self {
                    ConnectionType::None => "none",
                    ConnectionType::Cellular2g => "cellular2g",
                    ConnectionType::Cellular3g => "cellular3g",
                    ConnectionType::Cellular4g => "cellular4g",
                    ConnectionType::Bluetooth => "bluetooth",
                    ConnectionType::Ethernet => "ethernet",
                    ConnectionType::Wifi => "wifi",
                    ConnectionType::Wimax => "wimax",
                    ConnectionType::Other => "other",
                }
            }
        }
        impl ::std::str::FromStr for ConnectionType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "none" | "None" => Ok(ConnectionType::None),
                    "cellular2g" | "Cellular2g" => Ok(ConnectionType::Cellular2g),
                    "cellular3g" | "Cellular3g" => Ok(ConnectionType::Cellular3g),
                    "cellular4g" | "Cellular4g" => Ok(ConnectionType::Cellular4g),
                    "bluetooth" | "Bluetooth" => Ok(ConnectionType::Bluetooth),
                    "ethernet" | "Ethernet" => Ok(ConnectionType::Ethernet),
                    "wifi" | "Wifi" => Ok(ConnectionType::Wifi),
                    "wimax" | "Wimax" => Ok(ConnectionType::Wimax),
                    "other" | "Other" => Ok(ConnectionType::Other),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Represents the cookie's 'SameSite' status:\nhttps://tools.ietf.org/html/draft-west-first-party-cookies"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CookieSameSite {
            #[serde(rename = "Strict")]
            Strict,
            #[serde(rename = "Lax")]
            Lax,
            #[serde(rename = "None")]
            None,
        }
        impl AsRef<str> for CookieSameSite {
            fn as_ref(&self) -> &str {
                match self {
                    CookieSameSite::Strict => "Strict",
                    CookieSameSite::Lax => "Lax",
                    CookieSameSite::None => "None",
                }
            }
        }
        impl ::std::str::FromStr for CookieSameSite {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Strict" | "strict" => Ok(CookieSameSite::Strict),
                    "Lax" | "lax" => Ok(CookieSameSite::Lax),
                    "None" | "none" => Ok(CookieSameSite::None),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Represents the cookie's 'Priority' status:\nhttps://tools.ietf.org/html/draft-west-cookie-priority-00"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CookiePriority {
            #[serde(rename = "Low")]
            Low,
            #[serde(rename = "Medium")]
            Medium,
            #[serde(rename = "High")]
            High,
        }
        impl AsRef<str> for CookiePriority {
            fn as_ref(&self) -> &str {
                match self {
                    CookiePriority::Low => "Low",
                    CookiePriority::Medium => "Medium",
                    CookiePriority::High => "High",
                }
            }
        }
        impl ::std::str::FromStr for CookiePriority {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Low" | "low" => Ok(CookiePriority::Low),
                    "Medium" | "medium" => Ok(CookiePriority::Medium),
                    "High" | "high" => Ok(CookiePriority::High),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Represents the source scheme of the origin that originally set the cookie.\nA value of \"Unset\" allows protocol clients to emulate legacy cookie scope for the scheme.\nThis is a temporary ability and it will be removed in the future."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CookieSourceScheme {
            #[serde(rename = "Unset")]
            Unset,
            #[serde(rename = "NonSecure")]
            NonSecure,
            #[serde(rename = "Secure")]
            Secure,
        }
        impl AsRef<str> for CookieSourceScheme {
            fn as_ref(&self) -> &str {
                match self {
                    CookieSourceScheme::Unset => "Unset",
                    CookieSourceScheme::NonSecure => "NonSecure",
                    CookieSourceScheme::Secure => "Secure",
                }
            }
        }
        impl ::std::str::FromStr for CookieSourceScheme {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Unset" | "unset" => Ok(CookieSourceScheme::Unset),
                    "NonSecure" | "nonsecure" => Ok(CookieSourceScheme::NonSecure),
                    "Secure" | "secure" => Ok(CookieSourceScheme::Secure),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Timing information for the request.\n[ResourceTiming](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-ResourceTiming)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ResourceTiming {
            #[doc = "Timing's requestTime is a baseline in seconds, while the other numbers are ticks in\nmilliseconds relatively to this requestTime."]
            #[serde(rename = "requestTime")]
            pub request_time: f64,
            #[doc = "Started resolving proxy."]
            #[serde(rename = "proxyStart")]
            pub proxy_start: f64,
            #[doc = "Finished resolving proxy."]
            #[serde(rename = "proxyEnd")]
            pub proxy_end: f64,
            #[doc = "Started DNS address resolve."]
            #[serde(rename = "dnsStart")]
            pub dns_start: f64,
            #[doc = "Finished DNS address resolve."]
            #[serde(rename = "dnsEnd")]
            pub dns_end: f64,
            #[doc = "Started connecting to the remote host."]
            #[serde(rename = "connectStart")]
            pub connect_start: f64,
            #[doc = "Connected to the remote host."]
            #[serde(rename = "connectEnd")]
            pub connect_end: f64,
            #[doc = "Started SSL handshake."]
            #[serde(rename = "sslStart")]
            pub ssl_start: f64,
            #[doc = "Finished SSL handshake."]
            #[serde(rename = "sslEnd")]
            pub ssl_end: f64,
            #[doc = "Started running ServiceWorker."]
            #[serde(rename = "workerStart")]
            pub worker_start: f64,
            #[doc = "Finished Starting ServiceWorker."]
            #[serde(rename = "workerReady")]
            pub worker_ready: f64,
            #[doc = "Started fetch event."]
            #[serde(rename = "workerFetchStart")]
            pub worker_fetch_start: f64,
            #[doc = "Settled fetch event respondWith promise."]
            #[serde(rename = "workerRespondWithSettled")]
            pub worker_respond_with_settled: f64,
            #[doc = "Started sending request."]
            #[serde(rename = "sendStart")]
            pub send_start: f64,
            #[doc = "Finished sending request."]
            #[serde(rename = "sendEnd")]
            pub send_end: f64,
            #[doc = "Time the server started pushing request."]
            #[serde(rename = "pushStart")]
            pub push_start: f64,
            #[doc = "Time the server finished pushing request."]
            #[serde(rename = "pushEnd")]
            pub push_end: f64,
            #[doc = "Finished receiving response headers."]
            #[serde(rename = "receiveHeadersEnd")]
            pub receive_headers_end: f64,
        }
        impl ResourceTiming {
            pub fn builder() -> ResourceTimingBuilder {
                ResourceTimingBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ResourceTimingBuilder {
            request_time: Option<f64>,
            proxy_start: Option<f64>,
            proxy_end: Option<f64>,
            dns_start: Option<f64>,
            dns_end: Option<f64>,
            connect_start: Option<f64>,
            connect_end: Option<f64>,
            ssl_start: Option<f64>,
            ssl_end: Option<f64>,
            worker_start: Option<f64>,
            worker_ready: Option<f64>,
            worker_fetch_start: Option<f64>,
            worker_respond_with_settled: Option<f64>,
            send_start: Option<f64>,
            send_end: Option<f64>,
            push_start: Option<f64>,
            push_end: Option<f64>,
            receive_headers_end: Option<f64>,
        }
        impl ResourceTimingBuilder {
            pub fn request_time(mut self, request_time: impl Into<f64>) -> Self {
                self.request_time = Some(request_time.into());
                self
            }
            pub fn proxy_start(mut self, proxy_start: impl Into<f64>) -> Self {
                self.proxy_start = Some(proxy_start.into());
                self
            }
            pub fn proxy_end(mut self, proxy_end: impl Into<f64>) -> Self {
                self.proxy_end = Some(proxy_end.into());
                self
            }
            pub fn dns_start(mut self, dns_start: impl Into<f64>) -> Self {
                self.dns_start = Some(dns_start.into());
                self
            }
            pub fn dns_end(mut self, dns_end: impl Into<f64>) -> Self {
                self.dns_end = Some(dns_end.into());
                self
            }
            pub fn connect_start(mut self, connect_start: impl Into<f64>) -> Self {
                self.connect_start = Some(connect_start.into());
                self
            }
            pub fn connect_end(mut self, connect_end: impl Into<f64>) -> Self {
                self.connect_end = Some(connect_end.into());
                self
            }
            pub fn ssl_start(mut self, ssl_start: impl Into<f64>) -> Self {
                self.ssl_start = Some(ssl_start.into());
                self
            }
            pub fn ssl_end(mut self, ssl_end: impl Into<f64>) -> Self {
                self.ssl_end = Some(ssl_end.into());
                self
            }
            pub fn worker_start(mut self, worker_start: impl Into<f64>) -> Self {
                self.worker_start = Some(worker_start.into());
                self
            }
            pub fn worker_ready(mut self, worker_ready: impl Into<f64>) -> Self {
                self.worker_ready = Some(worker_ready.into());
                self
            }
            pub fn worker_fetch_start(mut self, worker_fetch_start: impl Into<f64>) -> Self {
                self.worker_fetch_start = Some(worker_fetch_start.into());
                self
            }
            pub fn worker_respond_with_settled(
                mut self,
                worker_respond_with_settled: impl Into<f64>,
            ) -> Self {
                self.worker_respond_with_settled = Some(worker_respond_with_settled.into());
                self
            }
            pub fn send_start(mut self, send_start: impl Into<f64>) -> Self {
                self.send_start = Some(send_start.into());
                self
            }
            pub fn send_end(mut self, send_end: impl Into<f64>) -> Self {
                self.send_end = Some(send_end.into());
                self
            }
            pub fn push_start(mut self, push_start: impl Into<f64>) -> Self {
                self.push_start = Some(push_start.into());
                self
            }
            pub fn push_end(mut self, push_end: impl Into<f64>) -> Self {
                self.push_end = Some(push_end.into());
                self
            }
            pub fn receive_headers_end(mut self, receive_headers_end: impl Into<f64>) -> Self {
                self.receive_headers_end = Some(receive_headers_end.into());
                self
            }
            pub fn build(self) -> Result<ResourceTiming, String> {
                Ok(ResourceTiming {
                    request_time: self.request_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_time))
                    })?,
                    proxy_start: self.proxy_start.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(proxy_start))
                    })?,
                    proxy_end: self.proxy_end.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(proxy_end))
                    })?,
                    dns_start: self.dns_start.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(dns_start))
                    })?,
                    dns_end: self.dns_end.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(dns_end))
                    })?,
                    connect_start: self.connect_start.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(connect_start))
                    })?,
                    connect_end: self.connect_end.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(connect_end))
                    })?,
                    ssl_start: self.ssl_start.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(ssl_start))
                    })?,
                    ssl_end: self.ssl_end.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(ssl_end))
                    })?,
                    worker_start: self.worker_start.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(worker_start))
                    })?,
                    worker_ready: self.worker_ready.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(worker_ready))
                    })?,
                    worker_fetch_start: self.worker_fetch_start.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(worker_fetch_start)
                        )
                    })?,
                    worker_respond_with_settled: self.worker_respond_with_settled.ok_or_else(
                        || {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(worker_respond_with_settled)
                            )
                        },
                    )?,
                    send_start: self.send_start.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(send_start))
                    })?,
                    send_end: self.send_end.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(send_end))
                    })?,
                    push_start: self.push_start.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(push_start))
                    })?,
                    push_end: self.push_end.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(push_end))
                    })?,
                    receive_headers_end: self.receive_headers_end.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(receive_headers_end)
                        )
                    })?,
                })
            }
        }
        impl ResourceTiming {
            pub const IDENTIFIER: &'static str = "Network.ResourceTiming";
        }
        #[doc = "Loading priority of a resource request."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ResourcePriority {
            #[serde(rename = "VeryLow")]
            VeryLow,
            #[serde(rename = "Low")]
            Low,
            #[serde(rename = "Medium")]
            Medium,
            #[serde(rename = "High")]
            High,
            #[serde(rename = "VeryHigh")]
            VeryHigh,
        }
        impl AsRef<str> for ResourcePriority {
            fn as_ref(&self) -> &str {
                match self {
                    ResourcePriority::VeryLow => "VeryLow",
                    ResourcePriority::Low => "Low",
                    ResourcePriority::Medium => "Medium",
                    ResourcePriority::High => "High",
                    ResourcePriority::VeryHigh => "VeryHigh",
                }
            }
        }
        impl ::std::str::FromStr for ResourcePriority {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "VeryLow" | "verylow" => Ok(ResourcePriority::VeryLow),
                    "Low" | "low" => Ok(ResourcePriority::Low),
                    "Medium" | "medium" => Ok(ResourcePriority::Medium),
                    "High" | "high" => Ok(ResourcePriority::High),
                    "VeryHigh" | "veryhigh" => Ok(ResourcePriority::VeryHigh),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Post data entry for HTTP request\n[PostDataEntry](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-PostDataEntry)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct PostDataEntry {
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub bytes: Option<chromiumoxide_types::Binary>,
        }
        impl PostDataEntry {
            pub fn builder() -> PostDataEntryBuilder {
                PostDataEntryBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PostDataEntryBuilder {
            bytes: Option<chromiumoxide_types::Binary>,
        }
        impl PostDataEntryBuilder {
            pub fn bytes(mut self, bytes: impl Into<chromiumoxide_types::Binary>) -> Self {
                self.bytes = Some(bytes.into());
                self
            }
            pub fn build(self) -> PostDataEntry {
                PostDataEntry { bytes: self.bytes }
            }
        }
        impl PostDataEntry {
            pub const IDENTIFIER: &'static str = "Network.PostDataEntry";
        }
        #[doc = "HTTP request data.\n[Request](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-Request)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Request {
            #[doc = "Request URL (without fragment)."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Fragment of the requested URL starting with hash, if present."]
            #[serde(rename = "urlFragment")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url_fragment: Option<String>,
            #[doc = "HTTP request method."]
            #[serde(rename = "method")]
            pub method: String,
            #[doc = "HTTP request headers."]
            #[serde(rename = "headers")]
            pub headers: Headers,
            #[doc = "HTTP POST request data."]
            #[serde(rename = "postData")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub post_data: Option<String>,
            #[doc = "True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long."]
            #[serde(rename = "hasPostData")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub has_post_data: Option<bool>,
            #[doc = "Request body elements. This will be converted from base64 to binary"]
            #[serde(rename = "postDataEntries")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub post_data_entries: Option<Vec<PostDataEntry>>,
            #[doc = "The mixed content type of the request."]
            #[serde(rename = "mixedContentType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub mixed_content_type: Option<super::security::MixedContentType>,
            #[doc = "Priority of the resource request at the time request is sent."]
            #[serde(rename = "initialPriority")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub initial_priority: ResourcePriority,
            #[doc = "The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/"]
            #[serde(rename = "referrerPolicy")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub referrer_policy: RequestReferrerPolicy,
            #[doc = "Whether is loaded via link preload."]
            #[serde(rename = "isLinkPreload")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_link_preload: Option<bool>,
            #[doc = "Set for requests when the TrustToken API is used. Contains the parameters\npassed by the developer (e.g. via \"fetch\") as understood by the backend."]
            #[serde(rename = "trustTokenParams")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub trust_token_params: Option<TrustTokenParams>,
            #[doc = "True if this resource request is considered to be the 'same site' as the\nrequest correspondinfg to the main frame."]
            #[serde(rename = "isSameSite")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_same_site: Option<bool>,
        }
        #[doc = "The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum RequestReferrerPolicy {
            #[serde(rename = "unsafe-url")]
            UnsafeUrl,
            #[serde(rename = "no-referrer-when-downgrade")]
            NoReferrerWhenDowngrade,
            #[serde(rename = "no-referrer")]
            NoReferrer,
            #[serde(rename = "origin")]
            Origin,
            #[serde(rename = "origin-when-cross-origin")]
            OriginWhenCrossOrigin,
            #[serde(rename = "same-origin")]
            SameOrigin,
            #[serde(rename = "strict-origin")]
            StrictOrigin,
            #[serde(rename = "strict-origin-when-cross-origin")]
            StrictOriginWhenCrossOrigin,
        }
        impl AsRef<str> for RequestReferrerPolicy {
            fn as_ref(&self) -> &str {
                match self {
                    RequestReferrerPolicy::UnsafeUrl => "unsafe-url",
                    RequestReferrerPolicy::NoReferrerWhenDowngrade => "no-referrer-when-downgrade",
                    RequestReferrerPolicy::NoReferrer => "no-referrer",
                    RequestReferrerPolicy::Origin => "origin",
                    RequestReferrerPolicy::OriginWhenCrossOrigin => "origin-when-cross-origin",
                    RequestReferrerPolicy::SameOrigin => "same-origin",
                    RequestReferrerPolicy::StrictOrigin => "strict-origin",
                    RequestReferrerPolicy::StrictOriginWhenCrossOrigin => {
                        "strict-origin-when-cross-origin"
                    }
                }
            }
        }
        impl ::std::str::FromStr for RequestReferrerPolicy {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "unsafe-url" | "UnsafeUrl" => Ok(RequestReferrerPolicy::UnsafeUrl),
                    "no-referrer-when-downgrade" | "NoReferrerWhenDowngrade" => {
                        Ok(RequestReferrerPolicy::NoReferrerWhenDowngrade)
                    }
                    "no-referrer" | "NoReferrer" => Ok(RequestReferrerPolicy::NoReferrer),
                    "origin" | "Origin" => Ok(RequestReferrerPolicy::Origin),
                    "origin-when-cross-origin" | "OriginWhenCrossOrigin" => {
                        Ok(RequestReferrerPolicy::OriginWhenCrossOrigin)
                    }
                    "same-origin" | "SameOrigin" => Ok(RequestReferrerPolicy::SameOrigin),
                    "strict-origin" | "StrictOrigin" => Ok(RequestReferrerPolicy::StrictOrigin),
                    "strict-origin-when-cross-origin" | "StrictOriginWhenCrossOrigin" => {
                        Ok(RequestReferrerPolicy::StrictOriginWhenCrossOrigin)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl Request {
            pub fn builder() -> RequestBuilder {
                RequestBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestBuilder {
            url: Option<String>,
            url_fragment: Option<String>,
            method: Option<String>,
            headers: Option<Headers>,
            post_data: Option<String>,
            has_post_data: Option<bool>,
            post_data_entries: Option<Vec<PostDataEntry>>,
            mixed_content_type: Option<super::security::MixedContentType>,
            initial_priority: Option<ResourcePriority>,
            referrer_policy: Option<RequestReferrerPolicy>,
            is_link_preload: Option<bool>,
            trust_token_params: Option<TrustTokenParams>,
            is_same_site: Option<bool>,
        }
        impl RequestBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn url_fragment(mut self, url_fragment: impl Into<String>) -> Self {
                self.url_fragment = Some(url_fragment.into());
                self
            }
            pub fn method(mut self, method: impl Into<String>) -> Self {
                self.method = Some(method.into());
                self
            }
            pub fn headers(mut self, headers: impl Into<Headers>) -> Self {
                self.headers = Some(headers.into());
                self
            }
            pub fn post_data(mut self, post_data: impl Into<String>) -> Self {
                self.post_data = Some(post_data.into());
                self
            }
            pub fn has_post_data(mut self, has_post_data: impl Into<bool>) -> Self {
                self.has_post_data = Some(has_post_data.into());
                self
            }
            pub fn post_data_entrie(mut self, post_data_entrie: impl Into<PostDataEntry>) -> Self {
                let v = self.post_data_entries.get_or_insert(Vec::new());
                v.push(post_data_entrie.into());
                self
            }
            pub fn post_data_entries<I, S>(mut self, post_data_entries: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PostDataEntry>,
            {
                let v = self.post_data_entries.get_or_insert(Vec::new());
                for val in post_data_entries {
                    v.push(val.into());
                }
                self
            }
            pub fn mixed_content_type(
                mut self,
                mixed_content_type: impl Into<super::security::MixedContentType>,
            ) -> Self {
                self.mixed_content_type = Some(mixed_content_type.into());
                self
            }
            pub fn initial_priority(
                mut self,
                initial_priority: impl Into<ResourcePriority>,
            ) -> Self {
                self.initial_priority = Some(initial_priority.into());
                self
            }
            pub fn referrer_policy(
                mut self,
                referrer_policy: impl Into<RequestReferrerPolicy>,
            ) -> Self {
                self.referrer_policy = Some(referrer_policy.into());
                self
            }
            pub fn is_link_preload(mut self, is_link_preload: impl Into<bool>) -> Self {
                self.is_link_preload = Some(is_link_preload.into());
                self
            }
            pub fn trust_token_params(
                mut self,
                trust_token_params: impl Into<TrustTokenParams>,
            ) -> Self {
                self.trust_token_params = Some(trust_token_params.into());
                self
            }
            pub fn is_same_site(mut self, is_same_site: impl Into<bool>) -> Self {
                self.is_same_site = Some(is_same_site.into());
                self
            }
            pub fn build(self) -> Result<Request, String> {
                Ok(Request {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    url_fragment: self.url_fragment,
                    method: self.method.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(method))
                    })?,
                    headers: self.headers.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(headers))
                    })?,
                    post_data: self.post_data,
                    has_post_data: self.has_post_data,
                    post_data_entries: self.post_data_entries,
                    mixed_content_type: self.mixed_content_type,
                    initial_priority: self.initial_priority.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(initial_priority)
                        )
                    })?,
                    referrer_policy: self.referrer_policy.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(referrer_policy))
                    })?,
                    is_link_preload: self.is_link_preload,
                    trust_token_params: self.trust_token_params,
                    is_same_site: self.is_same_site,
                })
            }
        }
        impl Request {
            pub const IDENTIFIER: &'static str = "Network.Request";
        }
        #[doc = "Details of a signed certificate timestamp (SCT).\n[SignedCertificateTimestamp](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-SignedCertificateTimestamp)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SignedCertificateTimestamp {
            #[doc = "Validation status."]
            #[serde(rename = "status")]
            pub status: String,
            #[doc = "Origin."]
            #[serde(rename = "origin")]
            pub origin: String,
            #[doc = "Log name / description."]
            #[serde(rename = "logDescription")]
            pub log_description: String,
            #[doc = "Log ID."]
            #[serde(rename = "logId")]
            pub log_id: String,
            #[doc = "Issuance date. Unlike TimeSinceEpoch, this contains the number of\nmilliseconds since January 1, 1970, UTC, not the number of seconds."]
            #[serde(rename = "timestamp")]
            pub timestamp: f64,
            #[doc = "Hash algorithm."]
            #[serde(rename = "hashAlgorithm")]
            pub hash_algorithm: String,
            #[doc = "Signature algorithm."]
            #[serde(rename = "signatureAlgorithm")]
            pub signature_algorithm: String,
            #[doc = "Signature data."]
            #[serde(rename = "signatureData")]
            pub signature_data: String,
        }
        impl SignedCertificateTimestamp {
            pub fn builder() -> SignedCertificateTimestampBuilder {
                SignedCertificateTimestampBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SignedCertificateTimestampBuilder {
            status: Option<String>,
            origin: Option<String>,
            log_description: Option<String>,
            log_id: Option<String>,
            timestamp: Option<f64>,
            hash_algorithm: Option<String>,
            signature_algorithm: Option<String>,
            signature_data: Option<String>,
        }
        impl SignedCertificateTimestampBuilder {
            pub fn status(mut self, status: impl Into<String>) -> Self {
                self.status = Some(status.into());
                self
            }
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn log_description(mut self, log_description: impl Into<String>) -> Self {
                self.log_description = Some(log_description.into());
                self
            }
            pub fn log_id(mut self, log_id: impl Into<String>) -> Self {
                self.log_id = Some(log_id.into());
                self
            }
            pub fn timestamp(mut self, timestamp: impl Into<f64>) -> Self {
                self.timestamp = Some(timestamp.into());
                self
            }
            pub fn hash_algorithm(mut self, hash_algorithm: impl Into<String>) -> Self {
                self.hash_algorithm = Some(hash_algorithm.into());
                self
            }
            pub fn signature_algorithm(mut self, signature_algorithm: impl Into<String>) -> Self {
                self.signature_algorithm = Some(signature_algorithm.into());
                self
            }
            pub fn signature_data(mut self, signature_data: impl Into<String>) -> Self {
                self.signature_data = Some(signature_data.into());
                self
            }
            pub fn build(self) -> Result<SignedCertificateTimestamp, String> {
                Ok(SignedCertificateTimestamp {
                    status: self.status.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(status))
                    })?,
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    log_description: self.log_description.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(log_description))
                    })?,
                    log_id: self.log_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(log_id))
                    })?,
                    timestamp: self.timestamp.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(timestamp))
                    })?,
                    hash_algorithm: self.hash_algorithm.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(hash_algorithm))
                    })?,
                    signature_algorithm: self.signature_algorithm.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(signature_algorithm)
                        )
                    })?,
                    signature_data: self.signature_data.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(signature_data))
                    })?,
                })
            }
        }
        impl SignedCertificateTimestamp {
            pub const IDENTIFIER: &'static str = "Network.SignedCertificateTimestamp";
        }
        #[doc = "Security details about a request.\n[SecurityDetails](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-SecurityDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SecurityDetails {
            #[doc = "Protocol name (e.g. \"TLS 1.2\" or \"QUIC\")."]
            #[serde(rename = "protocol")]
            pub protocol: String,
            #[doc = "Key Exchange used by the connection, or the empty string if not applicable."]
            #[serde(rename = "keyExchange")]
            pub key_exchange: String,
            #[doc = "(EC)DH group used by the connection, if applicable."]
            #[serde(rename = "keyExchangeGroup")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub key_exchange_group: Option<String>,
            #[doc = "Cipher name."]
            #[serde(rename = "cipher")]
            pub cipher: String,
            #[doc = "TLS MAC. Note that AEAD ciphers do not have separate MACs."]
            #[serde(rename = "mac")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub mac: Option<String>,
            #[doc = "Certificate ID value."]
            #[serde(rename = "certificateId")]
            pub certificate_id: super::security::CertificateId,
            #[doc = "Certificate subject name."]
            #[serde(rename = "subjectName")]
            pub subject_name: String,
            #[doc = "Subject Alternative Name (SAN) DNS names and IP addresses."]
            #[serde(rename = "sanList")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub san_list: Vec<String>,
            #[doc = "Name of the issuing CA."]
            #[serde(rename = "issuer")]
            pub issuer: String,
            #[doc = "Certificate valid from date."]
            #[serde(rename = "validFrom")]
            pub valid_from: TimeSinceEpoch,
            #[doc = "Certificate valid to (expiration) date"]
            #[serde(rename = "validTo")]
            pub valid_to: TimeSinceEpoch,
            #[doc = "List of signed certificate timestamps (SCTs)."]
            #[serde(rename = "signedCertificateTimestampList")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub signed_certificate_timestamp_list: Vec<SignedCertificateTimestamp>,
            #[doc = "Whether the request complied with Certificate Transparency policy"]
            #[serde(rename = "certificateTransparencyCompliance")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub certificate_transparency_compliance: CertificateTransparencyCompliance,
            #[doc = "The signature algorithm used by the server in the TLS server signature,\nrepresented as a TLS SignatureScheme code point. Omitted if not\napplicable or not known."]
            #[serde(rename = "serverSignatureAlgorithm")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub server_signature_algorithm: Option<i64>,
            #[doc = "Whether the connection used Encrypted ClientHello"]
            #[serde(rename = "encryptedClientHello")]
            pub encrypted_client_hello: bool,
        }
        impl SecurityDetails {
            pub fn builder() -> SecurityDetailsBuilder {
                SecurityDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SecurityDetailsBuilder {
            protocol: Option<String>,
            key_exchange: Option<String>,
            key_exchange_group: Option<String>,
            cipher: Option<String>,
            mac: Option<String>,
            certificate_id: Option<super::security::CertificateId>,
            subject_name: Option<String>,
            san_list: Option<Vec<String>>,
            issuer: Option<String>,
            valid_from: Option<TimeSinceEpoch>,
            valid_to: Option<TimeSinceEpoch>,
            signed_certificate_timestamp_list: Option<Vec<SignedCertificateTimestamp>>,
            certificate_transparency_compliance: Option<CertificateTransparencyCompliance>,
            server_signature_algorithm: Option<i64>,
            encrypted_client_hello: Option<bool>,
        }
        impl SecurityDetailsBuilder {
            pub fn protocol(mut self, protocol: impl Into<String>) -> Self {
                self.protocol = Some(protocol.into());
                self
            }
            pub fn key_exchange(mut self, key_exchange: impl Into<String>) -> Self {
                self.key_exchange = Some(key_exchange.into());
                self
            }
            pub fn key_exchange_group(mut self, key_exchange_group: impl Into<String>) -> Self {
                self.key_exchange_group = Some(key_exchange_group.into());
                self
            }
            pub fn cipher(mut self, cipher: impl Into<String>) -> Self {
                self.cipher = Some(cipher.into());
                self
            }
            pub fn mac(mut self, mac: impl Into<String>) -> Self {
                self.mac = Some(mac.into());
                self
            }
            pub fn certificate_id(
                mut self,
                certificate_id: impl Into<super::security::CertificateId>,
            ) -> Self {
                self.certificate_id = Some(certificate_id.into());
                self
            }
            pub fn subject_name(mut self, subject_name: impl Into<String>) -> Self {
                self.subject_name = Some(subject_name.into());
                self
            }
            pub fn san_list(mut self, san_list: impl Into<String>) -> Self {
                let v = self.san_list.get_or_insert(Vec::new());
                v.push(san_list.into());
                self
            }
            pub fn san_lists<I, S>(mut self, san_lists: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.san_list.get_or_insert(Vec::new());
                for val in san_lists {
                    v.push(val.into());
                }
                self
            }
            pub fn issuer(mut self, issuer: impl Into<String>) -> Self {
                self.issuer = Some(issuer.into());
                self
            }
            pub fn valid_from(mut self, valid_from: impl Into<TimeSinceEpoch>) -> Self {
                self.valid_from = Some(valid_from.into());
                self
            }
            pub fn valid_to(mut self, valid_to: impl Into<TimeSinceEpoch>) -> Self {
                self.valid_to = Some(valid_to.into());
                self
            }
            pub fn signed_certificate_timestamp_list(
                mut self,
                signed_certificate_timestamp_list: impl Into<SignedCertificateTimestamp>,
            ) -> Self {
                let v = self
                    .signed_certificate_timestamp_list
                    .get_or_insert(Vec::new());
                v.push(signed_certificate_timestamp_list.into());
                self
            }
            pub fn signed_certificate_timestamp_lists<I, S>(
                mut self,
                signed_certificate_timestamp_lists: I,
            ) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<SignedCertificateTimestamp>,
            {
                let v = self
                    .signed_certificate_timestamp_list
                    .get_or_insert(Vec::new());
                for val in signed_certificate_timestamp_lists {
                    v.push(val.into());
                }
                self
            }
            pub fn certificate_transparency_compliance(
                mut self,
                certificate_transparency_compliance: impl Into<CertificateTransparencyCompliance>,
            ) -> Self {
                self.certificate_transparency_compliance =
                    Some(certificate_transparency_compliance.into());
                self
            }
            pub fn server_signature_algorithm(
                mut self,
                server_signature_algorithm: impl Into<i64>,
            ) -> Self {
                self.server_signature_algorithm = Some(server_signature_algorithm.into());
                self
            }
            pub fn encrypted_client_hello(
                mut self,
                encrypted_client_hello: impl Into<bool>,
            ) -> Self {
                self.encrypted_client_hello = Some(encrypted_client_hello.into());
                self
            }
            pub fn build(self) -> Result<SecurityDetails, String> {
                Ok(SecurityDetails {
                    protocol: self.protocol.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(protocol))
                    })?,
                    key_exchange: self.key_exchange.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(key_exchange))
                    })?,
                    key_exchange_group: self.key_exchange_group,
                    cipher: self.cipher.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cipher))
                    })?,
                    mac: self.mac,
                    certificate_id: self.certificate_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(certificate_id))
                    })?,
                    subject_name: self.subject_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(subject_name))
                    })?,
                    san_list: self.san_list.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(san_list))
                    })?,
                    issuer: self.issuer.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(issuer))
                    })?,
                    valid_from: self.valid_from.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(valid_from))
                    })?,
                    valid_to: self.valid_to.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(valid_to))
                    })?,
                    signed_certificate_timestamp_list: self
                        .signed_certificate_timestamp_list
                        .ok_or_else(|| {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(signed_certificate_timestamp_list)
                            )
                        })?,
                    certificate_transparency_compliance: self
                        .certificate_transparency_compliance
                        .ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(certificate_transparency_compliance)
                        )
                    })?,
                    server_signature_algorithm: self.server_signature_algorithm,
                    encrypted_client_hello: self.encrypted_client_hello.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(encrypted_client_hello)
                        )
                    })?,
                })
            }
        }
        impl SecurityDetails {
            pub const IDENTIFIER: &'static str = "Network.SecurityDetails";
        }
        #[doc = "Whether the request complied with Certificate Transparency policy."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CertificateTransparencyCompliance {
            #[serde(rename = "unknown")]
            Unknown,
            #[serde(rename = "not-compliant")]
            NotCompliant,
            #[serde(rename = "compliant")]
            Compliant,
        }
        impl AsRef<str> for CertificateTransparencyCompliance {
            fn as_ref(&self) -> &str {
                match self {
                    CertificateTransparencyCompliance::Unknown => "unknown",
                    CertificateTransparencyCompliance::NotCompliant => "not-compliant",
                    CertificateTransparencyCompliance::Compliant => "compliant",
                }
            }
        }
        impl ::std::str::FromStr for CertificateTransparencyCompliance {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "unknown" | "Unknown" => Ok(CertificateTransparencyCompliance::Unknown),
                    "not-compliant" | "NotCompliant" => {
                        Ok(CertificateTransparencyCompliance::NotCompliant)
                    }
                    "compliant" | "Compliant" => Ok(CertificateTransparencyCompliance::Compliant),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "The reason why request was blocked."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum BlockedReason {
            #[serde(rename = "other")]
            Other,
            #[serde(rename = "csp")]
            Csp,
            #[serde(rename = "mixed-content")]
            MixedContent,
            #[serde(rename = "origin")]
            Origin,
            #[serde(rename = "inspector")]
            Inspector,
            #[serde(rename = "subresource-filter")]
            SubresourceFilter,
            #[serde(rename = "content-type")]
            ContentType,
            #[serde(rename = "coep-frame-resource-needs-coep-header")]
            CoepFrameResourceNeedsCoepHeader,
            #[serde(rename = "coop-sandboxed-iframe-cannot-navigate-to-coop-page")]
            CoopSandboxedIframeCannotNavigateToCoopPage,
            #[serde(rename = "corp-not-same-origin")]
            CorpNotSameOrigin,
            #[serde(rename = "corp-not-same-origin-after-defaulted-to-same-origin-by-coep")]
            CorpNotSameOriginAfterDefaultedToSameOriginByCoep,
            #[serde(rename = "corp-not-same-site")]
            CorpNotSameSite,
        }
        impl AsRef<str> for BlockedReason {
            fn as_ref(&self) -> &str {
                match self {
                    BlockedReason::Other => "other",
                    BlockedReason::Csp => "csp",
                    BlockedReason::MixedContent => "mixed-content",
                    BlockedReason::Origin => "origin",
                    BlockedReason::Inspector => "inspector",
                    BlockedReason::SubresourceFilter => "subresource-filter",
                    BlockedReason::ContentType => "content-type",
                    BlockedReason::CoepFrameResourceNeedsCoepHeader => {
                        "coep-frame-resource-needs-coep-header"
                    }
                    BlockedReason::CoopSandboxedIframeCannotNavigateToCoopPage => {
                        "coop-sandboxed-iframe-cannot-navigate-to-coop-page"
                    }
                    BlockedReason::CorpNotSameOrigin => "corp-not-same-origin",
                    BlockedReason::CorpNotSameOriginAfterDefaultedToSameOriginByCoep => {
                        "corp-not-same-origin-after-defaulted-to-same-origin-by-coep"
                    }
                    BlockedReason::CorpNotSameSite => "corp-not-same-site",
                }
            }
        }
        impl ::std::str::FromStr for BlockedReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "other" | "Other" => Ok(BlockedReason::Other),
                    "csp" | "Csp" => Ok(BlockedReason::Csp),
                    "mixed-content" | "MixedContent" => Ok(BlockedReason::MixedContent),
                    "origin" | "Origin" => Ok(BlockedReason::Origin),
                    "inspector" | "Inspector" => Ok(BlockedReason::Inspector),
                    "subresource-filter" | "SubresourceFilter" => {
                        Ok(BlockedReason::SubresourceFilter)
                    }
                    "content-type" | "ContentType" => Ok(BlockedReason::ContentType),
                    "coep-frame-resource-needs-coep-header"
                    | "CoepFrameResourceNeedsCoepHeader" => {
                        Ok(BlockedReason::CoepFrameResourceNeedsCoepHeader)
                    }
                    "coop-sandboxed-iframe-cannot-navigate-to-coop-page"
                    | "CoopSandboxedIframeCannotNavigateToCoopPage" => {
                        Ok(BlockedReason::CoopSandboxedIframeCannotNavigateToCoopPage)
                    }
                    "corp-not-same-origin" | "CorpNotSameOrigin" => {
                        Ok(BlockedReason::CorpNotSameOrigin)
                    }
                    "corp-not-same-origin-after-defaulted-to-same-origin-by-coep"
                    | "CorpNotSameOriginAfterDefaultedToSameOriginByCoep" => {
                        Ok(BlockedReason::CorpNotSameOriginAfterDefaultedToSameOriginByCoep)
                    }
                    "corp-not-same-site" | "CorpNotSameSite" => Ok(BlockedReason::CorpNotSameSite),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "The reason why request was blocked."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CorsError {
            #[serde(rename = "DisallowedByMode")]
            DisallowedByMode,
            #[serde(rename = "InvalidResponse")]
            InvalidResponse,
            #[serde(rename = "WildcardOriginNotAllowed")]
            WildcardOriginNotAllowed,
            #[serde(rename = "MissingAllowOriginHeader")]
            MissingAllowOriginHeader,
            #[serde(rename = "MultipleAllowOriginValues")]
            MultipleAllowOriginValues,
            #[serde(rename = "InvalidAllowOriginValue")]
            InvalidAllowOriginValue,
            #[serde(rename = "AllowOriginMismatch")]
            AllowOriginMismatch,
            #[serde(rename = "InvalidAllowCredentials")]
            InvalidAllowCredentials,
            #[serde(rename = "CorsDisabledScheme")]
            CorsDisabledScheme,
            #[serde(rename = "PreflightInvalidStatus")]
            PreflightInvalidStatus,
            #[serde(rename = "PreflightDisallowedRedirect")]
            PreflightDisallowedRedirect,
            #[serde(rename = "PreflightWildcardOriginNotAllowed")]
            PreflightWildcardOriginNotAllowed,
            #[serde(rename = "PreflightMissingAllowOriginHeader")]
            PreflightMissingAllowOriginHeader,
            #[serde(rename = "PreflightMultipleAllowOriginValues")]
            PreflightMultipleAllowOriginValues,
            #[serde(rename = "PreflightInvalidAllowOriginValue")]
            PreflightInvalidAllowOriginValue,
            #[serde(rename = "PreflightAllowOriginMismatch")]
            PreflightAllowOriginMismatch,
            #[serde(rename = "PreflightInvalidAllowCredentials")]
            PreflightInvalidAllowCredentials,
            #[doc = "TODO(https://crbug.com/1263483): Remove this once frontend code does\nnot reference it anymore."]
            #[serde(rename = "PreflightMissingAllowExternal")]
            PreflightMissingAllowExternal,
            #[doc = "TODO(https://crbug.com/1263483): Remove this once frontend code does\nnot reference it anymore."]
            #[serde(rename = "PreflightInvalidAllowExternal")]
            PreflightInvalidAllowExternal,
            #[serde(rename = "PreflightMissingAllowPrivateNetwork")]
            PreflightMissingAllowPrivateNetwork,
            #[serde(rename = "PreflightInvalidAllowPrivateNetwork")]
            PreflightInvalidAllowPrivateNetwork,
            #[serde(rename = "InvalidAllowMethodsPreflightResponse")]
            InvalidAllowMethodsPreflightResponse,
            #[serde(rename = "InvalidAllowHeadersPreflightResponse")]
            InvalidAllowHeadersPreflightResponse,
            #[serde(rename = "MethodDisallowedByPreflightResponse")]
            MethodDisallowedByPreflightResponse,
            #[serde(rename = "HeaderDisallowedByPreflightResponse")]
            HeaderDisallowedByPreflightResponse,
            #[serde(rename = "RedirectContainsCredentials")]
            RedirectContainsCredentials,
            #[doc = "Request was a private network request initiated by a non-secure context."]
            #[serde(rename = "InsecurePrivateNetwork")]
            InsecurePrivateNetwork,
            #[doc = "Request carried a target IP address space property that did not match\nthe target resource's address space."]
            #[serde(rename = "InvalidPrivateNetworkAccess")]
            InvalidPrivateNetworkAccess,
            #[doc = "Request was a private network request yet did not carry a target IP\naddress space."]
            #[serde(rename = "UnexpectedPrivateNetworkAccess")]
            UnexpectedPrivateNetworkAccess,
            #[serde(rename = "NoCorsRedirectModeNotFollow")]
            NoCorsRedirectModeNotFollow,
        }
        impl AsRef<str> for CorsError {
            fn as_ref(&self) -> &str {
                match self {
                    CorsError::DisallowedByMode => "DisallowedByMode",
                    CorsError::InvalidResponse => "InvalidResponse",
                    CorsError::WildcardOriginNotAllowed => "WildcardOriginNotAllowed",
                    CorsError::MissingAllowOriginHeader => "MissingAllowOriginHeader",
                    CorsError::MultipleAllowOriginValues => "MultipleAllowOriginValues",
                    CorsError::InvalidAllowOriginValue => "InvalidAllowOriginValue",
                    CorsError::AllowOriginMismatch => "AllowOriginMismatch",
                    CorsError::InvalidAllowCredentials => "InvalidAllowCredentials",
                    CorsError::CorsDisabledScheme => "CorsDisabledScheme",
                    CorsError::PreflightInvalidStatus => "PreflightInvalidStatus",
                    CorsError::PreflightDisallowedRedirect => "PreflightDisallowedRedirect",
                    CorsError::PreflightWildcardOriginNotAllowed => {
                        "PreflightWildcardOriginNotAllowed"
                    }
                    CorsError::PreflightMissingAllowOriginHeader => {
                        "PreflightMissingAllowOriginHeader"
                    }
                    CorsError::PreflightMultipleAllowOriginValues => {
                        "PreflightMultipleAllowOriginValues"
                    }
                    CorsError::PreflightInvalidAllowOriginValue => {
                        "PreflightInvalidAllowOriginValue"
                    }
                    CorsError::PreflightAllowOriginMismatch => "PreflightAllowOriginMismatch",
                    CorsError::PreflightInvalidAllowCredentials => {
                        "PreflightInvalidAllowCredentials"
                    }
                    CorsError::PreflightMissingAllowExternal => "PreflightMissingAllowExternal",
                    CorsError::PreflightInvalidAllowExternal => "PreflightInvalidAllowExternal",
                    CorsError::PreflightMissingAllowPrivateNetwork => {
                        "PreflightMissingAllowPrivateNetwork"
                    }
                    CorsError::PreflightInvalidAllowPrivateNetwork => {
                        "PreflightInvalidAllowPrivateNetwork"
                    }
                    CorsError::InvalidAllowMethodsPreflightResponse => {
                        "InvalidAllowMethodsPreflightResponse"
                    }
                    CorsError::InvalidAllowHeadersPreflightResponse => {
                        "InvalidAllowHeadersPreflightResponse"
                    }
                    CorsError::MethodDisallowedByPreflightResponse => {
                        "MethodDisallowedByPreflightResponse"
                    }
                    CorsError::HeaderDisallowedByPreflightResponse => {
                        "HeaderDisallowedByPreflightResponse"
                    }
                    CorsError::RedirectContainsCredentials => "RedirectContainsCredentials",
                    CorsError::InsecurePrivateNetwork => "InsecurePrivateNetwork",
                    CorsError::InvalidPrivateNetworkAccess => "InvalidPrivateNetworkAccess",
                    CorsError::UnexpectedPrivateNetworkAccess => "UnexpectedPrivateNetworkAccess",
                    CorsError::NoCorsRedirectModeNotFollow => "NoCorsRedirectModeNotFollow",
                }
            }
        }
        impl ::std::str::FromStr for CorsError {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "DisallowedByMode" | "disallowedbymode" => Ok(CorsError::DisallowedByMode),
                    "InvalidResponse" | "invalidresponse" => Ok(CorsError::InvalidResponse),
                    "WildcardOriginNotAllowed" | "wildcardoriginnotallowed" => {
                        Ok(CorsError::WildcardOriginNotAllowed)
                    }
                    "MissingAllowOriginHeader" | "missingalloworiginheader" => {
                        Ok(CorsError::MissingAllowOriginHeader)
                    }
                    "MultipleAllowOriginValues" | "multiplealloworiginvalues" => {
                        Ok(CorsError::MultipleAllowOriginValues)
                    }
                    "InvalidAllowOriginValue" | "invalidalloworiginvalue" => {
                        Ok(CorsError::InvalidAllowOriginValue)
                    }
                    "AllowOriginMismatch" | "alloworiginmismatch" => {
                        Ok(CorsError::AllowOriginMismatch)
                    }
                    "InvalidAllowCredentials" | "invalidallowcredentials" => {
                        Ok(CorsError::InvalidAllowCredentials)
                    }
                    "CorsDisabledScheme" | "corsdisabledscheme" => {
                        Ok(CorsError::CorsDisabledScheme)
                    }
                    "PreflightInvalidStatus" | "preflightinvalidstatus" => {
                        Ok(CorsError::PreflightInvalidStatus)
                    }
                    "PreflightDisallowedRedirect" | "preflightdisallowedredirect" => {
                        Ok(CorsError::PreflightDisallowedRedirect)
                    }
                    "PreflightWildcardOriginNotAllowed" | "preflightwildcardoriginnotallowed" => {
                        Ok(CorsError::PreflightWildcardOriginNotAllowed)
                    }
                    "PreflightMissingAllowOriginHeader" | "preflightmissingalloworiginheader" => {
                        Ok(CorsError::PreflightMissingAllowOriginHeader)
                    }
                    "PreflightMultipleAllowOriginValues" | "preflightmultiplealloworiginvalues" => {
                        Ok(CorsError::PreflightMultipleAllowOriginValues)
                    }
                    "PreflightInvalidAllowOriginValue" | "preflightinvalidalloworiginvalue" => {
                        Ok(CorsError::PreflightInvalidAllowOriginValue)
                    }
                    "PreflightAllowOriginMismatch" | "preflightalloworiginmismatch" => {
                        Ok(CorsError::PreflightAllowOriginMismatch)
                    }
                    "PreflightInvalidAllowCredentials" | "preflightinvalidallowcredentials" => {
                        Ok(CorsError::PreflightInvalidAllowCredentials)
                    }
                    "PreflightMissingAllowExternal" | "preflightmissingallowexternal" => {
                        Ok(CorsError::PreflightMissingAllowExternal)
                    }
                    "PreflightInvalidAllowExternal" | "preflightinvalidallowexternal" => {
                        Ok(CorsError::PreflightInvalidAllowExternal)
                    }
                    "PreflightMissingAllowPrivateNetwork"
                    | "preflightmissingallowprivatenetwork" => {
                        Ok(CorsError::PreflightMissingAllowPrivateNetwork)
                    }
                    "PreflightInvalidAllowPrivateNetwork"
                    | "preflightinvalidallowprivatenetwork" => {
                        Ok(CorsError::PreflightInvalidAllowPrivateNetwork)
                    }
                    "InvalidAllowMethodsPreflightResponse"
                    | "invalidallowmethodspreflightresponse" => {
                        Ok(CorsError::InvalidAllowMethodsPreflightResponse)
                    }
                    "InvalidAllowHeadersPreflightResponse"
                    | "invalidallowheaderspreflightresponse" => {
                        Ok(CorsError::InvalidAllowHeadersPreflightResponse)
                    }
                    "MethodDisallowedByPreflightResponse"
                    | "methoddisallowedbypreflightresponse" => {
                        Ok(CorsError::MethodDisallowedByPreflightResponse)
                    }
                    "HeaderDisallowedByPreflightResponse"
                    | "headerdisallowedbypreflightresponse" => {
                        Ok(CorsError::HeaderDisallowedByPreflightResponse)
                    }
                    "RedirectContainsCredentials" | "redirectcontainscredentials" => {
                        Ok(CorsError::RedirectContainsCredentials)
                    }
                    "InsecurePrivateNetwork" | "insecureprivatenetwork" => {
                        Ok(CorsError::InsecurePrivateNetwork)
                    }
                    "InvalidPrivateNetworkAccess" | "invalidprivatenetworkaccess" => {
                        Ok(CorsError::InvalidPrivateNetworkAccess)
                    }
                    "UnexpectedPrivateNetworkAccess" | "unexpectedprivatenetworkaccess" => {
                        Ok(CorsError::UnexpectedPrivateNetworkAccess)
                    }
                    "NoCorsRedirectModeNotFollow" | "nocorsredirectmodenotfollow" => {
                        Ok(CorsError::NoCorsRedirectModeNotFollow)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CorsErrorStatus {
            #[serde(rename = "corsError")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub cors_error: CorsError,
            #[serde(rename = "failedParameter")]
            pub failed_parameter: String,
        }
        impl CorsErrorStatus {
            pub fn new(
                cors_error: impl Into<CorsError>,
                failed_parameter: impl Into<String>,
            ) -> Self {
                Self {
                    cors_error: cors_error.into(),
                    failed_parameter: failed_parameter.into(),
                }
            }
        }
        impl CorsErrorStatus {
            pub fn builder() -> CorsErrorStatusBuilder {
                CorsErrorStatusBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CorsErrorStatusBuilder {
            cors_error: Option<CorsError>,
            failed_parameter: Option<String>,
        }
        impl CorsErrorStatusBuilder {
            pub fn cors_error(mut self, cors_error: impl Into<CorsError>) -> Self {
                self.cors_error = Some(cors_error.into());
                self
            }
            pub fn failed_parameter(mut self, failed_parameter: impl Into<String>) -> Self {
                self.failed_parameter = Some(failed_parameter.into());
                self
            }
            pub fn build(self) -> Result<CorsErrorStatus, String> {
                Ok(CorsErrorStatus {
                    cors_error: self.cors_error.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cors_error))
                    })?,
                    failed_parameter: self.failed_parameter.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(failed_parameter)
                        )
                    })?,
                })
            }
        }
        impl CorsErrorStatus {
            pub const IDENTIFIER: &'static str = "Network.CorsErrorStatus";
        }
        #[doc = "Source of serviceworker response."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ServiceWorkerResponseSource {
            #[serde(rename = "cache-storage")]
            CacheStorage,
            #[serde(rename = "http-cache")]
            HttpCache,
            #[serde(rename = "fallback-code")]
            FallbackCode,
            #[serde(rename = "network")]
            Network,
        }
        impl AsRef<str> for ServiceWorkerResponseSource {
            fn as_ref(&self) -> &str {
                match self {
                    ServiceWorkerResponseSource::CacheStorage => "cache-storage",
                    ServiceWorkerResponseSource::HttpCache => "http-cache",
                    ServiceWorkerResponseSource::FallbackCode => "fallback-code",
                    ServiceWorkerResponseSource::Network => "network",
                }
            }
        }
        impl ::std::str::FromStr for ServiceWorkerResponseSource {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "cache-storage" | "CacheStorage" => {
                        Ok(ServiceWorkerResponseSource::CacheStorage)
                    }
                    "http-cache" | "HttpCache" => Ok(ServiceWorkerResponseSource::HttpCache),
                    "fallback-code" | "FallbackCode" => {
                        Ok(ServiceWorkerResponseSource::FallbackCode)
                    }
                    "network" | "Network" => Ok(ServiceWorkerResponseSource::Network),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Determines what type of Trust Token operation is executed and\ndepending on the type, some additional parameters. The values\nare specified in third_party/blink/renderer/core/fetch/trust_token.idl.\n[TrustTokenParams](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-TrustTokenParams)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TrustTokenParams {
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: TrustTokenOperationType,
            #[doc = "Only set for \"token-redemption\" type and determine whether\nto request a fresh SRR or use a still valid cached SRR."]
            #[serde(rename = "refreshPolicy")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub refresh_policy: TrustTokenParamsRefreshPolicy,
            #[doc = "Origins of issuers from whom to request tokens or redemption\nrecords."]
            #[serde(rename = "issuers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub issuers: Option<Vec<String>>,
        }
        #[doc = "Only set for \"token-redemption\" type and determine whether\nto request a fresh SRR or use a still valid cached SRR."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum TrustTokenParamsRefreshPolicy {
            #[serde(rename = "UseCached")]
            UseCached,
            #[serde(rename = "Refresh")]
            Refresh,
        }
        impl AsRef<str> for TrustTokenParamsRefreshPolicy {
            fn as_ref(&self) -> &str {
                match self {
                    TrustTokenParamsRefreshPolicy::UseCached => "UseCached",
                    TrustTokenParamsRefreshPolicy::Refresh => "Refresh",
                }
            }
        }
        impl ::std::str::FromStr for TrustTokenParamsRefreshPolicy {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "UseCached" | "usecached" => Ok(TrustTokenParamsRefreshPolicy::UseCached),
                    "Refresh" | "refresh" => Ok(TrustTokenParamsRefreshPolicy::Refresh),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl TrustTokenParams {
            pub fn new(
                r#type: impl Into<TrustTokenOperationType>,
                refresh_policy: impl Into<TrustTokenParamsRefreshPolicy>,
            ) -> Self {
                Self {
                    r#type: r#type.into(),
                    refresh_policy: refresh_policy.into(),
                    issuers: None,
                }
            }
        }
        impl TrustTokenParams {
            pub fn builder() -> TrustTokenParamsBuilder {
                TrustTokenParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TrustTokenParamsBuilder {
            r#type: Option<TrustTokenOperationType>,
            refresh_policy: Option<TrustTokenParamsRefreshPolicy>,
            issuers: Option<Vec<String>>,
        }
        impl TrustTokenParamsBuilder {
            pub fn r#type(mut self, r#type: impl Into<TrustTokenOperationType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn refresh_policy(
                mut self,
                refresh_policy: impl Into<TrustTokenParamsRefreshPolicy>,
            ) -> Self {
                self.refresh_policy = Some(refresh_policy.into());
                self
            }
            pub fn issuer(mut self, issuer: impl Into<String>) -> Self {
                let v = self.issuers.get_or_insert(Vec::new());
                v.push(issuer.into());
                self
            }
            pub fn issuers<I, S>(mut self, issuers: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.issuers.get_or_insert(Vec::new());
                for val in issuers {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<TrustTokenParams, String> {
                Ok(TrustTokenParams {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    refresh_policy: self.refresh_policy.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(refresh_policy))
                    })?,
                    issuers: self.issuers,
                })
            }
        }
        impl TrustTokenParams {
            pub const IDENTIFIER: &'static str = "Network.TrustTokenParams";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum TrustTokenOperationType {
            #[doc = "Type \"token-request\" in the Trust Token API."]
            #[serde(rename = "Issuance")]
            Issuance,
            #[doc = "Type \"token-redemption\" in the Trust Token API."]
            #[serde(rename = "Redemption")]
            Redemption,
            #[doc = "Type \"send-redemption-record\" in the Trust Token API."]
            #[serde(rename = "Signing")]
            Signing,
        }
        impl AsRef<str> for TrustTokenOperationType {
            fn as_ref(&self) -> &str {
                match self {
                    TrustTokenOperationType::Issuance => "Issuance",
                    TrustTokenOperationType::Redemption => "Redemption",
                    TrustTokenOperationType::Signing => "Signing",
                }
            }
        }
        impl ::std::str::FromStr for TrustTokenOperationType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Issuance" | "issuance" => Ok(TrustTokenOperationType::Issuance),
                    "Redemption" | "redemption" => Ok(TrustTokenOperationType::Redemption),
                    "Signing" | "signing" => Ok(TrustTokenOperationType::Signing),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "HTTP response data.\n[Response](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-Response)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Response {
            #[doc = "Response URL. This URL can be different from CachedResource.url in case of redirect."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "HTTP response status code."]
            #[serde(rename = "status")]
            pub status: i64,
            #[doc = "HTTP response status text."]
            #[serde(rename = "statusText")]
            pub status_text: String,
            #[doc = "HTTP response headers."]
            #[serde(rename = "headers")]
            pub headers: Headers,
            #[doc = "Resource mimeType as determined by the browser."]
            #[serde(rename = "mimeType")]
            pub mime_type: String,
            #[doc = "Refined HTTP request headers that were actually transmitted over the network."]
            #[serde(rename = "requestHeaders")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub request_headers: Option<Headers>,
            #[doc = "Specifies whether physical connection was actually reused for this request."]
            #[serde(rename = "connectionReused")]
            pub connection_reused: bool,
            #[doc = "Physical connection id that was actually used for this request."]
            #[serde(rename = "connectionId")]
            pub connection_id: f64,
            #[doc = "Remote IP address."]
            #[serde(rename = "remoteIPAddress")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub remote_ip_address: Option<String>,
            #[doc = "Remote port."]
            #[serde(rename = "remotePort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub remote_port: Option<i64>,
            #[doc = "Specifies that the request was served from the disk cache."]
            #[serde(rename = "fromDiskCache")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub from_disk_cache: Option<bool>,
            #[doc = "Specifies that the request was served from the ServiceWorker."]
            #[serde(rename = "fromServiceWorker")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub from_service_worker: Option<bool>,
            #[doc = "Specifies that the request was served from the prefetch cache."]
            #[serde(rename = "fromPrefetchCache")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub from_prefetch_cache: Option<bool>,
            #[doc = "Total number of bytes received for this request so far."]
            #[serde(rename = "encodedDataLength")]
            pub encoded_data_length: f64,
            #[doc = "Timing information for the given request."]
            #[serde(rename = "timing")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub timing: Option<ResourceTiming>,
            #[doc = "Response source of response from ServiceWorker."]
            #[serde(rename = "serviceWorkerResponseSource")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub service_worker_response_source: Option<ServiceWorkerResponseSource>,
            #[doc = "The time at which the returned response was generated."]
            #[serde(rename = "responseTime")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub response_time: Option<TimeSinceEpoch>,
            #[doc = "Cache Storage Cache Name."]
            #[serde(rename = "cacheStorageCacheName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub cache_storage_cache_name: Option<String>,
            #[doc = "Protocol used to fetch this request."]
            #[serde(rename = "protocol")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub protocol: Option<String>,
            #[doc = "Security state of the request resource."]
            #[serde(rename = "securityState")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub security_state: super::security::SecurityState,
            #[doc = "Security details for the request."]
            #[serde(rename = "securityDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub security_details: Option<SecurityDetails>,
        }
        impl Response {
            pub fn builder() -> ResponseBuilder {
                ResponseBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ResponseBuilder {
            url: Option<String>,
            status: Option<i64>,
            status_text: Option<String>,
            headers: Option<Headers>,
            mime_type: Option<String>,
            request_headers: Option<Headers>,
            connection_reused: Option<bool>,
            connection_id: Option<f64>,
            remote_ip_address: Option<String>,
            remote_port: Option<i64>,
            from_disk_cache: Option<bool>,
            from_service_worker: Option<bool>,
            from_prefetch_cache: Option<bool>,
            encoded_data_length: Option<f64>,
            timing: Option<ResourceTiming>,
            service_worker_response_source: Option<ServiceWorkerResponseSource>,
            response_time: Option<TimeSinceEpoch>,
            cache_storage_cache_name: Option<String>,
            protocol: Option<String>,
            security_state: Option<super::security::SecurityState>,
            security_details: Option<SecurityDetails>,
        }
        impl ResponseBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn status(mut self, status: impl Into<i64>) -> Self {
                self.status = Some(status.into());
                self
            }
            pub fn status_text(mut self, status_text: impl Into<String>) -> Self {
                self.status_text = Some(status_text.into());
                self
            }
            pub fn headers(mut self, headers: impl Into<Headers>) -> Self {
                self.headers = Some(headers.into());
                self
            }
            pub fn mime_type(mut self, mime_type: impl Into<String>) -> Self {
                self.mime_type = Some(mime_type.into());
                self
            }
            pub fn request_headers(mut self, request_headers: impl Into<Headers>) -> Self {
                self.request_headers = Some(request_headers.into());
                self
            }
            pub fn connection_reused(mut self, connection_reused: impl Into<bool>) -> Self {
                self.connection_reused = Some(connection_reused.into());
                self
            }
            pub fn connection_id(mut self, connection_id: impl Into<f64>) -> Self {
                self.connection_id = Some(connection_id.into());
                self
            }
            pub fn remote_ip_address(mut self, remote_ip_address: impl Into<String>) -> Self {
                self.remote_ip_address = Some(remote_ip_address.into());
                self
            }
            pub fn remote_port(mut self, remote_port: impl Into<i64>) -> Self {
                self.remote_port = Some(remote_port.into());
                self
            }
            pub fn from_disk_cache(mut self, from_disk_cache: impl Into<bool>) -> Self {
                self.from_disk_cache = Some(from_disk_cache.into());
                self
            }
            pub fn from_service_worker(mut self, from_service_worker: impl Into<bool>) -> Self {
                self.from_service_worker = Some(from_service_worker.into());
                self
            }
            pub fn from_prefetch_cache(mut self, from_prefetch_cache: impl Into<bool>) -> Self {
                self.from_prefetch_cache = Some(from_prefetch_cache.into());
                self
            }
            pub fn encoded_data_length(mut self, encoded_data_length: impl Into<f64>) -> Self {
                self.encoded_data_length = Some(encoded_data_length.into());
                self
            }
            pub fn timing(mut self, timing: impl Into<ResourceTiming>) -> Self {
                self.timing = Some(timing.into());
                self
            }
            pub fn service_worker_response_source(
                mut self,
                service_worker_response_source: impl Into<ServiceWorkerResponseSource>,
            ) -> Self {
                self.service_worker_response_source = Some(service_worker_response_source.into());
                self
            }
            pub fn response_time(mut self, response_time: impl Into<TimeSinceEpoch>) -> Self {
                self.response_time = Some(response_time.into());
                self
            }
            pub fn cache_storage_cache_name(
                mut self,
                cache_storage_cache_name: impl Into<String>,
            ) -> Self {
                self.cache_storage_cache_name = Some(cache_storage_cache_name.into());
                self
            }
            pub fn protocol(mut self, protocol: impl Into<String>) -> Self {
                self.protocol = Some(protocol.into());
                self
            }
            pub fn security_state(
                mut self,
                security_state: impl Into<super::security::SecurityState>,
            ) -> Self {
                self.security_state = Some(security_state.into());
                self
            }
            pub fn security_details(
                mut self,
                security_details: impl Into<SecurityDetails>,
            ) -> Self {
                self.security_details = Some(security_details.into());
                self
            }
            pub fn build(self) -> Result<Response, String> {
                Ok(Response {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    status: self.status.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(status))
                    })?,
                    status_text: self.status_text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(status_text))
                    })?,
                    headers: self.headers.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(headers))
                    })?,
                    mime_type: self.mime_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(mime_type))
                    })?,
                    request_headers: self.request_headers,
                    connection_reused: self.connection_reused.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(connection_reused)
                        )
                    })?,
                    connection_id: self.connection_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(connection_id))
                    })?,
                    remote_ip_address: self.remote_ip_address,
                    remote_port: self.remote_port,
                    from_disk_cache: self.from_disk_cache,
                    from_service_worker: self.from_service_worker,
                    from_prefetch_cache: self.from_prefetch_cache,
                    encoded_data_length: self.encoded_data_length.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(encoded_data_length)
                        )
                    })?,
                    timing: self.timing,
                    service_worker_response_source: self.service_worker_response_source,
                    response_time: self.response_time,
                    cache_storage_cache_name: self.cache_storage_cache_name,
                    protocol: self.protocol,
                    security_state: self.security_state.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(security_state))
                    })?,
                    security_details: self.security_details,
                })
            }
        }
        impl Response {
            pub const IDENTIFIER: &'static str = "Network.Response";
        }
        #[doc = "WebSocket request data.\n[WebSocketRequest](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-WebSocketRequest)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct WebSocketRequest {
            #[doc = "HTTP request headers."]
            #[serde(rename = "headers")]
            pub headers: Headers,
        }
        impl WebSocketRequest {
            pub fn new(headers: impl Into<Headers>) -> Self {
                Self {
                    headers: headers.into(),
                }
            }
        }
        impl WebSocketRequest {
            pub fn builder() -> WebSocketRequestBuilder {
                WebSocketRequestBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct WebSocketRequestBuilder {
            headers: Option<Headers>,
        }
        impl WebSocketRequestBuilder {
            pub fn headers(mut self, headers: impl Into<Headers>) -> Self {
                self.headers = Some(headers.into());
                self
            }
            pub fn build(self) -> Result<WebSocketRequest, String> {
                Ok(WebSocketRequest {
                    headers: self.headers.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(headers))
                    })?,
                })
            }
        }
        impl WebSocketRequest {
            pub const IDENTIFIER: &'static str = "Network.WebSocketRequest";
        }
        #[doc = "WebSocket response data.\n[WebSocketResponse](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-WebSocketResponse)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct WebSocketResponse {
            #[doc = "HTTP response status code."]
            #[serde(rename = "status")]
            pub status: i64,
            #[doc = "HTTP response status text."]
            #[serde(rename = "statusText")]
            pub status_text: String,
            #[doc = "HTTP response headers."]
            #[serde(rename = "headers")]
            pub headers: Headers,
            #[doc = "HTTP response headers text."]
            #[serde(rename = "headersText")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub headers_text: Option<String>,
            #[doc = "HTTP request headers."]
            #[serde(rename = "requestHeaders")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub request_headers: Option<Headers>,
            #[doc = "HTTP request headers text."]
            #[serde(rename = "requestHeadersText")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub request_headers_text: Option<String>,
        }
        impl WebSocketResponse {
            pub fn new(
                status: impl Into<i64>,
                status_text: impl Into<String>,
                headers: impl Into<Headers>,
            ) -> Self {
                Self {
                    status: status.into(),
                    status_text: status_text.into(),
                    headers: headers.into(),
                    headers_text: None,
                    request_headers: None,
                    request_headers_text: None,
                }
            }
        }
        impl WebSocketResponse {
            pub fn builder() -> WebSocketResponseBuilder {
                WebSocketResponseBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct WebSocketResponseBuilder {
            status: Option<i64>,
            status_text: Option<String>,
            headers: Option<Headers>,
            headers_text: Option<String>,
            request_headers: Option<Headers>,
            request_headers_text: Option<String>,
        }
        impl WebSocketResponseBuilder {
            pub fn status(mut self, status: impl Into<i64>) -> Self {
                self.status = Some(status.into());
                self
            }
            pub fn status_text(mut self, status_text: impl Into<String>) -> Self {
                self.status_text = Some(status_text.into());
                self
            }
            pub fn headers(mut self, headers: impl Into<Headers>) -> Self {
                self.headers = Some(headers.into());
                self
            }
            pub fn headers_text(mut self, headers_text: impl Into<String>) -> Self {
                self.headers_text = Some(headers_text.into());
                self
            }
            pub fn request_headers(mut self, request_headers: impl Into<Headers>) -> Self {
                self.request_headers = Some(request_headers.into());
                self
            }
            pub fn request_headers_text(mut self, request_headers_text: impl Into<String>) -> Self {
                self.request_headers_text = Some(request_headers_text.into());
                self
            }
            pub fn build(self) -> Result<WebSocketResponse, String> {
                Ok(WebSocketResponse {
                    status: self.status.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(status))
                    })?,
                    status_text: self.status_text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(status_text))
                    })?,
                    headers: self.headers.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(headers))
                    })?,
                    headers_text: self.headers_text,
                    request_headers: self.request_headers,
                    request_headers_text: self.request_headers_text,
                })
            }
        }
        impl WebSocketResponse {
            pub const IDENTIFIER: &'static str = "Network.WebSocketResponse";
        }
        #[doc = "WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.\n[WebSocketFrame](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-WebSocketFrame)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct WebSocketFrame {
            #[doc = "WebSocket message opcode."]
            #[serde(rename = "opcode")]
            pub opcode: f64,
            #[doc = "WebSocket message mask."]
            #[serde(rename = "mask")]
            pub mask: bool,
            #[doc = "WebSocket message payload data.\nIf the opcode is 1, this is a text message and payloadData is a UTF-8 string.\nIf the opcode isn't 1, then payloadData is a base64 encoded string representing binary data."]
            #[serde(rename = "payloadData")]
            pub payload_data: String,
        }
        impl WebSocketFrame {
            pub fn new(
                opcode: impl Into<f64>,
                mask: impl Into<bool>,
                payload_data: impl Into<String>,
            ) -> Self {
                Self {
                    opcode: opcode.into(),
                    mask: mask.into(),
                    payload_data: payload_data.into(),
                }
            }
        }
        impl WebSocketFrame {
            pub fn builder() -> WebSocketFrameBuilder {
                WebSocketFrameBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct WebSocketFrameBuilder {
            opcode: Option<f64>,
            mask: Option<bool>,
            payload_data: Option<String>,
        }
        impl WebSocketFrameBuilder {
            pub fn opcode(mut self, opcode: impl Into<f64>) -> Self {
                self.opcode = Some(opcode.into());
                self
            }
            pub fn mask(mut self, mask: impl Into<bool>) -> Self {
                self.mask = Some(mask.into());
                self
            }
            pub fn payload_data(mut self, payload_data: impl Into<String>) -> Self {
                self.payload_data = Some(payload_data.into());
                self
            }
            pub fn build(self) -> Result<WebSocketFrame, String> {
                Ok(WebSocketFrame {
                    opcode: self.opcode.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(opcode))
                    })?,
                    mask: self.mask.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(mask))
                    })?,
                    payload_data: self.payload_data.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(payload_data))
                    })?,
                })
            }
        }
        impl WebSocketFrame {
            pub const IDENTIFIER: &'static str = "Network.WebSocketFrame";
        }
        #[doc = "Information about the cached resource.\n[CachedResource](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-CachedResource)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CachedResource {
            #[doc = "Resource URL. This is the url of the original network request."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Type of this resource."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: ResourceType,
            #[doc = "Cached response data."]
            #[serde(rename = "response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub response: Option<Response>,
            #[doc = "Cached response body size."]
            #[serde(rename = "bodySize")]
            pub body_size: f64,
        }
        impl CachedResource {
            pub fn new(
                url: impl Into<String>,
                r#type: impl Into<ResourceType>,
                body_size: impl Into<f64>,
            ) -> Self {
                Self {
                    url: url.into(),
                    r#type: r#type.into(),
                    body_size: body_size.into(),
                    response: None,
                }
            }
        }
        impl CachedResource {
            pub fn builder() -> CachedResourceBuilder {
                CachedResourceBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CachedResourceBuilder {
            url: Option<String>,
            r#type: Option<ResourceType>,
            response: Option<Response>,
            body_size: Option<f64>,
        }
        impl CachedResourceBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<ResourceType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn response(mut self, response: impl Into<Response>) -> Self {
                self.response = Some(response.into());
                self
            }
            pub fn body_size(mut self, body_size: impl Into<f64>) -> Self {
                self.body_size = Some(body_size.into());
                self
            }
            pub fn build(self) -> Result<CachedResource, String> {
                Ok(CachedResource {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    response: self.response,
                    body_size: self.body_size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(body_size))
                    })?,
                })
            }
        }
        impl CachedResource {
            pub const IDENTIFIER: &'static str = "Network.CachedResource";
        }
        #[doc = "Information about the request initiator.\n[Initiator](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-Initiator)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Initiator {
            #[doc = "Type of this initiator."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: InitiatorType,
            #[doc = "Initiator JavaScript stack trace, set for Script only."]
            #[serde(rename = "stack")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub stack: Option<super::super::js_protocol::runtime::StackTrace>,
            #[doc = "Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type."]
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url: Option<String>,
            #[doc = "Initiator line number, set for Parser type or for Script type (when script is importing\nmodule) (0-based)."]
            #[serde(rename = "lineNumber")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub line_number: Option<f64>,
            #[doc = "Initiator column number, set for Parser type or for Script type (when script is importing\nmodule) (0-based)."]
            #[serde(rename = "columnNumber")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub column_number: Option<f64>,
            #[doc = "Set if another request triggered this request (e.g. preflight)."]
            #[serde(rename = "requestId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub request_id: Option<RequestId>,
        }
        #[doc = "Type of this initiator."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum InitiatorType {
            #[serde(rename = "parser")]
            Parser,
            #[serde(rename = "script")]
            Script,
            #[serde(rename = "preload")]
            Preload,
            #[serde(rename = "SignedExchange")]
            SignedExchange,
            #[serde(rename = "preflight")]
            Preflight,
            #[serde(rename = "other")]
            Other,
        }
        impl AsRef<str> for InitiatorType {
            fn as_ref(&self) -> &str {
                match self {
                    InitiatorType::Parser => "parser",
                    InitiatorType::Script => "script",
                    InitiatorType::Preload => "preload",
                    InitiatorType::SignedExchange => "SignedExchange",
                    InitiatorType::Preflight => "preflight",
                    InitiatorType::Other => "other",
                }
            }
        }
        impl ::std::str::FromStr for InitiatorType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "parser" | "Parser" => Ok(InitiatorType::Parser),
                    "script" | "Script" => Ok(InitiatorType::Script),
                    "preload" | "Preload" => Ok(InitiatorType::Preload),
                    "SignedExchange" | "signedexchange" => Ok(InitiatorType::SignedExchange),
                    "preflight" | "Preflight" => Ok(InitiatorType::Preflight),
                    "other" | "Other" => Ok(InitiatorType::Other),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl Initiator {
            pub fn new(r#type: impl Into<InitiatorType>) -> Self {
                Self {
                    r#type: r#type.into(),
                    stack: None,
                    url: None,
                    line_number: None,
                    column_number: None,
                    request_id: None,
                }
            }
        }
        impl Initiator {
            pub fn builder() -> InitiatorBuilder {
                InitiatorBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct InitiatorBuilder {
            r#type: Option<InitiatorType>,
            stack: Option<super::super::js_protocol::runtime::StackTrace>,
            url: Option<String>,
            line_number: Option<f64>,
            column_number: Option<f64>,
            request_id: Option<RequestId>,
        }
        impl InitiatorBuilder {
            pub fn r#type(mut self, r#type: impl Into<InitiatorType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn stack(
                mut self,
                stack: impl Into<super::super::js_protocol::runtime::StackTrace>,
            ) -> Self {
                self.stack = Some(stack.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn line_number(mut self, line_number: impl Into<f64>) -> Self {
                self.line_number = Some(line_number.into());
                self
            }
            pub fn column_number(mut self, column_number: impl Into<f64>) -> Self {
                self.column_number = Some(column_number.into());
                self
            }
            pub fn request_id(mut self, request_id: impl Into<RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn build(self) -> Result<Initiator, String> {
                Ok(Initiator {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    stack: self.stack,
                    url: self.url,
                    line_number: self.line_number,
                    column_number: self.column_number,
                    request_id: self.request_id,
                })
            }
        }
        impl Initiator {
            pub const IDENTIFIER: &'static str = "Network.Initiator";
        }
        #[doc = "Cookie object\n[Cookie](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-Cookie)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Cookie {
            #[doc = "Cookie name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Cookie value."]
            #[serde(rename = "value")]
            pub value: String,
            #[doc = "Cookie domain."]
            #[serde(rename = "domain")]
            pub domain: String,
            #[doc = "Cookie path."]
            #[serde(rename = "path")]
            pub path: String,
            #[doc = "Cookie expiration date as the number of seconds since the UNIX epoch."]
            #[serde(rename = "expires")]
            pub expires: f64,
            #[doc = "Cookie size."]
            #[serde(rename = "size")]
            pub size: i64,
            #[doc = "True if cookie is http-only."]
            #[serde(rename = "httpOnly")]
            pub http_only: bool,
            #[doc = "True if cookie is secure."]
            #[serde(rename = "secure")]
            pub secure: bool,
            #[doc = "True in case of session cookie."]
            #[serde(rename = "session")]
            pub session: bool,
            #[doc = "Cookie SameSite type."]
            #[serde(rename = "sameSite")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub same_site: Option<CookieSameSite>,
            #[doc = "Cookie Priority"]
            #[serde(rename = "priority")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub priority: CookiePriority,
            #[doc = "True if cookie is SameParty."]
            #[serde(rename = "sameParty")]
            pub same_party: bool,
            #[doc = "Cookie source scheme type."]
            #[serde(rename = "sourceScheme")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub source_scheme: CookieSourceScheme,
            #[doc = "Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.\nAn unspecified port value allows protocol clients to emulate legacy cookie scope for the port.\nThis is a temporary ability and it will be removed in the future."]
            #[serde(rename = "sourcePort")]
            pub source_port: i64,
            #[doc = "Cookie partition key. The site of the top-level URL the browser was visiting at the start\nof the request to the endpoint that set the cookie."]
            #[serde(rename = "partitionKey")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub partition_key: Option<String>,
            #[doc = "True if cookie partition key is opaque."]
            #[serde(rename = "partitionKeyOpaque")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub partition_key_opaque: Option<bool>,
        }
        impl Cookie {
            pub fn builder() -> CookieBuilder {
                CookieBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CookieBuilder {
            name: Option<String>,
            value: Option<String>,
            domain: Option<String>,
            path: Option<String>,
            expires: Option<f64>,
            size: Option<i64>,
            http_only: Option<bool>,
            secure: Option<bool>,
            session: Option<bool>,
            same_site: Option<CookieSameSite>,
            priority: Option<CookiePriority>,
            same_party: Option<bool>,
            source_scheme: Option<CookieSourceScheme>,
            source_port: Option<i64>,
            partition_key: Option<String>,
            partition_key_opaque: Option<bool>,
        }
        impl CookieBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn domain(mut self, domain: impl Into<String>) -> Self {
                self.domain = Some(domain.into());
                self
            }
            pub fn path(mut self, path: impl Into<String>) -> Self {
                self.path = Some(path.into());
                self
            }
            pub fn expires(mut self, expires: impl Into<f64>) -> Self {
                self.expires = Some(expires.into());
                self
            }
            pub fn size(mut self, size: impl Into<i64>) -> Self {
                self.size = Some(size.into());
                self
            }
            pub fn http_only(mut self, http_only: impl Into<bool>) -> Self {
                self.http_only = Some(http_only.into());
                self
            }
            pub fn secure(mut self, secure: impl Into<bool>) -> Self {
                self.secure = Some(secure.into());
                self
            }
            pub fn session(mut self, session: impl Into<bool>) -> Self {
                self.session = Some(session.into());
                self
            }
            pub fn same_site(mut self, same_site: impl Into<CookieSameSite>) -> Self {
                self.same_site = Some(same_site.into());
                self
            }
            pub fn priority(mut self, priority: impl Into<CookiePriority>) -> Self {
                self.priority = Some(priority.into());
                self
            }
            pub fn same_party(mut self, same_party: impl Into<bool>) -> Self {
                self.same_party = Some(same_party.into());
                self
            }
            pub fn source_scheme(mut self, source_scheme: impl Into<CookieSourceScheme>) -> Self {
                self.source_scheme = Some(source_scheme.into());
                self
            }
            pub fn source_port(mut self, source_port: impl Into<i64>) -> Self {
                self.source_port = Some(source_port.into());
                self
            }
            pub fn partition_key(mut self, partition_key: impl Into<String>) -> Self {
                self.partition_key = Some(partition_key.into());
                self
            }
            pub fn partition_key_opaque(mut self, partition_key_opaque: impl Into<bool>) -> Self {
                self.partition_key_opaque = Some(partition_key_opaque.into());
                self
            }
            pub fn build(self) -> Result<Cookie, String> {
                Ok(Cookie {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                    domain: self.domain.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(domain))
                    })?,
                    path: self.path.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(path))
                    })?,
                    expires: self.expires.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(expires))
                    })?,
                    size: self.size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(size))
                    })?,
                    http_only: self.http_only.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(http_only))
                    })?,
                    secure: self.secure.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(secure))
                    })?,
                    session: self.session.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(session))
                    })?,
                    same_site: self.same_site,
                    priority: self.priority.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(priority))
                    })?,
                    same_party: self.same_party.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(same_party))
                    })?,
                    source_scheme: self.source_scheme.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(source_scheme))
                    })?,
                    source_port: self.source_port.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(source_port))
                    })?,
                    partition_key: self.partition_key,
                    partition_key_opaque: self.partition_key_opaque,
                })
            }
        }
        impl Cookie {
            pub const IDENTIFIER: &'static str = "Network.Cookie";
        }
        #[doc = "Types of reasons why a cookie may not be stored from a response."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SetCookieBlockedReason {
            #[doc = "The cookie had the \"Secure\" attribute but was not received over a secure connection."]
            #[serde(rename = "SecureOnly")]
            SecureOnly,
            #[doc = "The cookie had the \"SameSite=Strict\" attribute but came from a cross-origin response.\nThis includes navigation requests intitiated by other origins."]
            #[serde(rename = "SameSiteStrict")]
            SameSiteStrict,
            #[doc = "The cookie had the \"SameSite=Lax\" attribute but came from a cross-origin response."]
            #[serde(rename = "SameSiteLax")]
            SameSiteLax,
            #[doc = "The cookie didn't specify a \"SameSite\" attribute and was defaulted to \"SameSite=Lax\" and\nbroke the same rules specified in the SameSiteLax value."]
            #[serde(rename = "SameSiteUnspecifiedTreatedAsLax")]
            SameSiteUnspecifiedTreatedAsLax,
            #[doc = "The cookie had the \"SameSite=None\" attribute but did not specify the \"Secure\" attribute,\nwhich is required in order to use \"SameSite=None\"."]
            #[serde(rename = "SameSiteNoneInsecure")]
            SameSiteNoneInsecure,
            #[doc = "The cookie was not stored due to user preferences."]
            #[serde(rename = "UserPreferences")]
            UserPreferences,
            #[doc = "The syntax of the Set-Cookie header of the response was invalid."]
            #[serde(rename = "SyntaxError")]
            SyntaxError,
            #[doc = "The scheme of the connection is not allowed to store cookies."]
            #[serde(rename = "SchemeNotSupported")]
            SchemeNotSupported,
            #[doc = "The cookie was not sent over a secure connection and would have overwritten a cookie with\nthe Secure attribute."]
            #[serde(rename = "OverwriteSecure")]
            OverwriteSecure,
            #[doc = "The cookie's domain attribute was invalid with regards to the current host url."]
            #[serde(rename = "InvalidDomain")]
            InvalidDomain,
            #[doc = "The cookie used the \"__Secure-\" or \"__Host-\" prefix in its name and broke the additional\nrules applied to cookies with these prefixes as defined in\nhttps://tools.ietf.org/html/draft-west-cookie-prefixes-05"]
            #[serde(rename = "InvalidPrefix")]
            InvalidPrefix,
            #[doc = "An unknown error was encountered when trying to store this cookie."]
            #[serde(rename = "UnknownError")]
            UnknownError,
            #[doc = "The cookie had the \"SameSite=Strict\" attribute but came from a response\nwith the same registrable domain but a different scheme.\nThis includes navigation requests intitiated by other origins.\nThis is the \"Schemeful Same-Site\" version of the blocked reason."]
            #[serde(rename = "SchemefulSameSiteStrict")]
            SchemefulSameSiteStrict,
            #[doc = "The cookie had the \"SameSite=Lax\" attribute but came from a response\nwith the same registrable domain but a different scheme.\nThis is the \"Schemeful Same-Site\" version of the blocked reason."]
            #[serde(rename = "SchemefulSameSiteLax")]
            SchemefulSameSiteLax,
            #[doc = "The cookie didn't specify a \"SameSite\" attribute and was defaulted to\n\"SameSite=Lax\" and broke the same rules specified in the SchemefulSameSiteLax\nvalue.\nThis is the \"Schemeful Same-Site\" version of the blocked reason."]
            #[serde(rename = "SchemefulSameSiteUnspecifiedTreatedAsLax")]
            SchemefulSameSiteUnspecifiedTreatedAsLax,
            #[doc = "The cookie had the \"SameParty\" attribute but came from a cross-party response."]
            #[serde(rename = "SamePartyFromCrossPartyContext")]
            SamePartyFromCrossPartyContext,
            #[doc = "The cookie had the \"SameParty\" attribute but did not specify the \"Secure\" attribute\n(which is required in order to use \"SameParty\"); or specified the \"SameSite=Strict\"\nattribute (which is forbidden when using \"SameParty\")."]
            #[serde(rename = "SamePartyConflictsWithOtherAttributes")]
            SamePartyConflictsWithOtherAttributes,
            #[doc = "The cookie's name/value pair size exceeded the size limit defined in\nRFC6265bis."]
            #[serde(rename = "NameValuePairExceedsMaxSize")]
            NameValuePairExceedsMaxSize,
        }
        impl AsRef<str> for SetCookieBlockedReason {
            fn as_ref(&self) -> &str {
                match self {
                    SetCookieBlockedReason::SecureOnly => "SecureOnly",
                    SetCookieBlockedReason::SameSiteStrict => "SameSiteStrict",
                    SetCookieBlockedReason::SameSiteLax => "SameSiteLax",
                    SetCookieBlockedReason::SameSiteUnspecifiedTreatedAsLax => {
                        "SameSiteUnspecifiedTreatedAsLax"
                    }
                    SetCookieBlockedReason::SameSiteNoneInsecure => "SameSiteNoneInsecure",
                    SetCookieBlockedReason::UserPreferences => "UserPreferences",
                    SetCookieBlockedReason::SyntaxError => "SyntaxError",
                    SetCookieBlockedReason::SchemeNotSupported => "SchemeNotSupported",
                    SetCookieBlockedReason::OverwriteSecure => "OverwriteSecure",
                    SetCookieBlockedReason::InvalidDomain => "InvalidDomain",
                    SetCookieBlockedReason::InvalidPrefix => "InvalidPrefix",
                    SetCookieBlockedReason::UnknownError => "UnknownError",
                    SetCookieBlockedReason::SchemefulSameSiteStrict => "SchemefulSameSiteStrict",
                    SetCookieBlockedReason::SchemefulSameSiteLax => "SchemefulSameSiteLax",
                    SetCookieBlockedReason::SchemefulSameSiteUnspecifiedTreatedAsLax => {
                        "SchemefulSameSiteUnspecifiedTreatedAsLax"
                    }
                    SetCookieBlockedReason::SamePartyFromCrossPartyContext => {
                        "SamePartyFromCrossPartyContext"
                    }
                    SetCookieBlockedReason::SamePartyConflictsWithOtherAttributes => {
                        "SamePartyConflictsWithOtherAttributes"
                    }
                    SetCookieBlockedReason::NameValuePairExceedsMaxSize => {
                        "NameValuePairExceedsMaxSize"
                    }
                }
            }
        }
        impl ::std::str::FromStr for SetCookieBlockedReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "SecureOnly" | "secureonly" => Ok(SetCookieBlockedReason::SecureOnly),
                    "SameSiteStrict" | "samesitestrict" => {
                        Ok(SetCookieBlockedReason::SameSiteStrict)
                    }
                    "SameSiteLax" | "samesitelax" => Ok(SetCookieBlockedReason::SameSiteLax),
                    "SameSiteUnspecifiedTreatedAsLax" | "samesiteunspecifiedtreatedaslax" => {
                        Ok(SetCookieBlockedReason::SameSiteUnspecifiedTreatedAsLax)
                    }
                    "SameSiteNoneInsecure" | "samesitenoneinsecure" => {
                        Ok(SetCookieBlockedReason::SameSiteNoneInsecure)
                    }
                    "UserPreferences" | "userpreferences" => {
                        Ok(SetCookieBlockedReason::UserPreferences)
                    }
                    "SyntaxError" | "syntaxerror" => Ok(SetCookieBlockedReason::SyntaxError),
                    "SchemeNotSupported" | "schemenotsupported" => {
                        Ok(SetCookieBlockedReason::SchemeNotSupported)
                    }
                    "OverwriteSecure" | "overwritesecure" => {
                        Ok(SetCookieBlockedReason::OverwriteSecure)
                    }
                    "InvalidDomain" | "invaliddomain" => Ok(SetCookieBlockedReason::InvalidDomain),
                    "InvalidPrefix" | "invalidprefix" => Ok(SetCookieBlockedReason::InvalidPrefix),
                    "UnknownError" | "unknownerror" => Ok(SetCookieBlockedReason::UnknownError),
                    "SchemefulSameSiteStrict" | "schemefulsamesitestrict" => {
                        Ok(SetCookieBlockedReason::SchemefulSameSiteStrict)
                    }
                    "SchemefulSameSiteLax" | "schemefulsamesitelax" => {
                        Ok(SetCookieBlockedReason::SchemefulSameSiteLax)
                    }
                    "SchemefulSameSiteUnspecifiedTreatedAsLax"
                    | "schemefulsamesiteunspecifiedtreatedaslax" => {
                        Ok(SetCookieBlockedReason::SchemefulSameSiteUnspecifiedTreatedAsLax)
                    }
                    "SamePartyFromCrossPartyContext" | "samepartyfromcrosspartycontext" => {
                        Ok(SetCookieBlockedReason::SamePartyFromCrossPartyContext)
                    }
                    "SamePartyConflictsWithOtherAttributes"
                    | "samepartyconflictswithotherattributes" => {
                        Ok(SetCookieBlockedReason::SamePartyConflictsWithOtherAttributes)
                    }
                    "NameValuePairExceedsMaxSize" | "namevaluepairexceedsmaxsize" => {
                        Ok(SetCookieBlockedReason::NameValuePairExceedsMaxSize)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Types of reasons why a cookie may not be sent with a request."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CookieBlockedReason {
            #[doc = "The cookie had the \"Secure\" attribute and the connection was not secure."]
            #[serde(rename = "SecureOnly")]
            SecureOnly,
            #[doc = "The cookie's path was not within the request url's path."]
            #[serde(rename = "NotOnPath")]
            NotOnPath,
            #[doc = "The cookie's domain is not configured to match the request url's domain, even though they\nshare a common TLD+1 (TLD+1 of foo.bar.example.com is example.com)."]
            #[serde(rename = "DomainMismatch")]
            DomainMismatch,
            #[doc = "The cookie had the \"SameSite=Strict\" attribute and the request was made on on a different\nsite. This includes navigation requests initiated by other sites."]
            #[serde(rename = "SameSiteStrict")]
            SameSiteStrict,
            #[doc = "The cookie had the \"SameSite=Lax\" attribute and the request was made on a different site.\nThis does not include navigation requests initiated by other sites."]
            #[serde(rename = "SameSiteLax")]
            SameSiteLax,
            #[doc = "The cookie didn't specify a SameSite attribute when it was stored and was defaulted to\n\"SameSite=Lax\" and broke the same rules specified in the SameSiteLax value. The cookie had\nto have been set with \"SameSite=None\" to enable third-party usage."]
            #[serde(rename = "SameSiteUnspecifiedTreatedAsLax")]
            SameSiteUnspecifiedTreatedAsLax,
            #[doc = "The cookie had the \"SameSite=None\" attribute and the connection was not secure. Cookies\nwithout SameSite restrictions must be sent over a secure connection."]
            #[serde(rename = "SameSiteNoneInsecure")]
            SameSiteNoneInsecure,
            #[doc = "The cookie was not sent due to user preferences."]
            #[serde(rename = "UserPreferences")]
            UserPreferences,
            #[doc = "An unknown error was encountered when trying to send this cookie."]
            #[serde(rename = "UnknownError")]
            UnknownError,
            #[doc = "The cookie had the \"SameSite=Strict\" attribute but came from a response\nwith the same registrable domain but a different scheme.\nThis includes navigation requests intitiated by other origins.\nThis is the \"Schemeful Same-Site\" version of the blocked reason."]
            #[serde(rename = "SchemefulSameSiteStrict")]
            SchemefulSameSiteStrict,
            #[doc = "The cookie had the \"SameSite=Lax\" attribute but came from a response\nwith the same registrable domain but a different scheme.\nThis is the \"Schemeful Same-Site\" version of the blocked reason."]
            #[serde(rename = "SchemefulSameSiteLax")]
            SchemefulSameSiteLax,
            #[doc = "The cookie didn't specify a \"SameSite\" attribute and was defaulted to\n\"SameSite=Lax\" and broke the same rules specified in the SchemefulSameSiteLax\nvalue.\nThis is the \"Schemeful Same-Site\" version of the blocked reason."]
            #[serde(rename = "SchemefulSameSiteUnspecifiedTreatedAsLax")]
            SchemefulSameSiteUnspecifiedTreatedAsLax,
            #[doc = "The cookie had the \"SameParty\" attribute and the request was made from a cross-party context."]
            #[serde(rename = "SamePartyFromCrossPartyContext")]
            SamePartyFromCrossPartyContext,
            #[doc = "The cookie's name/value pair size exceeded the size limit defined in\nRFC6265bis."]
            #[serde(rename = "NameValuePairExceedsMaxSize")]
            NameValuePairExceedsMaxSize,
        }
        impl AsRef<str> for CookieBlockedReason {
            fn as_ref(&self) -> &str {
                match self {
                    CookieBlockedReason::SecureOnly => "SecureOnly",
                    CookieBlockedReason::NotOnPath => "NotOnPath",
                    CookieBlockedReason::DomainMismatch => "DomainMismatch",
                    CookieBlockedReason::SameSiteStrict => "SameSiteStrict",
                    CookieBlockedReason::SameSiteLax => "SameSiteLax",
                    CookieBlockedReason::SameSiteUnspecifiedTreatedAsLax => {
                        "SameSiteUnspecifiedTreatedAsLax"
                    }
                    CookieBlockedReason::SameSiteNoneInsecure => "SameSiteNoneInsecure",
                    CookieBlockedReason::UserPreferences => "UserPreferences",
                    CookieBlockedReason::UnknownError => "UnknownError",
                    CookieBlockedReason::SchemefulSameSiteStrict => "SchemefulSameSiteStrict",
                    CookieBlockedReason::SchemefulSameSiteLax => "SchemefulSameSiteLax",
                    CookieBlockedReason::SchemefulSameSiteUnspecifiedTreatedAsLax => {
                        "SchemefulSameSiteUnspecifiedTreatedAsLax"
                    }
                    CookieBlockedReason::SamePartyFromCrossPartyContext => {
                        "SamePartyFromCrossPartyContext"
                    }
                    CookieBlockedReason::NameValuePairExceedsMaxSize => {
                        "NameValuePairExceedsMaxSize"
                    }
                }
            }
        }
        impl ::std::str::FromStr for CookieBlockedReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "SecureOnly" | "secureonly" => Ok(CookieBlockedReason::SecureOnly),
                    "NotOnPath" | "notonpath" => Ok(CookieBlockedReason::NotOnPath),
                    "DomainMismatch" | "domainmismatch" => Ok(CookieBlockedReason::DomainMismatch),
                    "SameSiteStrict" | "samesitestrict" => Ok(CookieBlockedReason::SameSiteStrict),
                    "SameSiteLax" | "samesitelax" => Ok(CookieBlockedReason::SameSiteLax),
                    "SameSiteUnspecifiedTreatedAsLax" | "samesiteunspecifiedtreatedaslax" => {
                        Ok(CookieBlockedReason::SameSiteUnspecifiedTreatedAsLax)
                    }
                    "SameSiteNoneInsecure" | "samesitenoneinsecure" => {
                        Ok(CookieBlockedReason::SameSiteNoneInsecure)
                    }
                    "UserPreferences" | "userpreferences" => {
                        Ok(CookieBlockedReason::UserPreferences)
                    }
                    "UnknownError" | "unknownerror" => Ok(CookieBlockedReason::UnknownError),
                    "SchemefulSameSiteStrict" | "schemefulsamesitestrict" => {
                        Ok(CookieBlockedReason::SchemefulSameSiteStrict)
                    }
                    "SchemefulSameSiteLax" | "schemefulsamesitelax" => {
                        Ok(CookieBlockedReason::SchemefulSameSiteLax)
                    }
                    "SchemefulSameSiteUnspecifiedTreatedAsLax"
                    | "schemefulsamesiteunspecifiedtreatedaslax" => {
                        Ok(CookieBlockedReason::SchemefulSameSiteUnspecifiedTreatedAsLax)
                    }
                    "SamePartyFromCrossPartyContext" | "samepartyfromcrosspartycontext" => {
                        Ok(CookieBlockedReason::SamePartyFromCrossPartyContext)
                    }
                    "NameValuePairExceedsMaxSize" | "namevaluepairexceedsmaxsize" => {
                        Ok(CookieBlockedReason::NameValuePairExceedsMaxSize)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "A cookie which was not stored from a response with the corresponding reason.\n[BlockedSetCookieWithReason](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-BlockedSetCookieWithReason)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct BlockedSetCookieWithReason {
            #[doc = "The reason(s) this cookie was blocked."]
            #[serde(rename = "blockedReasons")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub blocked_reasons: Vec<SetCookieBlockedReason>,
            #[doc = "The string representing this individual cookie as it would appear in the header.\nThis is not the entire \"cookie\" or \"set-cookie\" header which could have multiple cookies."]
            #[serde(rename = "cookieLine")]
            pub cookie_line: String,
            #[doc = "The cookie object which represents the cookie which was not stored. It is optional because\nsometimes complete cookie information is not available, such as in the case of parsing\nerrors."]
            #[serde(rename = "cookie")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub cookie: Option<Cookie>,
        }
        impl BlockedSetCookieWithReason {
            pub fn new(
                blocked_reasons: Vec<SetCookieBlockedReason>,
                cookie_line: impl Into<String>,
            ) -> Self {
                Self {
                    blocked_reasons,
                    cookie_line: cookie_line.into(),
                    cookie: None,
                }
            }
        }
        impl BlockedSetCookieWithReason {
            pub fn builder() -> BlockedSetCookieWithReasonBuilder {
                BlockedSetCookieWithReasonBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BlockedSetCookieWithReasonBuilder {
            blocked_reasons: Option<Vec<SetCookieBlockedReason>>,
            cookie_line: Option<String>,
            cookie: Option<Cookie>,
        }
        impl BlockedSetCookieWithReasonBuilder {
            pub fn blocked_reason(
                mut self,
                blocked_reason: impl Into<SetCookieBlockedReason>,
            ) -> Self {
                let v = self.blocked_reasons.get_or_insert(Vec::new());
                v.push(blocked_reason.into());
                self
            }
            pub fn blocked_reasons<I, S>(mut self, blocked_reasons: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<SetCookieBlockedReason>,
            {
                let v = self.blocked_reasons.get_or_insert(Vec::new());
                for val in blocked_reasons {
                    v.push(val.into());
                }
                self
            }
            pub fn cookie_line(mut self, cookie_line: impl Into<String>) -> Self {
                self.cookie_line = Some(cookie_line.into());
                self
            }
            pub fn cookie(mut self, cookie: impl Into<Cookie>) -> Self {
                self.cookie = Some(cookie.into());
                self
            }
            pub fn build(self) -> Result<BlockedSetCookieWithReason, String> {
                Ok(BlockedSetCookieWithReason {
                    blocked_reasons: self.blocked_reasons.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(blocked_reasons))
                    })?,
                    cookie_line: self.cookie_line.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cookie_line))
                    })?,
                    cookie: self.cookie,
                })
            }
        }
        impl BlockedSetCookieWithReason {
            pub const IDENTIFIER: &'static str = "Network.BlockedSetCookieWithReason";
        }
        #[doc = "A cookie with was not sent with a request with the corresponding reason.\n[BlockedCookieWithReason](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-BlockedCookieWithReason)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct BlockedCookieWithReason {
            #[doc = "The reason(s) the cookie was blocked."]
            #[serde(rename = "blockedReasons")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub blocked_reasons: Vec<CookieBlockedReason>,
            #[doc = "The cookie object representing the cookie which was not sent."]
            #[serde(rename = "cookie")]
            pub cookie: Cookie,
        }
        impl BlockedCookieWithReason {
            pub fn new(
                blocked_reasons: Vec<CookieBlockedReason>,
                cookie: impl Into<Cookie>,
            ) -> Self {
                Self {
                    blocked_reasons,
                    cookie: cookie.into(),
                }
            }
        }
        impl BlockedCookieWithReason {
            pub fn builder() -> BlockedCookieWithReasonBuilder {
                BlockedCookieWithReasonBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BlockedCookieWithReasonBuilder {
            blocked_reasons: Option<Vec<CookieBlockedReason>>,
            cookie: Option<Cookie>,
        }
        impl BlockedCookieWithReasonBuilder {
            pub fn blocked_reason(
                mut self,
                blocked_reason: impl Into<CookieBlockedReason>,
            ) -> Self {
                let v = self.blocked_reasons.get_or_insert(Vec::new());
                v.push(blocked_reason.into());
                self
            }
            pub fn blocked_reasons<I, S>(mut self, blocked_reasons: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CookieBlockedReason>,
            {
                let v = self.blocked_reasons.get_or_insert(Vec::new());
                for val in blocked_reasons {
                    v.push(val.into());
                }
                self
            }
            pub fn cookie(mut self, cookie: impl Into<Cookie>) -> Self {
                self.cookie = Some(cookie.into());
                self
            }
            pub fn build(self) -> Result<BlockedCookieWithReason, String> {
                Ok(BlockedCookieWithReason {
                    blocked_reasons: self.blocked_reasons.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(blocked_reasons))
                    })?,
                    cookie: self.cookie.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cookie))
                    })?,
                })
            }
        }
        impl BlockedCookieWithReason {
            pub const IDENTIFIER: &'static str = "Network.BlockedCookieWithReason";
        }
        #[doc = "Cookie parameter object\n[CookieParam](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-CookieParam)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CookieParam {
            #[doc = "Cookie name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Cookie value."]
            #[serde(rename = "value")]
            pub value: String,
            #[doc = "The request-URI to associate with the setting of the cookie. This value can affect the\ndefault domain, path, source port, and source scheme values of the created cookie."]
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url: Option<String>,
            #[doc = "Cookie domain."]
            #[serde(rename = "domain")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub domain: Option<String>,
            #[doc = "Cookie path."]
            #[serde(rename = "path")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub path: Option<String>,
            #[doc = "True if cookie is secure."]
            #[serde(rename = "secure")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub secure: Option<bool>,
            #[doc = "True if cookie is http-only."]
            #[serde(rename = "httpOnly")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub http_only: Option<bool>,
            #[doc = "Cookie SameSite type."]
            #[serde(rename = "sameSite")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub same_site: Option<CookieSameSite>,
            #[doc = "Cookie expiration date, session cookie if not set"]
            #[serde(rename = "expires")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub expires: Option<TimeSinceEpoch>,
            #[doc = "Cookie Priority."]
            #[serde(rename = "priority")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub priority: Option<CookiePriority>,
            #[doc = "True if cookie is SameParty."]
            #[serde(rename = "sameParty")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub same_party: Option<bool>,
            #[doc = "Cookie source scheme type."]
            #[serde(rename = "sourceScheme")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub source_scheme: Option<CookieSourceScheme>,
            #[doc = "Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.\nAn unspecified port value allows protocol clients to emulate legacy cookie scope for the port.\nThis is a temporary ability and it will be removed in the future."]
            #[serde(rename = "sourcePort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub source_port: Option<i64>,
            #[doc = "Cookie partition key. The site of the top-level URL the browser was visiting at the start\nof the request to the endpoint that set the cookie.\nIf not set, the cookie will be set as not partitioned."]
            #[serde(rename = "partitionKey")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub partition_key: Option<String>,
        }
        impl CookieParam {
            pub fn new(name: impl Into<String>, value: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                    url: None,
                    domain: None,
                    path: None,
                    secure: None,
                    http_only: None,
                    same_site: None,
                    expires: None,
                    priority: None,
                    same_party: None,
                    source_scheme: None,
                    source_port: None,
                    partition_key: None,
                }
            }
        }
        impl CookieParam {
            pub fn builder() -> CookieParamBuilder {
                CookieParamBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CookieParamBuilder {
            name: Option<String>,
            value: Option<String>,
            url: Option<String>,
            domain: Option<String>,
            path: Option<String>,
            secure: Option<bool>,
            http_only: Option<bool>,
            same_site: Option<CookieSameSite>,
            expires: Option<TimeSinceEpoch>,
            priority: Option<CookiePriority>,
            same_party: Option<bool>,
            source_scheme: Option<CookieSourceScheme>,
            source_port: Option<i64>,
            partition_key: Option<String>,
        }
        impl CookieParamBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn domain(mut self, domain: impl Into<String>) -> Self {
                self.domain = Some(domain.into());
                self
            }
            pub fn path(mut self, path: impl Into<String>) -> Self {
                self.path = Some(path.into());
                self
            }
            pub fn secure(mut self, secure: impl Into<bool>) -> Self {
                self.secure = Some(secure.into());
                self
            }
            pub fn http_only(mut self, http_only: impl Into<bool>) -> Self {
                self.http_only = Some(http_only.into());
                self
            }
            pub fn same_site(mut self, same_site: impl Into<CookieSameSite>) -> Self {
                self.same_site = Some(same_site.into());
                self
            }
            pub fn expires(mut self, expires: impl Into<TimeSinceEpoch>) -> Self {
                self.expires = Some(expires.into());
                self
            }
            pub fn priority(mut self, priority: impl Into<CookiePriority>) -> Self {
                self.priority = Some(priority.into());
                self
            }
            pub fn same_party(mut self, same_party: impl Into<bool>) -> Self {
                self.same_party = Some(same_party.into());
                self
            }
            pub fn source_scheme(mut self, source_scheme: impl Into<CookieSourceScheme>) -> Self {
                self.source_scheme = Some(source_scheme.into());
                self
            }
            pub fn source_port(mut self, source_port: impl Into<i64>) -> Self {
                self.source_port = Some(source_port.into());
                self
            }
            pub fn partition_key(mut self, partition_key: impl Into<String>) -> Self {
                self.partition_key = Some(partition_key.into());
                self
            }
            pub fn build(self) -> Result<CookieParam, String> {
                Ok(CookieParam {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                    url: self.url,
                    domain: self.domain,
                    path: self.path,
                    secure: self.secure,
                    http_only: self.http_only,
                    same_site: self.same_site,
                    expires: self.expires,
                    priority: self.priority,
                    same_party: self.same_party,
                    source_scheme: self.source_scheme,
                    source_port: self.source_port,
                    partition_key: self.partition_key,
                })
            }
        }
        impl CookieParam {
            pub const IDENTIFIER: &'static str = "Network.CookieParam";
        }
        #[doc = "Authorization challenge for HTTP status code 401 or 407.\n[AuthChallenge](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-AuthChallenge)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AuthChallenge {
            #[doc = "Source of the authentication challenge."]
            #[serde(rename = "source")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub source: Option<AuthChallengeSource>,
            #[doc = "Origin of the challenger."]
            #[serde(rename = "origin")]
            pub origin: String,
            #[doc = "The authentication scheme used, such as basic or digest"]
            #[serde(rename = "scheme")]
            pub scheme: String,
            #[doc = "The realm of the challenge. May be empty."]
            #[serde(rename = "realm")]
            pub realm: String,
        }
        #[doc = "Source of the authentication challenge."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AuthChallengeSource {
            #[serde(rename = "Server")]
            Server,
            #[serde(rename = "Proxy")]
            Proxy,
        }
        impl AsRef<str> for AuthChallengeSource {
            fn as_ref(&self) -> &str {
                match self {
                    AuthChallengeSource::Server => "Server",
                    AuthChallengeSource::Proxy => "Proxy",
                }
            }
        }
        impl ::std::str::FromStr for AuthChallengeSource {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Server" | "server" => Ok(AuthChallengeSource::Server),
                    "Proxy" | "proxy" => Ok(AuthChallengeSource::Proxy),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl AuthChallenge {
            pub fn new(
                origin: impl Into<String>,
                scheme: impl Into<String>,
                realm: impl Into<String>,
            ) -> Self {
                Self {
                    origin: origin.into(),
                    scheme: scheme.into(),
                    realm: realm.into(),
                    source: None,
                }
            }
        }
        impl AuthChallenge {
            pub fn builder() -> AuthChallengeBuilder {
                AuthChallengeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AuthChallengeBuilder {
            source: Option<AuthChallengeSource>,
            origin: Option<String>,
            scheme: Option<String>,
            realm: Option<String>,
        }
        impl AuthChallengeBuilder {
            pub fn source(mut self, source: impl Into<AuthChallengeSource>) -> Self {
                self.source = Some(source.into());
                self
            }
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn scheme(mut self, scheme: impl Into<String>) -> Self {
                self.scheme = Some(scheme.into());
                self
            }
            pub fn realm(mut self, realm: impl Into<String>) -> Self {
                self.realm = Some(realm.into());
                self
            }
            pub fn build(self) -> Result<AuthChallenge, String> {
                Ok(AuthChallenge {
                    source: self.source,
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    scheme: self.scheme.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scheme))
                    })?,
                    realm: self.realm.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(realm))
                    })?,
                })
            }
        }
        impl AuthChallenge {
            pub const IDENTIFIER: &'static str = "Network.AuthChallenge";
        }
        #[doc = "Response to an AuthChallenge.\n[AuthChallengeResponse](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-AuthChallengeResponse)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AuthChallengeResponse {
            #[doc = "The decision on what to do in response to the authorization challenge.  Default means\ndeferring to the default behavior of the net stack, which will likely either the Cancel\nauthentication or display a popup dialog box."]
            #[serde(rename = "response")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub response: AuthChallengeResponseResponse,
            #[doc = "The username to provide, possibly empty. Should only be set if response is\nProvideCredentials."]
            #[serde(rename = "username")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub username: Option<String>,
            #[doc = "The password to provide, possibly empty. Should only be set if response is\nProvideCredentials."]
            #[serde(rename = "password")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub password: Option<String>,
        }
        #[doc = "The decision on what to do in response to the authorization challenge.  Default means\ndeferring to the default behavior of the net stack, which will likely either the Cancel\nauthentication or display a popup dialog box."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AuthChallengeResponseResponse {
            #[serde(rename = "Default")]
            Default,
            #[serde(rename = "CancelAuth")]
            CancelAuth,
            #[serde(rename = "ProvideCredentials")]
            ProvideCredentials,
        }
        impl AsRef<str> for AuthChallengeResponseResponse {
            fn as_ref(&self) -> &str {
                match self {
                    AuthChallengeResponseResponse::Default => "Default",
                    AuthChallengeResponseResponse::CancelAuth => "CancelAuth",
                    AuthChallengeResponseResponse::ProvideCredentials => "ProvideCredentials",
                }
            }
        }
        impl ::std::str::FromStr for AuthChallengeResponseResponse {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Default" | "default" => Ok(AuthChallengeResponseResponse::Default),
                    "CancelAuth" | "cancelauth" => Ok(AuthChallengeResponseResponse::CancelAuth),
                    "ProvideCredentials" | "providecredentials" => {
                        Ok(AuthChallengeResponseResponse::ProvideCredentials)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl AuthChallengeResponse {
            pub fn new(response: impl Into<AuthChallengeResponseResponse>) -> Self {
                Self {
                    response: response.into(),
                    username: None,
                    password: None,
                }
            }
        }
        impl AuthChallengeResponse {
            pub fn builder() -> AuthChallengeResponseBuilder {
                AuthChallengeResponseBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AuthChallengeResponseBuilder {
            response: Option<AuthChallengeResponseResponse>,
            username: Option<String>,
            password: Option<String>,
        }
        impl AuthChallengeResponseBuilder {
            pub fn response(mut self, response: impl Into<AuthChallengeResponseResponse>) -> Self {
                self.response = Some(response.into());
                self
            }
            pub fn username(mut self, username: impl Into<String>) -> Self {
                self.username = Some(username.into());
                self
            }
            pub fn password(mut self, password: impl Into<String>) -> Self {
                self.password = Some(password.into());
                self
            }
            pub fn build(self) -> Result<AuthChallengeResponse, String> {
                Ok(AuthChallengeResponse {
                    response: self.response.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(response))
                    })?,
                    username: self.username,
                    password: self.password,
                })
            }
        }
        impl AuthChallengeResponse {
            pub const IDENTIFIER: &'static str = "Network.AuthChallengeResponse";
        }
        #[doc = "Stages of the interception to begin intercepting. Request will intercept before the request is\nsent. Response will intercept after the response is received."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum InterceptionStage {
            #[serde(rename = "Request")]
            Request,
            #[serde(rename = "HeadersReceived")]
            HeadersReceived,
        }
        impl AsRef<str> for InterceptionStage {
            fn as_ref(&self) -> &str {
                match self {
                    InterceptionStage::Request => "Request",
                    InterceptionStage::HeadersReceived => "HeadersReceived",
                }
            }
        }
        impl ::std::str::FromStr for InterceptionStage {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Request" | "request" => Ok(InterceptionStage::Request),
                    "HeadersReceived" | "headersreceived" => Ok(InterceptionStage::HeadersReceived),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Request pattern for interception.\n[RequestPattern](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-RequestPattern)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RequestPattern {
            #[doc = "Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is\nbackslash. Omitting is equivalent to `\"*\"`."]
            #[serde(rename = "urlPattern")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url_pattern: Option<String>,
            #[doc = "If set, only requests for matching resource types will be intercepted."]
            #[serde(rename = "resourceType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub resource_type: Option<ResourceType>,
            #[doc = "Stage at which to begin intercepting requests. Default is Request."]
            #[serde(rename = "interceptionStage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub interception_stage: Option<InterceptionStage>,
        }
        impl RequestPattern {
            pub fn builder() -> RequestPatternBuilder {
                RequestPatternBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestPatternBuilder {
            url_pattern: Option<String>,
            resource_type: Option<ResourceType>,
            interception_stage: Option<InterceptionStage>,
        }
        impl RequestPatternBuilder {
            pub fn url_pattern(mut self, url_pattern: impl Into<String>) -> Self {
                self.url_pattern = Some(url_pattern.into());
                self
            }
            pub fn resource_type(mut self, resource_type: impl Into<ResourceType>) -> Self {
                self.resource_type = Some(resource_type.into());
                self
            }
            pub fn interception_stage(
                mut self,
                interception_stage: impl Into<InterceptionStage>,
            ) -> Self {
                self.interception_stage = Some(interception_stage.into());
                self
            }
            pub fn build(self) -> RequestPattern {
                RequestPattern {
                    url_pattern: self.url_pattern,
                    resource_type: self.resource_type,
                    interception_stage: self.interception_stage,
                }
            }
        }
        impl RequestPattern {
            pub const IDENTIFIER: &'static str = "Network.RequestPattern";
        }
        #[doc = "Information about a signed exchange signature.\nhttps://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1\n[SignedExchangeSignature](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-SignedExchangeSignature)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SignedExchangeSignature {
            #[doc = "Signed exchange signature label."]
            #[serde(rename = "label")]
            pub label: String,
            #[doc = "The hex string of signed exchange signature."]
            #[serde(rename = "signature")]
            pub signature: String,
            #[doc = "Signed exchange signature integrity."]
            #[serde(rename = "integrity")]
            pub integrity: String,
            #[doc = "Signed exchange signature cert Url."]
            #[serde(rename = "certUrl")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub cert_url: Option<String>,
            #[doc = "The hex string of signed exchange signature cert sha256."]
            #[serde(rename = "certSha256")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub cert_sha256: Option<String>,
            #[doc = "Signed exchange signature validity Url."]
            #[serde(rename = "validityUrl")]
            pub validity_url: String,
            #[doc = "Signed exchange signature date."]
            #[serde(rename = "date")]
            pub date: i64,
            #[doc = "Signed exchange signature expires."]
            #[serde(rename = "expires")]
            pub expires: i64,
            #[doc = "The encoded certificates."]
            #[serde(rename = "certificates")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub certificates: Option<Vec<String>>,
        }
        impl SignedExchangeSignature {
            pub fn builder() -> SignedExchangeSignatureBuilder {
                SignedExchangeSignatureBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SignedExchangeSignatureBuilder {
            label: Option<String>,
            signature: Option<String>,
            integrity: Option<String>,
            cert_url: Option<String>,
            cert_sha256: Option<String>,
            validity_url: Option<String>,
            date: Option<i64>,
            expires: Option<i64>,
            certificates: Option<Vec<String>>,
        }
        impl SignedExchangeSignatureBuilder {
            pub fn label(mut self, label: impl Into<String>) -> Self {
                self.label = Some(label.into());
                self
            }
            pub fn signature(mut self, signature: impl Into<String>) -> Self {
                self.signature = Some(signature.into());
                self
            }
            pub fn integrity(mut self, integrity: impl Into<String>) -> Self {
                self.integrity = Some(integrity.into());
                self
            }
            pub fn cert_url(mut self, cert_url: impl Into<String>) -> Self {
                self.cert_url = Some(cert_url.into());
                self
            }
            pub fn cert_sha256(mut self, cert_sha256: impl Into<String>) -> Self {
                self.cert_sha256 = Some(cert_sha256.into());
                self
            }
            pub fn validity_url(mut self, validity_url: impl Into<String>) -> Self {
                self.validity_url = Some(validity_url.into());
                self
            }
            pub fn date(mut self, date: impl Into<i64>) -> Self {
                self.date = Some(date.into());
                self
            }
            pub fn expires(mut self, expires: impl Into<i64>) -> Self {
                self.expires = Some(expires.into());
                self
            }
            pub fn certificate(mut self, certificate: impl Into<String>) -> Self {
                let v = self.certificates.get_or_insert(Vec::new());
                v.push(certificate.into());
                self
            }
            pub fn certificates<I, S>(mut self, certificates: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.certificates.get_or_insert(Vec::new());
                for val in certificates {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SignedExchangeSignature, String> {
                Ok(SignedExchangeSignature {
                    label: self.label.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(label))
                    })?,
                    signature: self.signature.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(signature))
                    })?,
                    integrity: self.integrity.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(integrity))
                    })?,
                    cert_url: self.cert_url,
                    cert_sha256: self.cert_sha256,
                    validity_url: self.validity_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(validity_url))
                    })?,
                    date: self.date.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(date))
                    })?,
                    expires: self.expires.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(expires))
                    })?,
                    certificates: self.certificates,
                })
            }
        }
        impl SignedExchangeSignature {
            pub const IDENTIFIER: &'static str = "Network.SignedExchangeSignature";
        }
        #[doc = "Information about a signed exchange header.\nhttps://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation\n[SignedExchangeHeader](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-SignedExchangeHeader)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SignedExchangeHeader {
            #[doc = "Signed exchange request URL."]
            #[serde(rename = "requestUrl")]
            pub request_url: String,
            #[doc = "Signed exchange response code."]
            #[serde(rename = "responseCode")]
            pub response_code: i64,
            #[doc = "Signed exchange response headers."]
            #[serde(rename = "responseHeaders")]
            pub response_headers: Headers,
            #[doc = "Signed exchange response signature."]
            #[serde(rename = "signatures")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub signatures: Vec<SignedExchangeSignature>,
            #[doc = "Signed exchange header integrity hash in the form of \"sha256-<base64-hash-value>\"."]
            #[serde(rename = "headerIntegrity")]
            pub header_integrity: String,
        }
        impl SignedExchangeHeader {
            pub fn builder() -> SignedExchangeHeaderBuilder {
                SignedExchangeHeaderBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SignedExchangeHeaderBuilder {
            request_url: Option<String>,
            response_code: Option<i64>,
            response_headers: Option<Headers>,
            signatures: Option<Vec<SignedExchangeSignature>>,
            header_integrity: Option<String>,
        }
        impl SignedExchangeHeaderBuilder {
            pub fn request_url(mut self, request_url: impl Into<String>) -> Self {
                self.request_url = Some(request_url.into());
                self
            }
            pub fn response_code(mut self, response_code: impl Into<i64>) -> Self {
                self.response_code = Some(response_code.into());
                self
            }
            pub fn response_headers(mut self, response_headers: impl Into<Headers>) -> Self {
                self.response_headers = Some(response_headers.into());
                self
            }
            pub fn signature(mut self, signature: impl Into<SignedExchangeSignature>) -> Self {
                let v = self.signatures.get_or_insert(Vec::new());
                v.push(signature.into());
                self
            }
            pub fn signatures<I, S>(mut self, signatures: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<SignedExchangeSignature>,
            {
                let v = self.signatures.get_or_insert(Vec::new());
                for val in signatures {
                    v.push(val.into());
                }
                self
            }
            pub fn header_integrity(mut self, header_integrity: impl Into<String>) -> Self {
                self.header_integrity = Some(header_integrity.into());
                self
            }
            pub fn build(self) -> Result<SignedExchangeHeader, String> {
                Ok(SignedExchangeHeader {
                    request_url: self.request_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_url))
                    })?,
                    response_code: self.response_code.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(response_code))
                    })?,
                    response_headers: self.response_headers.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(response_headers)
                        )
                    })?,
                    signatures: self.signatures.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(signatures))
                    })?,
                    header_integrity: self.header_integrity.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(header_integrity)
                        )
                    })?,
                })
            }
        }
        impl SignedExchangeHeader {
            pub const IDENTIFIER: &'static str = "Network.SignedExchangeHeader";
        }
        #[doc = "Field type for a signed exchange related error."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SignedExchangeErrorField {
            #[serde(rename = "signatureSig")]
            SignatureSig,
            #[serde(rename = "signatureIntegrity")]
            SignatureIntegrity,
            #[serde(rename = "signatureCertUrl")]
            SignatureCertUrl,
            #[serde(rename = "signatureCertSha256")]
            SignatureCertSha256,
            #[serde(rename = "signatureValidityUrl")]
            SignatureValidityUrl,
            #[serde(rename = "signatureTimestamps")]
            SignatureTimestamps,
        }
        impl AsRef<str> for SignedExchangeErrorField {
            fn as_ref(&self) -> &str {
                match self {
                    SignedExchangeErrorField::SignatureSig => "signatureSig",
                    SignedExchangeErrorField::SignatureIntegrity => "signatureIntegrity",
                    SignedExchangeErrorField::SignatureCertUrl => "signatureCertUrl",
                    SignedExchangeErrorField::SignatureCertSha256 => "signatureCertSha256",
                    SignedExchangeErrorField::SignatureValidityUrl => "signatureValidityUrl",
                    SignedExchangeErrorField::SignatureTimestamps => "signatureTimestamps",
                }
            }
        }
        impl ::std::str::FromStr for SignedExchangeErrorField {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "signatureSig" | "SignatureSig" | "signaturesig" => {
                        Ok(SignedExchangeErrorField::SignatureSig)
                    }
                    "signatureIntegrity" | "SignatureIntegrity" | "signatureintegrity" => {
                        Ok(SignedExchangeErrorField::SignatureIntegrity)
                    }
                    "signatureCertUrl" | "SignatureCertUrl" | "signaturecerturl" => {
                        Ok(SignedExchangeErrorField::SignatureCertUrl)
                    }
                    "signatureCertSha256" | "SignatureCertSha256" | "signaturecertsha256" => {
                        Ok(SignedExchangeErrorField::SignatureCertSha256)
                    }
                    "signatureValidityUrl" | "SignatureValidityUrl" | "signaturevalidityurl" => {
                        Ok(SignedExchangeErrorField::SignatureValidityUrl)
                    }
                    "signatureTimestamps" | "SignatureTimestamps" | "signaturetimestamps" => {
                        Ok(SignedExchangeErrorField::SignatureTimestamps)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Information about a signed exchange response.\n[SignedExchangeError](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-SignedExchangeError)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SignedExchangeError {
            #[doc = "Error message."]
            #[serde(rename = "message")]
            pub message: String,
            #[doc = "The index of the signature which caused the error."]
            #[serde(rename = "signatureIndex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub signature_index: Option<i64>,
            #[doc = "The field which caused the error."]
            #[serde(rename = "errorField")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub error_field: Option<SignedExchangeErrorField>,
        }
        impl SignedExchangeError {
            pub fn new(message: impl Into<String>) -> Self {
                Self {
                    message: message.into(),
                    signature_index: None,
                    error_field: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for SignedExchangeError {
            fn from(url: T) -> Self {
                SignedExchangeError::new(url)
            }
        }
        impl SignedExchangeError {
            pub fn builder() -> SignedExchangeErrorBuilder {
                SignedExchangeErrorBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SignedExchangeErrorBuilder {
            message: Option<String>,
            signature_index: Option<i64>,
            error_field: Option<SignedExchangeErrorField>,
        }
        impl SignedExchangeErrorBuilder {
            pub fn message(mut self, message: impl Into<String>) -> Self {
                self.message = Some(message.into());
                self
            }
            pub fn signature_index(mut self, signature_index: impl Into<i64>) -> Self {
                self.signature_index = Some(signature_index.into());
                self
            }
            pub fn error_field(mut self, error_field: impl Into<SignedExchangeErrorField>) -> Self {
                self.error_field = Some(error_field.into());
                self
            }
            pub fn build(self) -> Result<SignedExchangeError, String> {
                Ok(SignedExchangeError {
                    message: self.message.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(message))
                    })?,
                    signature_index: self.signature_index,
                    error_field: self.error_field,
                })
            }
        }
        impl SignedExchangeError {
            pub const IDENTIFIER: &'static str = "Network.SignedExchangeError";
        }
        #[doc = "Information about a signed exchange response.\n[SignedExchangeInfo](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-SignedExchangeInfo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SignedExchangeInfo {
            #[doc = "The outer response of signed HTTP exchange which was received from network."]
            #[serde(rename = "outerResponse")]
            pub outer_response: Response,
            #[doc = "Information about the signed exchange header."]
            #[serde(rename = "header")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub header: Option<SignedExchangeHeader>,
            #[doc = "Security details for the signed exchange header."]
            #[serde(rename = "securityDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub security_details: Option<SecurityDetails>,
            #[doc = "Errors occurred while handling the signed exchagne."]
            #[serde(rename = "errors")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub errors: Option<Vec<SignedExchangeError>>,
        }
        impl SignedExchangeInfo {
            pub fn new(outer_response: impl Into<Response>) -> Self {
                Self {
                    outer_response: outer_response.into(),
                    header: None,
                    security_details: None,
                    errors: None,
                }
            }
        }
        impl SignedExchangeInfo {
            pub fn builder() -> SignedExchangeInfoBuilder {
                SignedExchangeInfoBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SignedExchangeInfoBuilder {
            outer_response: Option<Response>,
            header: Option<SignedExchangeHeader>,
            security_details: Option<SecurityDetails>,
            errors: Option<Vec<SignedExchangeError>>,
        }
        impl SignedExchangeInfoBuilder {
            pub fn outer_response(mut self, outer_response: impl Into<Response>) -> Self {
                self.outer_response = Some(outer_response.into());
                self
            }
            pub fn header(mut self, header: impl Into<SignedExchangeHeader>) -> Self {
                self.header = Some(header.into());
                self
            }
            pub fn security_details(
                mut self,
                security_details: impl Into<SecurityDetails>,
            ) -> Self {
                self.security_details = Some(security_details.into());
                self
            }
            pub fn error(mut self, error: impl Into<SignedExchangeError>) -> Self {
                let v = self.errors.get_or_insert(Vec::new());
                v.push(error.into());
                self
            }
            pub fn errors<I, S>(mut self, errors: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<SignedExchangeError>,
            {
                let v = self.errors.get_or_insert(Vec::new());
                for val in errors {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SignedExchangeInfo, String> {
                Ok(SignedExchangeInfo {
                    outer_response: self.outer_response.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(outer_response))
                    })?,
                    header: self.header,
                    security_details: self.security_details,
                    errors: self.errors,
                })
            }
        }
        impl SignedExchangeInfo {
            pub const IDENTIFIER: &'static str = "Network.SignedExchangeInfo";
        }
        #[doc = "List of content encodings supported by the backend."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ContentEncoding {
            #[serde(rename = "deflate")]
            Deflate,
            #[serde(rename = "gzip")]
            Gzip,
            #[serde(rename = "br")]
            Br,
        }
        impl AsRef<str> for ContentEncoding {
            fn as_ref(&self) -> &str {
                match self {
                    ContentEncoding::Deflate => "deflate",
                    ContentEncoding::Gzip => "gzip",
                    ContentEncoding::Br => "br",
                }
            }
        }
        impl ::std::str::FromStr for ContentEncoding {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "deflate" | "Deflate" => Ok(ContentEncoding::Deflate),
                    "gzip" | "Gzip" => Ok(ContentEncoding::Gzip),
                    "br" | "Br" => Ok(ContentEncoding::Br),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PrivateNetworkRequestPolicy {
            #[serde(rename = "Allow")]
            Allow,
            #[serde(rename = "BlockFromInsecureToMorePrivate")]
            BlockFromInsecureToMorePrivate,
            #[serde(rename = "WarnFromInsecureToMorePrivate")]
            WarnFromInsecureToMorePrivate,
            #[serde(rename = "PreflightBlock")]
            PreflightBlock,
            #[serde(rename = "PreflightWarn")]
            PreflightWarn,
        }
        impl AsRef<str> for PrivateNetworkRequestPolicy {
            fn as_ref(&self) -> &str {
                match self {
                    PrivateNetworkRequestPolicy::Allow => "Allow",
                    PrivateNetworkRequestPolicy::BlockFromInsecureToMorePrivate => {
                        "BlockFromInsecureToMorePrivate"
                    }
                    PrivateNetworkRequestPolicy::WarnFromInsecureToMorePrivate => {
                        "WarnFromInsecureToMorePrivate"
                    }
                    PrivateNetworkRequestPolicy::PreflightBlock => "PreflightBlock",
                    PrivateNetworkRequestPolicy::PreflightWarn => "PreflightWarn",
                }
            }
        }
        impl ::std::str::FromStr for PrivateNetworkRequestPolicy {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Allow" | "allow" => Ok(PrivateNetworkRequestPolicy::Allow),
                    "BlockFromInsecureToMorePrivate" | "blockfrominsecuretomoreprivate" => {
                        Ok(PrivateNetworkRequestPolicy::BlockFromInsecureToMorePrivate)
                    }
                    "WarnFromInsecureToMorePrivate" | "warnfrominsecuretomoreprivate" => {
                        Ok(PrivateNetworkRequestPolicy::WarnFromInsecureToMorePrivate)
                    }
                    "PreflightBlock" | "preflightblock" => {
                        Ok(PrivateNetworkRequestPolicy::PreflightBlock)
                    }
                    "PreflightWarn" | "preflightwarn" => {
                        Ok(PrivateNetworkRequestPolicy::PreflightWarn)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum IpAddressSpace {
            #[serde(rename = "Local")]
            Local,
            #[serde(rename = "Private")]
            Private,
            #[serde(rename = "Public")]
            Public,
            #[serde(rename = "Unknown")]
            Unknown,
        }
        impl AsRef<str> for IpAddressSpace {
            fn as_ref(&self) -> &str {
                match self {
                    IpAddressSpace::Local => "Local",
                    IpAddressSpace::Private => "Private",
                    IpAddressSpace::Public => "Public",
                    IpAddressSpace::Unknown => "Unknown",
                }
            }
        }
        impl ::std::str::FromStr for IpAddressSpace {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Local" | "local" => Ok(IpAddressSpace::Local),
                    "Private" | "private" => Ok(IpAddressSpace::Private),
                    "Public" | "public" => Ok(IpAddressSpace::Public),
                    "Unknown" | "unknown" => Ok(IpAddressSpace::Unknown),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ConnectTiming {
            #[doc = "Timing's requestTime is a baseline in seconds, while the other numbers are ticks in\nmilliseconds relatively to this requestTime. Matches ResourceTiming's requestTime for\nthe same request (but not for redirected requests)."]
            #[serde(rename = "requestTime")]
            pub request_time: f64,
        }
        impl ConnectTiming {
            pub fn new(request_time: impl Into<f64>) -> Self {
                Self {
                    request_time: request_time.into(),
                }
            }
        }
        impl ConnectTiming {
            pub fn builder() -> ConnectTimingBuilder {
                ConnectTimingBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ConnectTimingBuilder {
            request_time: Option<f64>,
        }
        impl ConnectTimingBuilder {
            pub fn request_time(mut self, request_time: impl Into<f64>) -> Self {
                self.request_time = Some(request_time.into());
                self
            }
            pub fn build(self) -> Result<ConnectTiming, String> {
                Ok(ConnectTiming {
                    request_time: self.request_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_time))
                    })?,
                })
            }
        }
        impl ConnectTiming {
            pub const IDENTIFIER: &'static str = "Network.ConnectTiming";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ClientSecurityState {
            #[serde(rename = "initiatorIsSecureContext")]
            pub initiator_is_secure_context: bool,
            #[serde(rename = "initiatorIPAddressSpace")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub initiator_ip_address_space: IpAddressSpace,
            #[serde(rename = "privateNetworkRequestPolicy")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub private_network_request_policy: PrivateNetworkRequestPolicy,
        }
        impl ClientSecurityState {
            pub fn new(
                initiator_is_secure_context: impl Into<bool>,
                initiator_ip_address_space: impl Into<IpAddressSpace>,
                private_network_request_policy: impl Into<PrivateNetworkRequestPolicy>,
            ) -> Self {
                Self {
                    initiator_is_secure_context: initiator_is_secure_context.into(),
                    initiator_ip_address_space: initiator_ip_address_space.into(),
                    private_network_request_policy: private_network_request_policy.into(),
                }
            }
        }
        impl ClientSecurityState {
            pub fn builder() -> ClientSecurityStateBuilder {
                ClientSecurityStateBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ClientSecurityStateBuilder {
            initiator_is_secure_context: Option<bool>,
            initiator_ip_address_space: Option<IpAddressSpace>,
            private_network_request_policy: Option<PrivateNetworkRequestPolicy>,
        }
        impl ClientSecurityStateBuilder {
            pub fn initiator_is_secure_context(
                mut self,
                initiator_is_secure_context: impl Into<bool>,
            ) -> Self {
                self.initiator_is_secure_context = Some(initiator_is_secure_context.into());
                self
            }
            pub fn initiator_ip_address_space(
                mut self,
                initiator_ip_address_space: impl Into<IpAddressSpace>,
            ) -> Self {
                self.initiator_ip_address_space = Some(initiator_ip_address_space.into());
                self
            }
            pub fn private_network_request_policy(
                mut self,
                private_network_request_policy: impl Into<PrivateNetworkRequestPolicy>,
            ) -> Self {
                self.private_network_request_policy = Some(private_network_request_policy.into());
                self
            }
            pub fn build(self) -> Result<ClientSecurityState, String> {
                Ok(ClientSecurityState {
                    initiator_is_secure_context: self.initiator_is_secure_context.ok_or_else(
                        || {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(initiator_is_secure_context)
                            )
                        },
                    )?,
                    initiator_ip_address_space: self.initiator_ip_address_space.ok_or_else(
                        || {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(initiator_ip_address_space)
                            )
                        },
                    )?,
                    private_network_request_policy: self
                        .private_network_request_policy
                        .ok_or_else(|| {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(private_network_request_policy)
                            )
                        })?,
                })
            }
        }
        impl ClientSecurityState {
            pub const IDENTIFIER: &'static str = "Network.ClientSecurityState";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CrossOriginOpenerPolicyValue {
            #[serde(rename = "SameOrigin")]
            SameOrigin,
            #[serde(rename = "SameOriginAllowPopups")]
            SameOriginAllowPopups,
            #[serde(rename = "RestrictProperties")]
            RestrictProperties,
            #[serde(rename = "UnsafeNone")]
            UnsafeNone,
            #[serde(rename = "SameOriginPlusCoep")]
            SameOriginPlusCoep,
            #[serde(rename = "RestrictPropertiesPlusCoep")]
            RestrictPropertiesPlusCoep,
        }
        impl AsRef<str> for CrossOriginOpenerPolicyValue {
            fn as_ref(&self) -> &str {
                match self {
                    CrossOriginOpenerPolicyValue::SameOrigin => "SameOrigin",
                    CrossOriginOpenerPolicyValue::SameOriginAllowPopups => "SameOriginAllowPopups",
                    CrossOriginOpenerPolicyValue::RestrictProperties => "RestrictProperties",
                    CrossOriginOpenerPolicyValue::UnsafeNone => "UnsafeNone",
                    CrossOriginOpenerPolicyValue::SameOriginPlusCoep => "SameOriginPlusCoep",
                    CrossOriginOpenerPolicyValue::RestrictPropertiesPlusCoep => {
                        "RestrictPropertiesPlusCoep"
                    }
                }
            }
        }
        impl ::std::str::FromStr for CrossOriginOpenerPolicyValue {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "SameOrigin" | "sameorigin" => Ok(CrossOriginOpenerPolicyValue::SameOrigin),
                    "SameOriginAllowPopups" | "sameoriginallowpopups" => {
                        Ok(CrossOriginOpenerPolicyValue::SameOriginAllowPopups)
                    }
                    "RestrictProperties" | "restrictproperties" => {
                        Ok(CrossOriginOpenerPolicyValue::RestrictProperties)
                    }
                    "UnsafeNone" | "unsafenone" => Ok(CrossOriginOpenerPolicyValue::UnsafeNone),
                    "SameOriginPlusCoep" | "sameoriginpluscoep" => {
                        Ok(CrossOriginOpenerPolicyValue::SameOriginPlusCoep)
                    }
                    "RestrictPropertiesPlusCoep" | "restrictpropertiespluscoep" => {
                        Ok(CrossOriginOpenerPolicyValue::RestrictPropertiesPlusCoep)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CrossOriginOpenerPolicyStatus {
            #[serde(rename = "value")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub value: CrossOriginOpenerPolicyValue,
            #[serde(rename = "reportOnlyValue")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub report_only_value: CrossOriginOpenerPolicyValue,
            #[serde(rename = "reportingEndpoint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub reporting_endpoint: Option<String>,
            #[serde(rename = "reportOnlyReportingEndpoint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub report_only_reporting_endpoint: Option<String>,
        }
        impl CrossOriginOpenerPolicyStatus {
            pub fn new(
                value: impl Into<CrossOriginOpenerPolicyValue>,
                report_only_value: impl Into<CrossOriginOpenerPolicyValue>,
            ) -> Self {
                Self {
                    value: value.into(),
                    report_only_value: report_only_value.into(),
                    reporting_endpoint: None,
                    report_only_reporting_endpoint: None,
                }
            }
        }
        impl CrossOriginOpenerPolicyStatus {
            pub fn builder() -> CrossOriginOpenerPolicyStatusBuilder {
                CrossOriginOpenerPolicyStatusBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CrossOriginOpenerPolicyStatusBuilder {
            value: Option<CrossOriginOpenerPolicyValue>,
            report_only_value: Option<CrossOriginOpenerPolicyValue>,
            reporting_endpoint: Option<String>,
            report_only_reporting_endpoint: Option<String>,
        }
        impl CrossOriginOpenerPolicyStatusBuilder {
            pub fn value(mut self, value: impl Into<CrossOriginOpenerPolicyValue>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn report_only_value(
                mut self,
                report_only_value: impl Into<CrossOriginOpenerPolicyValue>,
            ) -> Self {
                self.report_only_value = Some(report_only_value.into());
                self
            }
            pub fn reporting_endpoint(mut self, reporting_endpoint: impl Into<String>) -> Self {
                self.reporting_endpoint = Some(reporting_endpoint.into());
                self
            }
            pub fn report_only_reporting_endpoint(
                mut self,
                report_only_reporting_endpoint: impl Into<String>,
            ) -> Self {
                self.report_only_reporting_endpoint = Some(report_only_reporting_endpoint.into());
                self
            }
            pub fn build(self) -> Result<CrossOriginOpenerPolicyStatus, String> {
                Ok(CrossOriginOpenerPolicyStatus {
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                    report_only_value: self.report_only_value.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(report_only_value)
                        )
                    })?,
                    reporting_endpoint: self.reporting_endpoint,
                    report_only_reporting_endpoint: self.report_only_reporting_endpoint,
                })
            }
        }
        impl CrossOriginOpenerPolicyStatus {
            pub const IDENTIFIER: &'static str = "Network.CrossOriginOpenerPolicyStatus";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CrossOriginEmbedderPolicyValue {
            #[serde(rename = "None")]
            None,
            #[serde(rename = "Credentialless")]
            Credentialless,
            #[serde(rename = "RequireCorp")]
            RequireCorp,
        }
        impl AsRef<str> for CrossOriginEmbedderPolicyValue {
            fn as_ref(&self) -> &str {
                match self {
                    CrossOriginEmbedderPolicyValue::None => "None",
                    CrossOriginEmbedderPolicyValue::Credentialless => "Credentialless",
                    CrossOriginEmbedderPolicyValue::RequireCorp => "RequireCorp",
                }
            }
        }
        impl ::std::str::FromStr for CrossOriginEmbedderPolicyValue {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "None" | "none" => Ok(CrossOriginEmbedderPolicyValue::None),
                    "Credentialless" | "credentialless" => {
                        Ok(CrossOriginEmbedderPolicyValue::Credentialless)
                    }
                    "RequireCorp" | "requirecorp" => {
                        Ok(CrossOriginEmbedderPolicyValue::RequireCorp)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CrossOriginEmbedderPolicyStatus {
            #[serde(rename = "value")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub value: CrossOriginEmbedderPolicyValue,
            #[serde(rename = "reportOnlyValue")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub report_only_value: CrossOriginEmbedderPolicyValue,
            #[serde(rename = "reportingEndpoint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub reporting_endpoint: Option<String>,
            #[serde(rename = "reportOnlyReportingEndpoint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub report_only_reporting_endpoint: Option<String>,
        }
        impl CrossOriginEmbedderPolicyStatus {
            pub fn new(
                value: impl Into<CrossOriginEmbedderPolicyValue>,
                report_only_value: impl Into<CrossOriginEmbedderPolicyValue>,
            ) -> Self {
                Self {
                    value: value.into(),
                    report_only_value: report_only_value.into(),
                    reporting_endpoint: None,
                    report_only_reporting_endpoint: None,
                }
            }
        }
        impl CrossOriginEmbedderPolicyStatus {
            pub fn builder() -> CrossOriginEmbedderPolicyStatusBuilder {
                CrossOriginEmbedderPolicyStatusBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CrossOriginEmbedderPolicyStatusBuilder {
            value: Option<CrossOriginEmbedderPolicyValue>,
            report_only_value: Option<CrossOriginEmbedderPolicyValue>,
            reporting_endpoint: Option<String>,
            report_only_reporting_endpoint: Option<String>,
        }
        impl CrossOriginEmbedderPolicyStatusBuilder {
            pub fn value(mut self, value: impl Into<CrossOriginEmbedderPolicyValue>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn report_only_value(
                mut self,
                report_only_value: impl Into<CrossOriginEmbedderPolicyValue>,
            ) -> Self {
                self.report_only_value = Some(report_only_value.into());
                self
            }
            pub fn reporting_endpoint(mut self, reporting_endpoint: impl Into<String>) -> Self {
                self.reporting_endpoint = Some(reporting_endpoint.into());
                self
            }
            pub fn report_only_reporting_endpoint(
                mut self,
                report_only_reporting_endpoint: impl Into<String>,
            ) -> Self {
                self.report_only_reporting_endpoint = Some(report_only_reporting_endpoint.into());
                self
            }
            pub fn build(self) -> Result<CrossOriginEmbedderPolicyStatus, String> {
                Ok(CrossOriginEmbedderPolicyStatus {
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                    report_only_value: self.report_only_value.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(report_only_value)
                        )
                    })?,
                    reporting_endpoint: self.reporting_endpoint,
                    report_only_reporting_endpoint: self.report_only_reporting_endpoint,
                })
            }
        }
        impl CrossOriginEmbedderPolicyStatus {
            pub const IDENTIFIER: &'static str = "Network.CrossOriginEmbedderPolicyStatus";
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SecurityIsolationStatus {
            #[serde(rename = "coop")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub coop: Option<CrossOriginOpenerPolicyStatus>,
            #[serde(rename = "coep")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub coep: Option<CrossOriginEmbedderPolicyStatus>,
        }
        impl SecurityIsolationStatus {
            pub fn builder() -> SecurityIsolationStatusBuilder {
                SecurityIsolationStatusBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SecurityIsolationStatusBuilder {
            coop: Option<CrossOriginOpenerPolicyStatus>,
            coep: Option<CrossOriginEmbedderPolicyStatus>,
        }
        impl SecurityIsolationStatusBuilder {
            pub fn coop(mut self, coop: impl Into<CrossOriginOpenerPolicyStatus>) -> Self {
                self.coop = Some(coop.into());
                self
            }
            pub fn coep(mut self, coep: impl Into<CrossOriginEmbedderPolicyStatus>) -> Self {
                self.coep = Some(coep.into());
                self
            }
            pub fn build(self) -> SecurityIsolationStatus {
                SecurityIsolationStatus {
                    coop: self.coop,
                    coep: self.coep,
                }
            }
        }
        impl SecurityIsolationStatus {
            pub const IDENTIFIER: &'static str = "Network.SecurityIsolationStatus";
        }
        #[doc = "The status of a Reporting API report."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ReportStatus {
            #[doc = "Report has been queued and no attempt has been made to deliver it yet,\nor attempted previous upload failed (impermanently)."]
            #[serde(rename = "Queued")]
            Queued,
            #[doc = "There is an ongoing attempt to upload this report."]
            #[serde(rename = "Pending")]
            Pending,
            #[doc = "Deletion of this report was requested while it was pending, so it will\nbe removed after possibly outstanding upload attempts complete (successful\nor not)."]
            #[serde(rename = "MarkedForRemoval")]
            MarkedForRemoval,
            #[doc = "Successfully uploaded and MarkedForRemoval."]
            #[serde(rename = "Success")]
            Success,
        }
        impl AsRef<str> for ReportStatus {
            fn as_ref(&self) -> &str {
                match self {
                    ReportStatus::Queued => "Queued",
                    ReportStatus::Pending => "Pending",
                    ReportStatus::MarkedForRemoval => "MarkedForRemoval",
                    ReportStatus::Success => "Success",
                }
            }
        }
        impl ::std::str::FromStr for ReportStatus {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Queued" | "queued" => Ok(ReportStatus::Queued),
                    "Pending" | "pending" => Ok(ReportStatus::Pending),
                    "MarkedForRemoval" | "markedforremoval" => Ok(ReportStatus::MarkedForRemoval),
                    "Success" | "success" => Ok(ReportStatus::Success),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct ReportId(String);
        impl ReportId {
            pub fn new(val: impl Into<String>) -> Self {
                ReportId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for ReportId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<ReportId> for String {
            fn from(el: ReportId) -> String {
                el.0
            }
        }
        impl From<String> for ReportId {
            fn from(expr: String) -> Self {
                ReportId(expr)
            }
        }
        impl std::borrow::Borrow<str> for ReportId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl ReportId {
            pub const IDENTIFIER: &'static str = "Network.ReportId";
        }
        #[doc = "An object representing a report generated by the Reporting API.\n[ReportingApiReport](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-ReportingApiReport)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ReportingApiReport {
            #[serde(rename = "id")]
            pub id: ReportId,
            #[doc = "The URL of the document that triggered the report."]
            #[serde(rename = "initiatorUrl")]
            pub initiator_url: String,
            #[doc = "The name of the endpoint group that should be used to deliver the report."]
            #[serde(rename = "destination")]
            pub destination: String,
            #[doc = "The type of the report (specifies the set of data that is contained in the report body)."]
            #[serde(rename = "type")]
            pub r#type: String,
            #[doc = "When the report was generated."]
            #[serde(rename = "timestamp")]
            pub timestamp: super::network::TimeSinceEpoch,
            #[doc = "How many uploads deep the related request was."]
            #[serde(rename = "depth")]
            pub depth: i64,
            #[doc = "The number of delivery attempts made so far, not including an active attempt."]
            #[serde(rename = "completedAttempts")]
            pub completed_attempts: i64,
            #[serde(rename = "body")]
            pub body: serde_json::Value,
            #[serde(rename = "status")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub status: ReportStatus,
        }
        impl ReportingApiReport {
            pub fn builder() -> ReportingApiReportBuilder {
                ReportingApiReportBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ReportingApiReportBuilder {
            id: Option<ReportId>,
            initiator_url: Option<String>,
            destination: Option<String>,
            r#type: Option<String>,
            timestamp: Option<super::network::TimeSinceEpoch>,
            depth: Option<i64>,
            completed_attempts: Option<i64>,
            body: Option<serde_json::Value>,
            status: Option<ReportStatus>,
        }
        impl ReportingApiReportBuilder {
            pub fn id(mut self, id: impl Into<ReportId>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn initiator_url(mut self, initiator_url: impl Into<String>) -> Self {
                self.initiator_url = Some(initiator_url.into());
                self
            }
            pub fn destination(mut self, destination: impl Into<String>) -> Self {
                self.destination = Some(destination.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn timestamp(
                mut self,
                timestamp: impl Into<super::network::TimeSinceEpoch>,
            ) -> Self {
                self.timestamp = Some(timestamp.into());
                self
            }
            pub fn depth(mut self, depth: impl Into<i64>) -> Self {
                self.depth = Some(depth.into());
                self
            }
            pub fn completed_attempts(mut self, completed_attempts: impl Into<i64>) -> Self {
                self.completed_attempts = Some(completed_attempts.into());
                self
            }
            pub fn body(mut self, body: impl Into<serde_json::Value>) -> Self {
                self.body = Some(body.into());
                self
            }
            pub fn status(mut self, status: impl Into<ReportStatus>) -> Self {
                self.status = Some(status.into());
                self
            }
            pub fn build(self) -> Result<ReportingApiReport, String> {
                Ok(ReportingApiReport {
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                    initiator_url: self.initiator_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(initiator_url))
                    })?,
                    destination: self.destination.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(destination))
                    })?,
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    timestamp: self.timestamp.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(timestamp))
                    })?,
                    depth: self.depth.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(depth))
                    })?,
                    completed_attempts: self.completed_attempts.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(completed_attempts)
                        )
                    })?,
                    body: self.body.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(body))
                    })?,
                    status: self.status.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(status))
                    })?,
                })
            }
        }
        impl ReportingApiReport {
            pub const IDENTIFIER: &'static str = "Network.ReportingApiReport";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ReportingApiEndpoint {
            #[doc = "The URL of the endpoint to which reports may be delivered."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Name of the endpoint group."]
            #[serde(rename = "groupName")]
            pub group_name: String,
        }
        impl ReportingApiEndpoint {
            pub fn new(url: impl Into<String>, group_name: impl Into<String>) -> Self {
                Self {
                    url: url.into(),
                    group_name: group_name.into(),
                }
            }
        }
        impl ReportingApiEndpoint {
            pub fn builder() -> ReportingApiEndpointBuilder {
                ReportingApiEndpointBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ReportingApiEndpointBuilder {
            url: Option<String>,
            group_name: Option<String>,
        }
        impl ReportingApiEndpointBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn group_name(mut self, group_name: impl Into<String>) -> Self {
                self.group_name = Some(group_name.into());
                self
            }
            pub fn build(self) -> Result<ReportingApiEndpoint, String> {
                Ok(ReportingApiEndpoint {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    group_name: self.group_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(group_name))
                    })?,
                })
            }
        }
        impl ReportingApiEndpoint {
            pub const IDENTIFIER: &'static str = "Network.ReportingApiEndpoint";
        }
        #[doc = "An object providing the result of a network resource load.\n[LoadNetworkResourcePageResult](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-LoadNetworkResourcePageResult)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LoadNetworkResourcePageResult {
            #[serde(rename = "success")]
            pub success: bool,
            #[doc = "Optional values used for error reporting."]
            #[serde(rename = "netError")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub net_error: Option<f64>,
            #[serde(rename = "netErrorName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub net_error_name: Option<String>,
            #[serde(rename = "httpStatusCode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub http_status_code: Option<f64>,
            #[doc = "If successful, one of the following two fields holds the result."]
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub stream: Option<super::io::StreamHandle>,
            #[doc = "Response headers."]
            #[serde(rename = "headers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub headers: Option<super::network::Headers>,
        }
        impl LoadNetworkResourcePageResult {
            pub fn new(success: impl Into<bool>) -> Self {
                Self {
                    success: success.into(),
                    net_error: None,
                    net_error_name: None,
                    http_status_code: None,
                    stream: None,
                    headers: None,
                }
            }
        }
        impl LoadNetworkResourcePageResult {
            pub fn builder() -> LoadNetworkResourcePageResultBuilder {
                LoadNetworkResourcePageResultBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LoadNetworkResourcePageResultBuilder {
            success: Option<bool>,
            net_error: Option<f64>,
            net_error_name: Option<String>,
            http_status_code: Option<f64>,
            stream: Option<super::io::StreamHandle>,
            headers: Option<super::network::Headers>,
        }
        impl LoadNetworkResourcePageResultBuilder {
            pub fn success(mut self, success: impl Into<bool>) -> Self {
                self.success = Some(success.into());
                self
            }
            pub fn net_error(mut self, net_error: impl Into<f64>) -> Self {
                self.net_error = Some(net_error.into());
                self
            }
            pub fn net_error_name(mut self, net_error_name: impl Into<String>) -> Self {
                self.net_error_name = Some(net_error_name.into());
                self
            }
            pub fn http_status_code(mut self, http_status_code: impl Into<f64>) -> Self {
                self.http_status_code = Some(http_status_code.into());
                self
            }
            pub fn stream(mut self, stream: impl Into<super::io::StreamHandle>) -> Self {
                self.stream = Some(stream.into());
                self
            }
            pub fn headers(mut self, headers: impl Into<super::network::Headers>) -> Self {
                self.headers = Some(headers.into());
                self
            }
            pub fn build(self) -> Result<LoadNetworkResourcePageResult, String> {
                Ok(LoadNetworkResourcePageResult {
                    success: self.success.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(success))
                    })?,
                    net_error: self.net_error,
                    net_error_name: self.net_error_name,
                    http_status_code: self.http_status_code,
                    stream: self.stream,
                    headers: self.headers,
                })
            }
        }
        impl LoadNetworkResourcePageResult {
            pub const IDENTIFIER: &'static str = "Network.LoadNetworkResourcePageResult";
        }
        #[doc = "An options object that may be extended later to better support CORS,\nCORB and streaming.\n[LoadNetworkResourceOptions](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-LoadNetworkResourceOptions)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LoadNetworkResourceOptions {
            #[serde(rename = "disableCache")]
            pub disable_cache: bool,
            #[serde(rename = "includeCredentials")]
            pub include_credentials: bool,
        }
        impl LoadNetworkResourceOptions {
            pub fn new(
                disable_cache: impl Into<bool>,
                include_credentials: impl Into<bool>,
            ) -> Self {
                Self {
                    disable_cache: disable_cache.into(),
                    include_credentials: include_credentials.into(),
                }
            }
        }
        impl LoadNetworkResourceOptions {
            pub fn builder() -> LoadNetworkResourceOptionsBuilder {
                LoadNetworkResourceOptionsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LoadNetworkResourceOptionsBuilder {
            disable_cache: Option<bool>,
            include_credentials: Option<bool>,
        }
        impl LoadNetworkResourceOptionsBuilder {
            pub fn disable_cache(mut self, disable_cache: impl Into<bool>) -> Self {
                self.disable_cache = Some(disable_cache.into());
                self
            }
            pub fn include_credentials(mut self, include_credentials: impl Into<bool>) -> Self {
                self.include_credentials = Some(include_credentials.into());
                self
            }
            pub fn build(self) -> Result<LoadNetworkResourceOptions, String> {
                Ok(LoadNetworkResourceOptions {
                    disable_cache: self.disable_cache.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(disable_cache))
                    })?,
                    include_credentials: self.include_credentials.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(include_credentials)
                        )
                    })?,
                })
            }
        }
        impl LoadNetworkResourceOptions {
            pub const IDENTIFIER: &'static str = "Network.LoadNetworkResourceOptions";
        }
        #[doc = "Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.\n[setAcceptedEncodings](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setAcceptedEncodings)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetAcceptedEncodingsParams {
            #[doc = "List of accepted content encodings."]
            #[serde(rename = "encodings")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub encodings: Vec<ContentEncoding>,
        }
        impl SetAcceptedEncodingsParams {
            pub fn new(encodings: Vec<ContentEncoding>) -> Self {
                Self { encodings }
            }
        }
        impl SetAcceptedEncodingsParams {
            pub fn builder() -> SetAcceptedEncodingsParamsBuilder {
                SetAcceptedEncodingsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetAcceptedEncodingsParamsBuilder {
            encodings: Option<Vec<ContentEncoding>>,
        }
        impl SetAcceptedEncodingsParamsBuilder {
            pub fn encoding(mut self, encoding: impl Into<ContentEncoding>) -> Self {
                let v = self.encodings.get_or_insert(Vec::new());
                v.push(encoding.into());
                self
            }
            pub fn encodings<I, S>(mut self, encodings: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ContentEncoding>,
            {
                let v = self.encodings.get_or_insert(Vec::new());
                for val in encodings {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetAcceptedEncodingsParams, String> {
                Ok(SetAcceptedEncodingsParams {
                    encodings: self.encodings.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(encodings))
                    })?,
                })
            }
        }
        impl SetAcceptedEncodingsParams {
            pub const IDENTIFIER: &'static str = "Network.setAcceptedEncodings";
        }
        impl chromiumoxide_types::Method for SetAcceptedEncodingsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetAcceptedEncodingsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.\n[setAcceptedEncodings](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setAcceptedEncodings)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetAcceptedEncodingsReturns {}
        impl chromiumoxide_types::Command for SetAcceptedEncodingsParams {
            type Response = SetAcceptedEncodingsReturns;
        }
        #[doc = "Clears accepted encodings set by setAcceptedEncodings\n[clearAcceptedEncodingsOverride](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-clearAcceptedEncodingsOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearAcceptedEncodingsOverrideParams {}
        impl ClearAcceptedEncodingsOverrideParams {
            pub const IDENTIFIER: &'static str = "Network.clearAcceptedEncodingsOverride";
        }
        impl chromiumoxide_types::Method for ClearAcceptedEncodingsOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearAcceptedEncodingsOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears accepted encodings set by setAcceptedEncodings\n[clearAcceptedEncodingsOverride](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-clearAcceptedEncodingsOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearAcceptedEncodingsOverrideReturns {}
        impl chromiumoxide_types::Command for ClearAcceptedEncodingsOverrideParams {
            type Response = ClearAcceptedEncodingsOverrideReturns;
        }
        #[doc = "Clears browser cache.\n[clearBrowserCache](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-clearBrowserCache)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearBrowserCacheParams {}
        impl ClearBrowserCacheParams {
            pub const IDENTIFIER: &'static str = "Network.clearBrowserCache";
        }
        impl chromiumoxide_types::Method for ClearBrowserCacheParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearBrowserCacheParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears browser cache.\n[clearBrowserCache](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-clearBrowserCache)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearBrowserCacheReturns {}
        impl chromiumoxide_types::Command for ClearBrowserCacheParams {
            type Response = ClearBrowserCacheReturns;
        }
        #[doc = "Clears browser cookies.\n[clearBrowserCookies](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-clearBrowserCookies)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearBrowserCookiesParams {}
        impl ClearBrowserCookiesParams {
            pub const IDENTIFIER: &'static str = "Network.clearBrowserCookies";
        }
        impl chromiumoxide_types::Method for ClearBrowserCookiesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearBrowserCookiesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears browser cookies.\n[clearBrowserCookies](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-clearBrowserCookies)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearBrowserCookiesReturns {}
        impl chromiumoxide_types::Command for ClearBrowserCookiesParams {
            type Response = ClearBrowserCookiesReturns;
        }
        #[doc = "Deletes browser cookies with matching name and url or domain/path pair.\n[deleteCookies](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-deleteCookies)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DeleteCookiesParams {
            #[doc = "Name of the cookies to remove."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "If specified, deletes all the cookies with the given name where domain and path match\nprovided URL."]
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url: Option<String>,
            #[doc = "If specified, deletes only cookies with the exact domain."]
            #[serde(rename = "domain")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub domain: Option<String>,
            #[doc = "If specified, deletes only cookies with the exact path."]
            #[serde(rename = "path")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub path: Option<String>,
        }
        impl DeleteCookiesParams {
            pub fn new(name: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    url: None,
                    domain: None,
                    path: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for DeleteCookiesParams {
            fn from(url: T) -> Self {
                DeleteCookiesParams::new(url)
            }
        }
        impl DeleteCookiesParams {
            pub fn builder() -> DeleteCookiesParamsBuilder {
                DeleteCookiesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DeleteCookiesParamsBuilder {
            name: Option<String>,
            url: Option<String>,
            domain: Option<String>,
            path: Option<String>,
        }
        impl DeleteCookiesParamsBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn domain(mut self, domain: impl Into<String>) -> Self {
                self.domain = Some(domain.into());
                self
            }
            pub fn path(mut self, path: impl Into<String>) -> Self {
                self.path = Some(path.into());
                self
            }
            pub fn build(self) -> Result<DeleteCookiesParams, String> {
                Ok(DeleteCookiesParams {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    url: self.url,
                    domain: self.domain,
                    path: self.path,
                })
            }
        }
        impl DeleteCookiesParams {
            pub const IDENTIFIER: &'static str = "Network.deleteCookies";
        }
        impl chromiumoxide_types::Method for DeleteCookiesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DeleteCookiesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Deletes browser cookies with matching name and url or domain/path pair.\n[deleteCookies](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-deleteCookies)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DeleteCookiesReturns {}
        impl chromiumoxide_types::Command for DeleteCookiesParams {
            type Response = DeleteCookiesReturns;
        }
        #[doc = "Disables network tracking, prevents network events from being sent to the client.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Network.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables network tracking, prevents network events from being sent to the client.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Activates emulation of network conditions.\n[emulateNetworkConditions](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-emulateNetworkConditions)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EmulateNetworkConditionsParams {
            #[doc = "True to emulate internet disconnection."]
            #[serde(rename = "offline")]
            pub offline: bool,
            #[doc = "Minimum latency from request sent to response headers received (ms)."]
            #[serde(rename = "latency")]
            pub latency: f64,
            #[doc = "Maximal aggregated download throughput (bytes/sec). -1 disables download throttling."]
            #[serde(rename = "downloadThroughput")]
            pub download_throughput: f64,
            #[doc = "Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling."]
            #[serde(rename = "uploadThroughput")]
            pub upload_throughput: f64,
            #[doc = "Connection type if known."]
            #[serde(rename = "connectionType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub connection_type: Option<ConnectionType>,
        }
        impl EmulateNetworkConditionsParams {
            pub fn new(
                offline: impl Into<bool>,
                latency: impl Into<f64>,
                download_throughput: impl Into<f64>,
                upload_throughput: impl Into<f64>,
            ) -> Self {
                Self {
                    offline: offline.into(),
                    latency: latency.into(),
                    download_throughput: download_throughput.into(),
                    upload_throughput: upload_throughput.into(),
                    connection_type: None,
                }
            }
        }
        impl EmulateNetworkConditionsParams {
            pub fn builder() -> EmulateNetworkConditionsParamsBuilder {
                EmulateNetworkConditionsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EmulateNetworkConditionsParamsBuilder {
            offline: Option<bool>,
            latency: Option<f64>,
            download_throughput: Option<f64>,
            upload_throughput: Option<f64>,
            connection_type: Option<ConnectionType>,
        }
        impl EmulateNetworkConditionsParamsBuilder {
            pub fn offline(mut self, offline: impl Into<bool>) -> Self {
                self.offline = Some(offline.into());
                self
            }
            pub fn latency(mut self, latency: impl Into<f64>) -> Self {
                self.latency = Some(latency.into());
                self
            }
            pub fn download_throughput(mut self, download_throughput: impl Into<f64>) -> Self {
                self.download_throughput = Some(download_throughput.into());
                self
            }
            pub fn upload_throughput(mut self, upload_throughput: impl Into<f64>) -> Self {
                self.upload_throughput = Some(upload_throughput.into());
                self
            }
            pub fn connection_type(mut self, connection_type: impl Into<ConnectionType>) -> Self {
                self.connection_type = Some(connection_type.into());
                self
            }
            pub fn build(self) -> Result<EmulateNetworkConditionsParams, String> {
                Ok(EmulateNetworkConditionsParams {
                    offline: self.offline.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(offline))
                    })?,
                    latency: self.latency.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(latency))
                    })?,
                    download_throughput: self.download_throughput.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(download_throughput)
                        )
                    })?,
                    upload_throughput: self.upload_throughput.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(upload_throughput)
                        )
                    })?,
                    connection_type: self.connection_type,
                })
            }
        }
        impl EmulateNetworkConditionsParams {
            pub const IDENTIFIER: &'static str = "Network.emulateNetworkConditions";
        }
        impl chromiumoxide_types::Method for EmulateNetworkConditionsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EmulateNetworkConditionsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Activates emulation of network conditions.\n[emulateNetworkConditions](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-emulateNetworkConditions)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EmulateNetworkConditionsReturns {}
        impl chromiumoxide_types::Command for EmulateNetworkConditionsParams {
            type Response = EmulateNetworkConditionsReturns;
        }
        #[doc = "Enables network tracking, network events will now be delivered to the client.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {
            #[doc = "Buffer size in bytes to use when preserving network payloads (XHRs, etc)."]
            #[serde(rename = "maxTotalBufferSize")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub max_total_buffer_size: Option<i64>,
            #[doc = "Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc)."]
            #[serde(rename = "maxResourceBufferSize")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub max_resource_buffer_size: Option<i64>,
            #[doc = "Longest post body size (in bytes) that would be included in requestWillBeSent notification"]
            #[serde(rename = "maxPostDataSize")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub max_post_data_size: Option<i64>,
        }
        impl EnableParams {
            pub fn builder() -> EnableParamsBuilder {
                EnableParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EnableParamsBuilder {
            max_total_buffer_size: Option<i64>,
            max_resource_buffer_size: Option<i64>,
            max_post_data_size: Option<i64>,
        }
        impl EnableParamsBuilder {
            pub fn max_total_buffer_size(mut self, max_total_buffer_size: impl Into<i64>) -> Self {
                self.max_total_buffer_size = Some(max_total_buffer_size.into());
                self
            }
            pub fn max_resource_buffer_size(
                mut self,
                max_resource_buffer_size: impl Into<i64>,
            ) -> Self {
                self.max_resource_buffer_size = Some(max_resource_buffer_size.into());
                self
            }
            pub fn max_post_data_size(mut self, max_post_data_size: impl Into<i64>) -> Self {
                self.max_post_data_size = Some(max_post_data_size.into());
                self
            }
            pub fn build(self) -> EnableParams {
                EnableParams {
                    max_total_buffer_size: self.max_total_buffer_size,
                    max_resource_buffer_size: self.max_resource_buffer_size,
                    max_post_data_size: self.max_post_data_size,
                }
            }
        }
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Network.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables network tracking, network events will now be delivered to the client.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Returns all browser cookies. Depending on the backend support, will return detailed cookie\ninformation in the `cookies` field.\n[getAllCookies](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getAllCookies)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetAllCookiesParams {}
        impl GetAllCookiesParams {
            pub const IDENTIFIER: &'static str = "Network.getAllCookies";
        }
        impl chromiumoxide_types::Method for GetAllCookiesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetAllCookiesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns all browser cookies. Depending on the backend support, will return detailed cookie\ninformation in the `cookies` field.\n[getAllCookies](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getAllCookies)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetAllCookiesReturns {
            #[doc = "Array of cookie objects."]
            #[serde(rename = "cookies")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub cookies: Vec<Cookie>,
        }
        impl GetAllCookiesReturns {
            pub fn new(cookies: Vec<Cookie>) -> Self {
                Self { cookies }
            }
        }
        impl GetAllCookiesReturns {
            pub fn builder() -> GetAllCookiesReturnsBuilder {
                GetAllCookiesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetAllCookiesReturnsBuilder {
            cookies: Option<Vec<Cookie>>,
        }
        impl GetAllCookiesReturnsBuilder {
            pub fn cookie(mut self, cookie: impl Into<Cookie>) -> Self {
                let v = self.cookies.get_or_insert(Vec::new());
                v.push(cookie.into());
                self
            }
            pub fn cookies<I, S>(mut self, cookies: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Cookie>,
            {
                let v = self.cookies.get_or_insert(Vec::new());
                for val in cookies {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetAllCookiesReturns, String> {
                Ok(GetAllCookiesReturns {
                    cookies: self.cookies.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cookies))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetAllCookiesParams {
            type Response = GetAllCookiesReturns;
        }
        #[doc = "Returns the DER-encoded certificate.\n[getCertificate](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getCertificate)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetCertificateParams {
            #[doc = "Origin to get certificate for."]
            #[serde(rename = "origin")]
            pub origin: String,
        }
        impl GetCertificateParams {
            pub fn new(origin: impl Into<String>) -> Self {
                Self {
                    origin: origin.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for GetCertificateParams {
            fn from(url: T) -> Self {
                GetCertificateParams::new(url)
            }
        }
        impl GetCertificateParams {
            pub fn builder() -> GetCertificateParamsBuilder {
                GetCertificateParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetCertificateParamsBuilder {
            origin: Option<String>,
        }
        impl GetCertificateParamsBuilder {
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn build(self) -> Result<GetCertificateParams, String> {
                Ok(GetCertificateParams {
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                })
            }
        }
        impl GetCertificateParams {
            pub const IDENTIFIER: &'static str = "Network.getCertificate";
        }
        impl chromiumoxide_types::Method for GetCertificateParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetCertificateParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the DER-encoded certificate.\n[getCertificate](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getCertificate)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetCertificateReturns {
            #[serde(rename = "tableNames")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub table_names: Vec<String>,
        }
        impl GetCertificateReturns {
            pub fn new(table_names: Vec<String>) -> Self {
                Self { table_names }
            }
        }
        impl GetCertificateReturns {
            pub fn builder() -> GetCertificateReturnsBuilder {
                GetCertificateReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetCertificateReturnsBuilder {
            table_names: Option<Vec<String>>,
        }
        impl GetCertificateReturnsBuilder {
            pub fn table_name(mut self, table_name: impl Into<String>) -> Self {
                let v = self.table_names.get_or_insert(Vec::new());
                v.push(table_name.into());
                self
            }
            pub fn table_names<I, S>(mut self, table_names: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.table_names.get_or_insert(Vec::new());
                for val in table_names {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetCertificateReturns, String> {
                Ok(GetCertificateReturns {
                    table_names: self.table_names.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(table_names))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetCertificateParams {
            type Response = GetCertificateReturns;
        }
        #[doc = "Returns all browser cookies for the current URL. Depending on the backend support, will return\ndetailed cookie information in the `cookies` field.\n[getCookies](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getCookies)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetCookiesParams {
            #[doc = "The list of URLs for which applicable cookies will be fetched.\nIf not specified, it's assumed to be set to the list containing\nthe URLs of the page and all of its subframes."]
            #[serde(rename = "urls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub urls: Option<Vec<String>>,
        }
        impl GetCookiesParams {
            pub fn builder() -> GetCookiesParamsBuilder {
                GetCookiesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetCookiesParamsBuilder {
            urls: Option<Vec<String>>,
        }
        impl GetCookiesParamsBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                let v = self.urls.get_or_insert(Vec::new());
                v.push(url.into());
                self
            }
            pub fn urls<I, S>(mut self, urls: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.urls.get_or_insert(Vec::new());
                for val in urls {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> GetCookiesParams {
                GetCookiesParams { urls: self.urls }
            }
        }
        impl GetCookiesParams {
            pub const IDENTIFIER: &'static str = "Network.getCookies";
        }
        impl chromiumoxide_types::Method for GetCookiesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetCookiesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns all browser cookies for the current URL. Depending on the backend support, will return\ndetailed cookie information in the `cookies` field.\n[getCookies](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getCookies)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetCookiesReturns {
            #[doc = "Array of cookie objects."]
            #[serde(rename = "cookies")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub cookies: Vec<Cookie>,
        }
        impl GetCookiesReturns {
            pub fn new(cookies: Vec<Cookie>) -> Self {
                Self { cookies }
            }
        }
        impl GetCookiesReturns {
            pub fn builder() -> GetCookiesReturnsBuilder {
                GetCookiesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetCookiesReturnsBuilder {
            cookies: Option<Vec<Cookie>>,
        }
        impl GetCookiesReturnsBuilder {
            pub fn cookie(mut self, cookie: impl Into<Cookie>) -> Self {
                let v = self.cookies.get_or_insert(Vec::new());
                v.push(cookie.into());
                self
            }
            pub fn cookies<I, S>(mut self, cookies: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Cookie>,
            {
                let v = self.cookies.get_or_insert(Vec::new());
                for val in cookies {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetCookiesReturns, String> {
                Ok(GetCookiesReturns {
                    cookies: self.cookies.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cookies))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetCookiesParams {
            type Response = GetCookiesReturns;
        }
        #[doc = "Returns content served for the given request.\n[getResponseBody](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getResponseBody)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetResponseBodyParams {
            #[doc = "Identifier of the network request to get content for."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
        }
        impl GetResponseBodyParams {
            pub fn new(request_id: impl Into<RequestId>) -> Self {
                Self {
                    request_id: request_id.into(),
                }
            }
        }
        impl GetResponseBodyParams {
            pub fn builder() -> GetResponseBodyParamsBuilder {
                GetResponseBodyParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetResponseBodyParamsBuilder {
            request_id: Option<RequestId>,
        }
        impl GetResponseBodyParamsBuilder {
            pub fn request_id(mut self, request_id: impl Into<RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn build(self) -> Result<GetResponseBodyParams, String> {
                Ok(GetResponseBodyParams {
                    request_id: self.request_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_id))
                    })?,
                })
            }
        }
        impl GetResponseBodyParams {
            pub const IDENTIFIER: &'static str = "Network.getResponseBody";
        }
        impl chromiumoxide_types::Method for GetResponseBodyParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetResponseBodyParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns content served for the given request.\n[getResponseBody](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getResponseBody)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetResponseBodyReturns {
            #[doc = "Response body."]
            #[serde(rename = "body")]
            pub body: String,
            #[doc = "True, if content was sent as base64."]
            #[serde(rename = "base64Encoded")]
            pub base64_encoded: bool,
        }
        impl GetResponseBodyReturns {
            pub fn new(body: impl Into<String>, base64_encoded: impl Into<bool>) -> Self {
                Self {
                    body: body.into(),
                    base64_encoded: base64_encoded.into(),
                }
            }
        }
        impl GetResponseBodyReturns {
            pub fn builder() -> GetResponseBodyReturnsBuilder {
                GetResponseBodyReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetResponseBodyReturnsBuilder {
            body: Option<String>,
            base64_encoded: Option<bool>,
        }
        impl GetResponseBodyReturnsBuilder {
            pub fn body(mut self, body: impl Into<String>) -> Self {
                self.body = Some(body.into());
                self
            }
            pub fn base64_encoded(mut self, base64_encoded: impl Into<bool>) -> Self {
                self.base64_encoded = Some(base64_encoded.into());
                self
            }
            pub fn build(self) -> Result<GetResponseBodyReturns, String> {
                Ok(GetResponseBodyReturns {
                    body: self.body.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(body))
                    })?,
                    base64_encoded: self.base64_encoded.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(base64_encoded))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetResponseBodyParams {
            type Response = GetResponseBodyReturns;
        }
        #[doc = "Returns post data sent with the request. Returns an error when no data was sent with the request.\n[getRequestPostData](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getRequestPostData)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetRequestPostDataParams {
            #[doc = "Identifier of the network request to get content for."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
        }
        impl GetRequestPostDataParams {
            pub fn new(request_id: impl Into<RequestId>) -> Self {
                Self {
                    request_id: request_id.into(),
                }
            }
        }
        impl GetRequestPostDataParams {
            pub fn builder() -> GetRequestPostDataParamsBuilder {
                GetRequestPostDataParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetRequestPostDataParamsBuilder {
            request_id: Option<RequestId>,
        }
        impl GetRequestPostDataParamsBuilder {
            pub fn request_id(mut self, request_id: impl Into<RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn build(self) -> Result<GetRequestPostDataParams, String> {
                Ok(GetRequestPostDataParams {
                    request_id: self.request_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_id))
                    })?,
                })
            }
        }
        impl GetRequestPostDataParams {
            pub const IDENTIFIER: &'static str = "Network.getRequestPostData";
        }
        impl chromiumoxide_types::Method for GetRequestPostDataParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetRequestPostDataParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns post data sent with the request. Returns an error when no data was sent with the request.\n[getRequestPostData](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getRequestPostData)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetRequestPostDataReturns {
            #[doc = "Request body string, omitting files from multipart requests"]
            #[serde(rename = "postData")]
            pub post_data: String,
        }
        impl GetRequestPostDataReturns {
            pub fn new(post_data: impl Into<String>) -> Self {
                Self {
                    post_data: post_data.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for GetRequestPostDataReturns {
            fn from(url: T) -> Self {
                GetRequestPostDataReturns::new(url)
            }
        }
        impl GetRequestPostDataReturns {
            pub fn builder() -> GetRequestPostDataReturnsBuilder {
                GetRequestPostDataReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetRequestPostDataReturnsBuilder {
            post_data: Option<String>,
        }
        impl GetRequestPostDataReturnsBuilder {
            pub fn post_data(mut self, post_data: impl Into<String>) -> Self {
                self.post_data = Some(post_data.into());
                self
            }
            pub fn build(self) -> Result<GetRequestPostDataReturns, String> {
                Ok(GetRequestPostDataReturns {
                    post_data: self.post_data.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(post_data))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetRequestPostDataParams {
            type Response = GetRequestPostDataReturns;
        }
        #[doc = "Returns content served for the given currently intercepted request.\n[getResponseBodyForInterception](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getResponseBodyForInterception)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetResponseBodyForInterceptionParams {
            #[doc = "Identifier for the intercepted request to get body for."]
            #[serde(rename = "interceptionId")]
            pub interception_id: InterceptionId,
        }
        impl GetResponseBodyForInterceptionParams {
            pub fn new(interception_id: impl Into<InterceptionId>) -> Self {
                Self {
                    interception_id: interception_id.into(),
                }
            }
        }
        impl GetResponseBodyForInterceptionParams {
            pub fn builder() -> GetResponseBodyForInterceptionParamsBuilder {
                GetResponseBodyForInterceptionParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetResponseBodyForInterceptionParamsBuilder {
            interception_id: Option<InterceptionId>,
        }
        impl GetResponseBodyForInterceptionParamsBuilder {
            pub fn interception_id(mut self, interception_id: impl Into<InterceptionId>) -> Self {
                self.interception_id = Some(interception_id.into());
                self
            }
            pub fn build(self) -> Result<GetResponseBodyForInterceptionParams, String> {
                Ok(GetResponseBodyForInterceptionParams {
                    interception_id: self.interception_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(interception_id))
                    })?,
                })
            }
        }
        impl GetResponseBodyForInterceptionParams {
            pub const IDENTIFIER: &'static str = "Network.getResponseBodyForInterception";
        }
        impl chromiumoxide_types::Method for GetResponseBodyForInterceptionParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetResponseBodyForInterceptionParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns content served for the given currently intercepted request.\n[getResponseBodyForInterception](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getResponseBodyForInterception)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetResponseBodyForInterceptionReturns {
            #[doc = "Response body."]
            #[serde(rename = "body")]
            pub body: String,
            #[doc = "True, if content was sent as base64."]
            #[serde(rename = "base64Encoded")]
            pub base64_encoded: bool,
        }
        impl GetResponseBodyForInterceptionReturns {
            pub fn new(body: impl Into<String>, base64_encoded: impl Into<bool>) -> Self {
                Self {
                    body: body.into(),
                    base64_encoded: base64_encoded.into(),
                }
            }
        }
        impl GetResponseBodyForInterceptionReturns {
            pub fn builder() -> GetResponseBodyForInterceptionReturnsBuilder {
                GetResponseBodyForInterceptionReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetResponseBodyForInterceptionReturnsBuilder {
            body: Option<String>,
            base64_encoded: Option<bool>,
        }
        impl GetResponseBodyForInterceptionReturnsBuilder {
            pub fn body(mut self, body: impl Into<String>) -> Self {
                self.body = Some(body.into());
                self
            }
            pub fn base64_encoded(mut self, base64_encoded: impl Into<bool>) -> Self {
                self.base64_encoded = Some(base64_encoded.into());
                self
            }
            pub fn build(self) -> Result<GetResponseBodyForInterceptionReturns, String> {
                Ok(GetResponseBodyForInterceptionReturns {
                    body: self.body.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(body))
                    })?,
                    base64_encoded: self.base64_encoded.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(base64_encoded))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetResponseBodyForInterceptionParams {
            type Response = GetResponseBodyForInterceptionReturns;
        }
        #[doc = "Returns a handle to the stream representing the response body. Note that after this command,\nthe intercepted request can't be continued as is -- you either need to cancel it or to provide\nthe response body. The stream only supports sequential read, IO.read will fail if the position\nis specified.\n[takeResponseBodyForInterceptionAsStream](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-takeResponseBodyForInterceptionAsStream)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TakeResponseBodyForInterceptionAsStreamParams {
            #[serde(rename = "interceptionId")]
            pub interception_id: InterceptionId,
        }
        impl TakeResponseBodyForInterceptionAsStreamParams {
            pub fn new(interception_id: impl Into<InterceptionId>) -> Self {
                Self {
                    interception_id: interception_id.into(),
                }
            }
        }
        impl TakeResponseBodyForInterceptionAsStreamParams {
            pub fn builder() -> TakeResponseBodyForInterceptionAsStreamParamsBuilder {
                TakeResponseBodyForInterceptionAsStreamParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TakeResponseBodyForInterceptionAsStreamParamsBuilder {
            interception_id: Option<InterceptionId>,
        }
        impl TakeResponseBodyForInterceptionAsStreamParamsBuilder {
            pub fn interception_id(mut self, interception_id: impl Into<InterceptionId>) -> Self {
                self.interception_id = Some(interception_id.into());
                self
            }
            pub fn build(self) -> Result<TakeResponseBodyForInterceptionAsStreamParams, String> {
                Ok(TakeResponseBodyForInterceptionAsStreamParams {
                    interception_id: self.interception_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(interception_id))
                    })?,
                })
            }
        }
        impl TakeResponseBodyForInterceptionAsStreamParams {
            pub const IDENTIFIER: &'static str = "Network.takeResponseBodyForInterceptionAsStream";
        }
        impl chromiumoxide_types::Method for TakeResponseBodyForInterceptionAsStreamParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for TakeResponseBodyForInterceptionAsStreamParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns a handle to the stream representing the response body. Note that after this command,\nthe intercepted request can't be continued as is -- you either need to cancel it or to provide\nthe response body. The stream only supports sequential read, IO.read will fail if the position\nis specified.\n[takeResponseBodyForInterceptionAsStream](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-takeResponseBodyForInterceptionAsStream)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TakeResponseBodyForInterceptionAsStreamReturns {
            #[serde(rename = "stream")]
            pub stream: super::io::StreamHandle,
        }
        impl TakeResponseBodyForInterceptionAsStreamReturns {
            pub fn new(stream: impl Into<super::io::StreamHandle>) -> Self {
                Self {
                    stream: stream.into(),
                }
            }
        }
        impl TakeResponseBodyForInterceptionAsStreamReturns {
            pub fn builder() -> TakeResponseBodyForInterceptionAsStreamReturnsBuilder {
                TakeResponseBodyForInterceptionAsStreamReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TakeResponseBodyForInterceptionAsStreamReturnsBuilder {
            stream: Option<super::io::StreamHandle>,
        }
        impl TakeResponseBodyForInterceptionAsStreamReturnsBuilder {
            pub fn stream(mut self, stream: impl Into<super::io::StreamHandle>) -> Self {
                self.stream = Some(stream.into());
                self
            }
            pub fn build(self) -> Result<TakeResponseBodyForInterceptionAsStreamReturns, String> {
                Ok(TakeResponseBodyForInterceptionAsStreamReturns {
                    stream: self.stream.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(stream))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for TakeResponseBodyForInterceptionAsStreamParams {
            type Response = TakeResponseBodyForInterceptionAsStreamReturns;
        }
        #[doc = "This method sends a new XMLHttpRequest which is identical to the original one. The following\nparameters should be identical: method, url, async, request body, extra headers, withCredentials\nattribute, user, password.\n[replayXHR](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-replayXHR)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ReplayXhrParams {
            #[doc = "Identifier of XHR to replay."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
        }
        impl ReplayXhrParams {
            pub fn new(request_id: impl Into<RequestId>) -> Self {
                Self {
                    request_id: request_id.into(),
                }
            }
        }
        impl ReplayXhrParams {
            pub fn builder() -> ReplayXhrParamsBuilder {
                ReplayXhrParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ReplayXhrParamsBuilder {
            request_id: Option<RequestId>,
        }
        impl ReplayXhrParamsBuilder {
            pub fn request_id(mut self, request_id: impl Into<RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn build(self) -> Result<ReplayXhrParams, String> {
                Ok(ReplayXhrParams {
                    request_id: self.request_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_id))
                    })?,
                })
            }
        }
        impl ReplayXhrParams {
            pub const IDENTIFIER: &'static str = "Network.replayXHR";
        }
        impl chromiumoxide_types::Method for ReplayXhrParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ReplayXhrParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "This method sends a new XMLHttpRequest which is identical to the original one. The following\nparameters should be identical: method, url, async, request body, extra headers, withCredentials\nattribute, user, password.\n[replayXHR](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-replayXHR)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ReplayXhrReturns {}
        impl chromiumoxide_types::Command for ReplayXhrParams {
            type Response = ReplayXhrReturns;
        }
        #[doc = "Searches for given string in response content.\n[searchInResponseBody](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-searchInResponseBody)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SearchInResponseBodyParams {
            #[doc = "Identifier of the network response to search."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "String to search for."]
            #[serde(rename = "query")]
            pub query: String,
            #[doc = "If true, search is case sensitive."]
            #[serde(rename = "caseSensitive")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub case_sensitive: Option<bool>,
            #[doc = "If true, treats string parameter as regex."]
            #[serde(rename = "isRegex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_regex: Option<bool>,
        }
        impl SearchInResponseBodyParams {
            pub fn new(request_id: impl Into<RequestId>, query: impl Into<String>) -> Self {
                Self {
                    request_id: request_id.into(),
                    query: query.into(),
                    case_sensitive: None,
                    is_regex: None,
                }
            }
        }
        impl SearchInResponseBodyParams {
            pub fn builder() -> SearchInResponseBodyParamsBuilder {
                SearchInResponseBodyParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SearchInResponseBodyParamsBuilder {
            request_id: Option<RequestId>,
            query: Option<String>,
            case_sensitive: Option<bool>,
            is_regex: Option<bool>,
        }
        impl SearchInResponseBodyParamsBuilder {
            pub fn request_id(mut self, request_id: impl Into<RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn query(mut self, query: impl Into<String>) -> Self {
                self.query = Some(query.into());
                self
            }
            pub fn case_sensitive(mut self, case_sensitive: impl Into<bool>) -> Self {
                self.case_sensitive = Some(case_sensitive.into());
                self
            }
            pub fn is_regex(mut self, is_regex: impl Into<bool>) -> Self {
                self.is_regex = Some(is_regex.into());
                self
            }
            pub fn build(self) -> Result<SearchInResponseBodyParams, String> {
                Ok(SearchInResponseBodyParams {
                    request_id: self.request_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_id))
                    })?,
                    query: self.query.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(query))
                    })?,
                    case_sensitive: self.case_sensitive,
                    is_regex: self.is_regex,
                })
            }
        }
        impl SearchInResponseBodyParams {
            pub const IDENTIFIER: &'static str = "Network.searchInResponseBody";
        }
        impl chromiumoxide_types::Method for SearchInResponseBodyParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SearchInResponseBodyParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Searches for given string in response content.\n[searchInResponseBody](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-searchInResponseBody)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SearchInResponseBodyReturns {
            #[doc = "List of search matches."]
            #[serde(rename = "result")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub result: Vec<super::super::js_protocol::debugger::SearchMatch>,
        }
        impl SearchInResponseBodyReturns {
            pub fn new(result: Vec<super::super::js_protocol::debugger::SearchMatch>) -> Self {
                Self { result }
            }
        }
        impl SearchInResponseBodyReturns {
            pub fn builder() -> SearchInResponseBodyReturnsBuilder {
                SearchInResponseBodyReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SearchInResponseBodyReturnsBuilder {
            result: Option<Vec<super::super::js_protocol::debugger::SearchMatch>>,
        }
        impl SearchInResponseBodyReturnsBuilder {
            pub fn result(
                mut self,
                result: impl Into<super::super::js_protocol::debugger::SearchMatch>,
            ) -> Self {
                let v = self.result.get_or_insert(Vec::new());
                v.push(result.into());
                self
            }
            pub fn results<I, S>(mut self, results: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<super::super::js_protocol::debugger::SearchMatch>,
            {
                let v = self.result.get_or_insert(Vec::new());
                for val in results {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SearchInResponseBodyReturns, String> {
                Ok(SearchInResponseBodyReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SearchInResponseBodyParams {
            type Response = SearchInResponseBodyReturns;
        }
        #[doc = "Blocks URLs from loading.\n[setBlockedURLs](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setBlockedURLs)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetBlockedUrLsParams {
            #[doc = "URL patterns to block. Wildcards ('*') are allowed."]
            #[serde(rename = "urls")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub urls: Vec<String>,
        }
        impl SetBlockedUrLsParams {
            pub fn new(urls: Vec<String>) -> Self {
                Self { urls }
            }
        }
        impl SetBlockedUrLsParams {
            pub fn builder() -> SetBlockedUrLsParamsBuilder {
                SetBlockedUrLsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetBlockedUrLsParamsBuilder {
            urls: Option<Vec<String>>,
        }
        impl SetBlockedUrLsParamsBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                let v = self.urls.get_or_insert(Vec::new());
                v.push(url.into());
                self
            }
            pub fn urls<I, S>(mut self, urls: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.urls.get_or_insert(Vec::new());
                for val in urls {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetBlockedUrLsParams, String> {
                Ok(SetBlockedUrLsParams {
                    urls: self.urls.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(urls))
                    })?,
                })
            }
        }
        impl SetBlockedUrLsParams {
            pub const IDENTIFIER: &'static str = "Network.setBlockedURLs";
        }
        impl chromiumoxide_types::Method for SetBlockedUrLsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetBlockedUrLsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Blocks URLs from loading.\n[setBlockedURLs](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setBlockedURLs)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetBlockedUrLsReturns {}
        impl chromiumoxide_types::Command for SetBlockedUrLsParams {
            type Response = SetBlockedUrLsReturns;
        }
        #[doc = "Toggles ignoring of service worker for each request.\n[setBypassServiceWorker](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setBypassServiceWorker)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetBypassServiceWorkerParams {
            #[doc = "Bypass service worker and load from network."]
            #[serde(rename = "bypass")]
            pub bypass: bool,
        }
        impl SetBypassServiceWorkerParams {
            pub fn new(bypass: impl Into<bool>) -> Self {
                Self {
                    bypass: bypass.into(),
                }
            }
        }
        impl SetBypassServiceWorkerParams {
            pub fn builder() -> SetBypassServiceWorkerParamsBuilder {
                SetBypassServiceWorkerParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetBypassServiceWorkerParamsBuilder {
            bypass: Option<bool>,
        }
        impl SetBypassServiceWorkerParamsBuilder {
            pub fn bypass(mut self, bypass: impl Into<bool>) -> Self {
                self.bypass = Some(bypass.into());
                self
            }
            pub fn build(self) -> Result<SetBypassServiceWorkerParams, String> {
                Ok(SetBypassServiceWorkerParams {
                    bypass: self.bypass.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(bypass))
                    })?,
                })
            }
        }
        impl SetBypassServiceWorkerParams {
            pub const IDENTIFIER: &'static str = "Network.setBypassServiceWorker";
        }
        impl chromiumoxide_types::Method for SetBypassServiceWorkerParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetBypassServiceWorkerParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Toggles ignoring of service worker for each request.\n[setBypassServiceWorker](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setBypassServiceWorker)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetBypassServiceWorkerReturns {}
        impl chromiumoxide_types::Command for SetBypassServiceWorkerParams {
            type Response = SetBypassServiceWorkerReturns;
        }
        #[doc = "Toggles ignoring cache for each request. If `true`, cache will not be used.\n[setCacheDisabled](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setCacheDisabled)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetCacheDisabledParams {
            #[doc = "Cache disabled state."]
            #[serde(rename = "cacheDisabled")]
            pub cache_disabled: bool,
        }
        impl SetCacheDisabledParams {
            pub fn new(cache_disabled: impl Into<bool>) -> Self {
                Self {
                    cache_disabled: cache_disabled.into(),
                }
            }
        }
        impl SetCacheDisabledParams {
            pub fn builder() -> SetCacheDisabledParamsBuilder {
                SetCacheDisabledParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetCacheDisabledParamsBuilder {
            cache_disabled: Option<bool>,
        }
        impl SetCacheDisabledParamsBuilder {
            pub fn cache_disabled(mut self, cache_disabled: impl Into<bool>) -> Self {
                self.cache_disabled = Some(cache_disabled.into());
                self
            }
            pub fn build(self) -> Result<SetCacheDisabledParams, String> {
                Ok(SetCacheDisabledParams {
                    cache_disabled: self.cache_disabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cache_disabled))
                    })?,
                })
            }
        }
        impl SetCacheDisabledParams {
            pub const IDENTIFIER: &'static str = "Network.setCacheDisabled";
        }
        impl chromiumoxide_types::Method for SetCacheDisabledParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetCacheDisabledParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Toggles ignoring cache for each request. If `true`, cache will not be used.\n[setCacheDisabled](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setCacheDisabled)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetCacheDisabledReturns {}
        impl chromiumoxide_types::Command for SetCacheDisabledParams {
            type Response = SetCacheDisabledReturns;
        }
        #[doc = "Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.\n[setCookie](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setCookie)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetCookieParams {
            #[doc = "Cookie name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Cookie value."]
            #[serde(rename = "value")]
            pub value: String,
            #[doc = "The request-URI to associate with the setting of the cookie. This value can affect the\ndefault domain, path, source port, and source scheme values of the created cookie."]
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url: Option<String>,
            #[doc = "Cookie domain."]
            #[serde(rename = "domain")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub domain: Option<String>,
            #[doc = "Cookie path."]
            #[serde(rename = "path")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub path: Option<String>,
            #[doc = "True if cookie is secure."]
            #[serde(rename = "secure")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub secure: Option<bool>,
            #[doc = "True if cookie is http-only."]
            #[serde(rename = "httpOnly")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub http_only: Option<bool>,
            #[doc = "Cookie SameSite type."]
            #[serde(rename = "sameSite")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub same_site: Option<CookieSameSite>,
            #[doc = "Cookie expiration date, session cookie if not set"]
            #[serde(rename = "expires")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub expires: Option<TimeSinceEpoch>,
            #[doc = "Cookie Priority type."]
            #[serde(rename = "priority")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub priority: Option<CookiePriority>,
            #[doc = "True if cookie is SameParty."]
            #[serde(rename = "sameParty")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub same_party: Option<bool>,
            #[doc = "Cookie source scheme type."]
            #[serde(rename = "sourceScheme")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub source_scheme: Option<CookieSourceScheme>,
            #[doc = "Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.\nAn unspecified port value allows protocol clients to emulate legacy cookie scope for the port.\nThis is a temporary ability and it will be removed in the future."]
            #[serde(rename = "sourcePort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub source_port: Option<i64>,
            #[doc = "Cookie partition key. The site of the top-level URL the browser was visiting at the start\nof the request to the endpoint that set the cookie.\nIf not set, the cookie will be set as not partitioned."]
            #[serde(rename = "partitionKey")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub partition_key: Option<String>,
        }
        impl SetCookieParams {
            pub fn new(name: impl Into<String>, value: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                    url: None,
                    domain: None,
                    path: None,
                    secure: None,
                    http_only: None,
                    same_site: None,
                    expires: None,
                    priority: None,
                    same_party: None,
                    source_scheme: None,
                    source_port: None,
                    partition_key: None,
                }
            }
        }
        impl SetCookieParams {
            pub fn builder() -> SetCookieParamsBuilder {
                SetCookieParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetCookieParamsBuilder {
            name: Option<String>,
            value: Option<String>,
            url: Option<String>,
            domain: Option<String>,
            path: Option<String>,
            secure: Option<bool>,
            http_only: Option<bool>,
            same_site: Option<CookieSameSite>,
            expires: Option<TimeSinceEpoch>,
            priority: Option<CookiePriority>,
            same_party: Option<bool>,
            source_scheme: Option<CookieSourceScheme>,
            source_port: Option<i64>,
            partition_key: Option<String>,
        }
        impl SetCookieParamsBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn domain(mut self, domain: impl Into<String>) -> Self {
                self.domain = Some(domain.into());
                self
            }
            pub fn path(mut self, path: impl Into<String>) -> Self {
                self.path = Some(path.into());
                self
            }
            pub fn secure(mut self, secure: impl Into<bool>) -> Self {
                self.secure = Some(secure.into());
                self
            }
            pub fn http_only(mut self, http_only: impl Into<bool>) -> Self {
                self.http_only = Some(http_only.into());
                self
            }
            pub fn same_site(mut self, same_site: impl Into<CookieSameSite>) -> Self {
                self.same_site = Some(same_site.into());
                self
            }
            pub fn expires(mut self, expires: impl Into<TimeSinceEpoch>) -> Self {
                self.expires = Some(expires.into());
                self
            }
            pub fn priority(mut self, priority: impl Into<CookiePriority>) -> Self {
                self.priority = Some(priority.into());
                self
            }
            pub fn same_party(mut self, same_party: impl Into<bool>) -> Self {
                self.same_party = Some(same_party.into());
                self
            }
            pub fn source_scheme(mut self, source_scheme: impl Into<CookieSourceScheme>) -> Self {
                self.source_scheme = Some(source_scheme.into());
                self
            }
            pub fn source_port(mut self, source_port: impl Into<i64>) -> Self {
                self.source_port = Some(source_port.into());
                self
            }
            pub fn partition_key(mut self, partition_key: impl Into<String>) -> Self {
                self.partition_key = Some(partition_key.into());
                self
            }
            pub fn build(self) -> Result<SetCookieParams, String> {
                Ok(SetCookieParams {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                    url: self.url,
                    domain: self.domain,
                    path: self.path,
                    secure: self.secure,
                    http_only: self.http_only,
                    same_site: self.same_site,
                    expires: self.expires,
                    priority: self.priority,
                    same_party: self.same_party,
                    source_scheme: self.source_scheme,
                    source_port: self.source_port,
                    partition_key: self.partition_key,
                })
            }
        }
        impl SetCookieParams {
            pub const IDENTIFIER: &'static str = "Network.setCookie";
        }
        impl chromiumoxide_types::Method for SetCookieParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetCookieParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.\n[setCookie](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setCookie)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetCookieReturns {}
        impl chromiumoxide_types::Command for SetCookieParams {
            type Response = SetCookieReturns;
        }
        #[doc = "Sets given cookies.\n[setCookies](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setCookies)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetCookiesParams {
            #[doc = "Cookies to be set."]
            #[serde(rename = "cookies")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub cookies: Vec<CookieParam>,
        }
        impl SetCookiesParams {
            pub fn new(cookies: Vec<CookieParam>) -> Self {
                Self { cookies }
            }
        }
        impl SetCookiesParams {
            pub fn builder() -> SetCookiesParamsBuilder {
                SetCookiesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetCookiesParamsBuilder {
            cookies: Option<Vec<CookieParam>>,
        }
        impl SetCookiesParamsBuilder {
            pub fn cookie(mut self, cookie: impl Into<CookieParam>) -> Self {
                let v = self.cookies.get_or_insert(Vec::new());
                v.push(cookie.into());
                self
            }
            pub fn cookies<I, S>(mut self, cookies: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CookieParam>,
            {
                let v = self.cookies.get_or_insert(Vec::new());
                for val in cookies {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetCookiesParams, String> {
                Ok(SetCookiesParams {
                    cookies: self.cookies.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cookies))
                    })?,
                })
            }
        }
        impl SetCookiesParams {
            pub const IDENTIFIER: &'static str = "Network.setCookies";
        }
        impl chromiumoxide_types::Method for SetCookiesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetCookiesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets given cookies.\n[setCookies](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setCookies)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetCookiesReturns {}
        impl chromiumoxide_types::Command for SetCookiesParams {
            type Response = SetCookiesReturns;
        }
        #[doc = "Specifies whether to always send extra HTTP headers with the requests from this page.\n[setExtraHTTPHeaders](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setExtraHTTPHeaders)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetExtraHttpHeadersParams {
            #[doc = "Map with extra HTTP headers."]
            #[serde(rename = "headers")]
            pub headers: Headers,
        }
        impl SetExtraHttpHeadersParams {
            pub fn new(headers: impl Into<Headers>) -> Self {
                Self {
                    headers: headers.into(),
                }
            }
        }
        impl SetExtraHttpHeadersParams {
            pub fn builder() -> SetExtraHttpHeadersParamsBuilder {
                SetExtraHttpHeadersParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetExtraHttpHeadersParamsBuilder {
            headers: Option<Headers>,
        }
        impl SetExtraHttpHeadersParamsBuilder {
            pub fn headers(mut self, headers: impl Into<Headers>) -> Self {
                self.headers = Some(headers.into());
                self
            }
            pub fn build(self) -> Result<SetExtraHttpHeadersParams, String> {
                Ok(SetExtraHttpHeadersParams {
                    headers: self.headers.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(headers))
                    })?,
                })
            }
        }
        impl SetExtraHttpHeadersParams {
            pub const IDENTIFIER: &'static str = "Network.setExtraHTTPHeaders";
        }
        impl chromiumoxide_types::Method for SetExtraHttpHeadersParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetExtraHttpHeadersParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Specifies whether to always send extra HTTP headers with the requests from this page.\n[setExtraHTTPHeaders](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setExtraHTTPHeaders)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetExtraHttpHeadersReturns {}
        impl chromiumoxide_types::Command for SetExtraHttpHeadersParams {
            type Response = SetExtraHttpHeadersReturns;
        }
        #[doc = "Specifies whether to attach a page script stack id in requests\n[setAttachDebugStack](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setAttachDebugStack)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetAttachDebugStackParams {
            #[doc = "Whether to attach a page script stack for debugging purpose."]
            #[serde(rename = "enabled")]
            pub enabled: bool,
        }
        impl SetAttachDebugStackParams {
            pub fn new(enabled: impl Into<bool>) -> Self {
                Self {
                    enabled: enabled.into(),
                }
            }
        }
        impl SetAttachDebugStackParams {
            pub fn builder() -> SetAttachDebugStackParamsBuilder {
                SetAttachDebugStackParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetAttachDebugStackParamsBuilder {
            enabled: Option<bool>,
        }
        impl SetAttachDebugStackParamsBuilder {
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn build(self) -> Result<SetAttachDebugStackParams, String> {
                Ok(SetAttachDebugStackParams {
                    enabled: self.enabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enabled))
                    })?,
                })
            }
        }
        impl SetAttachDebugStackParams {
            pub const IDENTIFIER: &'static str = "Network.setAttachDebugStack";
        }
        impl chromiumoxide_types::Method for SetAttachDebugStackParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetAttachDebugStackParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Specifies whether to attach a page script stack id in requests\n[setAttachDebugStack](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setAttachDebugStack)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetAttachDebugStackReturns {}
        impl chromiumoxide_types::Command for SetAttachDebugStackParams {
            type Response = SetAttachDebugStackReturns;
        }
        #[doc = "Allows overriding user agent with the given string.\n[setUserAgentOverride](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setUserAgentOverride)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetUserAgentOverrideParams {
            #[doc = "User agent to use."]
            #[serde(rename = "userAgent")]
            pub user_agent: String,
            #[doc = "Browser langugage to emulate."]
            #[serde(rename = "acceptLanguage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub accept_language: Option<String>,
            #[doc = "The platform navigator.platform should return."]
            #[serde(rename = "platform")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub platform: Option<String>,
            #[doc = "To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData"]
            #[serde(rename = "userAgentMetadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub user_agent_metadata: Option<super::emulation::UserAgentMetadata>,
        }
        impl SetUserAgentOverrideParams {
            pub fn new(user_agent: impl Into<String>) -> Self {
                Self {
                    user_agent: user_agent.into(),
                    accept_language: None,
                    platform: None,
                    user_agent_metadata: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for SetUserAgentOverrideParams {
            fn from(url: T) -> Self {
                SetUserAgentOverrideParams::new(url)
            }
        }
        impl SetUserAgentOverrideParams {
            pub fn builder() -> SetUserAgentOverrideParamsBuilder {
                SetUserAgentOverrideParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetUserAgentOverrideParamsBuilder {
            user_agent: Option<String>,
            accept_language: Option<String>,
            platform: Option<String>,
            user_agent_metadata: Option<super::emulation::UserAgentMetadata>,
        }
        impl SetUserAgentOverrideParamsBuilder {
            pub fn user_agent(mut self, user_agent: impl Into<String>) -> Self {
                self.user_agent = Some(user_agent.into());
                self
            }
            pub fn accept_language(mut self, accept_language: impl Into<String>) -> Self {
                self.accept_language = Some(accept_language.into());
                self
            }
            pub fn platform(mut self, platform: impl Into<String>) -> Self {
                self.platform = Some(platform.into());
                self
            }
            pub fn user_agent_metadata(
                mut self,
                user_agent_metadata: impl Into<super::emulation::UserAgentMetadata>,
            ) -> Self {
                self.user_agent_metadata = Some(user_agent_metadata.into());
                self
            }
            pub fn build(self) -> Result<SetUserAgentOverrideParams, String> {
                Ok(SetUserAgentOverrideParams {
                    user_agent: self.user_agent.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(user_agent))
                    })?,
                    accept_language: self.accept_language,
                    platform: self.platform,
                    user_agent_metadata: self.user_agent_metadata,
                })
            }
        }
        impl SetUserAgentOverrideParams {
            pub const IDENTIFIER: &'static str = "Network.setUserAgentOverride";
        }
        impl chromiumoxide_types::Method for SetUserAgentOverrideParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetUserAgentOverrideParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Allows overriding user agent with the given string.\n[setUserAgentOverride](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setUserAgentOverride)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetUserAgentOverrideReturns {}
        impl chromiumoxide_types::Command for SetUserAgentOverrideParams {
            type Response = SetUserAgentOverrideReturns;
        }
        #[doc = "Returns information about the COEP/COOP isolation status.\n[getSecurityIsolationStatus](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getSecurityIsolationStatus)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetSecurityIsolationStatusParams {
            #[doc = "If no frameId is provided, the status of the target is provided."]
            #[serde(rename = "frameId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_id: Option<super::page::FrameId>,
        }
        impl GetSecurityIsolationStatusParams {
            pub fn builder() -> GetSecurityIsolationStatusParamsBuilder {
                GetSecurityIsolationStatusParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetSecurityIsolationStatusParamsBuilder {
            frame_id: Option<super::page::FrameId>,
        }
        impl GetSecurityIsolationStatusParamsBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn build(self) -> GetSecurityIsolationStatusParams {
                GetSecurityIsolationStatusParams {
                    frame_id: self.frame_id,
                }
            }
        }
        impl GetSecurityIsolationStatusParams {
            pub const IDENTIFIER: &'static str = "Network.getSecurityIsolationStatus";
        }
        impl chromiumoxide_types::Method for GetSecurityIsolationStatusParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetSecurityIsolationStatusParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns information about the COEP/COOP isolation status.\n[getSecurityIsolationStatus](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getSecurityIsolationStatus)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetSecurityIsolationStatusReturns {
            #[serde(rename = "status")]
            pub status: SecurityIsolationStatus,
        }
        impl GetSecurityIsolationStatusReturns {
            pub fn new(status: impl Into<SecurityIsolationStatus>) -> Self {
                Self {
                    status: status.into(),
                }
            }
        }
        impl GetSecurityIsolationStatusReturns {
            pub fn builder() -> GetSecurityIsolationStatusReturnsBuilder {
                GetSecurityIsolationStatusReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetSecurityIsolationStatusReturnsBuilder {
            status: Option<SecurityIsolationStatus>,
        }
        impl GetSecurityIsolationStatusReturnsBuilder {
            pub fn status(mut self, status: impl Into<SecurityIsolationStatus>) -> Self {
                self.status = Some(status.into());
                self
            }
            pub fn build(self) -> Result<GetSecurityIsolationStatusReturns, String> {
                Ok(GetSecurityIsolationStatusReturns {
                    status: self.status.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(status))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetSecurityIsolationStatusParams {
            type Response = GetSecurityIsolationStatusReturns;
        }
        #[doc = "Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.\nEnabling triggers 'reportingApiReportAdded' for all existing reports.\n[enableReportingApi](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-enableReportingApi)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EnableReportingApiParams {
            #[doc = "Whether to enable or disable events for the Reporting API"]
            #[serde(rename = "enable")]
            pub enable: bool,
        }
        impl EnableReportingApiParams {
            pub fn new(enable: impl Into<bool>) -> Self {
                Self {
                    enable: enable.into(),
                }
            }
        }
        impl EnableReportingApiParams {
            pub fn builder() -> EnableReportingApiParamsBuilder {
                EnableReportingApiParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EnableReportingApiParamsBuilder {
            enable: Option<bool>,
        }
        impl EnableReportingApiParamsBuilder {
            pub fn enable(mut self, enable: impl Into<bool>) -> Self {
                self.enable = Some(enable.into());
                self
            }
            pub fn build(self) -> Result<EnableReportingApiParams, String> {
                Ok(EnableReportingApiParams {
                    enable: self.enable.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enable))
                    })?,
                })
            }
        }
        impl EnableReportingApiParams {
            pub const IDENTIFIER: &'static str = "Network.enableReportingApi";
        }
        impl chromiumoxide_types::Method for EnableReportingApiParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableReportingApiParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.\nEnabling triggers 'reportingApiReportAdded' for all existing reports.\n[enableReportingApi](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-enableReportingApi)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReportingApiReturns {}
        impl chromiumoxide_types::Command for EnableReportingApiParams {
            type Response = EnableReportingApiReturns;
        }
        #[doc = "Fetches the resource and returns the content.\n[loadNetworkResource](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-loadNetworkResource)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LoadNetworkResourceParams {
            #[doc = "Frame id to get the resource for. Mandatory for frame targets, and\nshould be omitted for worker targets."]
            #[serde(rename = "frameId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_id: Option<super::page::FrameId>,
            #[doc = "URL of the resource to get content for."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Options for the request."]
            #[serde(rename = "options")]
            pub options: LoadNetworkResourceOptions,
        }
        impl LoadNetworkResourceParams {
            pub fn new(
                url: impl Into<String>,
                options: impl Into<LoadNetworkResourceOptions>,
            ) -> Self {
                Self {
                    url: url.into(),
                    options: options.into(),
                    frame_id: None,
                }
            }
        }
        impl LoadNetworkResourceParams {
            pub fn builder() -> LoadNetworkResourceParamsBuilder {
                LoadNetworkResourceParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LoadNetworkResourceParamsBuilder {
            frame_id: Option<super::page::FrameId>,
            url: Option<String>,
            options: Option<LoadNetworkResourceOptions>,
        }
        impl LoadNetworkResourceParamsBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn options(mut self, options: impl Into<LoadNetworkResourceOptions>) -> Self {
                self.options = Some(options.into());
                self
            }
            pub fn build(self) -> Result<LoadNetworkResourceParams, String> {
                Ok(LoadNetworkResourceParams {
                    frame_id: self.frame_id,
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    options: self.options.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(options))
                    })?,
                })
            }
        }
        impl LoadNetworkResourceParams {
            pub const IDENTIFIER: &'static str = "Network.loadNetworkResource";
        }
        impl chromiumoxide_types::Method for LoadNetworkResourceParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for LoadNetworkResourceParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fetches the resource and returns the content.\n[loadNetworkResource](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-loadNetworkResource)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LoadNetworkResourceReturns {
            #[serde(rename = "resource")]
            pub resource: LoadNetworkResourcePageResult,
        }
        impl LoadNetworkResourceReturns {
            pub fn new(resource: impl Into<LoadNetworkResourcePageResult>) -> Self {
                Self {
                    resource: resource.into(),
                }
            }
        }
        impl LoadNetworkResourceReturns {
            pub fn builder() -> LoadNetworkResourceReturnsBuilder {
                LoadNetworkResourceReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LoadNetworkResourceReturnsBuilder {
            resource: Option<LoadNetworkResourcePageResult>,
        }
        impl LoadNetworkResourceReturnsBuilder {
            pub fn resource(mut self, resource: impl Into<LoadNetworkResourcePageResult>) -> Self {
                self.resource = Some(resource.into());
                self
            }
            pub fn build(self) -> Result<LoadNetworkResourceReturns, String> {
                Ok(LoadNetworkResourceReturns {
                    resource: self.resource.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(resource))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for LoadNetworkResourceParams {
            type Response = LoadNetworkResourceReturns;
        }
        #[doc = "Fired when data chunk was received over the network.\n[dataReceived](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-dataReceived)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDataReceived {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
            #[doc = "Data chunk length."]
            #[serde(rename = "dataLength")]
            pub data_length: i64,
            #[doc = "Actual bytes received (might be less than dataLength for compressed encodings)."]
            #[serde(rename = "encodedDataLength")]
            pub encoded_data_length: i64,
        }
        impl EventDataReceived {
            pub const IDENTIFIER: &'static str = "Network.dataReceived";
        }
        impl chromiumoxide_types::Method for EventDataReceived {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDataReceived {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when EventSource message is received.\n[eventSourceMessageReceived](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-eventSourceMessageReceived)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventEventSourceMessageReceived {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
            #[doc = "Message type."]
            #[serde(rename = "eventName")]
            pub event_name: String,
            #[doc = "Message identifier."]
            #[serde(rename = "eventId")]
            pub event_id: String,
            #[doc = "Message content."]
            #[serde(rename = "data")]
            pub data: String,
        }
        impl EventEventSourceMessageReceived {
            pub const IDENTIFIER: &'static str = "Network.eventSourceMessageReceived";
        }
        impl chromiumoxide_types::Method for EventEventSourceMessageReceived {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventEventSourceMessageReceived {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when HTTP request has failed to load.\n[loadingFailed](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-loadingFailed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventLoadingFailed {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
            #[doc = "Resource type."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: ResourceType,
            #[doc = "User friendly error message."]
            #[serde(rename = "errorText")]
            pub error_text: String,
            #[doc = "True if loading was canceled."]
            #[serde(rename = "canceled")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub canceled: Option<bool>,
            #[doc = "The reason why loading was blocked, if any."]
            #[serde(rename = "blockedReason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub blocked_reason: Option<BlockedReason>,
            #[doc = "The reason why loading was blocked by CORS, if any."]
            #[serde(rename = "corsErrorStatus")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub cors_error_status: Option<CorsErrorStatus>,
        }
        impl EventLoadingFailed {
            pub const IDENTIFIER: &'static str = "Network.loadingFailed";
        }
        impl chromiumoxide_types::Method for EventLoadingFailed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventLoadingFailed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when HTTP request has finished loading.\n[loadingFinished](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-loadingFinished)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventLoadingFinished {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
            #[doc = "Total number of bytes received for this request."]
            #[serde(rename = "encodedDataLength")]
            pub encoded_data_length: f64,
            #[doc = "Set when 1) response was blocked by Cross-Origin Read Blocking and also\n2) this needs to be reported to the DevTools console."]
            #[serde(rename = "shouldReportCorbBlocking")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub should_report_corb_blocking: Option<bool>,
        }
        impl EventLoadingFinished {
            pub const IDENTIFIER: &'static str = "Network.loadingFinished";
        }
        impl chromiumoxide_types::Method for EventLoadingFinished {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventLoadingFinished {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired if request ended up loading from cache.\n[requestServedFromCache](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestServedFromCache)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventRequestServedFromCache {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
        }
        impl EventRequestServedFromCache {
            pub const IDENTIFIER: &'static str = "Network.requestServedFromCache";
        }
        impl chromiumoxide_types::Method for EventRequestServedFromCache {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventRequestServedFromCache {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when page is about to send HTTP request.\n[requestWillBeSent](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestWillBeSent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventRequestWillBeSent {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Loader identifier. Empty string if the request is fetched from worker."]
            #[serde(rename = "loaderId")]
            pub loader_id: LoaderId,
            #[doc = "URL of the document this request is loaded for."]
            #[serde(rename = "documentURL")]
            pub document_url: String,
            #[doc = "Request data."]
            #[serde(rename = "request")]
            pub request: Request,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
            #[doc = "Timestamp."]
            #[serde(rename = "wallTime")]
            pub wall_time: TimeSinceEpoch,
            #[doc = "Request initiator."]
            #[serde(rename = "initiator")]
            pub initiator: Initiator,
            #[doc = "In the case that redirectResponse is populated, this flag indicates whether\nrequestWillBeSentExtraInfo and responseReceivedExtraInfo events will be or were emitted\nfor the request which was just redirected."]
            #[serde(rename = "redirectHasExtraInfo")]
            pub redirect_has_extra_info: bool,
            #[doc = "Redirect response data."]
            #[serde(rename = "redirectResponse")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub redirect_response: Option<Response>,
            #[doc = "Type of this resource."]
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub r#type: Option<ResourceType>,
            #[doc = "Frame identifier."]
            #[serde(rename = "frameId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_id: Option<super::page::FrameId>,
            #[doc = "Whether the request is initiated by a user gesture. Defaults to false."]
            #[serde(rename = "hasUserGesture")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub has_user_gesture: Option<bool>,
        }
        impl EventRequestWillBeSent {
            pub const IDENTIFIER: &'static str = "Network.requestWillBeSent";
        }
        impl chromiumoxide_types::Method for EventRequestWillBeSent {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventRequestWillBeSent {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when resource loading priority is changed\n[resourceChangedPriority](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-resourceChangedPriority)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventResourceChangedPriority {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "New priority"]
            #[serde(rename = "newPriority")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub new_priority: ResourcePriority,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
        }
        impl EventResourceChangedPriority {
            pub const IDENTIFIER: &'static str = "Network.resourceChangedPriority";
        }
        impl chromiumoxide_types::Method for EventResourceChangedPriority {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventResourceChangedPriority {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when a signed exchange was received over the network\n[signedExchangeReceived](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-signedExchangeReceived)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventSignedExchangeReceived {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Information about the signed exchange response."]
            #[serde(rename = "info")]
            pub info: SignedExchangeInfo,
        }
        impl EventSignedExchangeReceived {
            pub const IDENTIFIER: &'static str = "Network.signedExchangeReceived";
        }
        impl chromiumoxide_types::Method for EventSignedExchangeReceived {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventSignedExchangeReceived {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when HTTP response is available.\n[responseReceived](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-responseReceived)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventResponseReceived {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Loader identifier. Empty string if the request is fetched from worker."]
            #[serde(rename = "loaderId")]
            pub loader_id: LoaderId,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
            #[doc = "Resource type."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: ResourceType,
            #[doc = "Response data."]
            #[serde(rename = "response")]
            pub response: Response,
            #[doc = "Indicates whether requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be\nor were emitted for this request."]
            #[serde(rename = "hasExtraInfo")]
            pub has_extra_info: bool,
            #[doc = "Frame identifier."]
            #[serde(rename = "frameId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_id: Option<super::page::FrameId>,
        }
        impl EventResponseReceived {
            pub const IDENTIFIER: &'static str = "Network.responseReceived";
        }
        impl chromiumoxide_types::Method for EventResponseReceived {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventResponseReceived {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when WebSocket is closed.\n[webSocketClosed](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketClosed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWebSocketClosed {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
        }
        impl EventWebSocketClosed {
            pub const IDENTIFIER: &'static str = "Network.webSocketClosed";
        }
        impl chromiumoxide_types::Method for EventWebSocketClosed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWebSocketClosed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired upon WebSocket creation.\n[webSocketCreated](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketCreated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWebSocketCreated {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "WebSocket request URL."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Request initiator."]
            #[serde(rename = "initiator")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub initiator: Option<Initiator>,
        }
        impl EventWebSocketCreated {
            pub const IDENTIFIER: &'static str = "Network.webSocketCreated";
        }
        impl chromiumoxide_types::Method for EventWebSocketCreated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWebSocketCreated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when WebSocket message error occurs.\n[webSocketFrameError](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketFrameError)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWebSocketFrameError {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
            #[doc = "WebSocket error message."]
            #[serde(rename = "errorMessage")]
            pub error_message: String,
        }
        impl EventWebSocketFrameError {
            pub const IDENTIFIER: &'static str = "Network.webSocketFrameError";
        }
        impl chromiumoxide_types::Method for EventWebSocketFrameError {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWebSocketFrameError {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when WebSocket message is received.\n[webSocketFrameReceived](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketFrameReceived)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWebSocketFrameReceived {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
            #[doc = "WebSocket response data."]
            #[serde(rename = "response")]
            pub response: WebSocketFrame,
        }
        impl EventWebSocketFrameReceived {
            pub const IDENTIFIER: &'static str = "Network.webSocketFrameReceived";
        }
        impl chromiumoxide_types::Method for EventWebSocketFrameReceived {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWebSocketFrameReceived {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when WebSocket message is sent.\n[webSocketFrameSent](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketFrameSent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWebSocketFrameSent {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
            #[doc = "WebSocket response data."]
            #[serde(rename = "response")]
            pub response: WebSocketFrame,
        }
        impl EventWebSocketFrameSent {
            pub const IDENTIFIER: &'static str = "Network.webSocketFrameSent";
        }
        impl chromiumoxide_types::Method for EventWebSocketFrameSent {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWebSocketFrameSent {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when WebSocket handshake response becomes available.\n[webSocketHandshakeResponseReceived](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketHandshakeResponseReceived)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWebSocketHandshakeResponseReceived {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
            #[doc = "WebSocket response data."]
            #[serde(rename = "response")]
            pub response: WebSocketResponse,
        }
        impl EventWebSocketHandshakeResponseReceived {
            pub const IDENTIFIER: &'static str = "Network.webSocketHandshakeResponseReceived";
        }
        impl chromiumoxide_types::Method for EventWebSocketHandshakeResponseReceived {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWebSocketHandshakeResponseReceived {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when WebSocket is about to initiate handshake.\n[webSocketWillSendHandshakeRequest](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketWillSendHandshakeRequest)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWebSocketWillSendHandshakeRequest {
            #[doc = "Request identifier."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
            #[doc = "UTC Timestamp."]
            #[serde(rename = "wallTime")]
            pub wall_time: TimeSinceEpoch,
            #[doc = "WebSocket request data."]
            #[serde(rename = "request")]
            pub request: WebSocketRequest,
        }
        impl EventWebSocketWillSendHandshakeRequest {
            pub const IDENTIFIER: &'static str = "Network.webSocketWillSendHandshakeRequest";
        }
        impl chromiumoxide_types::Method for EventWebSocketWillSendHandshakeRequest {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWebSocketWillSendHandshakeRequest {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired upon WebTransport creation.\n[webTransportCreated](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webTransportCreated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWebTransportCreated {
            #[doc = "WebTransport identifier."]
            #[serde(rename = "transportId")]
            pub transport_id: RequestId,
            #[doc = "WebTransport request URL."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
            #[doc = "Request initiator."]
            #[serde(rename = "initiator")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub initiator: Option<Initiator>,
        }
        impl EventWebTransportCreated {
            pub const IDENTIFIER: &'static str = "Network.webTransportCreated";
        }
        impl chromiumoxide_types::Method for EventWebTransportCreated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWebTransportCreated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when WebTransport handshake is finished.\n[webTransportConnectionEstablished](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webTransportConnectionEstablished)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWebTransportConnectionEstablished {
            #[doc = "WebTransport identifier."]
            #[serde(rename = "transportId")]
            pub transport_id: RequestId,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
        }
        impl EventWebTransportConnectionEstablished {
            pub const IDENTIFIER: &'static str = "Network.webTransportConnectionEstablished";
        }
        impl chromiumoxide_types::Method for EventWebTransportConnectionEstablished {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWebTransportConnectionEstablished {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when WebTransport is disposed.\n[webTransportClosed](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webTransportClosed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWebTransportClosed {
            #[doc = "WebTransport identifier."]
            #[serde(rename = "transportId")]
            pub transport_id: RequestId,
            #[doc = "Timestamp."]
            #[serde(rename = "timestamp")]
            pub timestamp: MonotonicTime,
        }
        impl EventWebTransportClosed {
            pub const IDENTIFIER: &'static str = "Network.webTransportClosed";
        }
        impl chromiumoxide_types::Method for EventWebTransportClosed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWebTransportClosed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when additional information about a requestWillBeSent event is available from the\nnetwork stack. Not every requestWillBeSent event will have an additional\nrequestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent\nor requestWillBeSentExtraInfo will be fired first for the same request.\n[requestWillBeSentExtraInfo](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestWillBeSentExtraInfo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventRequestWillBeSentExtraInfo {
            #[doc = "Request identifier. Used to match this information to an existing requestWillBeSent event."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "A list of cookies potentially associated to the requested URL. This includes both cookies sent with\nthe request and the ones not sent; the latter are distinguished by having blockedReason field set."]
            #[serde(rename = "associatedCookies")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub associated_cookies: Vec<BlockedCookieWithReason>,
            #[doc = "Raw request headers as they will be sent over the wire."]
            #[serde(rename = "headers")]
            pub headers: Headers,
            #[doc = "Connection timing information for the request."]
            #[serde(rename = "connectTiming")]
            pub connect_timing: ConnectTiming,
            #[doc = "The client security state set for the request."]
            #[serde(rename = "clientSecurityState")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub client_security_state: Option<ClientSecurityState>,
        }
        impl EventRequestWillBeSentExtraInfo {
            pub const IDENTIFIER: &'static str = "Network.requestWillBeSentExtraInfo";
        }
        impl chromiumoxide_types::Method for EventRequestWillBeSentExtraInfo {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventRequestWillBeSentExtraInfo {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when additional information about a responseReceived event is available from the network\nstack. Not every responseReceived event will have an additional responseReceivedExtraInfo for\nit, and responseReceivedExtraInfo may be fired before or after responseReceived.\n[responseReceivedExtraInfo](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-responseReceivedExtraInfo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventResponseReceivedExtraInfo {
            #[doc = "Request identifier. Used to match this information to another responseReceived event."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "A list of cookies which were not stored from the response along with the corresponding\nreasons for blocking. The cookies here may not be valid due to syntax errors, which\nare represented by the invalid cookie line string instead of a proper cookie."]
            #[serde(rename = "blockedCookies")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub blocked_cookies: Vec<BlockedSetCookieWithReason>,
            #[doc = "Raw response headers as they were received over the wire."]
            #[serde(rename = "headers")]
            pub headers: Headers,
            #[doc = "The IP address space of the resource. The address space can only be determined once the transport\nestablished the connection, so we can't send it in `requestWillBeSentExtraInfo`."]
            #[serde(rename = "resourceIPAddressSpace")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub resource_ip_address_space: IpAddressSpace,
            #[doc = "The status code of the response. This is useful in cases the request failed and no responseReceived\nevent is triggered, which is the case for, e.g., CORS errors. This is also the correct status code\nfor cached requests, where the status in responseReceived is a 200 and this will be 304."]
            #[serde(rename = "statusCode")]
            pub status_code: i64,
            #[doc = "Raw response header text as it was received over the wire. The raw text may not always be\navailable, such as in the case of HTTP/2 or QUIC."]
            #[serde(rename = "headersText")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub headers_text: Option<String>,
        }
        impl EventResponseReceivedExtraInfo {
            pub const IDENTIFIER: &'static str = "Network.responseReceivedExtraInfo";
        }
        impl chromiumoxide_types::Method for EventResponseReceivedExtraInfo {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventResponseReceivedExtraInfo {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired exactly once for each Trust Token operation. Depending on\nthe type of the operation and whether the operation succeeded or\nfailed, the event is fired before the corresponding request was sent\nor after the response was received.\n[trustTokenOperationDone](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-trustTokenOperationDone)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventTrustTokenOperationDone {
            #[doc = "Detailed success or error status of the operation.\n'AlreadyExists' also signifies a successful operation, as the result\nof the operation already exists und thus, the operation was abort\npreemptively (e.g. a cache hit)."]
            #[serde(rename = "status")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub status: TrustTokenOperationDoneStatus,
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: TrustTokenOperationType,
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Top level origin. The context in which the operation was attempted."]
            #[serde(rename = "topLevelOrigin")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub top_level_origin: Option<String>,
            #[doc = "Origin of the issuer in case of a \"Issuance\" or \"Redemption\" operation."]
            #[serde(rename = "issuerOrigin")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub issuer_origin: Option<String>,
            #[doc = "The number of obtained Trust Tokens on a successful \"Issuance\" operation."]
            #[serde(rename = "issuedTokenCount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub issued_token_count: Option<i64>,
        }
        #[doc = "Detailed success or error status of the operation.\n'AlreadyExists' also signifies a successful operation, as the result\nof the operation already exists und thus, the operation was abort\npreemptively (e.g. a cache hit)."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum TrustTokenOperationDoneStatus {
            #[serde(rename = "Ok")]
            Ok,
            #[serde(rename = "InvalidArgument")]
            InvalidArgument,
            #[serde(rename = "FailedPrecondition")]
            FailedPrecondition,
            #[serde(rename = "ResourceExhausted")]
            ResourceExhausted,
            #[serde(rename = "AlreadyExists")]
            AlreadyExists,
            #[serde(rename = "Unavailable")]
            Unavailable,
            #[serde(rename = "BadResponse")]
            BadResponse,
            #[serde(rename = "InternalError")]
            InternalError,
            #[serde(rename = "UnknownError")]
            UnknownError,
            #[serde(rename = "FulfilledLocally")]
            FulfilledLocally,
        }
        impl AsRef<str> for TrustTokenOperationDoneStatus {
            fn as_ref(&self) -> &str {
                match self {
                    TrustTokenOperationDoneStatus::Ok => "Ok",
                    TrustTokenOperationDoneStatus::InvalidArgument => "InvalidArgument",
                    TrustTokenOperationDoneStatus::FailedPrecondition => "FailedPrecondition",
                    TrustTokenOperationDoneStatus::ResourceExhausted => "ResourceExhausted",
                    TrustTokenOperationDoneStatus::AlreadyExists => "AlreadyExists",
                    TrustTokenOperationDoneStatus::Unavailable => "Unavailable",
                    TrustTokenOperationDoneStatus::BadResponse => "BadResponse",
                    TrustTokenOperationDoneStatus::InternalError => "InternalError",
                    TrustTokenOperationDoneStatus::UnknownError => "UnknownError",
                    TrustTokenOperationDoneStatus::FulfilledLocally => "FulfilledLocally",
                }
            }
        }
        impl ::std::str::FromStr for TrustTokenOperationDoneStatus {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Ok" | "ok" => Ok(TrustTokenOperationDoneStatus::Ok),
                    "InvalidArgument" | "invalidargument" => {
                        Ok(TrustTokenOperationDoneStatus::InvalidArgument)
                    }
                    "FailedPrecondition" | "failedprecondition" => {
                        Ok(TrustTokenOperationDoneStatus::FailedPrecondition)
                    }
                    "ResourceExhausted" | "resourceexhausted" => {
                        Ok(TrustTokenOperationDoneStatus::ResourceExhausted)
                    }
                    "AlreadyExists" | "alreadyexists" => {
                        Ok(TrustTokenOperationDoneStatus::AlreadyExists)
                    }
                    "Unavailable" | "unavailable" => Ok(TrustTokenOperationDoneStatus::Unavailable),
                    "BadResponse" | "badresponse" => Ok(TrustTokenOperationDoneStatus::BadResponse),
                    "InternalError" | "internalerror" => {
                        Ok(TrustTokenOperationDoneStatus::InternalError)
                    }
                    "UnknownError" | "unknownerror" => {
                        Ok(TrustTokenOperationDoneStatus::UnknownError)
                    }
                    "FulfilledLocally" | "fulfilledlocally" => {
                        Ok(TrustTokenOperationDoneStatus::FulfilledLocally)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl EventTrustTokenOperationDone {
            pub const IDENTIFIER: &'static str = "Network.trustTokenOperationDone";
        }
        impl chromiumoxide_types::Method for EventTrustTokenOperationDone {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventTrustTokenOperationDone {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired once when parsing the .wbn file has succeeded.\nThe event contains the information about the web bundle contents.\n[subresourceWebBundleMetadataReceived](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-subresourceWebBundleMetadataReceived)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventSubresourceWebBundleMetadataReceived {
            #[doc = "Request identifier. Used to match this information to another event."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "A list of URLs of resources in the subresource Web Bundle."]
            #[serde(rename = "urls")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub urls: Vec<String>,
        }
        impl EventSubresourceWebBundleMetadataReceived {
            pub const IDENTIFIER: &'static str = "Network.subresourceWebBundleMetadataReceived";
        }
        impl chromiumoxide_types::Method for EventSubresourceWebBundleMetadataReceived {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventSubresourceWebBundleMetadataReceived {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired once when parsing the .wbn file has failed.\n[subresourceWebBundleMetadataError](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-subresourceWebBundleMetadataError)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventSubresourceWebBundleMetadataError {
            #[doc = "Request identifier. Used to match this information to another event."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Error message"]
            #[serde(rename = "errorMessage")]
            pub error_message: String,
        }
        impl EventSubresourceWebBundleMetadataError {
            pub const IDENTIFIER: &'static str = "Network.subresourceWebBundleMetadataError";
        }
        impl chromiumoxide_types::Method for EventSubresourceWebBundleMetadataError {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventSubresourceWebBundleMetadataError {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when handling requests for resources within a .wbn file.\nNote: this will only be fired for resources that are requested by the webpage.\n[subresourceWebBundleInnerResponseParsed](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-subresourceWebBundleInnerResponseParsed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventSubresourceWebBundleInnerResponseParsed {
            #[doc = "Request identifier of the subresource request"]
            #[serde(rename = "innerRequestId")]
            pub inner_request_id: RequestId,
            #[doc = "URL of the subresource resource."]
            #[serde(rename = "innerRequestURL")]
            pub inner_request_url: String,
            #[doc = "Bundle request identifier. Used to match this information to another event.\nThis made be absent in case when the instrumentation was enabled only\nafter webbundle was parsed."]
            #[serde(rename = "bundleRequestId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub bundle_request_id: Option<RequestId>,
        }
        impl EventSubresourceWebBundleInnerResponseParsed {
            pub const IDENTIFIER: &'static str = "Network.subresourceWebBundleInnerResponseParsed";
        }
        impl chromiumoxide_types::Method for EventSubresourceWebBundleInnerResponseParsed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventSubresourceWebBundleInnerResponseParsed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when request for resources within a .wbn file failed.\n[subresourceWebBundleInnerResponseError](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-subresourceWebBundleInnerResponseError)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventSubresourceWebBundleInnerResponseError {
            #[doc = "Request identifier of the subresource request"]
            #[serde(rename = "innerRequestId")]
            pub inner_request_id: RequestId,
            #[doc = "URL of the subresource resource."]
            #[serde(rename = "innerRequestURL")]
            pub inner_request_url: String,
            #[doc = "Error message"]
            #[serde(rename = "errorMessage")]
            pub error_message: String,
            #[doc = "Bundle request identifier. Used to match this information to another event.\nThis made be absent in case when the instrumentation was enabled only\nafter webbundle was parsed."]
            #[serde(rename = "bundleRequestId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub bundle_request_id: Option<RequestId>,
        }
        impl EventSubresourceWebBundleInnerResponseError {
            pub const IDENTIFIER: &'static str = "Network.subresourceWebBundleInnerResponseError";
        }
        impl chromiumoxide_types::Method for EventSubresourceWebBundleInnerResponseError {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventSubresourceWebBundleInnerResponseError {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Is sent whenever a new report is added.\nAnd after 'enableReportingApi' for all existing reports.\n[reportingApiReportAdded](https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-reportingApiReportAdded)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventReportingApiReportAdded {
            #[serde(rename = "report")]
            pub report: ReportingApiReport,
        }
        impl EventReportingApiReportAdded {
            pub const IDENTIFIER: &'static str = "Network.reportingApiReportAdded";
        }
        impl chromiumoxide_types::Method for EventReportingApiReportAdded {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventReportingApiReportAdded {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventReportingApiReportUpdated {
            #[serde(rename = "report")]
            pub report: ReportingApiReport,
        }
        impl EventReportingApiReportUpdated {
            pub const IDENTIFIER: &'static str = "Network.reportingApiReportUpdated";
        }
        impl chromiumoxide_types::Method for EventReportingApiReportUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventReportingApiReportUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventReportingApiEndpointsChangedForOrigin {
            #[doc = "Origin of the document(s) which configured the endpoints."]
            #[serde(rename = "origin")]
            pub origin: String,
            #[serde(rename = "endpoints")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub endpoints: Vec<ReportingApiEndpoint>,
        }
        impl EventReportingApiEndpointsChangedForOrigin {
            pub const IDENTIFIER: &'static str = "Network.reportingApiEndpointsChangedForOrigin";
        }
        impl chromiumoxide_types::Method for EventReportingApiEndpointsChangedForOrigin {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventReportingApiEndpointsChangedForOrigin {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "This domain provides various functionality related to drawing atop the inspected page."]
    pub mod overlay {
        use serde::{Deserialize, Serialize};
        #[doc = "Configuration data for drawing the source order of an elements children.\n[SourceOrderConfig](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#type-SourceOrderConfig)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SourceOrderConfig {
            #[doc = "the color to outline the givent element in."]
            #[serde(rename = "parentOutlineColor")]
            pub parent_outline_color: super::dom::Rgba,
            #[doc = "the color to outline the child elements in."]
            #[serde(rename = "childOutlineColor")]
            pub child_outline_color: super::dom::Rgba,
        }
        impl SourceOrderConfig {
            pub fn new(
                parent_outline_color: impl Into<super::dom::Rgba>,
                child_outline_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                Self {
                    parent_outline_color: parent_outline_color.into(),
                    child_outline_color: child_outline_color.into(),
                }
            }
        }
        impl SourceOrderConfig {
            pub fn builder() -> SourceOrderConfigBuilder {
                SourceOrderConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SourceOrderConfigBuilder {
            parent_outline_color: Option<super::dom::Rgba>,
            child_outline_color: Option<super::dom::Rgba>,
        }
        impl SourceOrderConfigBuilder {
            pub fn parent_outline_color(
                mut self,
                parent_outline_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                self.parent_outline_color = Some(parent_outline_color.into());
                self
            }
            pub fn child_outline_color(
                mut self,
                child_outline_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                self.child_outline_color = Some(child_outline_color.into());
                self
            }
            pub fn build(self) -> Result<SourceOrderConfig, String> {
                Ok(SourceOrderConfig {
                    parent_outline_color: self.parent_outline_color.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(parent_outline_color)
                        )
                    })?,
                    child_outline_color: self.child_outline_color.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(child_outline_color)
                        )
                    })?,
                })
            }
        }
        impl SourceOrderConfig {
            pub const IDENTIFIER: &'static str = "Overlay.SourceOrderConfig";
        }
        #[doc = "Configuration data for the highlighting of Grid elements.\n[GridHighlightConfig](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#type-GridHighlightConfig)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GridHighlightConfig {
            #[doc = "Whether the extension lines from grid cells to the rulers should be shown (default: false)."]
            #[serde(rename = "showGridExtensionLines")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub show_grid_extension_lines: Option<bool>,
            #[doc = "Show Positive line number labels (default: false)."]
            #[serde(rename = "showPositiveLineNumbers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub show_positive_line_numbers: Option<bool>,
            #[doc = "Show Negative line number labels (default: false)."]
            #[serde(rename = "showNegativeLineNumbers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub show_negative_line_numbers: Option<bool>,
            #[doc = "Show area name labels (default: false)."]
            #[serde(rename = "showAreaNames")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub show_area_names: Option<bool>,
            #[doc = "Show line name labels (default: false)."]
            #[serde(rename = "showLineNames")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub show_line_names: Option<bool>,
            #[doc = "Show track size labels (default: false)."]
            #[serde(rename = "showTrackSizes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub show_track_sizes: Option<bool>,
            #[doc = "The grid container border highlight color (default: transparent)."]
            #[serde(rename = "gridBorderColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub grid_border_color: Option<super::dom::Rgba>,
            #[doc = "The row line color (default: transparent)."]
            #[serde(rename = "rowLineColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub row_line_color: Option<super::dom::Rgba>,
            #[doc = "The column line color (default: transparent)."]
            #[serde(rename = "columnLineColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub column_line_color: Option<super::dom::Rgba>,
            #[doc = "Whether the grid border is dashed (default: false)."]
            #[serde(rename = "gridBorderDash")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub grid_border_dash: Option<bool>,
            #[doc = "Whether row lines are dashed (default: false)."]
            #[serde(rename = "rowLineDash")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub row_line_dash: Option<bool>,
            #[doc = "Whether column lines are dashed (default: false)."]
            #[serde(rename = "columnLineDash")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub column_line_dash: Option<bool>,
            #[doc = "The row gap highlight fill color (default: transparent)."]
            #[serde(rename = "rowGapColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub row_gap_color: Option<super::dom::Rgba>,
            #[doc = "The row gap hatching fill color (default: transparent)."]
            #[serde(rename = "rowHatchColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub row_hatch_color: Option<super::dom::Rgba>,
            #[doc = "The column gap highlight fill color (default: transparent)."]
            #[serde(rename = "columnGapColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub column_gap_color: Option<super::dom::Rgba>,
            #[doc = "The column gap hatching fill color (default: transparent)."]
            #[serde(rename = "columnHatchColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub column_hatch_color: Option<super::dom::Rgba>,
            #[doc = "The named grid areas border color (Default: transparent)."]
            #[serde(rename = "areaBorderColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub area_border_color: Option<super::dom::Rgba>,
            #[doc = "The grid container background color (Default: transparent)."]
            #[serde(rename = "gridBackgroundColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub grid_background_color: Option<super::dom::Rgba>,
        }
        impl GridHighlightConfig {
            pub fn builder() -> GridHighlightConfigBuilder {
                GridHighlightConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GridHighlightConfigBuilder {
            show_grid_extension_lines: Option<bool>,
            show_positive_line_numbers: Option<bool>,
            show_negative_line_numbers: Option<bool>,
            show_area_names: Option<bool>,
            show_line_names: Option<bool>,
            show_track_sizes: Option<bool>,
            grid_border_color: Option<super::dom::Rgba>,
            row_line_color: Option<super::dom::Rgba>,
            column_line_color: Option<super::dom::Rgba>,
            grid_border_dash: Option<bool>,
            row_line_dash: Option<bool>,
            column_line_dash: Option<bool>,
            row_gap_color: Option<super::dom::Rgba>,
            row_hatch_color: Option<super::dom::Rgba>,
            column_gap_color: Option<super::dom::Rgba>,
            column_hatch_color: Option<super::dom::Rgba>,
            area_border_color: Option<super::dom::Rgba>,
            grid_background_color: Option<super::dom::Rgba>,
        }
        impl GridHighlightConfigBuilder {
            pub fn show_grid_extension_lines(
                mut self,
                show_grid_extension_lines: impl Into<bool>,
            ) -> Self {
                self.show_grid_extension_lines = Some(show_grid_extension_lines.into());
                self
            }
            pub fn show_positive_line_numbers(
                mut self,
                show_positive_line_numbers: impl Into<bool>,
            ) -> Self {
                self.show_positive_line_numbers = Some(show_positive_line_numbers.into());
                self
            }
            pub fn show_negative_line_numbers(
                mut self,
                show_negative_line_numbers: impl Into<bool>,
            ) -> Self {
                self.show_negative_line_numbers = Some(show_negative_line_numbers.into());
                self
            }
            pub fn show_area_names(mut self, show_area_names: impl Into<bool>) -> Self {
                self.show_area_names = Some(show_area_names.into());
                self
            }
            pub fn show_line_names(mut self, show_line_names: impl Into<bool>) -> Self {
                self.show_line_names = Some(show_line_names.into());
                self
            }
            pub fn show_track_sizes(mut self, show_track_sizes: impl Into<bool>) -> Self {
                self.show_track_sizes = Some(show_track_sizes.into());
                self
            }
            pub fn grid_border_color(
                mut self,
                grid_border_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                self.grid_border_color = Some(grid_border_color.into());
                self
            }
            pub fn row_line_color(mut self, row_line_color: impl Into<super::dom::Rgba>) -> Self {
                self.row_line_color = Some(row_line_color.into());
                self
            }
            pub fn column_line_color(
                mut self,
                column_line_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                self.column_line_color = Some(column_line_color.into());
                self
            }
            pub fn grid_border_dash(mut self, grid_border_dash: impl Into<bool>) -> Self {
                self.grid_border_dash = Some(grid_border_dash.into());
                self
            }
            pub fn row_line_dash(mut self, row_line_dash: impl Into<bool>) -> Self {
                self.row_line_dash = Some(row_line_dash.into());
                self
            }
            pub fn column_line_dash(mut self, column_line_dash: impl Into<bool>) -> Self {
                self.column_line_dash = Some(column_line_dash.into());
                self
            }
            pub fn row_gap_color(mut self, row_gap_color: impl Into<super::dom::Rgba>) -> Self {
                self.row_gap_color = Some(row_gap_color.into());
                self
            }
            pub fn row_hatch_color(mut self, row_hatch_color: impl Into<super::dom::Rgba>) -> Self {
                self.row_hatch_color = Some(row_hatch_color.into());
                self
            }
            pub fn column_gap_color(
                mut self,
                column_gap_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                self.column_gap_color = Some(column_gap_color.into());
                self
            }
            pub fn column_hatch_color(
                mut self,
                column_hatch_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                self.column_hatch_color = Some(column_hatch_color.into());
                self
            }
            pub fn area_border_color(
                mut self,
                area_border_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                self.area_border_color = Some(area_border_color.into());
                self
            }
            pub fn grid_background_color(
                mut self,
                grid_background_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                self.grid_background_color = Some(grid_background_color.into());
                self
            }
            pub fn build(self) -> GridHighlightConfig {
                GridHighlightConfig {
                    show_grid_extension_lines: self.show_grid_extension_lines,
                    show_positive_line_numbers: self.show_positive_line_numbers,
                    show_negative_line_numbers: self.show_negative_line_numbers,
                    show_area_names: self.show_area_names,
                    show_line_names: self.show_line_names,
                    show_track_sizes: self.show_track_sizes,
                    grid_border_color: self.grid_border_color,
                    row_line_color: self.row_line_color,
                    column_line_color: self.column_line_color,
                    grid_border_dash: self.grid_border_dash,
                    row_line_dash: self.row_line_dash,
                    column_line_dash: self.column_line_dash,
                    row_gap_color: self.row_gap_color,
                    row_hatch_color: self.row_hatch_color,
                    column_gap_color: self.column_gap_color,
                    column_hatch_color: self.column_hatch_color,
                    area_border_color: self.area_border_color,
                    grid_background_color: self.grid_background_color,
                }
            }
        }
        impl GridHighlightConfig {
            pub const IDENTIFIER: &'static str = "Overlay.GridHighlightConfig";
        }
        #[doc = "Configuration data for the highlighting of Flex container elements.\n[FlexContainerHighlightConfig](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#type-FlexContainerHighlightConfig)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct FlexContainerHighlightConfig {
            #[doc = "The style of the container border"]
            #[serde(rename = "containerBorder")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub container_border: Option<LineStyle>,
            #[doc = "The style of the separator between lines"]
            #[serde(rename = "lineSeparator")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub line_separator: Option<LineStyle>,
            #[doc = "The style of the separator between items"]
            #[serde(rename = "itemSeparator")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub item_separator: Option<LineStyle>,
            #[doc = "Style of content-distribution space on the main axis (justify-content)."]
            #[serde(rename = "mainDistributedSpace")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub main_distributed_space: Option<BoxStyle>,
            #[doc = "Style of content-distribution space on the cross axis (align-content)."]
            #[serde(rename = "crossDistributedSpace")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub cross_distributed_space: Option<BoxStyle>,
            #[doc = "Style of empty space caused by row gaps (gap/row-gap)."]
            #[serde(rename = "rowGapSpace")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub row_gap_space: Option<BoxStyle>,
            #[doc = "Style of empty space caused by columns gaps (gap/column-gap)."]
            #[serde(rename = "columnGapSpace")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub column_gap_space: Option<BoxStyle>,
            #[doc = "Style of the self-alignment line (align-items)."]
            #[serde(rename = "crossAlignment")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub cross_alignment: Option<LineStyle>,
        }
        impl FlexContainerHighlightConfig {
            pub fn builder() -> FlexContainerHighlightConfigBuilder {
                FlexContainerHighlightConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FlexContainerHighlightConfigBuilder {
            container_border: Option<LineStyle>,
            line_separator: Option<LineStyle>,
            item_separator: Option<LineStyle>,
            main_distributed_space: Option<BoxStyle>,
            cross_distributed_space: Option<BoxStyle>,
            row_gap_space: Option<BoxStyle>,
            column_gap_space: Option<BoxStyle>,
            cross_alignment: Option<LineStyle>,
        }
        impl FlexContainerHighlightConfigBuilder {
            pub fn container_border(mut self, container_border: impl Into<LineStyle>) -> Self {
                self.container_border = Some(container_border.into());
                self
            }
            pub fn line_separator(mut self, line_separator: impl Into<LineStyle>) -> Self {
                self.line_separator = Some(line_separator.into());
                self
            }
            pub fn item_separator(mut self, item_separator: impl Into<LineStyle>) -> Self {
                self.item_separator = Some(item_separator.into());
                self
            }
            pub fn main_distributed_space(
                mut self,
                main_distributed_space: impl Into<BoxStyle>,
            ) -> Self {
                self.main_distributed_space = Some(main_distributed_space.into());
                self
            }
            pub fn cross_distributed_space(
                mut self,
                cross_distributed_space: impl Into<BoxStyle>,
            ) -> Self {
                self.cross_distributed_space = Some(cross_distributed_space.into());
                self
            }
            pub fn row_gap_space(mut self, row_gap_space: impl Into<BoxStyle>) -> Self {
                self.row_gap_space = Some(row_gap_space.into());
                self
            }
            pub fn column_gap_space(mut self, column_gap_space: impl Into<BoxStyle>) -> Self {
                self.column_gap_space = Some(column_gap_space.into());
                self
            }
            pub fn cross_alignment(mut self, cross_alignment: impl Into<LineStyle>) -> Self {
                self.cross_alignment = Some(cross_alignment.into());
                self
            }
            pub fn build(self) -> FlexContainerHighlightConfig {
                FlexContainerHighlightConfig {
                    container_border: self.container_border,
                    line_separator: self.line_separator,
                    item_separator: self.item_separator,
                    main_distributed_space: self.main_distributed_space,
                    cross_distributed_space: self.cross_distributed_space,
                    row_gap_space: self.row_gap_space,
                    column_gap_space: self.column_gap_space,
                    cross_alignment: self.cross_alignment,
                }
            }
        }
        impl FlexContainerHighlightConfig {
            pub const IDENTIFIER: &'static str = "Overlay.FlexContainerHighlightConfig";
        }
        #[doc = "Configuration data for the highlighting of Flex item elements.\n[FlexItemHighlightConfig](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#type-FlexItemHighlightConfig)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct FlexItemHighlightConfig {
            #[doc = "Style of the box representing the item's base size"]
            #[serde(rename = "baseSizeBox")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub base_size_box: Option<BoxStyle>,
            #[doc = "Style of the border around the box representing the item's base size"]
            #[serde(rename = "baseSizeBorder")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub base_size_border: Option<LineStyle>,
            #[doc = "Style of the arrow representing if the item grew or shrank"]
            #[serde(rename = "flexibilityArrow")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub flexibility_arrow: Option<LineStyle>,
        }
        impl FlexItemHighlightConfig {
            pub fn builder() -> FlexItemHighlightConfigBuilder {
                FlexItemHighlightConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FlexItemHighlightConfigBuilder {
            base_size_box: Option<BoxStyle>,
            base_size_border: Option<LineStyle>,
            flexibility_arrow: Option<LineStyle>,
        }
        impl FlexItemHighlightConfigBuilder {
            pub fn base_size_box(mut self, base_size_box: impl Into<BoxStyle>) -> Self {
                self.base_size_box = Some(base_size_box.into());
                self
            }
            pub fn base_size_border(mut self, base_size_border: impl Into<LineStyle>) -> Self {
                self.base_size_border = Some(base_size_border.into());
                self
            }
            pub fn flexibility_arrow(mut self, flexibility_arrow: impl Into<LineStyle>) -> Self {
                self.flexibility_arrow = Some(flexibility_arrow.into());
                self
            }
            pub fn build(self) -> FlexItemHighlightConfig {
                FlexItemHighlightConfig {
                    base_size_box: self.base_size_box,
                    base_size_border: self.base_size_border,
                    flexibility_arrow: self.flexibility_arrow,
                }
            }
        }
        impl FlexItemHighlightConfig {
            pub const IDENTIFIER: &'static str = "Overlay.FlexItemHighlightConfig";
        }
        #[doc = "Style information for drawing a line.\n[LineStyle](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#type-LineStyle)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct LineStyle {
            #[doc = "The color of the line (default: transparent)"]
            #[serde(rename = "color")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub color: Option<super::dom::Rgba>,
            #[doc = "The line pattern (default: solid)"]
            #[serde(rename = "pattern")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub pattern: Option<LineStylePattern>,
        }
        #[doc = "The line pattern (default: solid)"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum LineStylePattern {
            #[serde(rename = "dashed")]
            Dashed,
            #[serde(rename = "dotted")]
            Dotted,
        }
        impl AsRef<str> for LineStylePattern {
            fn as_ref(&self) -> &str {
                match self {
                    LineStylePattern::Dashed => "dashed",
                    LineStylePattern::Dotted => "dotted",
                }
            }
        }
        impl ::std::str::FromStr for LineStylePattern {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "dashed" | "Dashed" => Ok(LineStylePattern::Dashed),
                    "dotted" | "Dotted" => Ok(LineStylePattern::Dotted),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl LineStyle {
            pub fn builder() -> LineStyleBuilder {
                LineStyleBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LineStyleBuilder {
            color: Option<super::dom::Rgba>,
            pattern: Option<LineStylePattern>,
        }
        impl LineStyleBuilder {
            pub fn color(mut self, color: impl Into<super::dom::Rgba>) -> Self {
                self.color = Some(color.into());
                self
            }
            pub fn pattern(mut self, pattern: impl Into<LineStylePattern>) -> Self {
                self.pattern = Some(pattern.into());
                self
            }
            pub fn build(self) -> LineStyle {
                LineStyle {
                    color: self.color,
                    pattern: self.pattern,
                }
            }
        }
        impl LineStyle {
            pub const IDENTIFIER: &'static str = "Overlay.LineStyle";
        }
        #[doc = "Style information for drawing a box.\n[BoxStyle](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#type-BoxStyle)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct BoxStyle {
            #[doc = "The background color for the box (default: transparent)"]
            #[serde(rename = "fillColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub fill_color: Option<super::dom::Rgba>,
            #[doc = "The hatching color for the box (default: transparent)"]
            #[serde(rename = "hatchColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub hatch_color: Option<super::dom::Rgba>,
        }
        impl BoxStyle {
            pub fn builder() -> BoxStyleBuilder {
                BoxStyleBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BoxStyleBuilder {
            fill_color: Option<super::dom::Rgba>,
            hatch_color: Option<super::dom::Rgba>,
        }
        impl BoxStyleBuilder {
            pub fn fill_color(mut self, fill_color: impl Into<super::dom::Rgba>) -> Self {
                self.fill_color = Some(fill_color.into());
                self
            }
            pub fn hatch_color(mut self, hatch_color: impl Into<super::dom::Rgba>) -> Self {
                self.hatch_color = Some(hatch_color.into());
                self
            }
            pub fn build(self) -> BoxStyle {
                BoxStyle {
                    fill_color: self.fill_color,
                    hatch_color: self.hatch_color,
                }
            }
        }
        impl BoxStyle {
            pub const IDENTIFIER: &'static str = "Overlay.BoxStyle";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ContrastAlgorithm {
            #[serde(rename = "aa")]
            Aa,
            #[serde(rename = "aaa")]
            Aaa,
            #[serde(rename = "apca")]
            Apca,
        }
        impl AsRef<str> for ContrastAlgorithm {
            fn as_ref(&self) -> &str {
                match self {
                    ContrastAlgorithm::Aa => "aa",
                    ContrastAlgorithm::Aaa => "aaa",
                    ContrastAlgorithm::Apca => "apca",
                }
            }
        }
        impl ::std::str::FromStr for ContrastAlgorithm {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "aa" | "Aa" => Ok(ContrastAlgorithm::Aa),
                    "aaa" | "Aaa" => Ok(ContrastAlgorithm::Aaa),
                    "apca" | "Apca" => Ok(ContrastAlgorithm::Apca),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Configuration data for the highlighting of page elements.\n[HighlightConfig](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#type-HighlightConfig)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HighlightConfig {
            #[doc = "Whether the node info tooltip should be shown (default: false)."]
            #[serde(rename = "showInfo")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub show_info: Option<bool>,
            #[doc = "Whether the node styles in the tooltip (default: false)."]
            #[serde(rename = "showStyles")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub show_styles: Option<bool>,
            #[doc = "Whether the rulers should be shown (default: false)."]
            #[serde(rename = "showRulers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub show_rulers: Option<bool>,
            #[doc = "Whether the a11y info should be shown (default: true)."]
            #[serde(rename = "showAccessibilityInfo")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub show_accessibility_info: Option<bool>,
            #[doc = "Whether the extension lines from node to the rulers should be shown (default: false)."]
            #[serde(rename = "showExtensionLines")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub show_extension_lines: Option<bool>,
            #[doc = "The content box highlight fill color (default: transparent)."]
            #[serde(rename = "contentColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub content_color: Option<super::dom::Rgba>,
            #[doc = "The padding highlight fill color (default: transparent)."]
            #[serde(rename = "paddingColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub padding_color: Option<super::dom::Rgba>,
            #[doc = "The border highlight fill color (default: transparent)."]
            #[serde(rename = "borderColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub border_color: Option<super::dom::Rgba>,
            #[doc = "The margin highlight fill color (default: transparent)."]
            #[serde(rename = "marginColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub margin_color: Option<super::dom::Rgba>,
            #[doc = "The event target element highlight fill color (default: transparent)."]
            #[serde(rename = "eventTargetColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub event_target_color: Option<super::dom::Rgba>,
            #[doc = "The shape outside fill color (default: transparent)."]
            #[serde(rename = "shapeColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub shape_color: Option<super::dom::Rgba>,
            #[doc = "The shape margin fill color (default: transparent)."]
            #[serde(rename = "shapeMarginColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub shape_margin_color: Option<super::dom::Rgba>,
            #[doc = "The grid layout color (default: transparent)."]
            #[serde(rename = "cssGridColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub css_grid_color: Option<super::dom::Rgba>,
            #[doc = "The color format used to format color styles (default: hex)."]
            #[serde(rename = "colorFormat")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub color_format: Option<ColorFormat>,
            #[doc = "The grid layout highlight configuration (default: all transparent)."]
            #[serde(rename = "gridHighlightConfig")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub grid_highlight_config: Option<GridHighlightConfig>,
            #[doc = "The flex container highlight configuration (default: all transparent)."]
            #[serde(rename = "flexContainerHighlightConfig")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub flex_container_highlight_config: Option<FlexContainerHighlightConfig>,
            #[doc = "The flex item highlight configuration (default: all transparent)."]
            #[serde(rename = "flexItemHighlightConfig")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub flex_item_highlight_config: Option<FlexItemHighlightConfig>,
            #[doc = "The contrast algorithm to use for the contrast ratio (default: aa)."]
            #[serde(rename = "contrastAlgorithm")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub contrast_algorithm: Option<ContrastAlgorithm>,
            #[doc = "The container query container highlight configuration (default: all transparent)."]
            #[serde(rename = "containerQueryContainerHighlightConfig")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub container_query_container_highlight_config:
                Option<ContainerQueryContainerHighlightConfig>,
        }
        impl HighlightConfig {
            pub fn builder() -> HighlightConfigBuilder {
                HighlightConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct HighlightConfigBuilder {
            show_info: Option<bool>,
            show_styles: Option<bool>,
            show_rulers: Option<bool>,
            show_accessibility_info: Option<bool>,
            show_extension_lines: Option<bool>,
            content_color: Option<super::dom::Rgba>,
            padding_color: Option<super::dom::Rgba>,
            border_color: Option<super::dom::Rgba>,
            margin_color: Option<super::dom::Rgba>,
            event_target_color: Option<super::dom::Rgba>,
            shape_color: Option<super::dom::Rgba>,
            shape_margin_color: Option<super::dom::Rgba>,
            css_grid_color: Option<super::dom::Rgba>,
            color_format: Option<ColorFormat>,
            grid_highlight_config: Option<GridHighlightConfig>,
            flex_container_highlight_config: Option<FlexContainerHighlightConfig>,
            flex_item_highlight_config: Option<FlexItemHighlightConfig>,
            contrast_algorithm: Option<ContrastAlgorithm>,
            container_query_container_highlight_config:
                Option<ContainerQueryContainerHighlightConfig>,
        }
        impl HighlightConfigBuilder {
            pub fn show_info(mut self, show_info: impl Into<bool>) -> Self {
                self.show_info = Some(show_info.into());
                self
            }
            pub fn show_styles(mut self, show_styles: impl Into<bool>) -> Self {
                self.show_styles = Some(show_styles.into());
                self
            }
            pub fn show_rulers(mut self, show_rulers: impl Into<bool>) -> Self {
                self.show_rulers = Some(show_rulers.into());
                self
            }
            pub fn show_accessibility_info(
                mut self,
                show_accessibility_info: impl Into<bool>,
            ) -> Self {
                self.show_accessibility_info = Some(show_accessibility_info.into());
                self
            }
            pub fn show_extension_lines(mut self, show_extension_lines: impl Into<bool>) -> Self {
                self.show_extension_lines = Some(show_extension_lines.into());
                self
            }
            pub fn content_color(mut self, content_color: impl Into<super::dom::Rgba>) -> Self {
                self.content_color = Some(content_color.into());
                self
            }
            pub fn padding_color(mut self, padding_color: impl Into<super::dom::Rgba>) -> Self {
                self.padding_color = Some(padding_color.into());
                self
            }
            pub fn border_color(mut self, border_color: impl Into<super::dom::Rgba>) -> Self {
                self.border_color = Some(border_color.into());
                self
            }
            pub fn margin_color(mut self, margin_color: impl Into<super::dom::Rgba>) -> Self {
                self.margin_color = Some(margin_color.into());
                self
            }
            pub fn event_target_color(
                mut self,
                event_target_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                self.event_target_color = Some(event_target_color.into());
                self
            }
            pub fn shape_color(mut self, shape_color: impl Into<super::dom::Rgba>) -> Self {
                self.shape_color = Some(shape_color.into());
                self
            }
            pub fn shape_margin_color(
                mut self,
                shape_margin_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                self.shape_margin_color = Some(shape_margin_color.into());
                self
            }
            pub fn css_grid_color(mut self, css_grid_color: impl Into<super::dom::Rgba>) -> Self {
                self.css_grid_color = Some(css_grid_color.into());
                self
            }
            pub fn color_format(mut self, color_format: impl Into<ColorFormat>) -> Self {
                self.color_format = Some(color_format.into());
                self
            }
            pub fn grid_highlight_config(
                mut self,
                grid_highlight_config: impl Into<GridHighlightConfig>,
            ) -> Self {
                self.grid_highlight_config = Some(grid_highlight_config.into());
                self
            }
            pub fn flex_container_highlight_config(
                mut self,
                flex_container_highlight_config: impl Into<FlexContainerHighlightConfig>,
            ) -> Self {
                self.flex_container_highlight_config = Some(flex_container_highlight_config.into());
                self
            }
            pub fn flex_item_highlight_config(
                mut self,
                flex_item_highlight_config: impl Into<FlexItemHighlightConfig>,
            ) -> Self {
                self.flex_item_highlight_config = Some(flex_item_highlight_config.into());
                self
            }
            pub fn contrast_algorithm(
                mut self,
                contrast_algorithm: impl Into<ContrastAlgorithm>,
            ) -> Self {
                self.contrast_algorithm = Some(contrast_algorithm.into());
                self
            }
            pub fn container_query_container_highlight_config(
                mut self,
                container_query_container_highlight_config: impl Into<
                    ContainerQueryContainerHighlightConfig,
                >,
            ) -> Self {
                self.container_query_container_highlight_config =
                    Some(container_query_container_highlight_config.into());
                self
            }
            pub fn build(self) -> HighlightConfig {
                HighlightConfig {
                    show_info: self.show_info,
                    show_styles: self.show_styles,
                    show_rulers: self.show_rulers,
                    show_accessibility_info: self.show_accessibility_info,
                    show_extension_lines: self.show_extension_lines,
                    content_color: self.content_color,
                    padding_color: self.padding_color,
                    border_color: self.border_color,
                    margin_color: self.margin_color,
                    event_target_color: self.event_target_color,
                    shape_color: self.shape_color,
                    shape_margin_color: self.shape_margin_color,
                    css_grid_color: self.css_grid_color,
                    color_format: self.color_format,
                    grid_highlight_config: self.grid_highlight_config,
                    flex_container_highlight_config: self.flex_container_highlight_config,
                    flex_item_highlight_config: self.flex_item_highlight_config,
                    contrast_algorithm: self.contrast_algorithm,
                    container_query_container_highlight_config: self
                        .container_query_container_highlight_config,
                }
            }
        }
        impl HighlightConfig {
            pub const IDENTIFIER: &'static str = "Overlay.HighlightConfig";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ColorFormat {
            #[serde(rename = "rgb")]
            Rgb,
            #[serde(rename = "hsl")]
            Hsl,
            #[serde(rename = "hwb")]
            Hwb,
            #[serde(rename = "hex")]
            Hex,
        }
        impl AsRef<str> for ColorFormat {
            fn as_ref(&self) -> &str {
                match self {
                    ColorFormat::Rgb => "rgb",
                    ColorFormat::Hsl => "hsl",
                    ColorFormat::Hwb => "hwb",
                    ColorFormat::Hex => "hex",
                }
            }
        }
        impl ::std::str::FromStr for ColorFormat {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "rgb" | "Rgb" => Ok(ColorFormat::Rgb),
                    "hsl" | "Hsl" => Ok(ColorFormat::Hsl),
                    "hwb" | "Hwb" => Ok(ColorFormat::Hwb),
                    "hex" | "Hex" => Ok(ColorFormat::Hex),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Configurations for Persistent Grid Highlight\n[GridNodeHighlightConfig](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#type-GridNodeHighlightConfig)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GridNodeHighlightConfig {
            #[doc = "A descriptor for the highlight appearance."]
            #[serde(rename = "gridHighlightConfig")]
            pub grid_highlight_config: GridHighlightConfig,
            #[doc = "Identifier of the node to highlight."]
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
        }
        impl GridNodeHighlightConfig {
            pub fn new(
                grid_highlight_config: impl Into<GridHighlightConfig>,
                node_id: impl Into<super::dom::NodeId>,
            ) -> Self {
                Self {
                    grid_highlight_config: grid_highlight_config.into(),
                    node_id: node_id.into(),
                }
            }
        }
        impl GridNodeHighlightConfig {
            pub fn builder() -> GridNodeHighlightConfigBuilder {
                GridNodeHighlightConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GridNodeHighlightConfigBuilder {
            grid_highlight_config: Option<GridHighlightConfig>,
            node_id: Option<super::dom::NodeId>,
        }
        impl GridNodeHighlightConfigBuilder {
            pub fn grid_highlight_config(
                mut self,
                grid_highlight_config: impl Into<GridHighlightConfig>,
            ) -> Self {
                self.grid_highlight_config = Some(grid_highlight_config.into());
                self
            }
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GridNodeHighlightConfig, String> {
                Ok(GridNodeHighlightConfig {
                    grid_highlight_config: self.grid_highlight_config.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(grid_highlight_config)
                        )
                    })?,
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl GridNodeHighlightConfig {
            pub const IDENTIFIER: &'static str = "Overlay.GridNodeHighlightConfig";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct FlexNodeHighlightConfig {
            #[doc = "A descriptor for the highlight appearance of flex containers."]
            #[serde(rename = "flexContainerHighlightConfig")]
            pub flex_container_highlight_config: FlexContainerHighlightConfig,
            #[doc = "Identifier of the node to highlight."]
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
        }
        impl FlexNodeHighlightConfig {
            pub fn new(
                flex_container_highlight_config: impl Into<FlexContainerHighlightConfig>,
                node_id: impl Into<super::dom::NodeId>,
            ) -> Self {
                Self {
                    flex_container_highlight_config: flex_container_highlight_config.into(),
                    node_id: node_id.into(),
                }
            }
        }
        impl FlexNodeHighlightConfig {
            pub fn builder() -> FlexNodeHighlightConfigBuilder {
                FlexNodeHighlightConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FlexNodeHighlightConfigBuilder {
            flex_container_highlight_config: Option<FlexContainerHighlightConfig>,
            node_id: Option<super::dom::NodeId>,
        }
        impl FlexNodeHighlightConfigBuilder {
            pub fn flex_container_highlight_config(
                mut self,
                flex_container_highlight_config: impl Into<FlexContainerHighlightConfig>,
            ) -> Self {
                self.flex_container_highlight_config = Some(flex_container_highlight_config.into());
                self
            }
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<FlexNodeHighlightConfig, String> {
                Ok(FlexNodeHighlightConfig {
                    flex_container_highlight_config: self
                        .flex_container_highlight_config
                        .ok_or_else(|| {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(flex_container_highlight_config)
                            )
                        })?,
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl FlexNodeHighlightConfig {
            pub const IDENTIFIER: &'static str = "Overlay.FlexNodeHighlightConfig";
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ScrollSnapContainerHighlightConfig {
            #[doc = "The style of the snapport border (default: transparent)"]
            #[serde(rename = "snapportBorder")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub snapport_border: Option<LineStyle>,
            #[doc = "The style of the snap area border (default: transparent)"]
            #[serde(rename = "snapAreaBorder")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub snap_area_border: Option<LineStyle>,
            #[doc = "The margin highlight fill color (default: transparent)."]
            #[serde(rename = "scrollMarginColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub scroll_margin_color: Option<super::dom::Rgba>,
            #[doc = "The padding highlight fill color (default: transparent)."]
            #[serde(rename = "scrollPaddingColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub scroll_padding_color: Option<super::dom::Rgba>,
        }
        impl ScrollSnapContainerHighlightConfig {
            pub fn builder() -> ScrollSnapContainerHighlightConfigBuilder {
                ScrollSnapContainerHighlightConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ScrollSnapContainerHighlightConfigBuilder {
            snapport_border: Option<LineStyle>,
            snap_area_border: Option<LineStyle>,
            scroll_margin_color: Option<super::dom::Rgba>,
            scroll_padding_color: Option<super::dom::Rgba>,
        }
        impl ScrollSnapContainerHighlightConfigBuilder {
            pub fn snapport_border(mut self, snapport_border: impl Into<LineStyle>) -> Self {
                self.snapport_border = Some(snapport_border.into());
                self
            }
            pub fn snap_area_border(mut self, snap_area_border: impl Into<LineStyle>) -> Self {
                self.snap_area_border = Some(snap_area_border.into());
                self
            }
            pub fn scroll_margin_color(
                mut self,
                scroll_margin_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                self.scroll_margin_color = Some(scroll_margin_color.into());
                self
            }
            pub fn scroll_padding_color(
                mut self,
                scroll_padding_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                self.scroll_padding_color = Some(scroll_padding_color.into());
                self
            }
            pub fn build(self) -> ScrollSnapContainerHighlightConfig {
                ScrollSnapContainerHighlightConfig {
                    snapport_border: self.snapport_border,
                    snap_area_border: self.snap_area_border,
                    scroll_margin_color: self.scroll_margin_color,
                    scroll_padding_color: self.scroll_padding_color,
                }
            }
        }
        impl ScrollSnapContainerHighlightConfig {
            pub const IDENTIFIER: &'static str = "Overlay.ScrollSnapContainerHighlightConfig";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ScrollSnapHighlightConfig {
            #[doc = "A descriptor for the highlight appearance of scroll snap containers."]
            #[serde(rename = "scrollSnapContainerHighlightConfig")]
            pub scroll_snap_container_highlight_config: ScrollSnapContainerHighlightConfig,
            #[doc = "Identifier of the node to highlight."]
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
        }
        impl ScrollSnapHighlightConfig {
            pub fn new(
                scroll_snap_container_highlight_config: impl Into<ScrollSnapContainerHighlightConfig>,
                node_id: impl Into<super::dom::NodeId>,
            ) -> Self {
                Self {
                    scroll_snap_container_highlight_config: scroll_snap_container_highlight_config
                        .into(),
                    node_id: node_id.into(),
                }
            }
        }
        impl ScrollSnapHighlightConfig {
            pub fn builder() -> ScrollSnapHighlightConfigBuilder {
                ScrollSnapHighlightConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ScrollSnapHighlightConfigBuilder {
            scroll_snap_container_highlight_config: Option<ScrollSnapContainerHighlightConfig>,
            node_id: Option<super::dom::NodeId>,
        }
        impl ScrollSnapHighlightConfigBuilder {
            pub fn scroll_snap_container_highlight_config(
                mut self,
                scroll_snap_container_highlight_config: impl Into<ScrollSnapContainerHighlightConfig>,
            ) -> Self {
                self.scroll_snap_container_highlight_config =
                    Some(scroll_snap_container_highlight_config.into());
                self
            }
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<ScrollSnapHighlightConfig, String> {
                Ok(ScrollSnapHighlightConfig {
                    scroll_snap_container_highlight_config: self
                        .scroll_snap_container_highlight_config
                        .ok_or_else(|| {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(scroll_snap_container_highlight_config)
                            )
                        })?,
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl ScrollSnapHighlightConfig {
            pub const IDENTIFIER: &'static str = "Overlay.ScrollSnapHighlightConfig";
        }
        #[doc = "Configuration for dual screen hinge\n[HingeConfig](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#type-HingeConfig)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct HingeConfig {
            #[doc = "A rectangle represent hinge"]
            #[serde(rename = "rect")]
            pub rect: super::dom::Rect,
            #[doc = "The content box highlight fill color (default: a dark color)."]
            #[serde(rename = "contentColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub content_color: Option<super::dom::Rgba>,
            #[doc = "The content box highlight outline color (default: transparent)."]
            #[serde(rename = "outlineColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub outline_color: Option<super::dom::Rgba>,
        }
        impl HingeConfig {
            pub fn new(rect: impl Into<super::dom::Rect>) -> Self {
                Self {
                    rect: rect.into(),
                    content_color: None,
                    outline_color: None,
                }
            }
        }
        impl HingeConfig {
            pub fn builder() -> HingeConfigBuilder {
                HingeConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct HingeConfigBuilder {
            rect: Option<super::dom::Rect>,
            content_color: Option<super::dom::Rgba>,
            outline_color: Option<super::dom::Rgba>,
        }
        impl HingeConfigBuilder {
            pub fn rect(mut self, rect: impl Into<super::dom::Rect>) -> Self {
                self.rect = Some(rect.into());
                self
            }
            pub fn content_color(mut self, content_color: impl Into<super::dom::Rgba>) -> Self {
                self.content_color = Some(content_color.into());
                self
            }
            pub fn outline_color(mut self, outline_color: impl Into<super::dom::Rgba>) -> Self {
                self.outline_color = Some(outline_color.into());
                self
            }
            pub fn build(self) -> Result<HingeConfig, String> {
                Ok(HingeConfig {
                    rect: self.rect.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(rect))
                    })?,
                    content_color: self.content_color,
                    outline_color: self.outline_color,
                })
            }
        }
        impl HingeConfig {
            pub const IDENTIFIER: &'static str = "Overlay.HingeConfig";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ContainerQueryHighlightConfig {
            #[doc = "A descriptor for the highlight appearance of container query containers."]
            #[serde(rename = "containerQueryContainerHighlightConfig")]
            pub container_query_container_highlight_config: ContainerQueryContainerHighlightConfig,
            #[doc = "Identifier of the container node to highlight."]
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
        }
        impl ContainerQueryHighlightConfig {
            pub fn new(
                container_query_container_highlight_config: impl Into<
                    ContainerQueryContainerHighlightConfig,
                >,
                node_id: impl Into<super::dom::NodeId>,
            ) -> Self {
                Self {
                    container_query_container_highlight_config:
                        container_query_container_highlight_config.into(),
                    node_id: node_id.into(),
                }
            }
        }
        impl ContainerQueryHighlightConfig {
            pub fn builder() -> ContainerQueryHighlightConfigBuilder {
                ContainerQueryHighlightConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ContainerQueryHighlightConfigBuilder {
            container_query_container_highlight_config:
                Option<ContainerQueryContainerHighlightConfig>,
            node_id: Option<super::dom::NodeId>,
        }
        impl ContainerQueryHighlightConfigBuilder {
            pub fn container_query_container_highlight_config(
                mut self,
                container_query_container_highlight_config: impl Into<
                    ContainerQueryContainerHighlightConfig,
                >,
            ) -> Self {
                self.container_query_container_highlight_config =
                    Some(container_query_container_highlight_config.into());
                self
            }
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<ContainerQueryHighlightConfig, String> {
                Ok(ContainerQueryHighlightConfig {
                    container_query_container_highlight_config: self
                        .container_query_container_highlight_config
                        .ok_or_else(|| {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(container_query_container_highlight_config)
                            )
                        })?,
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl ContainerQueryHighlightConfig {
            pub const IDENTIFIER: &'static str = "Overlay.ContainerQueryHighlightConfig";
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ContainerQueryContainerHighlightConfig {
            #[doc = "The style of the container border."]
            #[serde(rename = "containerBorder")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub container_border: Option<LineStyle>,
            #[doc = "The style of the descendants' borders."]
            #[serde(rename = "descendantBorder")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub descendant_border: Option<LineStyle>,
        }
        impl ContainerQueryContainerHighlightConfig {
            pub fn builder() -> ContainerQueryContainerHighlightConfigBuilder {
                ContainerQueryContainerHighlightConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ContainerQueryContainerHighlightConfigBuilder {
            container_border: Option<LineStyle>,
            descendant_border: Option<LineStyle>,
        }
        impl ContainerQueryContainerHighlightConfigBuilder {
            pub fn container_border(mut self, container_border: impl Into<LineStyle>) -> Self {
                self.container_border = Some(container_border.into());
                self
            }
            pub fn descendant_border(mut self, descendant_border: impl Into<LineStyle>) -> Self {
                self.descendant_border = Some(descendant_border.into());
                self
            }
            pub fn build(self) -> ContainerQueryContainerHighlightConfig {
                ContainerQueryContainerHighlightConfig {
                    container_border: self.container_border,
                    descendant_border: self.descendant_border,
                }
            }
        }
        impl ContainerQueryContainerHighlightConfig {
            pub const IDENTIFIER: &'static str = "Overlay.ContainerQueryContainerHighlightConfig";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct IsolatedElementHighlightConfig {
            #[doc = "A descriptor for the highlight appearance of an element in isolation mode."]
            #[serde(rename = "isolationModeHighlightConfig")]
            pub isolation_mode_highlight_config: IsolationModeHighlightConfig,
            #[doc = "Identifier of the isolated element to highlight."]
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
        }
        impl IsolatedElementHighlightConfig {
            pub fn new(
                isolation_mode_highlight_config: impl Into<IsolationModeHighlightConfig>,
                node_id: impl Into<super::dom::NodeId>,
            ) -> Self {
                Self {
                    isolation_mode_highlight_config: isolation_mode_highlight_config.into(),
                    node_id: node_id.into(),
                }
            }
        }
        impl IsolatedElementHighlightConfig {
            pub fn builder() -> IsolatedElementHighlightConfigBuilder {
                IsolatedElementHighlightConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct IsolatedElementHighlightConfigBuilder {
            isolation_mode_highlight_config: Option<IsolationModeHighlightConfig>,
            node_id: Option<super::dom::NodeId>,
        }
        impl IsolatedElementHighlightConfigBuilder {
            pub fn isolation_mode_highlight_config(
                mut self,
                isolation_mode_highlight_config: impl Into<IsolationModeHighlightConfig>,
            ) -> Self {
                self.isolation_mode_highlight_config = Some(isolation_mode_highlight_config.into());
                self
            }
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<IsolatedElementHighlightConfig, String> {
                Ok(IsolatedElementHighlightConfig {
                    isolation_mode_highlight_config: self
                        .isolation_mode_highlight_config
                        .ok_or_else(|| {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(isolation_mode_highlight_config)
                            )
                        })?,
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl IsolatedElementHighlightConfig {
            pub const IDENTIFIER: &'static str = "Overlay.IsolatedElementHighlightConfig";
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct IsolationModeHighlightConfig {
            #[doc = "The fill color of the resizers (default: transparent)."]
            #[serde(rename = "resizerColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub resizer_color: Option<super::dom::Rgba>,
            #[doc = "The fill color for resizer handles (default: transparent)."]
            #[serde(rename = "resizerHandleColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub resizer_handle_color: Option<super::dom::Rgba>,
            #[doc = "The fill color for the mask covering non-isolated elements (default: transparent)."]
            #[serde(rename = "maskColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub mask_color: Option<super::dom::Rgba>,
        }
        impl IsolationModeHighlightConfig {
            pub fn builder() -> IsolationModeHighlightConfigBuilder {
                IsolationModeHighlightConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct IsolationModeHighlightConfigBuilder {
            resizer_color: Option<super::dom::Rgba>,
            resizer_handle_color: Option<super::dom::Rgba>,
            mask_color: Option<super::dom::Rgba>,
        }
        impl IsolationModeHighlightConfigBuilder {
            pub fn resizer_color(mut self, resizer_color: impl Into<super::dom::Rgba>) -> Self {
                self.resizer_color = Some(resizer_color.into());
                self
            }
            pub fn resizer_handle_color(
                mut self,
                resizer_handle_color: impl Into<super::dom::Rgba>,
            ) -> Self {
                self.resizer_handle_color = Some(resizer_handle_color.into());
                self
            }
            pub fn mask_color(mut self, mask_color: impl Into<super::dom::Rgba>) -> Self {
                self.mask_color = Some(mask_color.into());
                self
            }
            pub fn build(self) -> IsolationModeHighlightConfig {
                IsolationModeHighlightConfig {
                    resizer_color: self.resizer_color,
                    resizer_handle_color: self.resizer_handle_color,
                    mask_color: self.mask_color,
                }
            }
        }
        impl IsolationModeHighlightConfig {
            pub const IDENTIFIER: &'static str = "Overlay.IsolationModeHighlightConfig";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum InspectMode {
            #[serde(rename = "searchForNode")]
            SearchForNode,
            #[serde(rename = "searchForUAShadowDOM")]
            SearchForUaShadowDom,
            #[serde(rename = "captureAreaScreenshot")]
            CaptureAreaScreenshot,
            #[serde(rename = "showDistances")]
            ShowDistances,
            #[serde(rename = "none")]
            None,
        }
        impl AsRef<str> for InspectMode {
            fn as_ref(&self) -> &str {
                match self {
                    InspectMode::SearchForNode => "searchForNode",
                    InspectMode::SearchForUaShadowDom => "searchForUAShadowDOM",
                    InspectMode::CaptureAreaScreenshot => "captureAreaScreenshot",
                    InspectMode::ShowDistances => "showDistances",
                    InspectMode::None => "none",
                }
            }
        }
        impl ::std::str::FromStr for InspectMode {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "searchForNode" | "SearchForNode" | "searchfornode" => {
                        Ok(InspectMode::SearchForNode)
                    }
                    "searchForUAShadowDOM" | "SearchForUaShadowDom" | "searchforuashadowdom" => {
                        Ok(InspectMode::SearchForUaShadowDom)
                    }
                    "captureAreaScreenshot" | "CaptureAreaScreenshot" | "captureareascreenshot" => {
                        Ok(InspectMode::CaptureAreaScreenshot)
                    }
                    "showDistances" | "ShowDistances" | "showdistances" => {
                        Ok(InspectMode::ShowDistances)
                    }
                    "none" | "None" => Ok(InspectMode::None),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Disables domain notifications.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Overlay.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables domain notifications.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables domain notifications.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Overlay.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables domain notifications.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "For testing.\n[getHighlightObjectForTest](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-getHighlightObjectForTest)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetHighlightObjectForTestParams {
            #[doc = "Id of the node to get highlight object for."]
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
            #[doc = "Whether to include distance info."]
            #[serde(rename = "includeDistance")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub include_distance: Option<bool>,
            #[doc = "Whether to include style info."]
            #[serde(rename = "includeStyle")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub include_style: Option<bool>,
            #[doc = "The color format to get config with (default: hex)."]
            #[serde(rename = "colorFormat")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub color_format: Option<ColorFormat>,
            #[doc = "Whether to show accessibility info (default: true)."]
            #[serde(rename = "showAccessibilityInfo")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub show_accessibility_info: Option<bool>,
        }
        impl GetHighlightObjectForTestParams {
            pub fn new(node_id: impl Into<super::dom::NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                    include_distance: None,
                    include_style: None,
                    color_format: None,
                    show_accessibility_info: None,
                }
            }
        }
        impl GetHighlightObjectForTestParams {
            pub fn builder() -> GetHighlightObjectForTestParamsBuilder {
                GetHighlightObjectForTestParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetHighlightObjectForTestParamsBuilder {
            node_id: Option<super::dom::NodeId>,
            include_distance: Option<bool>,
            include_style: Option<bool>,
            color_format: Option<ColorFormat>,
            show_accessibility_info: Option<bool>,
        }
        impl GetHighlightObjectForTestParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn include_distance(mut self, include_distance: impl Into<bool>) -> Self {
                self.include_distance = Some(include_distance.into());
                self
            }
            pub fn include_style(mut self, include_style: impl Into<bool>) -> Self {
                self.include_style = Some(include_style.into());
                self
            }
            pub fn color_format(mut self, color_format: impl Into<ColorFormat>) -> Self {
                self.color_format = Some(color_format.into());
                self
            }
            pub fn show_accessibility_info(
                mut self,
                show_accessibility_info: impl Into<bool>,
            ) -> Self {
                self.show_accessibility_info = Some(show_accessibility_info.into());
                self
            }
            pub fn build(self) -> Result<GetHighlightObjectForTestParams, String> {
                Ok(GetHighlightObjectForTestParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    include_distance: self.include_distance,
                    include_style: self.include_style,
                    color_format: self.color_format,
                    show_accessibility_info: self.show_accessibility_info,
                })
            }
        }
        impl GetHighlightObjectForTestParams {
            pub const IDENTIFIER: &'static str = "Overlay.getHighlightObjectForTest";
        }
        impl chromiumoxide_types::Method for GetHighlightObjectForTestParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetHighlightObjectForTestParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "For testing.\n[getHighlightObjectForTest](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-getHighlightObjectForTest)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetHighlightObjectForTestReturns {
            #[doc = "Highlight data for the node."]
            #[serde(rename = "highlight")]
            pub highlight: serde_json::Value,
        }
        impl GetHighlightObjectForTestReturns {
            pub fn new(highlight: impl Into<serde_json::Value>) -> Self {
                Self {
                    highlight: highlight.into(),
                }
            }
        }
        impl GetHighlightObjectForTestReturns {
            pub fn builder() -> GetHighlightObjectForTestReturnsBuilder {
                GetHighlightObjectForTestReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetHighlightObjectForTestReturnsBuilder {
            highlight: Option<serde_json::Value>,
        }
        impl GetHighlightObjectForTestReturnsBuilder {
            pub fn highlight(mut self, highlight: impl Into<serde_json::Value>) -> Self {
                self.highlight = Some(highlight.into());
                self
            }
            pub fn build(self) -> Result<GetHighlightObjectForTestReturns, String> {
                Ok(GetHighlightObjectForTestReturns {
                    highlight: self.highlight.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(highlight))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetHighlightObjectForTestParams {
            type Response = GetHighlightObjectForTestReturns;
        }
        #[doc = "For Persistent Grid testing.\n[getGridHighlightObjectsForTest](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-getGridHighlightObjectsForTest)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetGridHighlightObjectsForTestParams {
            #[doc = "Ids of the node to get highlight object for."]
            #[serde(rename = "nodeIds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub node_ids: Vec<super::dom::NodeId>,
        }
        impl GetGridHighlightObjectsForTestParams {
            pub fn new(node_ids: Vec<super::dom::NodeId>) -> Self {
                Self { node_ids }
            }
        }
        impl GetGridHighlightObjectsForTestParams {
            pub fn builder() -> GetGridHighlightObjectsForTestParamsBuilder {
                GetGridHighlightObjectsForTestParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetGridHighlightObjectsForTestParamsBuilder {
            node_ids: Option<Vec<super::dom::NodeId>>,
        }
        impl GetGridHighlightObjectsForTestParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                let v = self.node_ids.get_or_insert(Vec::new());
                v.push(node_id.into());
                self
            }
            pub fn node_ids<I, S>(mut self, node_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<super::dom::NodeId>,
            {
                let v = self.node_ids.get_or_insert(Vec::new());
                for val in node_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetGridHighlightObjectsForTestParams, String> {
                Ok(GetGridHighlightObjectsForTestParams {
                    node_ids: self.node_ids.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_ids))
                    })?,
                })
            }
        }
        impl GetGridHighlightObjectsForTestParams {
            pub const IDENTIFIER: &'static str = "Overlay.getGridHighlightObjectsForTest";
        }
        impl chromiumoxide_types::Method for GetGridHighlightObjectsForTestParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetGridHighlightObjectsForTestParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "For Persistent Grid testing.\n[getGridHighlightObjectsForTest](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-getGridHighlightObjectsForTest)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetGridHighlightObjectsForTestReturns {
            #[doc = "Grid Highlight data for the node ids provided."]
            #[serde(rename = "highlights")]
            pub highlights: serde_json::Value,
        }
        impl GetGridHighlightObjectsForTestReturns {
            pub fn new(highlights: impl Into<serde_json::Value>) -> Self {
                Self {
                    highlights: highlights.into(),
                }
            }
        }
        impl GetGridHighlightObjectsForTestReturns {
            pub fn builder() -> GetGridHighlightObjectsForTestReturnsBuilder {
                GetGridHighlightObjectsForTestReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetGridHighlightObjectsForTestReturnsBuilder {
            highlights: Option<serde_json::Value>,
        }
        impl GetGridHighlightObjectsForTestReturnsBuilder {
            pub fn highlights(mut self, highlights: impl Into<serde_json::Value>) -> Self {
                self.highlights = Some(highlights.into());
                self
            }
            pub fn build(self) -> Result<GetGridHighlightObjectsForTestReturns, String> {
                Ok(GetGridHighlightObjectsForTestReturns {
                    highlights: self.highlights.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(highlights))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetGridHighlightObjectsForTestParams {
            type Response = GetGridHighlightObjectsForTestReturns;
        }
        #[doc = "For Source Order Viewer testing.\n[getSourceOrderHighlightObjectForTest](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-getSourceOrderHighlightObjectForTest)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetSourceOrderHighlightObjectForTestParams {
            #[doc = "Id of the node to highlight."]
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
        }
        impl GetSourceOrderHighlightObjectForTestParams {
            pub fn new(node_id: impl Into<super::dom::NodeId>) -> Self {
                Self {
                    node_id: node_id.into(),
                }
            }
        }
        impl GetSourceOrderHighlightObjectForTestParams {
            pub fn builder() -> GetSourceOrderHighlightObjectForTestParamsBuilder {
                GetSourceOrderHighlightObjectForTestParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetSourceOrderHighlightObjectForTestParamsBuilder {
            node_id: Option<super::dom::NodeId>,
        }
        impl GetSourceOrderHighlightObjectForTestParamsBuilder {
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<GetSourceOrderHighlightObjectForTestParams, String> {
                Ok(GetSourceOrderHighlightObjectForTestParams {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                })
            }
        }
        impl GetSourceOrderHighlightObjectForTestParams {
            pub const IDENTIFIER: &'static str = "Overlay.getSourceOrderHighlightObjectForTest";
        }
        impl chromiumoxide_types::Method for GetSourceOrderHighlightObjectForTestParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetSourceOrderHighlightObjectForTestParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "For Source Order Viewer testing.\n[getSourceOrderHighlightObjectForTest](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-getSourceOrderHighlightObjectForTest)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetSourceOrderHighlightObjectForTestReturns {
            #[doc = "Source order highlight data for the node id provided."]
            #[serde(rename = "highlight")]
            pub highlight: serde_json::Value,
        }
        impl GetSourceOrderHighlightObjectForTestReturns {
            pub fn new(highlight: impl Into<serde_json::Value>) -> Self {
                Self {
                    highlight: highlight.into(),
                }
            }
        }
        impl GetSourceOrderHighlightObjectForTestReturns {
            pub fn builder() -> GetSourceOrderHighlightObjectForTestReturnsBuilder {
                GetSourceOrderHighlightObjectForTestReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetSourceOrderHighlightObjectForTestReturnsBuilder {
            highlight: Option<serde_json::Value>,
        }
        impl GetSourceOrderHighlightObjectForTestReturnsBuilder {
            pub fn highlight(mut self, highlight: impl Into<serde_json::Value>) -> Self {
                self.highlight = Some(highlight.into());
                self
            }
            pub fn build(self) -> Result<GetSourceOrderHighlightObjectForTestReturns, String> {
                Ok(GetSourceOrderHighlightObjectForTestReturns {
                    highlight: self.highlight.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(highlight))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetSourceOrderHighlightObjectForTestParams {
            type Response = GetSourceOrderHighlightObjectForTestReturns;
        }
        #[doc = "Hides any highlight.\n[hideHighlight](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-hideHighlight)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HideHighlightParams {}
        impl HideHighlightParams {
            pub const IDENTIFIER: &'static str = "Overlay.hideHighlight";
        }
        impl chromiumoxide_types::Method for HideHighlightParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for HideHighlightParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Hides any highlight.\n[hideHighlight](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-hideHighlight)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HideHighlightReturns {}
        impl chromiumoxide_types::Command for HideHighlightParams {
            type Response = HideHighlightReturns;
        }
        #[doc = "Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or\nobjectId must be specified.\n[highlightNode](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-highlightNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct HighlightNodeParams {
            #[doc = "A descriptor for the highlight appearance."]
            #[serde(rename = "highlightConfig")]
            pub highlight_config: HighlightConfig,
            #[doc = "Identifier of the node to highlight."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<super::dom::NodeId>,
            #[doc = "Identifier of the backend node to highlight."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<super::dom::BackendNodeId>,
            #[doc = "JavaScript object id of the node to be highlighted."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
            #[doc = "Selectors to highlight relevant nodes."]
            #[serde(rename = "selector")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub selector: Option<String>,
        }
        impl HighlightNodeParams {
            pub fn new(highlight_config: impl Into<HighlightConfig>) -> Self {
                Self {
                    highlight_config: highlight_config.into(),
                    node_id: None,
                    backend_node_id: None,
                    object_id: None,
                    selector: None,
                }
            }
        }
        impl HighlightNodeParams {
            pub fn builder() -> HighlightNodeParamsBuilder {
                HighlightNodeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct HighlightNodeParamsBuilder {
            highlight_config: Option<HighlightConfig>,
            node_id: Option<super::dom::NodeId>,
            backend_node_id: Option<super::dom::BackendNodeId>,
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
            selector: Option<String>,
        }
        impl HighlightNodeParamsBuilder {
            pub fn highlight_config(
                mut self,
                highlight_config: impl Into<HighlightConfig>,
            ) -> Self {
                self.highlight_config = Some(highlight_config.into());
                self
            }
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn backend_node_id(
                mut self,
                backend_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn selector(mut self, selector: impl Into<String>) -> Self {
                self.selector = Some(selector.into());
                self
            }
            pub fn build(self) -> Result<HighlightNodeParams, String> {
                Ok(HighlightNodeParams {
                    highlight_config: self.highlight_config.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(highlight_config)
                        )
                    })?,
                    node_id: self.node_id,
                    backend_node_id: self.backend_node_id,
                    object_id: self.object_id,
                    selector: self.selector,
                })
            }
        }
        impl HighlightNodeParams {
            pub const IDENTIFIER: &'static str = "Overlay.highlightNode";
        }
        impl chromiumoxide_types::Method for HighlightNodeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for HighlightNodeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or\nobjectId must be specified.\n[highlightNode](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-highlightNode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HighlightNodeReturns {}
        impl chromiumoxide_types::Command for HighlightNodeParams {
            type Response = HighlightNodeReturns;
        }
        #[doc = "Highlights given quad. Coordinates are absolute with respect to the main frame viewport.\n[highlightQuad](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-highlightQuad)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct HighlightQuadParams {
            #[doc = "Quad to highlight"]
            #[serde(rename = "quad")]
            pub quad: super::dom::Quad,
            #[doc = "The highlight fill color (default: transparent)."]
            #[serde(rename = "color")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub color: Option<super::dom::Rgba>,
            #[doc = "The highlight outline color (default: transparent)."]
            #[serde(rename = "outlineColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub outline_color: Option<super::dom::Rgba>,
        }
        impl HighlightQuadParams {
            pub fn new(quad: impl Into<super::dom::Quad>) -> Self {
                Self {
                    quad: quad.into(),
                    color: None,
                    outline_color: None,
                }
            }
        }
        impl HighlightQuadParams {
            pub fn builder() -> HighlightQuadParamsBuilder {
                HighlightQuadParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct HighlightQuadParamsBuilder {
            quad: Option<super::dom::Quad>,
            color: Option<super::dom::Rgba>,
            outline_color: Option<super::dom::Rgba>,
        }
        impl HighlightQuadParamsBuilder {
            pub fn quad(mut self, quad: impl Into<super::dom::Quad>) -> Self {
                self.quad = Some(quad.into());
                self
            }
            pub fn color(mut self, color: impl Into<super::dom::Rgba>) -> Self {
                self.color = Some(color.into());
                self
            }
            pub fn outline_color(mut self, outline_color: impl Into<super::dom::Rgba>) -> Self {
                self.outline_color = Some(outline_color.into());
                self
            }
            pub fn build(self) -> Result<HighlightQuadParams, String> {
                Ok(HighlightQuadParams {
                    quad: self.quad.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(quad))
                    })?,
                    color: self.color,
                    outline_color: self.outline_color,
                })
            }
        }
        impl HighlightQuadParams {
            pub const IDENTIFIER: &'static str = "Overlay.highlightQuad";
        }
        impl chromiumoxide_types::Method for HighlightQuadParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for HighlightQuadParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Highlights given quad. Coordinates are absolute with respect to the main frame viewport.\n[highlightQuad](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-highlightQuad)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HighlightQuadReturns {}
        impl chromiumoxide_types::Command for HighlightQuadParams {
            type Response = HighlightQuadReturns;
        }
        #[doc = "Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.\n[highlightRect](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-highlightRect)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct HighlightRectParams {
            #[doc = "X coordinate"]
            #[serde(rename = "x")]
            pub x: i64,
            #[doc = "Y coordinate"]
            #[serde(rename = "y")]
            pub y: i64,
            #[doc = "Rectangle width"]
            #[serde(rename = "width")]
            pub width: i64,
            #[doc = "Rectangle height"]
            #[serde(rename = "height")]
            pub height: i64,
            #[doc = "The highlight fill color (default: transparent)."]
            #[serde(rename = "color")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub color: Option<super::dom::Rgba>,
            #[doc = "The highlight outline color (default: transparent)."]
            #[serde(rename = "outlineColor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub outline_color: Option<super::dom::Rgba>,
        }
        impl HighlightRectParams {
            pub fn new(
                x: impl Into<i64>,
                y: impl Into<i64>,
                width: impl Into<i64>,
                height: impl Into<i64>,
            ) -> Self {
                Self {
                    x: x.into(),
                    y: y.into(),
                    width: width.into(),
                    height: height.into(),
                    color: None,
                    outline_color: None,
                }
            }
        }
        impl HighlightRectParams {
            pub fn builder() -> HighlightRectParamsBuilder {
                HighlightRectParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct HighlightRectParamsBuilder {
            x: Option<i64>,
            y: Option<i64>,
            width: Option<i64>,
            height: Option<i64>,
            color: Option<super::dom::Rgba>,
            outline_color: Option<super::dom::Rgba>,
        }
        impl HighlightRectParamsBuilder {
            pub fn x(mut self, x: impl Into<i64>) -> Self {
                self.x = Some(x.into());
                self
            }
            pub fn y(mut self, y: impl Into<i64>) -> Self {
                self.y = Some(y.into());
                self
            }
            pub fn width(mut self, width: impl Into<i64>) -> Self {
                self.width = Some(width.into());
                self
            }
            pub fn height(mut self, height: impl Into<i64>) -> Self {
                self.height = Some(height.into());
                self
            }
            pub fn color(mut self, color: impl Into<super::dom::Rgba>) -> Self {
                self.color = Some(color.into());
                self
            }
            pub fn outline_color(mut self, outline_color: impl Into<super::dom::Rgba>) -> Self {
                self.outline_color = Some(outline_color.into());
                self
            }
            pub fn build(self) -> Result<HighlightRectParams, String> {
                Ok(HighlightRectParams {
                    x: self
                        .x
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(x)))?,
                    y: self
                        .y
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(y)))?,
                    width: self.width.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(width))
                    })?,
                    height: self.height.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(height))
                    })?,
                    color: self.color,
                    outline_color: self.outline_color,
                })
            }
        }
        impl HighlightRectParams {
            pub const IDENTIFIER: &'static str = "Overlay.highlightRect";
        }
        impl chromiumoxide_types::Method for HighlightRectParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for HighlightRectParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.\n[highlightRect](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-highlightRect)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HighlightRectReturns {}
        impl chromiumoxide_types::Command for HighlightRectParams {
            type Response = HighlightRectReturns;
        }
        #[doc = "Highlights the source order of the children of the DOM node with given id or with the given\nJavaScript object wrapper. Either nodeId or objectId must be specified.\n[highlightSourceOrder](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-highlightSourceOrder)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct HighlightSourceOrderParams {
            #[doc = "A descriptor for the appearance of the overlay drawing."]
            #[serde(rename = "sourceOrderConfig")]
            pub source_order_config: SourceOrderConfig,
            #[doc = "Identifier of the node to highlight."]
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<super::dom::NodeId>,
            #[doc = "Identifier of the backend node to highlight."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<super::dom::BackendNodeId>,
            #[doc = "JavaScript object id of the node to be highlighted."]
            #[serde(rename = "objectId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl HighlightSourceOrderParams {
            pub fn new(source_order_config: impl Into<SourceOrderConfig>) -> Self {
                Self {
                    source_order_config: source_order_config.into(),
                    node_id: None,
                    backend_node_id: None,
                    object_id: None,
                }
            }
        }
        impl HighlightSourceOrderParams {
            pub fn builder() -> HighlightSourceOrderParamsBuilder {
                HighlightSourceOrderParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct HighlightSourceOrderParamsBuilder {
            source_order_config: Option<SourceOrderConfig>,
            node_id: Option<super::dom::NodeId>,
            backend_node_id: Option<super::dom::BackendNodeId>,
            object_id: Option<super::super::js_protocol::runtime::RemoteObjectId>,
        }
        impl HighlightSourceOrderParamsBuilder {
            pub fn source_order_config(
                mut self,
                source_order_config: impl Into<SourceOrderConfig>,
            ) -> Self {
                self.source_order_config = Some(source_order_config.into());
                self
            }
            pub fn node_id(mut self, node_id: impl Into<super::dom::NodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn backend_node_id(
                mut self,
                backend_node_id: impl Into<super::dom::BackendNodeId>,
            ) -> Self {
                self.backend_node_id = Some(backend_node_id.into());
                self
            }
            pub fn object_id(
                mut self,
                object_id: impl Into<super::super::js_protocol::runtime::RemoteObjectId>,
            ) -> Self {
                self.object_id = Some(object_id.into());
                self
            }
            pub fn build(self) -> Result<HighlightSourceOrderParams, String> {
                Ok(HighlightSourceOrderParams {
                    source_order_config: self.source_order_config.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(source_order_config)
                        )
                    })?,
                    node_id: self.node_id,
                    backend_node_id: self.backend_node_id,
                    object_id: self.object_id,
                })
            }
        }
        impl HighlightSourceOrderParams {
            pub const IDENTIFIER: &'static str = "Overlay.highlightSourceOrder";
        }
        impl chromiumoxide_types::Method for HighlightSourceOrderParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for HighlightSourceOrderParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Highlights the source order of the children of the DOM node with given id or with the given\nJavaScript object wrapper. Either nodeId or objectId must be specified.\n[highlightSourceOrder](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-highlightSourceOrder)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HighlightSourceOrderReturns {}
        impl chromiumoxide_types::Command for HighlightSourceOrderParams {
            type Response = HighlightSourceOrderReturns;
        }
        #[doc = "Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.\nBackend then generates 'inspectNodeRequested' event upon element selection.\n[setInspectMode](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setInspectMode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetInspectModeParams {
            #[doc = "Set an inspection mode."]
            #[serde(rename = "mode")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub mode: InspectMode,
            #[doc = "A descriptor for the highlight appearance of hovered-over nodes. May be omitted if `enabled\n== false`."]
            #[serde(rename = "highlightConfig")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub highlight_config: Option<HighlightConfig>,
        }
        impl SetInspectModeParams {
            pub fn new(mode: impl Into<InspectMode>) -> Self {
                Self {
                    mode: mode.into(),
                    highlight_config: None,
                }
            }
        }
        impl SetInspectModeParams {
            pub fn builder() -> SetInspectModeParamsBuilder {
                SetInspectModeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetInspectModeParamsBuilder {
            mode: Option<InspectMode>,
            highlight_config: Option<HighlightConfig>,
        }
        impl SetInspectModeParamsBuilder {
            pub fn mode(mut self, mode: impl Into<InspectMode>) -> Self {
                self.mode = Some(mode.into());
                self
            }
            pub fn highlight_config(
                mut self,
                highlight_config: impl Into<HighlightConfig>,
            ) -> Self {
                self.highlight_config = Some(highlight_config.into());
                self
            }
            pub fn build(self) -> Result<SetInspectModeParams, String> {
                Ok(SetInspectModeParams {
                    mode: self.mode.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(mode))
                    })?,
                    highlight_config: self.highlight_config,
                })
            }
        }
        impl SetInspectModeParams {
            pub const IDENTIFIER: &'static str = "Overlay.setInspectMode";
        }
        impl chromiumoxide_types::Method for SetInspectModeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetInspectModeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.\nBackend then generates 'inspectNodeRequested' event upon element selection.\n[setInspectMode](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setInspectMode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetInspectModeReturns {}
        impl chromiumoxide_types::Command for SetInspectModeParams {
            type Response = SetInspectModeReturns;
        }
        #[doc = "Highlights owner element of all frames detected to be ads.\n[setShowAdHighlights](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowAdHighlights)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetShowAdHighlightsParams {
            #[doc = "True for showing ad highlights"]
            #[serde(rename = "show")]
            pub show: bool,
        }
        impl SetShowAdHighlightsParams {
            pub fn new(show: impl Into<bool>) -> Self {
                Self { show: show.into() }
            }
        }
        impl SetShowAdHighlightsParams {
            pub fn builder() -> SetShowAdHighlightsParamsBuilder {
                SetShowAdHighlightsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowAdHighlightsParamsBuilder {
            show: Option<bool>,
        }
        impl SetShowAdHighlightsParamsBuilder {
            pub fn show(mut self, show: impl Into<bool>) -> Self {
                self.show = Some(show.into());
                self
            }
            pub fn build(self) -> Result<SetShowAdHighlightsParams, String> {
                Ok(SetShowAdHighlightsParams {
                    show: self.show.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(show))
                    })?,
                })
            }
        }
        impl SetShowAdHighlightsParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowAdHighlights";
        }
        impl chromiumoxide_types::Method for SetShowAdHighlightsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowAdHighlightsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Highlights owner element of all frames detected to be ads.\n[setShowAdHighlights](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowAdHighlights)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowAdHighlightsReturns {}
        impl chromiumoxide_types::Command for SetShowAdHighlightsParams {
            type Response = SetShowAdHighlightsReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetPausedInDebuggerMessageParams {
            #[doc = "The message to display, also triggers resume and step over controls."]
            #[serde(rename = "message")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub message: Option<String>,
        }
        impl SetPausedInDebuggerMessageParams {
            pub fn builder() -> SetPausedInDebuggerMessageParamsBuilder {
                SetPausedInDebuggerMessageParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetPausedInDebuggerMessageParamsBuilder {
            message: Option<String>,
        }
        impl SetPausedInDebuggerMessageParamsBuilder {
            pub fn message(mut self, message: impl Into<String>) -> Self {
                self.message = Some(message.into());
                self
            }
            pub fn build(self) -> SetPausedInDebuggerMessageParams {
                SetPausedInDebuggerMessageParams {
                    message: self.message,
                }
            }
        }
        impl SetPausedInDebuggerMessageParams {
            pub const IDENTIFIER: &'static str = "Overlay.setPausedInDebuggerMessage";
        }
        impl chromiumoxide_types::Method for SetPausedInDebuggerMessageParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetPausedInDebuggerMessageParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetPausedInDebuggerMessageReturns {}
        impl chromiumoxide_types::Command for SetPausedInDebuggerMessageParams {
            type Response = SetPausedInDebuggerMessageReturns;
        }
        #[doc = "Requests that backend shows debug borders on layers\n[setShowDebugBorders](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowDebugBorders)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetShowDebugBordersParams {
            #[doc = "True for showing debug borders"]
            #[serde(rename = "show")]
            pub show: bool,
        }
        impl SetShowDebugBordersParams {
            pub fn new(show: impl Into<bool>) -> Self {
                Self { show: show.into() }
            }
        }
        impl SetShowDebugBordersParams {
            pub fn builder() -> SetShowDebugBordersParamsBuilder {
                SetShowDebugBordersParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowDebugBordersParamsBuilder {
            show: Option<bool>,
        }
        impl SetShowDebugBordersParamsBuilder {
            pub fn show(mut self, show: impl Into<bool>) -> Self {
                self.show = Some(show.into());
                self
            }
            pub fn build(self) -> Result<SetShowDebugBordersParams, String> {
                Ok(SetShowDebugBordersParams {
                    show: self.show.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(show))
                    })?,
                })
            }
        }
        impl SetShowDebugBordersParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowDebugBorders";
        }
        impl chromiumoxide_types::Method for SetShowDebugBordersParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowDebugBordersParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests that backend shows debug borders on layers\n[setShowDebugBorders](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowDebugBorders)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowDebugBordersReturns {}
        impl chromiumoxide_types::Command for SetShowDebugBordersParams {
            type Response = SetShowDebugBordersReturns;
        }
        #[doc = "Requests that backend shows the FPS counter\n[setShowFPSCounter](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowFPSCounter)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetShowFpsCounterParams {
            #[doc = "True for showing the FPS counter"]
            #[serde(rename = "show")]
            pub show: bool,
        }
        impl SetShowFpsCounterParams {
            pub fn new(show: impl Into<bool>) -> Self {
                Self { show: show.into() }
            }
        }
        impl SetShowFpsCounterParams {
            pub fn builder() -> SetShowFpsCounterParamsBuilder {
                SetShowFpsCounterParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowFpsCounterParamsBuilder {
            show: Option<bool>,
        }
        impl SetShowFpsCounterParamsBuilder {
            pub fn show(mut self, show: impl Into<bool>) -> Self {
                self.show = Some(show.into());
                self
            }
            pub fn build(self) -> Result<SetShowFpsCounterParams, String> {
                Ok(SetShowFpsCounterParams {
                    show: self.show.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(show))
                    })?,
                })
            }
        }
        impl SetShowFpsCounterParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowFPSCounter";
        }
        impl chromiumoxide_types::Method for SetShowFpsCounterParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowFpsCounterParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests that backend shows the FPS counter\n[setShowFPSCounter](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowFPSCounter)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowFpsCounterReturns {}
        impl chromiumoxide_types::Command for SetShowFpsCounterParams {
            type Response = SetShowFpsCounterReturns;
        }
        #[doc = "Highlight multiple elements with the CSS Grid overlay.\n[setShowGridOverlays](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowGridOverlays)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetShowGridOverlaysParams {
            #[doc = "An array of node identifiers and descriptors for the highlight appearance."]
            #[serde(rename = "gridNodeHighlightConfigs")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub grid_node_highlight_configs: Vec<GridNodeHighlightConfig>,
        }
        impl SetShowGridOverlaysParams {
            pub fn new(grid_node_highlight_configs: Vec<GridNodeHighlightConfig>) -> Self {
                Self {
                    grid_node_highlight_configs,
                }
            }
        }
        impl SetShowGridOverlaysParams {
            pub fn builder() -> SetShowGridOverlaysParamsBuilder {
                SetShowGridOverlaysParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowGridOverlaysParamsBuilder {
            grid_node_highlight_configs: Option<Vec<GridNodeHighlightConfig>>,
        }
        impl SetShowGridOverlaysParamsBuilder {
            pub fn grid_node_highlight_config(
                mut self,
                grid_node_highlight_config: impl Into<GridNodeHighlightConfig>,
            ) -> Self {
                let v = self.grid_node_highlight_configs.get_or_insert(Vec::new());
                v.push(grid_node_highlight_config.into());
                self
            }
            pub fn grid_node_highlight_configs<I, S>(
                mut self,
                grid_node_highlight_configs: I,
            ) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<GridNodeHighlightConfig>,
            {
                let v = self.grid_node_highlight_configs.get_or_insert(Vec::new());
                for val in grid_node_highlight_configs {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetShowGridOverlaysParams, String> {
                Ok(SetShowGridOverlaysParams {
                    grid_node_highlight_configs: self.grid_node_highlight_configs.ok_or_else(
                        || {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(grid_node_highlight_configs)
                            )
                        },
                    )?,
                })
            }
        }
        impl SetShowGridOverlaysParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowGridOverlays";
        }
        impl chromiumoxide_types::Method for SetShowGridOverlaysParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowGridOverlaysParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Highlight multiple elements with the CSS Grid overlay.\n[setShowGridOverlays](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowGridOverlays)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowGridOverlaysReturns {}
        impl chromiumoxide_types::Command for SetShowGridOverlaysParams {
            type Response = SetShowGridOverlaysReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetShowFlexOverlaysParams {
            #[doc = "An array of node identifiers and descriptors for the highlight appearance."]
            #[serde(rename = "flexNodeHighlightConfigs")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub flex_node_highlight_configs: Vec<FlexNodeHighlightConfig>,
        }
        impl SetShowFlexOverlaysParams {
            pub fn new(flex_node_highlight_configs: Vec<FlexNodeHighlightConfig>) -> Self {
                Self {
                    flex_node_highlight_configs,
                }
            }
        }
        impl SetShowFlexOverlaysParams {
            pub fn builder() -> SetShowFlexOverlaysParamsBuilder {
                SetShowFlexOverlaysParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowFlexOverlaysParamsBuilder {
            flex_node_highlight_configs: Option<Vec<FlexNodeHighlightConfig>>,
        }
        impl SetShowFlexOverlaysParamsBuilder {
            pub fn flex_node_highlight_config(
                mut self,
                flex_node_highlight_config: impl Into<FlexNodeHighlightConfig>,
            ) -> Self {
                let v = self.flex_node_highlight_configs.get_or_insert(Vec::new());
                v.push(flex_node_highlight_config.into());
                self
            }
            pub fn flex_node_highlight_configs<I, S>(
                mut self,
                flex_node_highlight_configs: I,
            ) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<FlexNodeHighlightConfig>,
            {
                let v = self.flex_node_highlight_configs.get_or_insert(Vec::new());
                for val in flex_node_highlight_configs {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetShowFlexOverlaysParams, String> {
                Ok(SetShowFlexOverlaysParams {
                    flex_node_highlight_configs: self.flex_node_highlight_configs.ok_or_else(
                        || {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(flex_node_highlight_configs)
                            )
                        },
                    )?,
                })
            }
        }
        impl SetShowFlexOverlaysParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowFlexOverlays";
        }
        impl chromiumoxide_types::Method for SetShowFlexOverlaysParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowFlexOverlaysParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowFlexOverlaysReturns {}
        impl chromiumoxide_types::Command for SetShowFlexOverlaysParams {
            type Response = SetShowFlexOverlaysReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetShowScrollSnapOverlaysParams {
            #[doc = "An array of node identifiers and descriptors for the highlight appearance."]
            #[serde(rename = "scrollSnapHighlightConfigs")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub scroll_snap_highlight_configs: Vec<ScrollSnapHighlightConfig>,
        }
        impl SetShowScrollSnapOverlaysParams {
            pub fn new(scroll_snap_highlight_configs: Vec<ScrollSnapHighlightConfig>) -> Self {
                Self {
                    scroll_snap_highlight_configs,
                }
            }
        }
        impl SetShowScrollSnapOverlaysParams {
            pub fn builder() -> SetShowScrollSnapOverlaysParamsBuilder {
                SetShowScrollSnapOverlaysParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowScrollSnapOverlaysParamsBuilder {
            scroll_snap_highlight_configs: Option<Vec<ScrollSnapHighlightConfig>>,
        }
        impl SetShowScrollSnapOverlaysParamsBuilder {
            pub fn scroll_snap_highlight_config(
                mut self,
                scroll_snap_highlight_config: impl Into<ScrollSnapHighlightConfig>,
            ) -> Self {
                let v = self.scroll_snap_highlight_configs.get_or_insert(Vec::new());
                v.push(scroll_snap_highlight_config.into());
                self
            }
            pub fn scroll_snap_highlight_configs<I, S>(
                mut self,
                scroll_snap_highlight_configs: I,
            ) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ScrollSnapHighlightConfig>,
            {
                let v = self.scroll_snap_highlight_configs.get_or_insert(Vec::new());
                for val in scroll_snap_highlight_configs {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetShowScrollSnapOverlaysParams, String> {
                Ok(SetShowScrollSnapOverlaysParams {
                    scroll_snap_highlight_configs: self.scroll_snap_highlight_configs.ok_or_else(
                        || {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(scroll_snap_highlight_configs)
                            )
                        },
                    )?,
                })
            }
        }
        impl SetShowScrollSnapOverlaysParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowScrollSnapOverlays";
        }
        impl chromiumoxide_types::Method for SetShowScrollSnapOverlaysParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowScrollSnapOverlaysParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowScrollSnapOverlaysReturns {}
        impl chromiumoxide_types::Command for SetShowScrollSnapOverlaysParams {
            type Response = SetShowScrollSnapOverlaysReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetShowContainerQueryOverlaysParams {
            #[doc = "An array of node identifiers and descriptors for the highlight appearance."]
            #[serde(rename = "containerQueryHighlightConfigs")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub container_query_highlight_configs: Vec<ContainerQueryHighlightConfig>,
        }
        impl SetShowContainerQueryOverlaysParams {
            pub fn new(
                container_query_highlight_configs: Vec<ContainerQueryHighlightConfig>,
            ) -> Self {
                Self {
                    container_query_highlight_configs,
                }
            }
        }
        impl SetShowContainerQueryOverlaysParams {
            pub fn builder() -> SetShowContainerQueryOverlaysParamsBuilder {
                SetShowContainerQueryOverlaysParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowContainerQueryOverlaysParamsBuilder {
            container_query_highlight_configs: Option<Vec<ContainerQueryHighlightConfig>>,
        }
        impl SetShowContainerQueryOverlaysParamsBuilder {
            pub fn container_query_highlight_config(
                mut self,
                container_query_highlight_config: impl Into<ContainerQueryHighlightConfig>,
            ) -> Self {
                let v = self
                    .container_query_highlight_configs
                    .get_or_insert(Vec::new());
                v.push(container_query_highlight_config.into());
                self
            }
            pub fn container_query_highlight_configs<I, S>(
                mut self,
                container_query_highlight_configs: I,
            ) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ContainerQueryHighlightConfig>,
            {
                let v = self
                    .container_query_highlight_configs
                    .get_or_insert(Vec::new());
                for val in container_query_highlight_configs {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetShowContainerQueryOverlaysParams, String> {
                Ok(SetShowContainerQueryOverlaysParams {
                    container_query_highlight_configs: self
                        .container_query_highlight_configs
                        .ok_or_else(|| {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(container_query_highlight_configs)
                            )
                        })?,
                })
            }
        }
        impl SetShowContainerQueryOverlaysParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowContainerQueryOverlays";
        }
        impl chromiumoxide_types::Method for SetShowContainerQueryOverlaysParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowContainerQueryOverlaysParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowContainerQueryOverlaysReturns {}
        impl chromiumoxide_types::Command for SetShowContainerQueryOverlaysParams {
            type Response = SetShowContainerQueryOverlaysReturns;
        }
        #[doc = "Requests that backend shows paint rectangles\n[setShowPaintRects](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowPaintRects)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetShowPaintRectsParams {
            #[doc = "True for showing paint rectangles"]
            #[serde(rename = "result")]
            pub result: bool,
        }
        impl SetShowPaintRectsParams {
            pub fn new(result: impl Into<bool>) -> Self {
                Self {
                    result: result.into(),
                }
            }
        }
        impl SetShowPaintRectsParams {
            pub fn builder() -> SetShowPaintRectsParamsBuilder {
                SetShowPaintRectsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowPaintRectsParamsBuilder {
            result: Option<bool>,
        }
        impl SetShowPaintRectsParamsBuilder {
            pub fn result(mut self, result: impl Into<bool>) -> Self {
                self.result = Some(result.into());
                self
            }
            pub fn build(self) -> Result<SetShowPaintRectsParams, String> {
                Ok(SetShowPaintRectsParams {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                })
            }
        }
        impl SetShowPaintRectsParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowPaintRects";
        }
        impl chromiumoxide_types::Method for SetShowPaintRectsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowPaintRectsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests that backend shows paint rectangles\n[setShowPaintRects](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowPaintRects)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowPaintRectsReturns {}
        impl chromiumoxide_types::Command for SetShowPaintRectsParams {
            type Response = SetShowPaintRectsReturns;
        }
        #[doc = "Requests that backend shows layout shift regions\n[setShowLayoutShiftRegions](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowLayoutShiftRegions)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetShowLayoutShiftRegionsParams {
            #[doc = "True for showing layout shift regions"]
            #[serde(rename = "result")]
            pub result: bool,
        }
        impl SetShowLayoutShiftRegionsParams {
            pub fn new(result: impl Into<bool>) -> Self {
                Self {
                    result: result.into(),
                }
            }
        }
        impl SetShowLayoutShiftRegionsParams {
            pub fn builder() -> SetShowLayoutShiftRegionsParamsBuilder {
                SetShowLayoutShiftRegionsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowLayoutShiftRegionsParamsBuilder {
            result: Option<bool>,
        }
        impl SetShowLayoutShiftRegionsParamsBuilder {
            pub fn result(mut self, result: impl Into<bool>) -> Self {
                self.result = Some(result.into());
                self
            }
            pub fn build(self) -> Result<SetShowLayoutShiftRegionsParams, String> {
                Ok(SetShowLayoutShiftRegionsParams {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                })
            }
        }
        impl SetShowLayoutShiftRegionsParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowLayoutShiftRegions";
        }
        impl chromiumoxide_types::Method for SetShowLayoutShiftRegionsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowLayoutShiftRegionsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests that backend shows layout shift regions\n[setShowLayoutShiftRegions](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowLayoutShiftRegions)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowLayoutShiftRegionsReturns {}
        impl chromiumoxide_types::Command for SetShowLayoutShiftRegionsParams {
            type Response = SetShowLayoutShiftRegionsReturns;
        }
        #[doc = "Requests that backend shows scroll bottleneck rects\n[setShowScrollBottleneckRects](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowScrollBottleneckRects)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetShowScrollBottleneckRectsParams {
            #[doc = "True for showing scroll bottleneck rects"]
            #[serde(rename = "show")]
            pub show: bool,
        }
        impl SetShowScrollBottleneckRectsParams {
            pub fn new(show: impl Into<bool>) -> Self {
                Self { show: show.into() }
            }
        }
        impl SetShowScrollBottleneckRectsParams {
            pub fn builder() -> SetShowScrollBottleneckRectsParamsBuilder {
                SetShowScrollBottleneckRectsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowScrollBottleneckRectsParamsBuilder {
            show: Option<bool>,
        }
        impl SetShowScrollBottleneckRectsParamsBuilder {
            pub fn show(mut self, show: impl Into<bool>) -> Self {
                self.show = Some(show.into());
                self
            }
            pub fn build(self) -> Result<SetShowScrollBottleneckRectsParams, String> {
                Ok(SetShowScrollBottleneckRectsParams {
                    show: self.show.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(show))
                    })?,
                })
            }
        }
        impl SetShowScrollBottleneckRectsParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowScrollBottleneckRects";
        }
        impl chromiumoxide_types::Method for SetShowScrollBottleneckRectsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowScrollBottleneckRectsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests that backend shows scroll bottleneck rects\n[setShowScrollBottleneckRects](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowScrollBottleneckRects)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowScrollBottleneckRectsReturns {}
        impl chromiumoxide_types::Command for SetShowScrollBottleneckRectsParams {
            type Response = SetShowScrollBottleneckRectsReturns;
        }
        #[doc = "Request that backend shows an overlay with web vital metrics.\n[setShowWebVitals](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowWebVitals)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetShowWebVitalsParams {
            #[serde(rename = "show")]
            pub show: bool,
        }
        impl SetShowWebVitalsParams {
            pub fn new(show: impl Into<bool>) -> Self {
                Self { show: show.into() }
            }
        }
        impl SetShowWebVitalsParams {
            pub fn builder() -> SetShowWebVitalsParamsBuilder {
                SetShowWebVitalsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowWebVitalsParamsBuilder {
            show: Option<bool>,
        }
        impl SetShowWebVitalsParamsBuilder {
            pub fn show(mut self, show: impl Into<bool>) -> Self {
                self.show = Some(show.into());
                self
            }
            pub fn build(self) -> Result<SetShowWebVitalsParams, String> {
                Ok(SetShowWebVitalsParams {
                    show: self.show.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(show))
                    })?,
                })
            }
        }
        impl SetShowWebVitalsParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowWebVitals";
        }
        impl chromiumoxide_types::Method for SetShowWebVitalsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowWebVitalsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Request that backend shows an overlay with web vital metrics.\n[setShowWebVitals](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowWebVitals)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowWebVitalsReturns {}
        impl chromiumoxide_types::Command for SetShowWebVitalsParams {
            type Response = SetShowWebVitalsReturns;
        }
        #[doc = "Paints viewport size upon main frame resize.\n[setShowViewportSizeOnResize](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowViewportSizeOnResize)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetShowViewportSizeOnResizeParams {
            #[doc = "Whether to paint size or not."]
            #[serde(rename = "show")]
            pub show: bool,
        }
        impl SetShowViewportSizeOnResizeParams {
            pub fn new(show: impl Into<bool>) -> Self {
                Self { show: show.into() }
            }
        }
        impl SetShowViewportSizeOnResizeParams {
            pub fn builder() -> SetShowViewportSizeOnResizeParamsBuilder {
                SetShowViewportSizeOnResizeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowViewportSizeOnResizeParamsBuilder {
            show: Option<bool>,
        }
        impl SetShowViewportSizeOnResizeParamsBuilder {
            pub fn show(mut self, show: impl Into<bool>) -> Self {
                self.show = Some(show.into());
                self
            }
            pub fn build(self) -> Result<SetShowViewportSizeOnResizeParams, String> {
                Ok(SetShowViewportSizeOnResizeParams {
                    show: self.show.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(show))
                    })?,
                })
            }
        }
        impl SetShowViewportSizeOnResizeParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowViewportSizeOnResize";
        }
        impl chromiumoxide_types::Method for SetShowViewportSizeOnResizeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowViewportSizeOnResizeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Paints viewport size upon main frame resize.\n[setShowViewportSizeOnResize](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowViewportSizeOnResize)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowViewportSizeOnResizeReturns {}
        impl chromiumoxide_types::Command for SetShowViewportSizeOnResizeParams {
            type Response = SetShowViewportSizeOnResizeReturns;
        }
        #[doc = "Add a dual screen device hinge\n[setShowHinge](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowHinge)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowHingeParams {
            #[doc = "hinge data, null means hideHinge"]
            #[serde(rename = "hingeConfig")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub hinge_config: Option<HingeConfig>,
        }
        impl SetShowHingeParams {
            pub fn builder() -> SetShowHingeParamsBuilder {
                SetShowHingeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowHingeParamsBuilder {
            hinge_config: Option<HingeConfig>,
        }
        impl SetShowHingeParamsBuilder {
            pub fn hinge_config(mut self, hinge_config: impl Into<HingeConfig>) -> Self {
                self.hinge_config = Some(hinge_config.into());
                self
            }
            pub fn build(self) -> SetShowHingeParams {
                SetShowHingeParams {
                    hinge_config: self.hinge_config,
                }
            }
        }
        impl SetShowHingeParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowHinge";
        }
        impl chromiumoxide_types::Method for SetShowHingeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowHingeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Add a dual screen device hinge\n[setShowHinge](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowHinge)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowHingeReturns {}
        impl chromiumoxide_types::Command for SetShowHingeParams {
            type Response = SetShowHingeReturns;
        }
        #[doc = "Show elements in isolation mode with overlays.\n[setShowIsolatedElements](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowIsolatedElements)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetShowIsolatedElementsParams {
            #[doc = "An array of node identifiers and descriptors for the highlight appearance."]
            #[serde(rename = "isolatedElementHighlightConfigs")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub isolated_element_highlight_configs: Vec<IsolatedElementHighlightConfig>,
        }
        impl SetShowIsolatedElementsParams {
            pub fn new(
                isolated_element_highlight_configs: Vec<IsolatedElementHighlightConfig>,
            ) -> Self {
                Self {
                    isolated_element_highlight_configs,
                }
            }
        }
        impl SetShowIsolatedElementsParams {
            pub fn builder() -> SetShowIsolatedElementsParamsBuilder {
                SetShowIsolatedElementsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetShowIsolatedElementsParamsBuilder {
            isolated_element_highlight_configs: Option<Vec<IsolatedElementHighlightConfig>>,
        }
        impl SetShowIsolatedElementsParamsBuilder {
            pub fn isolated_element_highlight_config(
                mut self,
                isolated_element_highlight_config: impl Into<IsolatedElementHighlightConfig>,
            ) -> Self {
                let v = self
                    .isolated_element_highlight_configs
                    .get_or_insert(Vec::new());
                v.push(isolated_element_highlight_config.into());
                self
            }
            pub fn isolated_element_highlight_configs<I, S>(
                mut self,
                isolated_element_highlight_configs: I,
            ) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<IsolatedElementHighlightConfig>,
            {
                let v = self
                    .isolated_element_highlight_configs
                    .get_or_insert(Vec::new());
                for val in isolated_element_highlight_configs {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetShowIsolatedElementsParams, String> {
                Ok(SetShowIsolatedElementsParams {
                    isolated_element_highlight_configs: self
                        .isolated_element_highlight_configs
                        .ok_or_else(|| {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(isolated_element_highlight_configs)
                            )
                        })?,
                })
            }
        }
        impl SetShowIsolatedElementsParams {
            pub const IDENTIFIER: &'static str = "Overlay.setShowIsolatedElements";
        }
        impl chromiumoxide_types::Method for SetShowIsolatedElementsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetShowIsolatedElementsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Show elements in isolation mode with overlays.\n[setShowIsolatedElements](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowIsolatedElements)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetShowIsolatedElementsReturns {}
        impl chromiumoxide_types::Command for SetShowIsolatedElementsParams {
            type Response = SetShowIsolatedElementsReturns;
        }
        #[doc = "Fired when the node should be inspected. This happens after call to `setInspectMode` or when\nuser manually inspects an element.\n[inspectNodeRequested](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#event-inspectNodeRequested)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventInspectNodeRequested {
            #[doc = "Id of the node to inspect."]
            #[serde(rename = "backendNodeId")]
            pub backend_node_id: super::dom::BackendNodeId,
        }
        impl EventInspectNodeRequested {
            pub const IDENTIFIER: &'static str = "Overlay.inspectNodeRequested";
        }
        impl chromiumoxide_types::Method for EventInspectNodeRequested {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventInspectNodeRequested {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when the node should be highlighted. This happens after call to `setInspectMode`.\n[nodeHighlightRequested](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#event-nodeHighlightRequested)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventNodeHighlightRequested {
            #[serde(rename = "nodeId")]
            pub node_id: super::dom::NodeId,
        }
        impl EventNodeHighlightRequested {
            pub const IDENTIFIER: &'static str = "Overlay.nodeHighlightRequested";
        }
        impl chromiumoxide_types::Method for EventNodeHighlightRequested {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventNodeHighlightRequested {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when user asks to capture screenshot of some area on the page.\n[screenshotRequested](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#event-screenshotRequested)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventScreenshotRequested {
            #[doc = "Viewport to capture, in device independent pixels (dip)."]
            #[serde(rename = "viewport")]
            pub viewport: super::page::Viewport,
        }
        impl EventScreenshotRequested {
            pub const IDENTIFIER: &'static str = "Overlay.screenshotRequested";
        }
        impl chromiumoxide_types::Method for EventScreenshotRequested {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventScreenshotRequested {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when user cancels the inspect mode.\n[inspectModeCanceled](https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#event-inspectModeCanceled)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventInspectModeCanceled {}
        impl EventInspectModeCanceled {
            pub const IDENTIFIER: &'static str = "Overlay.inspectModeCanceled";
        }
        impl chromiumoxide_types::Method for EventInspectModeCanceled {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventInspectModeCanceled {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "Actions and events related to the inspected page belong to the page domain."]
    pub mod page {
        use serde::{Deserialize, Serialize};
        #[doc = "Unique frame identifier.\n[FrameId](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-FrameId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct FrameId(String);
        impl FrameId {
            pub fn new(val: impl Into<String>) -> Self {
                FrameId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for FrameId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<FrameId> for String {
            fn from(el: FrameId) -> String {
                el.0
            }
        }
        impl From<String> for FrameId {
            fn from(expr: String) -> Self {
                FrameId(expr)
            }
        }
        impl std::borrow::Borrow<str> for FrameId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl FrameId {
            pub const IDENTIFIER: &'static str = "Page.FrameId";
        }
        #[doc = "Indicates whether a frame has been identified as an ad."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AdFrameType {
            #[serde(rename = "none")]
            None,
            #[doc = "This frame is a subframe of an ad frame."]
            #[serde(rename = "child")]
            Child,
            #[doc = "This frame is the root of an ad frame."]
            #[serde(rename = "root")]
            Root,
        }
        impl AsRef<str> for AdFrameType {
            fn as_ref(&self) -> &str {
                match self {
                    AdFrameType::None => "none",
                    AdFrameType::Child => "child",
                    AdFrameType::Root => "root",
                }
            }
        }
        impl ::std::str::FromStr for AdFrameType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "none" | "None" => Ok(AdFrameType::None),
                    "child" | "Child" => Ok(AdFrameType::Child),
                    "root" | "Root" => Ok(AdFrameType::Root),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AdFrameExplanation {
            #[serde(rename = "ParentIsAd")]
            ParentIsAd,
            #[serde(rename = "CreatedByAdScript")]
            CreatedByAdScript,
            #[serde(rename = "MatchedBlockingRule")]
            MatchedBlockingRule,
        }
        impl AsRef<str> for AdFrameExplanation {
            fn as_ref(&self) -> &str {
                match self {
                    AdFrameExplanation::ParentIsAd => "ParentIsAd",
                    AdFrameExplanation::CreatedByAdScript => "CreatedByAdScript",
                    AdFrameExplanation::MatchedBlockingRule => "MatchedBlockingRule",
                }
            }
        }
        impl ::std::str::FromStr for AdFrameExplanation {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "ParentIsAd" | "parentisad" => Ok(AdFrameExplanation::ParentIsAd),
                    "CreatedByAdScript" | "createdbyadscript" => {
                        Ok(AdFrameExplanation::CreatedByAdScript)
                    }
                    "MatchedBlockingRule" | "matchedblockingrule" => {
                        Ok(AdFrameExplanation::MatchedBlockingRule)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Indicates whether a frame has been identified as an ad and why.\n[AdFrameStatus](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-AdFrameStatus)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AdFrameStatus {
            #[serde(rename = "adFrameType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub ad_frame_type: AdFrameType,
            #[serde(rename = "explanations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub explanations: Option<Vec<AdFrameExplanation>>,
        }
        impl AdFrameStatus {
            pub fn new(ad_frame_type: impl Into<AdFrameType>) -> Self {
                Self {
                    ad_frame_type: ad_frame_type.into(),
                    explanations: None,
                }
            }
        }
        impl AdFrameStatus {
            pub fn builder() -> AdFrameStatusBuilder {
                AdFrameStatusBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AdFrameStatusBuilder {
            ad_frame_type: Option<AdFrameType>,
            explanations: Option<Vec<AdFrameExplanation>>,
        }
        impl AdFrameStatusBuilder {
            pub fn ad_frame_type(mut self, ad_frame_type: impl Into<AdFrameType>) -> Self {
                self.ad_frame_type = Some(ad_frame_type.into());
                self
            }
            pub fn explanation(mut self, explanation: impl Into<AdFrameExplanation>) -> Self {
                let v = self.explanations.get_or_insert(Vec::new());
                v.push(explanation.into());
                self
            }
            pub fn explanations<I, S>(mut self, explanations: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<AdFrameExplanation>,
            {
                let v = self.explanations.get_or_insert(Vec::new());
                for val in explanations {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<AdFrameStatus, String> {
                Ok(AdFrameStatus {
                    ad_frame_type: self.ad_frame_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(ad_frame_type))
                    })?,
                    explanations: self.explanations,
                })
            }
        }
        impl AdFrameStatus {
            pub const IDENTIFIER: &'static str = "Page.AdFrameStatus";
        }
        #[doc = "Identifies the bottom-most script which caused the frame to be labelled\nas an ad.\n[AdScriptId](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-AdScriptId)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AdScriptId {
            #[doc = "Script Id of the bottom-most script which caused the frame to be labelled\nas an ad."]
            #[serde(rename = "scriptId")]
            pub script_id: super::super::js_protocol::runtime::ScriptId,
            #[doc = "Id of adScriptId's debugger."]
            #[serde(rename = "debuggerId")]
            pub debugger_id: super::super::js_protocol::runtime::UniqueDebuggerId,
        }
        impl AdScriptId {
            pub fn new(
                script_id: impl Into<super::super::js_protocol::runtime::ScriptId>,
                debugger_id: impl Into<super::super::js_protocol::runtime::UniqueDebuggerId>,
            ) -> Self {
                Self {
                    script_id: script_id.into(),
                    debugger_id: debugger_id.into(),
                }
            }
        }
        impl AdScriptId {
            pub fn builder() -> AdScriptIdBuilder {
                AdScriptIdBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AdScriptIdBuilder {
            script_id: Option<super::super::js_protocol::runtime::ScriptId>,
            debugger_id: Option<super::super::js_protocol::runtime::UniqueDebuggerId>,
        }
        impl AdScriptIdBuilder {
            pub fn script_id(
                mut self,
                script_id: impl Into<super::super::js_protocol::runtime::ScriptId>,
            ) -> Self {
                self.script_id = Some(script_id.into());
                self
            }
            pub fn debugger_id(
                mut self,
                debugger_id: impl Into<super::super::js_protocol::runtime::UniqueDebuggerId>,
            ) -> Self {
                self.debugger_id = Some(debugger_id.into());
                self
            }
            pub fn build(self) -> Result<AdScriptId, String> {
                Ok(AdScriptId {
                    script_id: self.script_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_id))
                    })?,
                    debugger_id: self.debugger_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(debugger_id))
                    })?,
                })
            }
        }
        impl AdScriptId {
            pub const IDENTIFIER: &'static str = "Page.AdScriptId";
        }
        #[doc = "Indicates whether the frame is a secure context and why it is the case."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SecureContextType {
            #[doc = "The origin is a secure context."]
            #[serde(rename = "Secure")]
            Secure,
            #[doc = "The host is localhost and hence is considered secure."]
            #[serde(rename = "SecureLocalhost")]
            SecureLocalhost,
            #[doc = "The origin has an insecure scheme and is not localhost."]
            #[serde(rename = "InsecureScheme")]
            InsecureScheme,
            #[doc = "One of the ancestor frames is not a secure context."]
            #[serde(rename = "InsecureAncestor")]
            InsecureAncestor,
        }
        impl AsRef<str> for SecureContextType {
            fn as_ref(&self) -> &str {
                match self {
                    SecureContextType::Secure => "Secure",
                    SecureContextType::SecureLocalhost => "SecureLocalhost",
                    SecureContextType::InsecureScheme => "InsecureScheme",
                    SecureContextType::InsecureAncestor => "InsecureAncestor",
                }
            }
        }
        impl ::std::str::FromStr for SecureContextType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Secure" | "secure" => Ok(SecureContextType::Secure),
                    "SecureLocalhost" | "securelocalhost" => Ok(SecureContextType::SecureLocalhost),
                    "InsecureScheme" | "insecurescheme" => Ok(SecureContextType::InsecureScheme),
                    "InsecureAncestor" | "insecureancestor" => {
                        Ok(SecureContextType::InsecureAncestor)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Indicates whether the frame is cross-origin isolated and why it is the case."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CrossOriginIsolatedContextType {
            #[doc = "The origin is cross-origin isolated."]
            #[serde(rename = "Isolated")]
            Isolated,
            #[doc = "The origin is not cross-origin isolated."]
            #[serde(rename = "NotIsolated")]
            NotIsolated,
            #[doc = "The cross-origin isolation feature is disabled."]
            #[serde(rename = "NotIsolatedFeatureDisabled")]
            NotIsolatedFeatureDisabled,
        }
        impl AsRef<str> for CrossOriginIsolatedContextType {
            fn as_ref(&self) -> &str {
                match self {
                    CrossOriginIsolatedContextType::Isolated => "Isolated",
                    CrossOriginIsolatedContextType::NotIsolated => "NotIsolated",
                    CrossOriginIsolatedContextType::NotIsolatedFeatureDisabled => {
                        "NotIsolatedFeatureDisabled"
                    }
                }
            }
        }
        impl ::std::str::FromStr for CrossOriginIsolatedContextType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Isolated" | "isolated" => Ok(CrossOriginIsolatedContextType::Isolated),
                    "NotIsolated" | "notisolated" => {
                        Ok(CrossOriginIsolatedContextType::NotIsolated)
                    }
                    "NotIsolatedFeatureDisabled" | "notisolatedfeaturedisabled" => {
                        Ok(CrossOriginIsolatedContextType::NotIsolatedFeatureDisabled)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum GatedApiFeatures {
            #[serde(rename = "SharedArrayBuffers")]
            SharedArrayBuffers,
            #[serde(rename = "SharedArrayBuffersTransferAllowed")]
            SharedArrayBuffersTransferAllowed,
            #[serde(rename = "PerformanceMeasureMemory")]
            PerformanceMeasureMemory,
            #[serde(rename = "PerformanceProfile")]
            PerformanceProfile,
        }
        impl AsRef<str> for GatedApiFeatures {
            fn as_ref(&self) -> &str {
                match self {
                    GatedApiFeatures::SharedArrayBuffers => "SharedArrayBuffers",
                    GatedApiFeatures::SharedArrayBuffersTransferAllowed => {
                        "SharedArrayBuffersTransferAllowed"
                    }
                    GatedApiFeatures::PerformanceMeasureMemory => "PerformanceMeasureMemory",
                    GatedApiFeatures::PerformanceProfile => "PerformanceProfile",
                }
            }
        }
        impl ::std::str::FromStr for GatedApiFeatures {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "SharedArrayBuffers" | "sharedarraybuffers" => {
                        Ok(GatedApiFeatures::SharedArrayBuffers)
                    }
                    "SharedArrayBuffersTransferAllowed" | "sharedarraybufferstransferallowed" => {
                        Ok(GatedApiFeatures::SharedArrayBuffersTransferAllowed)
                    }
                    "PerformanceMeasureMemory" | "performancemeasurememory" => {
                        Ok(GatedApiFeatures::PerformanceMeasureMemory)
                    }
                    "PerformanceProfile" | "performanceprofile" => {
                        Ok(GatedApiFeatures::PerformanceProfile)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "All Permissions Policy features. This enum should match the one defined\nin third_party/blink/renderer/core/permissions_policy/permissions_policy_features.json5."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PermissionsPolicyFeature {
            #[serde(rename = "accelerometer")]
            Accelerometer,
            #[serde(rename = "ambient-light-sensor")]
            AmbientLightSensor,
            #[serde(rename = "attribution-reporting")]
            AttributionReporting,
            #[serde(rename = "autoplay")]
            Autoplay,
            #[serde(rename = "bluetooth")]
            Bluetooth,
            #[serde(rename = "browsing-topics")]
            BrowsingTopics,
            #[serde(rename = "camera")]
            Camera,
            #[serde(rename = "ch-dpr")]
            ChDpr,
            #[serde(rename = "ch-device-memory")]
            ChDeviceMemory,
            #[serde(rename = "ch-downlink")]
            ChDownlink,
            #[serde(rename = "ch-ect")]
            ChEct,
            #[serde(rename = "ch-prefers-color-scheme")]
            ChPrefersColorScheme,
            #[serde(rename = "ch-rtt")]
            ChRtt,
            #[serde(rename = "ch-save-data")]
            ChSaveData,
            #[serde(rename = "ch-ua")]
            ChUa,
            #[serde(rename = "ch-ua-arch")]
            ChUaArch,
            #[serde(rename = "ch-ua-bitness")]
            ChUaBitness,
            #[serde(rename = "ch-ua-platform")]
            ChUaPlatform,
            #[serde(rename = "ch-ua-model")]
            ChUaModel,
            #[serde(rename = "ch-ua-mobile")]
            ChUaMobile,
            #[serde(rename = "ch-ua-full")]
            ChUaFull,
            #[serde(rename = "ch-ua-full-version")]
            ChUaFullVersion,
            #[serde(rename = "ch-ua-full-version-list")]
            ChUaFullVersionList,
            #[serde(rename = "ch-ua-platform-version")]
            ChUaPlatformVersion,
            #[serde(rename = "ch-ua-reduced")]
            ChUaReduced,
            #[serde(rename = "ch-ua-wow64")]
            ChUaWow64,
            #[serde(rename = "ch-viewport-height")]
            ChViewportHeight,
            #[serde(rename = "ch-viewport-width")]
            ChViewportWidth,
            #[serde(rename = "ch-width")]
            ChWidth,
            #[serde(rename = "clipboard-read")]
            ClipboardRead,
            #[serde(rename = "clipboard-write")]
            ClipboardWrite,
            #[serde(rename = "cross-origin-isolated")]
            CrossOriginIsolated,
            #[serde(rename = "direct-sockets")]
            DirectSockets,
            #[serde(rename = "display-capture")]
            DisplayCapture,
            #[serde(rename = "document-domain")]
            DocumentDomain,
            #[serde(rename = "encrypted-media")]
            EncryptedMedia,
            #[serde(rename = "execution-while-out-of-viewport")]
            ExecutionWhileOutOfViewport,
            #[serde(rename = "execution-while-not-rendered")]
            ExecutionWhileNotRendered,
            #[serde(rename = "federated-credentials")]
            FederatedCredentials,
            #[serde(rename = "focus-without-user-activation")]
            FocusWithoutUserActivation,
            #[serde(rename = "fullscreen")]
            Fullscreen,
            #[serde(rename = "frobulate")]
            Frobulate,
            #[serde(rename = "gamepad")]
            Gamepad,
            #[serde(rename = "geolocation")]
            Geolocation,
            #[serde(rename = "gyroscope")]
            Gyroscope,
            #[serde(rename = "hid")]
            Hid,
            #[serde(rename = "idle-detection")]
            IdleDetection,
            #[serde(rename = "interest-cohort")]
            InterestCohort,
            #[serde(rename = "join-ad-interest-group")]
            JoinAdInterestGroup,
            #[serde(rename = "keyboard-map")]
            KeyboardMap,
            #[serde(rename = "local-fonts")]
            LocalFonts,
            #[serde(rename = "magnetometer")]
            Magnetometer,
            #[serde(rename = "microphone")]
            Microphone,
            #[serde(rename = "midi")]
            Midi,
            #[serde(rename = "otp-credentials")]
            OtpCredentials,
            #[serde(rename = "payment")]
            Payment,
            #[serde(rename = "picture-in-picture")]
            PictureInPicture,
            #[serde(rename = "publickey-credentials-get")]
            PublickeyCredentialsGet,
            #[serde(rename = "run-ad-auction")]
            RunAdAuction,
            #[serde(rename = "screen-wake-lock")]
            ScreenWakeLock,
            #[serde(rename = "serial")]
            Serial,
            #[serde(rename = "shared-autofill")]
            SharedAutofill,
            #[serde(rename = "shared-storage")]
            SharedStorage,
            #[serde(rename = "storage-access")]
            StorageAccess,
            #[serde(rename = "sync-xhr")]
            SyncXhr,
            #[serde(rename = "trust-token-redemption")]
            TrustTokenRedemption,
            #[serde(rename = "unload")]
            Unload,
            #[serde(rename = "usb")]
            Usb,
            #[serde(rename = "vertical-scroll")]
            VerticalScroll,
            #[serde(rename = "web-share")]
            WebShare,
            #[serde(rename = "window-placement")]
            WindowPlacement,
            #[serde(rename = "xr-spatial-tracking")]
            XrSpatialTracking,
        }
        impl AsRef<str> for PermissionsPolicyFeature {
            fn as_ref(&self) -> &str {
                match self {
                    PermissionsPolicyFeature::Accelerometer => "accelerometer",
                    PermissionsPolicyFeature::AmbientLightSensor => "ambient-light-sensor",
                    PermissionsPolicyFeature::AttributionReporting => "attribution-reporting",
                    PermissionsPolicyFeature::Autoplay => "autoplay",
                    PermissionsPolicyFeature::Bluetooth => "bluetooth",
                    PermissionsPolicyFeature::BrowsingTopics => "browsing-topics",
                    PermissionsPolicyFeature::Camera => "camera",
                    PermissionsPolicyFeature::ChDpr => "ch-dpr",
                    PermissionsPolicyFeature::ChDeviceMemory => "ch-device-memory",
                    PermissionsPolicyFeature::ChDownlink => "ch-downlink",
                    PermissionsPolicyFeature::ChEct => "ch-ect",
                    PermissionsPolicyFeature::ChPrefersColorScheme => "ch-prefers-color-scheme",
                    PermissionsPolicyFeature::ChRtt => "ch-rtt",
                    PermissionsPolicyFeature::ChSaveData => "ch-save-data",
                    PermissionsPolicyFeature::ChUa => "ch-ua",
                    PermissionsPolicyFeature::ChUaArch => "ch-ua-arch",
                    PermissionsPolicyFeature::ChUaBitness => "ch-ua-bitness",
                    PermissionsPolicyFeature::ChUaPlatform => "ch-ua-platform",
                    PermissionsPolicyFeature::ChUaModel => "ch-ua-model",
                    PermissionsPolicyFeature::ChUaMobile => "ch-ua-mobile",
                    PermissionsPolicyFeature::ChUaFull => "ch-ua-full",
                    PermissionsPolicyFeature::ChUaFullVersion => "ch-ua-full-version",
                    PermissionsPolicyFeature::ChUaFullVersionList => "ch-ua-full-version-list",
                    PermissionsPolicyFeature::ChUaPlatformVersion => "ch-ua-platform-version",
                    PermissionsPolicyFeature::ChUaReduced => "ch-ua-reduced",
                    PermissionsPolicyFeature::ChUaWow64 => "ch-ua-wow64",
                    PermissionsPolicyFeature::ChViewportHeight => "ch-viewport-height",
                    PermissionsPolicyFeature::ChViewportWidth => "ch-viewport-width",
                    PermissionsPolicyFeature::ChWidth => "ch-width",
                    PermissionsPolicyFeature::ClipboardRead => "clipboard-read",
                    PermissionsPolicyFeature::ClipboardWrite => "clipboard-write",
                    PermissionsPolicyFeature::CrossOriginIsolated => "cross-origin-isolated",
                    PermissionsPolicyFeature::DirectSockets => "direct-sockets",
                    PermissionsPolicyFeature::DisplayCapture => "display-capture",
                    PermissionsPolicyFeature::DocumentDomain => "document-domain",
                    PermissionsPolicyFeature::EncryptedMedia => "encrypted-media",
                    PermissionsPolicyFeature::ExecutionWhileOutOfViewport => {
                        "execution-while-out-of-viewport"
                    }
                    PermissionsPolicyFeature::ExecutionWhileNotRendered => {
                        "execution-while-not-rendered"
                    }
                    PermissionsPolicyFeature::FederatedCredentials => "federated-credentials",
                    PermissionsPolicyFeature::FocusWithoutUserActivation => {
                        "focus-without-user-activation"
                    }
                    PermissionsPolicyFeature::Fullscreen => "fullscreen",
                    PermissionsPolicyFeature::Frobulate => "frobulate",
                    PermissionsPolicyFeature::Gamepad => "gamepad",
                    PermissionsPolicyFeature::Geolocation => "geolocation",
                    PermissionsPolicyFeature::Gyroscope => "gyroscope",
                    PermissionsPolicyFeature::Hid => "hid",
                    PermissionsPolicyFeature::IdleDetection => "idle-detection",
                    PermissionsPolicyFeature::InterestCohort => "interest-cohort",
                    PermissionsPolicyFeature::JoinAdInterestGroup => "join-ad-interest-group",
                    PermissionsPolicyFeature::KeyboardMap => "keyboard-map",
                    PermissionsPolicyFeature::LocalFonts => "local-fonts",
                    PermissionsPolicyFeature::Magnetometer => "magnetometer",
                    PermissionsPolicyFeature::Microphone => "microphone",
                    PermissionsPolicyFeature::Midi => "midi",
                    PermissionsPolicyFeature::OtpCredentials => "otp-credentials",
                    PermissionsPolicyFeature::Payment => "payment",
                    PermissionsPolicyFeature::PictureInPicture => "picture-in-picture",
                    PermissionsPolicyFeature::PublickeyCredentialsGet => {
                        "publickey-credentials-get"
                    }
                    PermissionsPolicyFeature::RunAdAuction => "run-ad-auction",
                    PermissionsPolicyFeature::ScreenWakeLock => "screen-wake-lock",
                    PermissionsPolicyFeature::Serial => "serial",
                    PermissionsPolicyFeature::SharedAutofill => "shared-autofill",
                    PermissionsPolicyFeature::SharedStorage => "shared-storage",
                    PermissionsPolicyFeature::StorageAccess => "storage-access",
                    PermissionsPolicyFeature::SyncXhr => "sync-xhr",
                    PermissionsPolicyFeature::TrustTokenRedemption => "trust-token-redemption",
                    PermissionsPolicyFeature::Unload => "unload",
                    PermissionsPolicyFeature::Usb => "usb",
                    PermissionsPolicyFeature::VerticalScroll => "vertical-scroll",
                    PermissionsPolicyFeature::WebShare => "web-share",
                    PermissionsPolicyFeature::WindowPlacement => "window-placement",
                    PermissionsPolicyFeature::XrSpatialTracking => "xr-spatial-tracking",
                }
            }
        }
        impl ::std::str::FromStr for PermissionsPolicyFeature {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "accelerometer" | "Accelerometer" => {
                        Ok(PermissionsPolicyFeature::Accelerometer)
                    }
                    "ambient-light-sensor" | "AmbientLightSensor" => {
                        Ok(PermissionsPolicyFeature::AmbientLightSensor)
                    }
                    "attribution-reporting" | "AttributionReporting" => {
                        Ok(PermissionsPolicyFeature::AttributionReporting)
                    }
                    "autoplay" | "Autoplay" => Ok(PermissionsPolicyFeature::Autoplay),
                    "bluetooth" | "Bluetooth" => Ok(PermissionsPolicyFeature::Bluetooth),
                    "browsing-topics" | "BrowsingTopics" => {
                        Ok(PermissionsPolicyFeature::BrowsingTopics)
                    }
                    "camera" | "Camera" => Ok(PermissionsPolicyFeature::Camera),
                    "ch-dpr" | "ChDpr" => Ok(PermissionsPolicyFeature::ChDpr),
                    "ch-device-memory" | "ChDeviceMemory" => {
                        Ok(PermissionsPolicyFeature::ChDeviceMemory)
                    }
                    "ch-downlink" | "ChDownlink" => Ok(PermissionsPolicyFeature::ChDownlink),
                    "ch-ect" | "ChEct" => Ok(PermissionsPolicyFeature::ChEct),
                    "ch-prefers-color-scheme" | "ChPrefersColorScheme" => {
                        Ok(PermissionsPolicyFeature::ChPrefersColorScheme)
                    }
                    "ch-rtt" | "ChRtt" => Ok(PermissionsPolicyFeature::ChRtt),
                    "ch-save-data" | "ChSaveData" => Ok(PermissionsPolicyFeature::ChSaveData),
                    "ch-ua" | "ChUa" => Ok(PermissionsPolicyFeature::ChUa),
                    "ch-ua-arch" | "ChUaArch" => Ok(PermissionsPolicyFeature::ChUaArch),
                    "ch-ua-bitness" | "ChUaBitness" => Ok(PermissionsPolicyFeature::ChUaBitness),
                    "ch-ua-platform" | "ChUaPlatform" => Ok(PermissionsPolicyFeature::ChUaPlatform),
                    "ch-ua-model" | "ChUaModel" => Ok(PermissionsPolicyFeature::ChUaModel),
                    "ch-ua-mobile" | "ChUaMobile" => Ok(PermissionsPolicyFeature::ChUaMobile),
                    "ch-ua-full" | "ChUaFull" => Ok(PermissionsPolicyFeature::ChUaFull),
                    "ch-ua-full-version" | "ChUaFullVersion" => {
                        Ok(PermissionsPolicyFeature::ChUaFullVersion)
                    }
                    "ch-ua-full-version-list" | "ChUaFullVersionList" => {
                        Ok(PermissionsPolicyFeature::ChUaFullVersionList)
                    }
                    "ch-ua-platform-version" | "ChUaPlatformVersion" => {
                        Ok(PermissionsPolicyFeature::ChUaPlatformVersion)
                    }
                    "ch-ua-reduced" | "ChUaReduced" => Ok(PermissionsPolicyFeature::ChUaReduced),
                    "ch-ua-wow64" | "ChUaWow64" => Ok(PermissionsPolicyFeature::ChUaWow64),
                    "ch-viewport-height" | "ChViewportHeight" => {
                        Ok(PermissionsPolicyFeature::ChViewportHeight)
                    }
                    "ch-viewport-width" | "ChViewportWidth" => {
                        Ok(PermissionsPolicyFeature::ChViewportWidth)
                    }
                    "ch-width" | "ChWidth" => Ok(PermissionsPolicyFeature::ChWidth),
                    "clipboard-read" | "ClipboardRead" => {
                        Ok(PermissionsPolicyFeature::ClipboardRead)
                    }
                    "clipboard-write" | "ClipboardWrite" => {
                        Ok(PermissionsPolicyFeature::ClipboardWrite)
                    }
                    "cross-origin-isolated" | "CrossOriginIsolated" => {
                        Ok(PermissionsPolicyFeature::CrossOriginIsolated)
                    }
                    "direct-sockets" | "DirectSockets" => {
                        Ok(PermissionsPolicyFeature::DirectSockets)
                    }
                    "display-capture" | "DisplayCapture" => {
                        Ok(PermissionsPolicyFeature::DisplayCapture)
                    }
                    "document-domain" | "DocumentDomain" => {
                        Ok(PermissionsPolicyFeature::DocumentDomain)
                    }
                    "encrypted-media" | "EncryptedMedia" => {
                        Ok(PermissionsPolicyFeature::EncryptedMedia)
                    }
                    "execution-while-out-of-viewport" | "ExecutionWhileOutOfViewport" => {
                        Ok(PermissionsPolicyFeature::ExecutionWhileOutOfViewport)
                    }
                    "execution-while-not-rendered" | "ExecutionWhileNotRendered" => {
                        Ok(PermissionsPolicyFeature::ExecutionWhileNotRendered)
                    }
                    "federated-credentials" | "FederatedCredentials" => {
                        Ok(PermissionsPolicyFeature::FederatedCredentials)
                    }
                    "focus-without-user-activation" | "FocusWithoutUserActivation" => {
                        Ok(PermissionsPolicyFeature::FocusWithoutUserActivation)
                    }
                    "fullscreen" | "Fullscreen" => Ok(PermissionsPolicyFeature::Fullscreen),
                    "frobulate" | "Frobulate" => Ok(PermissionsPolicyFeature::Frobulate),
                    "gamepad" | "Gamepad" => Ok(PermissionsPolicyFeature::Gamepad),
                    "geolocation" | "Geolocation" => Ok(PermissionsPolicyFeature::Geolocation),
                    "gyroscope" | "Gyroscope" => Ok(PermissionsPolicyFeature::Gyroscope),
                    "hid" | "Hid" => Ok(PermissionsPolicyFeature::Hid),
                    "idle-detection" | "IdleDetection" => {
                        Ok(PermissionsPolicyFeature::IdleDetection)
                    }
                    "interest-cohort" | "InterestCohort" => {
                        Ok(PermissionsPolicyFeature::InterestCohort)
                    }
                    "join-ad-interest-group" | "JoinAdInterestGroup" => {
                        Ok(PermissionsPolicyFeature::JoinAdInterestGroup)
                    }
                    "keyboard-map" | "KeyboardMap" => Ok(PermissionsPolicyFeature::KeyboardMap),
                    "local-fonts" | "LocalFonts" => Ok(PermissionsPolicyFeature::LocalFonts),
                    "magnetometer" | "Magnetometer" => Ok(PermissionsPolicyFeature::Magnetometer),
                    "microphone" | "Microphone" => Ok(PermissionsPolicyFeature::Microphone),
                    "midi" | "Midi" => Ok(PermissionsPolicyFeature::Midi),
                    "otp-credentials" | "OtpCredentials" => {
                        Ok(PermissionsPolicyFeature::OtpCredentials)
                    }
                    "payment" | "Payment" => Ok(PermissionsPolicyFeature::Payment),
                    "picture-in-picture" | "PictureInPicture" => {
                        Ok(PermissionsPolicyFeature::PictureInPicture)
                    }
                    "publickey-credentials-get" | "PublickeyCredentialsGet" => {
                        Ok(PermissionsPolicyFeature::PublickeyCredentialsGet)
                    }
                    "run-ad-auction" | "RunAdAuction" => Ok(PermissionsPolicyFeature::RunAdAuction),
                    "screen-wake-lock" | "ScreenWakeLock" => {
                        Ok(PermissionsPolicyFeature::ScreenWakeLock)
                    }
                    "serial" | "Serial" => Ok(PermissionsPolicyFeature::Serial),
                    "shared-autofill" | "SharedAutofill" => {
                        Ok(PermissionsPolicyFeature::SharedAutofill)
                    }
                    "shared-storage" | "SharedStorage" => {
                        Ok(PermissionsPolicyFeature::SharedStorage)
                    }
                    "storage-access" | "StorageAccess" => {
                        Ok(PermissionsPolicyFeature::StorageAccess)
                    }
                    "sync-xhr" | "SyncXhr" => Ok(PermissionsPolicyFeature::SyncXhr),
                    "trust-token-redemption" | "TrustTokenRedemption" => {
                        Ok(PermissionsPolicyFeature::TrustTokenRedemption)
                    }
                    "unload" | "Unload" => Ok(PermissionsPolicyFeature::Unload),
                    "usb" | "Usb" => Ok(PermissionsPolicyFeature::Usb),
                    "vertical-scroll" | "VerticalScroll" => {
                        Ok(PermissionsPolicyFeature::VerticalScroll)
                    }
                    "web-share" | "WebShare" => Ok(PermissionsPolicyFeature::WebShare),
                    "window-placement" | "WindowPlacement" => {
                        Ok(PermissionsPolicyFeature::WindowPlacement)
                    }
                    "xr-spatial-tracking" | "XrSpatialTracking" => {
                        Ok(PermissionsPolicyFeature::XrSpatialTracking)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Reason for a permissions policy feature to be disabled."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PermissionsPolicyBlockReason {
            #[doc = "Declaration in HTTP header."]
            #[serde(rename = "Header")]
            Header,
            #[doc = "Declaration in iframe attribute."]
            #[serde(rename = "IframeAttribute")]
            IframeAttribute,
            #[doc = "Inside fenced frame."]
            #[serde(rename = "InFencedFrameTree")]
            InFencedFrameTree,
            #[doc = "Inside an Isolated Application."]
            #[serde(rename = "InIsolatedApp")]
            InIsolatedApp,
        }
        impl AsRef<str> for PermissionsPolicyBlockReason {
            fn as_ref(&self) -> &str {
                match self {
                    PermissionsPolicyBlockReason::Header => "Header",
                    PermissionsPolicyBlockReason::IframeAttribute => "IframeAttribute",
                    PermissionsPolicyBlockReason::InFencedFrameTree => "InFencedFrameTree",
                    PermissionsPolicyBlockReason::InIsolatedApp => "InIsolatedApp",
                }
            }
        }
        impl ::std::str::FromStr for PermissionsPolicyBlockReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Header" | "header" => Ok(PermissionsPolicyBlockReason::Header),
                    "IframeAttribute" | "iframeattribute" => {
                        Ok(PermissionsPolicyBlockReason::IframeAttribute)
                    }
                    "InFencedFrameTree" | "infencedframetree" => {
                        Ok(PermissionsPolicyBlockReason::InFencedFrameTree)
                    }
                    "InIsolatedApp" | "inisolatedapp" => {
                        Ok(PermissionsPolicyBlockReason::InIsolatedApp)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PermissionsPolicyBlockLocator {
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
            #[serde(rename = "blockReason")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub block_reason: PermissionsPolicyBlockReason,
        }
        impl PermissionsPolicyBlockLocator {
            pub fn new(
                frame_id: impl Into<FrameId>,
                block_reason: impl Into<PermissionsPolicyBlockReason>,
            ) -> Self {
                Self {
                    frame_id: frame_id.into(),
                    block_reason: block_reason.into(),
                }
            }
        }
        impl PermissionsPolicyBlockLocator {
            pub fn builder() -> PermissionsPolicyBlockLocatorBuilder {
                PermissionsPolicyBlockLocatorBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PermissionsPolicyBlockLocatorBuilder {
            frame_id: Option<FrameId>,
            block_reason: Option<PermissionsPolicyBlockReason>,
        }
        impl PermissionsPolicyBlockLocatorBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn block_reason(
                mut self,
                block_reason: impl Into<PermissionsPolicyBlockReason>,
            ) -> Self {
                self.block_reason = Some(block_reason.into());
                self
            }
            pub fn build(self) -> Result<PermissionsPolicyBlockLocator, String> {
                Ok(PermissionsPolicyBlockLocator {
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                    block_reason: self.block_reason.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(block_reason))
                    })?,
                })
            }
        }
        impl PermissionsPolicyBlockLocator {
            pub const IDENTIFIER: &'static str = "Page.PermissionsPolicyBlockLocator";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PermissionsPolicyFeatureState {
            #[serde(rename = "feature")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub feature: PermissionsPolicyFeature,
            #[serde(rename = "allowed")]
            pub allowed: bool,
            #[serde(rename = "locator")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub locator: Option<PermissionsPolicyBlockLocator>,
        }
        impl PermissionsPolicyFeatureState {
            pub fn new(
                feature: impl Into<PermissionsPolicyFeature>,
                allowed: impl Into<bool>,
            ) -> Self {
                Self {
                    feature: feature.into(),
                    allowed: allowed.into(),
                    locator: None,
                }
            }
        }
        impl PermissionsPolicyFeatureState {
            pub fn builder() -> PermissionsPolicyFeatureStateBuilder {
                PermissionsPolicyFeatureStateBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PermissionsPolicyFeatureStateBuilder {
            feature: Option<PermissionsPolicyFeature>,
            allowed: Option<bool>,
            locator: Option<PermissionsPolicyBlockLocator>,
        }
        impl PermissionsPolicyFeatureStateBuilder {
            pub fn feature(mut self, feature: impl Into<PermissionsPolicyFeature>) -> Self {
                self.feature = Some(feature.into());
                self
            }
            pub fn allowed(mut self, allowed: impl Into<bool>) -> Self {
                self.allowed = Some(allowed.into());
                self
            }
            pub fn locator(mut self, locator: impl Into<PermissionsPolicyBlockLocator>) -> Self {
                self.locator = Some(locator.into());
                self
            }
            pub fn build(self) -> Result<PermissionsPolicyFeatureState, String> {
                Ok(PermissionsPolicyFeatureState {
                    feature: self.feature.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(feature))
                    })?,
                    allowed: self.allowed.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(allowed))
                    })?,
                    locator: self.locator,
                })
            }
        }
        impl PermissionsPolicyFeatureState {
            pub const IDENTIFIER: &'static str = "Page.PermissionsPolicyFeatureState";
        }
        #[doc = "Origin Trial(https://www.chromium.org/blink/origin-trials) support.\nStatus for an Origin Trial token."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum OriginTrialTokenStatus {
            #[serde(rename = "Success")]
            Success,
            #[serde(rename = "NotSupported")]
            NotSupported,
            #[serde(rename = "Insecure")]
            Insecure,
            #[serde(rename = "Expired")]
            Expired,
            #[serde(rename = "WrongOrigin")]
            WrongOrigin,
            #[serde(rename = "InvalidSignature")]
            InvalidSignature,
            #[serde(rename = "Malformed")]
            Malformed,
            #[serde(rename = "WrongVersion")]
            WrongVersion,
            #[serde(rename = "FeatureDisabled")]
            FeatureDisabled,
            #[serde(rename = "TokenDisabled")]
            TokenDisabled,
            #[serde(rename = "FeatureDisabledForUser")]
            FeatureDisabledForUser,
            #[serde(rename = "UnknownTrial")]
            UnknownTrial,
        }
        impl AsRef<str> for OriginTrialTokenStatus {
            fn as_ref(&self) -> &str {
                match self {
                    OriginTrialTokenStatus::Success => "Success",
                    OriginTrialTokenStatus::NotSupported => "NotSupported",
                    OriginTrialTokenStatus::Insecure => "Insecure",
                    OriginTrialTokenStatus::Expired => "Expired",
                    OriginTrialTokenStatus::WrongOrigin => "WrongOrigin",
                    OriginTrialTokenStatus::InvalidSignature => "InvalidSignature",
                    OriginTrialTokenStatus::Malformed => "Malformed",
                    OriginTrialTokenStatus::WrongVersion => "WrongVersion",
                    OriginTrialTokenStatus::FeatureDisabled => "FeatureDisabled",
                    OriginTrialTokenStatus::TokenDisabled => "TokenDisabled",
                    OriginTrialTokenStatus::FeatureDisabledForUser => "FeatureDisabledForUser",
                    OriginTrialTokenStatus::UnknownTrial => "UnknownTrial",
                }
            }
        }
        impl ::std::str::FromStr for OriginTrialTokenStatus {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Success" | "success" => Ok(OriginTrialTokenStatus::Success),
                    "NotSupported" | "notsupported" => Ok(OriginTrialTokenStatus::NotSupported),
                    "Insecure" | "insecure" => Ok(OriginTrialTokenStatus::Insecure),
                    "Expired" | "expired" => Ok(OriginTrialTokenStatus::Expired),
                    "WrongOrigin" | "wrongorigin" => Ok(OriginTrialTokenStatus::WrongOrigin),
                    "InvalidSignature" | "invalidsignature" => {
                        Ok(OriginTrialTokenStatus::InvalidSignature)
                    }
                    "Malformed" | "malformed" => Ok(OriginTrialTokenStatus::Malformed),
                    "WrongVersion" | "wrongversion" => Ok(OriginTrialTokenStatus::WrongVersion),
                    "FeatureDisabled" | "featuredisabled" => {
                        Ok(OriginTrialTokenStatus::FeatureDisabled)
                    }
                    "TokenDisabled" | "tokendisabled" => Ok(OriginTrialTokenStatus::TokenDisabled),
                    "FeatureDisabledForUser" | "featuredisabledforuser" => {
                        Ok(OriginTrialTokenStatus::FeatureDisabledForUser)
                    }
                    "UnknownTrial" | "unknowntrial" => Ok(OriginTrialTokenStatus::UnknownTrial),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Status for an Origin Trial."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum OriginTrialStatus {
            #[serde(rename = "Enabled")]
            Enabled,
            #[serde(rename = "ValidTokenNotProvided")]
            ValidTokenNotProvided,
            #[serde(rename = "OSNotSupported")]
            OsNotSupported,
            #[serde(rename = "TrialNotAllowed")]
            TrialNotAllowed,
        }
        impl AsRef<str> for OriginTrialStatus {
            fn as_ref(&self) -> &str {
                match self {
                    OriginTrialStatus::Enabled => "Enabled",
                    OriginTrialStatus::ValidTokenNotProvided => "ValidTokenNotProvided",
                    OriginTrialStatus::OsNotSupported => "OSNotSupported",
                    OriginTrialStatus::TrialNotAllowed => "TrialNotAllowed",
                }
            }
        }
        impl ::std::str::FromStr for OriginTrialStatus {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Enabled" | "enabled" => Ok(OriginTrialStatus::Enabled),
                    "ValidTokenNotProvided" | "validtokennotprovided" => {
                        Ok(OriginTrialStatus::ValidTokenNotProvided)
                    }
                    "OSNotSupported" | "OsNotSupported" | "osnotsupported" => {
                        Ok(OriginTrialStatus::OsNotSupported)
                    }
                    "TrialNotAllowed" | "trialnotallowed" => Ok(OriginTrialStatus::TrialNotAllowed),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum OriginTrialUsageRestriction {
            #[serde(rename = "None")]
            None,
            #[serde(rename = "Subset")]
            Subset,
        }
        impl AsRef<str> for OriginTrialUsageRestriction {
            fn as_ref(&self) -> &str {
                match self {
                    OriginTrialUsageRestriction::None => "None",
                    OriginTrialUsageRestriction::Subset => "Subset",
                }
            }
        }
        impl ::std::str::FromStr for OriginTrialUsageRestriction {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "None" | "none" => Ok(OriginTrialUsageRestriction::None),
                    "Subset" | "subset" => Ok(OriginTrialUsageRestriction::Subset),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct OriginTrialToken {
            #[serde(rename = "origin")]
            pub origin: String,
            #[serde(rename = "matchSubDomains")]
            pub match_sub_domains: bool,
            #[serde(rename = "trialName")]
            pub trial_name: String,
            #[serde(rename = "expiryTime")]
            pub expiry_time: super::network::TimeSinceEpoch,
            #[serde(rename = "isThirdParty")]
            pub is_third_party: bool,
            #[serde(rename = "usageRestriction")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub usage_restriction: OriginTrialUsageRestriction,
        }
        impl OriginTrialToken {
            pub fn builder() -> OriginTrialTokenBuilder {
                OriginTrialTokenBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct OriginTrialTokenBuilder {
            origin: Option<String>,
            match_sub_domains: Option<bool>,
            trial_name: Option<String>,
            expiry_time: Option<super::network::TimeSinceEpoch>,
            is_third_party: Option<bool>,
            usage_restriction: Option<OriginTrialUsageRestriction>,
        }
        impl OriginTrialTokenBuilder {
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn match_sub_domains(mut self, match_sub_domains: impl Into<bool>) -> Self {
                self.match_sub_domains = Some(match_sub_domains.into());
                self
            }
            pub fn trial_name(mut self, trial_name: impl Into<String>) -> Self {
                self.trial_name = Some(trial_name.into());
                self
            }
            pub fn expiry_time(
                mut self,
                expiry_time: impl Into<super::network::TimeSinceEpoch>,
            ) -> Self {
                self.expiry_time = Some(expiry_time.into());
                self
            }
            pub fn is_third_party(mut self, is_third_party: impl Into<bool>) -> Self {
                self.is_third_party = Some(is_third_party.into());
                self
            }
            pub fn usage_restriction(
                mut self,
                usage_restriction: impl Into<OriginTrialUsageRestriction>,
            ) -> Self {
                self.usage_restriction = Some(usage_restriction.into());
                self
            }
            pub fn build(self) -> Result<OriginTrialToken, String> {
                Ok(OriginTrialToken {
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    match_sub_domains: self.match_sub_domains.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(match_sub_domains)
                        )
                    })?,
                    trial_name: self.trial_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(trial_name))
                    })?,
                    expiry_time: self.expiry_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(expiry_time))
                    })?,
                    is_third_party: self.is_third_party.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(is_third_party))
                    })?,
                    usage_restriction: self.usage_restriction.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(usage_restriction)
                        )
                    })?,
                })
            }
        }
        impl OriginTrialToken {
            pub const IDENTIFIER: &'static str = "Page.OriginTrialToken";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct OriginTrialTokenWithStatus {
            #[serde(rename = "rawTokenText")]
            pub raw_token_text: String,
            #[doc = "`parsedToken` is present only when the token is extractable and\nparsable."]
            #[serde(rename = "parsedToken")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub parsed_token: Option<OriginTrialToken>,
            #[serde(rename = "status")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub status: OriginTrialTokenStatus,
        }
        impl OriginTrialTokenWithStatus {
            pub fn new(
                raw_token_text: impl Into<String>,
                status: impl Into<OriginTrialTokenStatus>,
            ) -> Self {
                Self {
                    raw_token_text: raw_token_text.into(),
                    status: status.into(),
                    parsed_token: None,
                }
            }
        }
        impl OriginTrialTokenWithStatus {
            pub fn builder() -> OriginTrialTokenWithStatusBuilder {
                OriginTrialTokenWithStatusBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct OriginTrialTokenWithStatusBuilder {
            raw_token_text: Option<String>,
            parsed_token: Option<OriginTrialToken>,
            status: Option<OriginTrialTokenStatus>,
        }
        impl OriginTrialTokenWithStatusBuilder {
            pub fn raw_token_text(mut self, raw_token_text: impl Into<String>) -> Self {
                self.raw_token_text = Some(raw_token_text.into());
                self
            }
            pub fn parsed_token(mut self, parsed_token: impl Into<OriginTrialToken>) -> Self {
                self.parsed_token = Some(parsed_token.into());
                self
            }
            pub fn status(mut self, status: impl Into<OriginTrialTokenStatus>) -> Self {
                self.status = Some(status.into());
                self
            }
            pub fn build(self) -> Result<OriginTrialTokenWithStatus, String> {
                Ok(OriginTrialTokenWithStatus {
                    raw_token_text: self.raw_token_text.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(raw_token_text))
                    })?,
                    parsed_token: self.parsed_token,
                    status: self.status.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(status))
                    })?,
                })
            }
        }
        impl OriginTrialTokenWithStatus {
            pub const IDENTIFIER: &'static str = "Page.OriginTrialTokenWithStatus";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct OriginTrial {
            #[serde(rename = "trialName")]
            pub trial_name: String,
            #[serde(rename = "status")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub status: OriginTrialStatus,
            #[serde(rename = "tokensWithStatus")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub tokens_with_status: Vec<OriginTrialTokenWithStatus>,
        }
        impl OriginTrial {
            pub fn new(
                trial_name: impl Into<String>,
                status: impl Into<OriginTrialStatus>,
                tokens_with_status: Vec<OriginTrialTokenWithStatus>,
            ) -> Self {
                Self {
                    trial_name: trial_name.into(),
                    status: status.into(),
                    tokens_with_status,
                }
            }
        }
        impl OriginTrial {
            pub fn builder() -> OriginTrialBuilder {
                OriginTrialBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct OriginTrialBuilder {
            trial_name: Option<String>,
            status: Option<OriginTrialStatus>,
            tokens_with_status: Option<Vec<OriginTrialTokenWithStatus>>,
        }
        impl OriginTrialBuilder {
            pub fn trial_name(mut self, trial_name: impl Into<String>) -> Self {
                self.trial_name = Some(trial_name.into());
                self
            }
            pub fn status(mut self, status: impl Into<OriginTrialStatus>) -> Self {
                self.status = Some(status.into());
                self
            }
            pub fn tokens_with_statu(
                mut self,
                tokens_with_statu: impl Into<OriginTrialTokenWithStatus>,
            ) -> Self {
                let v = self.tokens_with_status.get_or_insert(Vec::new());
                v.push(tokens_with_statu.into());
                self
            }
            pub fn tokens_with_status<I, S>(mut self, tokens_with_status: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<OriginTrialTokenWithStatus>,
            {
                let v = self.tokens_with_status.get_or_insert(Vec::new());
                for val in tokens_with_status {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<OriginTrial, String> {
                Ok(OriginTrial {
                    trial_name: self.trial_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(trial_name))
                    })?,
                    status: self.status.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(status))
                    })?,
                    tokens_with_status: self.tokens_with_status.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(tokens_with_status)
                        )
                    })?,
                })
            }
        }
        impl OriginTrial {
            pub const IDENTIFIER: &'static str = "Page.OriginTrial";
        }
        #[doc = "Information about the Frame on the page.\n[Frame](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-Frame)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Frame {
            #[doc = "Frame unique identifier."]
            #[serde(rename = "id")]
            pub id: FrameId,
            #[doc = "Parent frame identifier."]
            #[serde(rename = "parentId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub parent_id: Option<FrameId>,
            #[doc = "Identifier of the loader associated with this frame."]
            #[serde(rename = "loaderId")]
            pub loader_id: super::network::LoaderId,
            #[doc = "Frame's name as specified in the tag."]
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub name: Option<String>,
            #[doc = "Frame document's URL without fragment."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Frame document's URL fragment including the '#'."]
            #[serde(rename = "urlFragment")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url_fragment: Option<String>,
            #[doc = "Frame document's registered domain, taking the public suffixes list into account.\nExtracted from the Frame's url.\nExample URLs: http://www.google.com/file.html -> \"google.com\"\nhttp://a.b.co.uk/file.html      -> \"b.co.uk\""]
            #[serde(rename = "domainAndRegistry")]
            pub domain_and_registry: String,
            #[doc = "Frame document's security origin."]
            #[serde(rename = "securityOrigin")]
            pub security_origin: String,
            #[doc = "Frame document's mimeType as determined by the browser."]
            #[serde(rename = "mimeType")]
            pub mime_type: String,
            #[doc = "If the frame failed to load, this contains the URL that could not be loaded. Note that unlike url above, this URL may contain a fragment."]
            #[serde(rename = "unreachableUrl")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub unreachable_url: Option<String>,
            #[doc = "Indicates whether this frame was tagged as an ad and why."]
            #[serde(rename = "adFrameStatus")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub ad_frame_status: Option<AdFrameStatus>,
            #[doc = "Indicates whether the main document is a secure context and explains why that is the case."]
            #[serde(rename = "secureContextType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub secure_context_type: SecureContextType,
            #[doc = "Indicates whether this is a cross origin isolated context."]
            #[serde(rename = "crossOriginIsolatedContextType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub cross_origin_isolated_context_type: CrossOriginIsolatedContextType,
            #[doc = "Indicated which gated APIs / features are available."]
            #[serde(rename = "gatedAPIFeatures")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub gated_api_features: Vec<GatedApiFeatures>,
        }
        impl Frame {
            pub fn builder() -> FrameBuilder {
                FrameBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FrameBuilder {
            id: Option<FrameId>,
            parent_id: Option<FrameId>,
            loader_id: Option<super::network::LoaderId>,
            name: Option<String>,
            url: Option<String>,
            url_fragment: Option<String>,
            domain_and_registry: Option<String>,
            security_origin: Option<String>,
            mime_type: Option<String>,
            unreachable_url: Option<String>,
            ad_frame_status: Option<AdFrameStatus>,
            secure_context_type: Option<SecureContextType>,
            cross_origin_isolated_context_type: Option<CrossOriginIsolatedContextType>,
            gated_api_features: Option<Vec<GatedApiFeatures>>,
        }
        impl FrameBuilder {
            pub fn id(mut self, id: impl Into<FrameId>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn parent_id(mut self, parent_id: impl Into<FrameId>) -> Self {
                self.parent_id = Some(parent_id.into());
                self
            }
            pub fn loader_id(mut self, loader_id: impl Into<super::network::LoaderId>) -> Self {
                self.loader_id = Some(loader_id.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn url_fragment(mut self, url_fragment: impl Into<String>) -> Self {
                self.url_fragment = Some(url_fragment.into());
                self
            }
            pub fn domain_and_registry(mut self, domain_and_registry: impl Into<String>) -> Self {
                self.domain_and_registry = Some(domain_and_registry.into());
                self
            }
            pub fn security_origin(mut self, security_origin: impl Into<String>) -> Self {
                self.security_origin = Some(security_origin.into());
                self
            }
            pub fn mime_type(mut self, mime_type: impl Into<String>) -> Self {
                self.mime_type = Some(mime_type.into());
                self
            }
            pub fn unreachable_url(mut self, unreachable_url: impl Into<String>) -> Self {
                self.unreachable_url = Some(unreachable_url.into());
                self
            }
            pub fn ad_frame_status(mut self, ad_frame_status: impl Into<AdFrameStatus>) -> Self {
                self.ad_frame_status = Some(ad_frame_status.into());
                self
            }
            pub fn secure_context_type(
                mut self,
                secure_context_type: impl Into<SecureContextType>,
            ) -> Self {
                self.secure_context_type = Some(secure_context_type.into());
                self
            }
            pub fn cross_origin_isolated_context_type(
                mut self,
                cross_origin_isolated_context_type: impl Into<CrossOriginIsolatedContextType>,
            ) -> Self {
                self.cross_origin_isolated_context_type =
                    Some(cross_origin_isolated_context_type.into());
                self
            }
            pub fn gated_api_feature(
                mut self,
                gated_api_feature: impl Into<GatedApiFeatures>,
            ) -> Self {
                let v = self.gated_api_features.get_or_insert(Vec::new());
                v.push(gated_api_feature.into());
                self
            }
            pub fn gated_api_features<I, S>(mut self, gated_api_features: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<GatedApiFeatures>,
            {
                let v = self.gated_api_features.get_or_insert(Vec::new());
                for val in gated_api_features {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<Frame, String> {
                Ok(Frame {
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                    parent_id: self.parent_id,
                    loader_id: self.loader_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(loader_id))
                    })?,
                    name: self.name,
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    url_fragment: self.url_fragment,
                    domain_and_registry: self.domain_and_registry.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(domain_and_registry)
                        )
                    })?,
                    security_origin: self.security_origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(security_origin))
                    })?,
                    mime_type: self.mime_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(mime_type))
                    })?,
                    unreachable_url: self.unreachable_url,
                    ad_frame_status: self.ad_frame_status,
                    secure_context_type: self.secure_context_type.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(secure_context_type)
                        )
                    })?,
                    cross_origin_isolated_context_type: self
                        .cross_origin_isolated_context_type
                        .ok_or_else(|| {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(cross_origin_isolated_context_type)
                            )
                        })?,
                    gated_api_features: self.gated_api_features.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(gated_api_features)
                        )
                    })?,
                })
            }
        }
        impl Frame {
            pub const IDENTIFIER: &'static str = "Page.Frame";
        }
        #[doc = "Information about the Resource on the page.\n[FrameResource](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-FrameResource)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct FrameResource {
            #[doc = "Resource URL."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Type of this resource."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: super::network::ResourceType,
            #[doc = "Resource mimeType as determined by the browser."]
            #[serde(rename = "mimeType")]
            pub mime_type: String,
            #[doc = "last-modified timestamp as reported by server."]
            #[serde(rename = "lastModified")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub last_modified: Option<super::network::TimeSinceEpoch>,
            #[doc = "Resource content size."]
            #[serde(rename = "contentSize")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub content_size: Option<f64>,
            #[doc = "True if the resource failed to load."]
            #[serde(rename = "failed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub failed: Option<bool>,
            #[doc = "True if the resource was canceled during loading."]
            #[serde(rename = "canceled")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub canceled: Option<bool>,
        }
        impl FrameResource {
            pub fn new(
                url: impl Into<String>,
                r#type: impl Into<super::network::ResourceType>,
                mime_type: impl Into<String>,
            ) -> Self {
                Self {
                    url: url.into(),
                    r#type: r#type.into(),
                    mime_type: mime_type.into(),
                    last_modified: None,
                    content_size: None,
                    failed: None,
                    canceled: None,
                }
            }
        }
        impl FrameResource {
            pub fn builder() -> FrameResourceBuilder {
                FrameResourceBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FrameResourceBuilder {
            url: Option<String>,
            r#type: Option<super::network::ResourceType>,
            mime_type: Option<String>,
            last_modified: Option<super::network::TimeSinceEpoch>,
            content_size: Option<f64>,
            failed: Option<bool>,
            canceled: Option<bool>,
        }
        impl FrameResourceBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<super::network::ResourceType>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn mime_type(mut self, mime_type: impl Into<String>) -> Self {
                self.mime_type = Some(mime_type.into());
                self
            }
            pub fn last_modified(
                mut self,
                last_modified: impl Into<super::network::TimeSinceEpoch>,
            ) -> Self {
                self.last_modified = Some(last_modified.into());
                self
            }
            pub fn content_size(mut self, content_size: impl Into<f64>) -> Self {
                self.content_size = Some(content_size.into());
                self
            }
            pub fn failed(mut self, failed: impl Into<bool>) -> Self {
                self.failed = Some(failed.into());
                self
            }
            pub fn canceled(mut self, canceled: impl Into<bool>) -> Self {
                self.canceled = Some(canceled.into());
                self
            }
            pub fn build(self) -> Result<FrameResource, String> {
                Ok(FrameResource {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    mime_type: self.mime_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(mime_type))
                    })?,
                    last_modified: self.last_modified,
                    content_size: self.content_size,
                    failed: self.failed,
                    canceled: self.canceled,
                })
            }
        }
        impl FrameResource {
            pub const IDENTIFIER: &'static str = "Page.FrameResource";
        }
        #[doc = "Information about the Frame hierarchy along with their cached resources.\n[FrameResourceTree](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-FrameResourceTree)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct FrameResourceTree {
            #[doc = "Frame information for this tree item."]
            #[serde(rename = "frame")]
            pub frame: Frame,
            #[doc = "Child frames."]
            #[serde(rename = "childFrames")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub child_frames: Option<Vec<FrameResourceTree>>,
            #[doc = "Information about frame resources."]
            #[serde(rename = "resources")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub resources: Vec<FrameResource>,
        }
        impl FrameResourceTree {
            pub fn new(frame: impl Into<Frame>, resources: Vec<FrameResource>) -> Self {
                Self {
                    frame: frame.into(),
                    resources,
                    child_frames: None,
                }
            }
        }
        impl FrameResourceTree {
            pub fn builder() -> FrameResourceTreeBuilder {
                FrameResourceTreeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FrameResourceTreeBuilder {
            frame: Option<Frame>,
            child_frames: Option<Vec<FrameResourceTree>>,
            resources: Option<Vec<FrameResource>>,
        }
        impl FrameResourceTreeBuilder {
            pub fn frame(mut self, frame: impl Into<Frame>) -> Self {
                self.frame = Some(frame.into());
                self
            }
            pub fn child_frame(mut self, child_frame: impl Into<FrameResourceTree>) -> Self {
                let v = self.child_frames.get_or_insert(Vec::new());
                v.push(child_frame.into());
                self
            }
            pub fn child_frames<I, S>(mut self, child_frames: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<FrameResourceTree>,
            {
                let v = self.child_frames.get_or_insert(Vec::new());
                for val in child_frames {
                    v.push(val.into());
                }
                self
            }
            pub fn resource(mut self, resource: impl Into<FrameResource>) -> Self {
                let v = self.resources.get_or_insert(Vec::new());
                v.push(resource.into());
                self
            }
            pub fn resources<I, S>(mut self, resources: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<FrameResource>,
            {
                let v = self.resources.get_or_insert(Vec::new());
                for val in resources {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<FrameResourceTree, String> {
                Ok(FrameResourceTree {
                    frame: self.frame.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame))
                    })?,
                    child_frames: self.child_frames,
                    resources: self.resources.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(resources))
                    })?,
                })
            }
        }
        impl FrameResourceTree {
            pub const IDENTIFIER: &'static str = "Page.FrameResourceTree";
        }
        #[doc = "Information about the Frame hierarchy.\n[FrameTree](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-FrameTree)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct FrameTree {
            #[doc = "Frame information for this tree item."]
            #[serde(rename = "frame")]
            pub frame: Frame,
            #[doc = "Child frames."]
            #[serde(rename = "childFrames")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub child_frames: Option<Vec<FrameTree>>,
        }
        impl FrameTree {
            pub fn new(frame: impl Into<Frame>) -> Self {
                Self {
                    frame: frame.into(),
                    child_frames: None,
                }
            }
        }
        impl FrameTree {
            pub fn builder() -> FrameTreeBuilder {
                FrameTreeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FrameTreeBuilder {
            frame: Option<Frame>,
            child_frames: Option<Vec<FrameTree>>,
        }
        impl FrameTreeBuilder {
            pub fn frame(mut self, frame: impl Into<Frame>) -> Self {
                self.frame = Some(frame.into());
                self
            }
            pub fn child_frame(mut self, child_frame: impl Into<FrameTree>) -> Self {
                let v = self.child_frames.get_or_insert(Vec::new());
                v.push(child_frame.into());
                self
            }
            pub fn child_frames<I, S>(mut self, child_frames: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<FrameTree>,
            {
                let v = self.child_frames.get_or_insert(Vec::new());
                for val in child_frames {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<FrameTree, String> {
                Ok(FrameTree {
                    frame: self.frame.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame))
                    })?,
                    child_frames: self.child_frames,
                })
            }
        }
        impl FrameTree {
            pub const IDENTIFIER: &'static str = "Page.FrameTree";
        }
        #[doc = "Unique script identifier.\n[ScriptIdentifier](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-ScriptIdentifier)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct ScriptIdentifier(String);
        impl ScriptIdentifier {
            pub fn new(val: impl Into<String>) -> Self {
                ScriptIdentifier(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for ScriptIdentifier {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<ScriptIdentifier> for String {
            fn from(el: ScriptIdentifier) -> String {
                el.0
            }
        }
        impl From<String> for ScriptIdentifier {
            fn from(expr: String) -> Self {
                ScriptIdentifier(expr)
            }
        }
        impl ScriptIdentifier {
            pub const IDENTIFIER: &'static str = "Page.ScriptIdentifier";
        }
        #[doc = "Transition type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum TransitionType {
            #[serde(rename = "link")]
            Link,
            #[serde(rename = "typed")]
            Typed,
            #[serde(rename = "address_bar")]
            AddressBar,
            #[serde(rename = "auto_bookmark")]
            AutoBookmark,
            #[serde(rename = "auto_subframe")]
            AutoSubframe,
            #[serde(rename = "manual_subframe")]
            ManualSubframe,
            #[serde(rename = "generated")]
            Generated,
            #[serde(rename = "auto_toplevel")]
            AutoToplevel,
            #[serde(rename = "form_submit")]
            FormSubmit,
            #[serde(rename = "reload")]
            Reload,
            #[serde(rename = "keyword")]
            Keyword,
            #[serde(rename = "keyword_generated")]
            KeywordGenerated,
            #[serde(rename = "other")]
            Other,
        }
        impl AsRef<str> for TransitionType {
            fn as_ref(&self) -> &str {
                match self {
                    TransitionType::Link => "link",
                    TransitionType::Typed => "typed",
                    TransitionType::AddressBar => "address_bar",
                    TransitionType::AutoBookmark => "auto_bookmark",
                    TransitionType::AutoSubframe => "auto_subframe",
                    TransitionType::ManualSubframe => "manual_subframe",
                    TransitionType::Generated => "generated",
                    TransitionType::AutoToplevel => "auto_toplevel",
                    TransitionType::FormSubmit => "form_submit",
                    TransitionType::Reload => "reload",
                    TransitionType::Keyword => "keyword",
                    TransitionType::KeywordGenerated => "keyword_generated",
                    TransitionType::Other => "other",
                }
            }
        }
        impl ::std::str::FromStr for TransitionType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "link" | "Link" => Ok(TransitionType::Link),
                    "typed" | "Typed" => Ok(TransitionType::Typed),
                    "address_bar" | "AddressBar" => Ok(TransitionType::AddressBar),
                    "auto_bookmark" | "AutoBookmark" => Ok(TransitionType::AutoBookmark),
                    "auto_subframe" | "AutoSubframe" => Ok(TransitionType::AutoSubframe),
                    "manual_subframe" | "ManualSubframe" => Ok(TransitionType::ManualSubframe),
                    "generated" | "Generated" => Ok(TransitionType::Generated),
                    "auto_toplevel" | "AutoToplevel" => Ok(TransitionType::AutoToplevel),
                    "form_submit" | "FormSubmit" => Ok(TransitionType::FormSubmit),
                    "reload" | "Reload" => Ok(TransitionType::Reload),
                    "keyword" | "Keyword" => Ok(TransitionType::Keyword),
                    "keyword_generated" | "KeywordGenerated" => {
                        Ok(TransitionType::KeywordGenerated)
                    }
                    "other" | "Other" => Ok(TransitionType::Other),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Navigation history entry.\n[NavigationEntry](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-NavigationEntry)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct NavigationEntry {
            #[doc = "Unique id of the navigation history entry."]
            #[serde(rename = "id")]
            pub id: i64,
            #[doc = "URL of the navigation history entry."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "URL that the user typed in the url bar."]
            #[serde(rename = "userTypedURL")]
            pub user_typed_url: String,
            #[doc = "Title of the navigation history entry."]
            #[serde(rename = "title")]
            pub title: String,
            #[doc = "Transition type."]
            #[serde(rename = "transitionType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub transition_type: TransitionType,
        }
        impl NavigationEntry {
            pub fn builder() -> NavigationEntryBuilder {
                NavigationEntryBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct NavigationEntryBuilder {
            id: Option<i64>,
            url: Option<String>,
            user_typed_url: Option<String>,
            title: Option<String>,
            transition_type: Option<TransitionType>,
        }
        impl NavigationEntryBuilder {
            pub fn id(mut self, id: impl Into<i64>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn user_typed_url(mut self, user_typed_url: impl Into<String>) -> Self {
                self.user_typed_url = Some(user_typed_url.into());
                self
            }
            pub fn title(mut self, title: impl Into<String>) -> Self {
                self.title = Some(title.into());
                self
            }
            pub fn transition_type(mut self, transition_type: impl Into<TransitionType>) -> Self {
                self.transition_type = Some(transition_type.into());
                self
            }
            pub fn build(self) -> Result<NavigationEntry, String> {
                Ok(NavigationEntry {
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    user_typed_url: self.user_typed_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(user_typed_url))
                    })?,
                    title: self.title.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(title))
                    })?,
                    transition_type: self.transition_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(transition_type))
                    })?,
                })
            }
        }
        impl NavigationEntry {
            pub const IDENTIFIER: &'static str = "Page.NavigationEntry";
        }
        #[doc = "Screencast frame metadata.\n[ScreencastFrameMetadata](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-ScreencastFrameMetadata)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ScreencastFrameMetadata {
            #[doc = "Top offset in DIP."]
            #[serde(rename = "offsetTop")]
            pub offset_top: f64,
            #[doc = "Page scale factor."]
            #[serde(rename = "pageScaleFactor")]
            pub page_scale_factor: f64,
            #[doc = "Device screen width in DIP."]
            #[serde(rename = "deviceWidth")]
            pub device_width: f64,
            #[doc = "Device screen height in DIP."]
            #[serde(rename = "deviceHeight")]
            pub device_height: f64,
            #[doc = "Position of horizontal scroll in CSS pixels."]
            #[serde(rename = "scrollOffsetX")]
            pub scroll_offset_x: f64,
            #[doc = "Position of vertical scroll in CSS pixels."]
            #[serde(rename = "scrollOffsetY")]
            pub scroll_offset_y: f64,
            #[doc = "Frame swap timestamp."]
            #[serde(rename = "timestamp")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub timestamp: Option<super::network::TimeSinceEpoch>,
        }
        impl ScreencastFrameMetadata {
            pub fn builder() -> ScreencastFrameMetadataBuilder {
                ScreencastFrameMetadataBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ScreencastFrameMetadataBuilder {
            offset_top: Option<f64>,
            page_scale_factor: Option<f64>,
            device_width: Option<f64>,
            device_height: Option<f64>,
            scroll_offset_x: Option<f64>,
            scroll_offset_y: Option<f64>,
            timestamp: Option<super::network::TimeSinceEpoch>,
        }
        impl ScreencastFrameMetadataBuilder {
            pub fn offset_top(mut self, offset_top: impl Into<f64>) -> Self {
                self.offset_top = Some(offset_top.into());
                self
            }
            pub fn page_scale_factor(mut self, page_scale_factor: impl Into<f64>) -> Self {
                self.page_scale_factor = Some(page_scale_factor.into());
                self
            }
            pub fn device_width(mut self, device_width: impl Into<f64>) -> Self {
                self.device_width = Some(device_width.into());
                self
            }
            pub fn device_height(mut self, device_height: impl Into<f64>) -> Self {
                self.device_height = Some(device_height.into());
                self
            }
            pub fn scroll_offset_x(mut self, scroll_offset_x: impl Into<f64>) -> Self {
                self.scroll_offset_x = Some(scroll_offset_x.into());
                self
            }
            pub fn scroll_offset_y(mut self, scroll_offset_y: impl Into<f64>) -> Self {
                self.scroll_offset_y = Some(scroll_offset_y.into());
                self
            }
            pub fn timestamp(
                mut self,
                timestamp: impl Into<super::network::TimeSinceEpoch>,
            ) -> Self {
                self.timestamp = Some(timestamp.into());
                self
            }
            pub fn build(self) -> Result<ScreencastFrameMetadata, String> {
                Ok(ScreencastFrameMetadata {
                    offset_top: self.offset_top.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(offset_top))
                    })?,
                    page_scale_factor: self.page_scale_factor.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(page_scale_factor)
                        )
                    })?,
                    device_width: self.device_width.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(device_width))
                    })?,
                    device_height: self.device_height.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(device_height))
                    })?,
                    scroll_offset_x: self.scroll_offset_x.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scroll_offset_x))
                    })?,
                    scroll_offset_y: self.scroll_offset_y.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scroll_offset_y))
                    })?,
                    timestamp: self.timestamp,
                })
            }
        }
        impl ScreencastFrameMetadata {
            pub const IDENTIFIER: &'static str = "Page.ScreencastFrameMetadata";
        }
        #[doc = "Javascript dialog type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum DialogType {
            #[serde(rename = "alert")]
            Alert,
            #[serde(rename = "confirm")]
            Confirm,
            #[serde(rename = "prompt")]
            Prompt,
            #[serde(rename = "beforeunload")]
            Beforeunload,
        }
        impl AsRef<str> for DialogType {
            fn as_ref(&self) -> &str {
                match self {
                    DialogType::Alert => "alert",
                    DialogType::Confirm => "confirm",
                    DialogType::Prompt => "prompt",
                    DialogType::Beforeunload => "beforeunload",
                }
            }
        }
        impl ::std::str::FromStr for DialogType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "alert" | "Alert" => Ok(DialogType::Alert),
                    "confirm" | "Confirm" => Ok(DialogType::Confirm),
                    "prompt" | "Prompt" => Ok(DialogType::Prompt),
                    "beforeunload" | "Beforeunload" => Ok(DialogType::Beforeunload),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Error while paring app manifest.\n[AppManifestError](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-AppManifestError)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AppManifestError {
            #[doc = "Error message."]
            #[serde(rename = "message")]
            pub message: String,
            #[doc = "If criticial, this is a non-recoverable parse error."]
            #[serde(rename = "critical")]
            pub critical: i64,
            #[doc = "Error line."]
            #[serde(rename = "line")]
            pub line: i64,
            #[doc = "Error column."]
            #[serde(rename = "column")]
            pub column: i64,
        }
        impl AppManifestError {
            pub fn new(
                message: impl Into<String>,
                critical: impl Into<i64>,
                line: impl Into<i64>,
                column: impl Into<i64>,
            ) -> Self {
                Self {
                    message: message.into(),
                    critical: critical.into(),
                    line: line.into(),
                    column: column.into(),
                }
            }
        }
        impl AppManifestError {
            pub fn builder() -> AppManifestErrorBuilder {
                AppManifestErrorBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AppManifestErrorBuilder {
            message: Option<String>,
            critical: Option<i64>,
            line: Option<i64>,
            column: Option<i64>,
        }
        impl AppManifestErrorBuilder {
            pub fn message(mut self, message: impl Into<String>) -> Self {
                self.message = Some(message.into());
                self
            }
            pub fn critical(mut self, critical: impl Into<i64>) -> Self {
                self.critical = Some(critical.into());
                self
            }
            pub fn line(mut self, line: impl Into<i64>) -> Self {
                self.line = Some(line.into());
                self
            }
            pub fn column(mut self, column: impl Into<i64>) -> Self {
                self.column = Some(column.into());
                self
            }
            pub fn build(self) -> Result<AppManifestError, String> {
                Ok(AppManifestError {
                    message: self.message.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(message))
                    })?,
                    critical: self.critical.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(critical))
                    })?,
                    line: self.line.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line))
                    })?,
                    column: self.column.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(column))
                    })?,
                })
            }
        }
        impl AppManifestError {
            pub const IDENTIFIER: &'static str = "Page.AppManifestError";
        }
        #[doc = "Parsed app manifest properties.\n[AppManifestParsedProperties](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-AppManifestParsedProperties)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AppManifestParsedProperties {
            #[doc = "Computed scope value"]
            #[serde(rename = "scope")]
            pub scope: String,
        }
        impl AppManifestParsedProperties {
            pub fn new(scope: impl Into<String>) -> Self {
                Self {
                    scope: scope.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for AppManifestParsedProperties {
            fn from(url: T) -> Self {
                AppManifestParsedProperties::new(url)
            }
        }
        impl AppManifestParsedProperties {
            pub fn builder() -> AppManifestParsedPropertiesBuilder {
                AppManifestParsedPropertiesBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AppManifestParsedPropertiesBuilder {
            scope: Option<String>,
        }
        impl AppManifestParsedPropertiesBuilder {
            pub fn scope(mut self, scope: impl Into<String>) -> Self {
                self.scope = Some(scope.into());
                self
            }
            pub fn build(self) -> Result<AppManifestParsedProperties, String> {
                Ok(AppManifestParsedProperties {
                    scope: self.scope.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scope))
                    })?,
                })
            }
        }
        impl AppManifestParsedProperties {
            pub const IDENTIFIER: &'static str = "Page.AppManifestParsedProperties";
        }
        #[doc = "Layout viewport position and dimensions.\n[LayoutViewport](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-LayoutViewport)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LayoutViewport {
            #[doc = "Horizontal offset relative to the document (CSS pixels)."]
            #[serde(rename = "pageX")]
            pub page_x: i64,
            #[doc = "Vertical offset relative to the document (CSS pixels)."]
            #[serde(rename = "pageY")]
            pub page_y: i64,
            #[doc = "Width (CSS pixels), excludes scrollbar if present."]
            #[serde(rename = "clientWidth")]
            pub client_width: i64,
            #[doc = "Height (CSS pixels), excludes scrollbar if present."]
            #[serde(rename = "clientHeight")]
            pub client_height: i64,
        }
        impl LayoutViewport {
            pub fn new(
                page_x: impl Into<i64>,
                page_y: impl Into<i64>,
                client_width: impl Into<i64>,
                client_height: impl Into<i64>,
            ) -> Self {
                Self {
                    page_x: page_x.into(),
                    page_y: page_y.into(),
                    client_width: client_width.into(),
                    client_height: client_height.into(),
                }
            }
        }
        impl LayoutViewport {
            pub fn builder() -> LayoutViewportBuilder {
                LayoutViewportBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LayoutViewportBuilder {
            page_x: Option<i64>,
            page_y: Option<i64>,
            client_width: Option<i64>,
            client_height: Option<i64>,
        }
        impl LayoutViewportBuilder {
            pub fn page_x(mut self, page_x: impl Into<i64>) -> Self {
                self.page_x = Some(page_x.into());
                self
            }
            pub fn page_y(mut self, page_y: impl Into<i64>) -> Self {
                self.page_y = Some(page_y.into());
                self
            }
            pub fn client_width(mut self, client_width: impl Into<i64>) -> Self {
                self.client_width = Some(client_width.into());
                self
            }
            pub fn client_height(mut self, client_height: impl Into<i64>) -> Self {
                self.client_height = Some(client_height.into());
                self
            }
            pub fn build(self) -> Result<LayoutViewport, String> {
                Ok(LayoutViewport {
                    page_x: self.page_x.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(page_x))
                    })?,
                    page_y: self.page_y.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(page_y))
                    })?,
                    client_width: self.client_width.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(client_width))
                    })?,
                    client_height: self.client_height.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(client_height))
                    })?,
                })
            }
        }
        impl LayoutViewport {
            pub const IDENTIFIER: &'static str = "Page.LayoutViewport";
        }
        #[doc = "Visual viewport position, dimensions, and scale.\n[VisualViewport](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-VisualViewport)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct VisualViewport {
            #[doc = "Horizontal offset relative to the layout viewport (CSS pixels)."]
            #[serde(rename = "offsetX")]
            pub offset_x: f64,
            #[doc = "Vertical offset relative to the layout viewport (CSS pixels)."]
            #[serde(rename = "offsetY")]
            pub offset_y: f64,
            #[doc = "Horizontal offset relative to the document (CSS pixels)."]
            #[serde(rename = "pageX")]
            pub page_x: f64,
            #[doc = "Vertical offset relative to the document (CSS pixels)."]
            #[serde(rename = "pageY")]
            pub page_y: f64,
            #[doc = "Width (CSS pixels), excludes scrollbar if present."]
            #[serde(rename = "clientWidth")]
            pub client_width: f64,
            #[doc = "Height (CSS pixels), excludes scrollbar if present."]
            #[serde(rename = "clientHeight")]
            pub client_height: f64,
            #[doc = "Scale relative to the ideal viewport (size at width=device-width)."]
            #[serde(rename = "scale")]
            pub scale: f64,
            #[doc = "Page zoom factor (CSS to device independent pixels ratio)."]
            #[serde(rename = "zoom")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub zoom: Option<f64>,
        }
        impl VisualViewport {
            pub fn builder() -> VisualViewportBuilder {
                VisualViewportBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct VisualViewportBuilder {
            offset_x: Option<f64>,
            offset_y: Option<f64>,
            page_x: Option<f64>,
            page_y: Option<f64>,
            client_width: Option<f64>,
            client_height: Option<f64>,
            scale: Option<f64>,
            zoom: Option<f64>,
        }
        impl VisualViewportBuilder {
            pub fn offset_x(mut self, offset_x: impl Into<f64>) -> Self {
                self.offset_x = Some(offset_x.into());
                self
            }
            pub fn offset_y(mut self, offset_y: impl Into<f64>) -> Self {
                self.offset_y = Some(offset_y.into());
                self
            }
            pub fn page_x(mut self, page_x: impl Into<f64>) -> Self {
                self.page_x = Some(page_x.into());
                self
            }
            pub fn page_y(mut self, page_y: impl Into<f64>) -> Self {
                self.page_y = Some(page_y.into());
                self
            }
            pub fn client_width(mut self, client_width: impl Into<f64>) -> Self {
                self.client_width = Some(client_width.into());
                self
            }
            pub fn client_height(mut self, client_height: impl Into<f64>) -> Self {
                self.client_height = Some(client_height.into());
                self
            }
            pub fn scale(mut self, scale: impl Into<f64>) -> Self {
                self.scale = Some(scale.into());
                self
            }
            pub fn zoom(mut self, zoom: impl Into<f64>) -> Self {
                self.zoom = Some(zoom.into());
                self
            }
            pub fn build(self) -> Result<VisualViewport, String> {
                Ok(VisualViewport {
                    offset_x: self.offset_x.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(offset_x))
                    })?,
                    offset_y: self.offset_y.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(offset_y))
                    })?,
                    page_x: self.page_x.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(page_x))
                    })?,
                    page_y: self.page_y.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(page_y))
                    })?,
                    client_width: self.client_width.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(client_width))
                    })?,
                    client_height: self.client_height.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(client_height))
                    })?,
                    scale: self.scale.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scale))
                    })?,
                    zoom: self.zoom,
                })
            }
        }
        impl VisualViewport {
            pub const IDENTIFIER: &'static str = "Page.VisualViewport";
        }
        #[doc = "Viewport for capturing screenshot.\n[Viewport](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-Viewport)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Viewport {
            #[doc = "X offset in device independent pixels (dip)."]
            #[serde(rename = "x")]
            pub x: f64,
            #[doc = "Y offset in device independent pixels (dip)."]
            #[serde(rename = "y")]
            pub y: f64,
            #[doc = "Rectangle width in device independent pixels (dip)."]
            #[serde(rename = "width")]
            pub width: f64,
            #[doc = "Rectangle height in device independent pixels (dip)."]
            #[serde(rename = "height")]
            pub height: f64,
            #[doc = "Page scale factor."]
            #[serde(rename = "scale")]
            pub scale: f64,
        }
        impl Viewport {
            pub fn builder() -> ViewportBuilder {
                ViewportBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ViewportBuilder {
            x: Option<f64>,
            y: Option<f64>,
            width: Option<f64>,
            height: Option<f64>,
            scale: Option<f64>,
        }
        impl ViewportBuilder {
            pub fn x(mut self, x: impl Into<f64>) -> Self {
                self.x = Some(x.into());
                self
            }
            pub fn y(mut self, y: impl Into<f64>) -> Self {
                self.y = Some(y.into());
                self
            }
            pub fn width(mut self, width: impl Into<f64>) -> Self {
                self.width = Some(width.into());
                self
            }
            pub fn height(mut self, height: impl Into<f64>) -> Self {
                self.height = Some(height.into());
                self
            }
            pub fn scale(mut self, scale: impl Into<f64>) -> Self {
                self.scale = Some(scale.into());
                self
            }
            pub fn build(self) -> Result<Viewport, String> {
                Ok(Viewport {
                    x: self
                        .x
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(x)))?,
                    y: self
                        .y
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(y)))?,
                    width: self.width.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(width))
                    })?,
                    height: self.height.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(height))
                    })?,
                    scale: self.scale.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scale))
                    })?,
                })
            }
        }
        impl Viewport {
            pub const IDENTIFIER: &'static str = "Page.Viewport";
        }
        #[doc = "Generic font families collection.\n[FontFamilies](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-FontFamilies)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct FontFamilies {
            #[doc = "The standard font-family."]
            #[serde(rename = "standard")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub standard: Option<String>,
            #[doc = "The fixed font-family."]
            #[serde(rename = "fixed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub fixed: Option<String>,
            #[doc = "The serif font-family."]
            #[serde(rename = "serif")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub serif: Option<String>,
            #[doc = "The sansSerif font-family."]
            #[serde(rename = "sansSerif")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub sans_serif: Option<String>,
            #[doc = "The cursive font-family."]
            #[serde(rename = "cursive")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub cursive: Option<String>,
            #[doc = "The fantasy font-family."]
            #[serde(rename = "fantasy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub fantasy: Option<String>,
            #[doc = "The math font-family."]
            #[serde(rename = "math")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub math: Option<String>,
        }
        impl FontFamilies {
            pub fn builder() -> FontFamiliesBuilder {
                FontFamiliesBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FontFamiliesBuilder {
            standard: Option<String>,
            fixed: Option<String>,
            serif: Option<String>,
            sans_serif: Option<String>,
            cursive: Option<String>,
            fantasy: Option<String>,
            math: Option<String>,
        }
        impl FontFamiliesBuilder {
            pub fn standard(mut self, standard: impl Into<String>) -> Self {
                self.standard = Some(standard.into());
                self
            }
            pub fn fixed(mut self, fixed: impl Into<String>) -> Self {
                self.fixed = Some(fixed.into());
                self
            }
            pub fn serif(mut self, serif: impl Into<String>) -> Self {
                self.serif = Some(serif.into());
                self
            }
            pub fn sans_serif(mut self, sans_serif: impl Into<String>) -> Self {
                self.sans_serif = Some(sans_serif.into());
                self
            }
            pub fn cursive(mut self, cursive: impl Into<String>) -> Self {
                self.cursive = Some(cursive.into());
                self
            }
            pub fn fantasy(mut self, fantasy: impl Into<String>) -> Self {
                self.fantasy = Some(fantasy.into());
                self
            }
            pub fn math(mut self, math: impl Into<String>) -> Self {
                self.math = Some(math.into());
                self
            }
            pub fn build(self) -> FontFamilies {
                FontFamilies {
                    standard: self.standard,
                    fixed: self.fixed,
                    serif: self.serif,
                    sans_serif: self.sans_serif,
                    cursive: self.cursive,
                    fantasy: self.fantasy,
                    math: self.math,
                }
            }
        }
        impl FontFamilies {
            pub const IDENTIFIER: &'static str = "Page.FontFamilies";
        }
        #[doc = "Font families collection for a script.\n[ScriptFontFamilies](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-ScriptFontFamilies)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ScriptFontFamilies {
            #[doc = "Name of the script which these font families are defined for."]
            #[serde(rename = "script")]
            pub script: String,
            #[doc = "Generic font families collection for the script."]
            #[serde(rename = "fontFamilies")]
            pub font_families: FontFamilies,
        }
        impl ScriptFontFamilies {
            pub fn new(script: impl Into<String>, font_families: impl Into<FontFamilies>) -> Self {
                Self {
                    script: script.into(),
                    font_families: font_families.into(),
                }
            }
        }
        impl ScriptFontFamilies {
            pub fn builder() -> ScriptFontFamiliesBuilder {
                ScriptFontFamiliesBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ScriptFontFamiliesBuilder {
            script: Option<String>,
            font_families: Option<FontFamilies>,
        }
        impl ScriptFontFamiliesBuilder {
            pub fn script(mut self, script: impl Into<String>) -> Self {
                self.script = Some(script.into());
                self
            }
            pub fn font_families(mut self, font_families: impl Into<FontFamilies>) -> Self {
                self.font_families = Some(font_families.into());
                self
            }
            pub fn build(self) -> Result<ScriptFontFamilies, String> {
                Ok(ScriptFontFamilies {
                    script: self.script.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script))
                    })?,
                    font_families: self.font_families.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(font_families))
                    })?,
                })
            }
        }
        impl ScriptFontFamilies {
            pub const IDENTIFIER: &'static str = "Page.ScriptFontFamilies";
        }
        #[doc = "Default font sizes.\n[FontSizes](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-FontSizes)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct FontSizes {
            #[doc = "Default standard font size."]
            #[serde(rename = "standard")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub standard: Option<i64>,
            #[doc = "Default fixed font size."]
            #[serde(rename = "fixed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub fixed: Option<i64>,
        }
        impl FontSizes {
            pub fn builder() -> FontSizesBuilder {
                FontSizesBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FontSizesBuilder {
            standard: Option<i64>,
            fixed: Option<i64>,
        }
        impl FontSizesBuilder {
            pub fn standard(mut self, standard: impl Into<i64>) -> Self {
                self.standard = Some(standard.into());
                self
            }
            pub fn fixed(mut self, fixed: impl Into<i64>) -> Self {
                self.fixed = Some(fixed.into());
                self
            }
            pub fn build(self) -> FontSizes {
                FontSizes {
                    standard: self.standard,
                    fixed: self.fixed,
                }
            }
        }
        impl FontSizes {
            pub const IDENTIFIER: &'static str = "Page.FontSizes";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ClientNavigationReason {
            #[serde(rename = "formSubmissionGet")]
            FormSubmissionGet,
            #[serde(rename = "formSubmissionPost")]
            FormSubmissionPost,
            #[serde(rename = "httpHeaderRefresh")]
            HttpHeaderRefresh,
            #[serde(rename = "scriptInitiated")]
            ScriptInitiated,
            #[serde(rename = "metaTagRefresh")]
            MetaTagRefresh,
            #[serde(rename = "pageBlockInterstitial")]
            PageBlockInterstitial,
            #[serde(rename = "reload")]
            Reload,
            #[serde(rename = "anchorClick")]
            AnchorClick,
        }
        impl AsRef<str> for ClientNavigationReason {
            fn as_ref(&self) -> &str {
                match self {
                    ClientNavigationReason::FormSubmissionGet => "formSubmissionGet",
                    ClientNavigationReason::FormSubmissionPost => "formSubmissionPost",
                    ClientNavigationReason::HttpHeaderRefresh => "httpHeaderRefresh",
                    ClientNavigationReason::ScriptInitiated => "scriptInitiated",
                    ClientNavigationReason::MetaTagRefresh => "metaTagRefresh",
                    ClientNavigationReason::PageBlockInterstitial => "pageBlockInterstitial",
                    ClientNavigationReason::Reload => "reload",
                    ClientNavigationReason::AnchorClick => "anchorClick",
                }
            }
        }
        impl ::std::str::FromStr for ClientNavigationReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "formSubmissionGet" | "FormSubmissionGet" | "formsubmissionget" => {
                        Ok(ClientNavigationReason::FormSubmissionGet)
                    }
                    "formSubmissionPost" | "FormSubmissionPost" | "formsubmissionpost" => {
                        Ok(ClientNavigationReason::FormSubmissionPost)
                    }
                    "httpHeaderRefresh" | "HttpHeaderRefresh" | "httpheaderrefresh" => {
                        Ok(ClientNavigationReason::HttpHeaderRefresh)
                    }
                    "scriptInitiated" | "ScriptInitiated" | "scriptinitiated" => {
                        Ok(ClientNavigationReason::ScriptInitiated)
                    }
                    "metaTagRefresh" | "MetaTagRefresh" | "metatagrefresh" => {
                        Ok(ClientNavigationReason::MetaTagRefresh)
                    }
                    "pageBlockInterstitial" | "PageBlockInterstitial" | "pageblockinterstitial" => {
                        Ok(ClientNavigationReason::PageBlockInterstitial)
                    }
                    "reload" | "Reload" => Ok(ClientNavigationReason::Reload),
                    "anchorClick" | "AnchorClick" | "anchorclick" => {
                        Ok(ClientNavigationReason::AnchorClick)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ClientNavigationDisposition {
            #[serde(rename = "currentTab")]
            CurrentTab,
            #[serde(rename = "newTab")]
            NewTab,
            #[serde(rename = "newWindow")]
            NewWindow,
            #[serde(rename = "download")]
            Download,
        }
        impl AsRef<str> for ClientNavigationDisposition {
            fn as_ref(&self) -> &str {
                match self {
                    ClientNavigationDisposition::CurrentTab => "currentTab",
                    ClientNavigationDisposition::NewTab => "newTab",
                    ClientNavigationDisposition::NewWindow => "newWindow",
                    ClientNavigationDisposition::Download => "download",
                }
            }
        }
        impl ::std::str::FromStr for ClientNavigationDisposition {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "currentTab" | "CurrentTab" | "currenttab" => {
                        Ok(ClientNavigationDisposition::CurrentTab)
                    }
                    "newTab" | "NewTab" | "newtab" => Ok(ClientNavigationDisposition::NewTab),
                    "newWindow" | "NewWindow" | "newwindow" => {
                        Ok(ClientNavigationDisposition::NewWindow)
                    }
                    "download" | "Download" => Ok(ClientNavigationDisposition::Download),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InstallabilityErrorArgument {
            #[doc = "Argument name (e.g. name:'minimum-icon-size-in-pixels')."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Argument value (e.g. value:'64')."]
            #[serde(rename = "value")]
            pub value: String,
        }
        impl InstallabilityErrorArgument {
            pub fn new(name: impl Into<String>, value: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                }
            }
        }
        impl InstallabilityErrorArgument {
            pub fn builder() -> InstallabilityErrorArgumentBuilder {
                InstallabilityErrorArgumentBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct InstallabilityErrorArgumentBuilder {
            name: Option<String>,
            value: Option<String>,
        }
        impl InstallabilityErrorArgumentBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<InstallabilityErrorArgument, String> {
                Ok(InstallabilityErrorArgument {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl InstallabilityErrorArgument {
            pub const IDENTIFIER: &'static str = "Page.InstallabilityErrorArgument";
        }
        #[doc = "The installability error\n[InstallabilityError](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-InstallabilityError)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InstallabilityError {
            #[doc = "The error id (e.g. 'manifest-missing-suitable-icon')."]
            #[serde(rename = "errorId")]
            pub error_id: String,
            #[doc = "The list of error arguments (e.g. {name:'minimum-icon-size-in-pixels', value:'64'})."]
            #[serde(rename = "errorArguments")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub error_arguments: Vec<InstallabilityErrorArgument>,
        }
        impl InstallabilityError {
            pub fn new(
                error_id: impl Into<String>,
                error_arguments: Vec<InstallabilityErrorArgument>,
            ) -> Self {
                Self {
                    error_id: error_id.into(),
                    error_arguments,
                }
            }
        }
        impl InstallabilityError {
            pub fn builder() -> InstallabilityErrorBuilder {
                InstallabilityErrorBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct InstallabilityErrorBuilder {
            error_id: Option<String>,
            error_arguments: Option<Vec<InstallabilityErrorArgument>>,
        }
        impl InstallabilityErrorBuilder {
            pub fn error_id(mut self, error_id: impl Into<String>) -> Self {
                self.error_id = Some(error_id.into());
                self
            }
            pub fn error_argument(
                mut self,
                error_argument: impl Into<InstallabilityErrorArgument>,
            ) -> Self {
                let v = self.error_arguments.get_or_insert(Vec::new());
                v.push(error_argument.into());
                self
            }
            pub fn error_arguments<I, S>(mut self, error_arguments: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<InstallabilityErrorArgument>,
            {
                let v = self.error_arguments.get_or_insert(Vec::new());
                for val in error_arguments {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<InstallabilityError, String> {
                Ok(InstallabilityError {
                    error_id: self.error_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(error_id))
                    })?,
                    error_arguments: self.error_arguments.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(error_arguments))
                    })?,
                })
            }
        }
        impl InstallabilityError {
            pub const IDENTIFIER: &'static str = "Page.InstallabilityError";
        }
        #[doc = "The referring-policy used for the navigation."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ReferrerPolicy {
            #[serde(rename = "noReferrer")]
            NoReferrer,
            #[serde(rename = "noReferrerWhenDowngrade")]
            NoReferrerWhenDowngrade,
            #[serde(rename = "origin")]
            Origin,
            #[serde(rename = "originWhenCrossOrigin")]
            OriginWhenCrossOrigin,
            #[serde(rename = "sameOrigin")]
            SameOrigin,
            #[serde(rename = "strictOrigin")]
            StrictOrigin,
            #[serde(rename = "strictOriginWhenCrossOrigin")]
            StrictOriginWhenCrossOrigin,
            #[serde(rename = "unsafeUrl")]
            UnsafeUrl,
        }
        impl AsRef<str> for ReferrerPolicy {
            fn as_ref(&self) -> &str {
                match self {
                    ReferrerPolicy::NoReferrer => "noReferrer",
                    ReferrerPolicy::NoReferrerWhenDowngrade => "noReferrerWhenDowngrade",
                    ReferrerPolicy::Origin => "origin",
                    ReferrerPolicy::OriginWhenCrossOrigin => "originWhenCrossOrigin",
                    ReferrerPolicy::SameOrigin => "sameOrigin",
                    ReferrerPolicy::StrictOrigin => "strictOrigin",
                    ReferrerPolicy::StrictOriginWhenCrossOrigin => "strictOriginWhenCrossOrigin",
                    ReferrerPolicy::UnsafeUrl => "unsafeUrl",
                }
            }
        }
        impl ::std::str::FromStr for ReferrerPolicy {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "noReferrer" | "NoReferrer" | "noreferrer" => Ok(ReferrerPolicy::NoReferrer),
                    "noReferrerWhenDowngrade"
                    | "NoReferrerWhenDowngrade"
                    | "noreferrerwhendowngrade" => Ok(ReferrerPolicy::NoReferrerWhenDowngrade),
                    "origin" | "Origin" => Ok(ReferrerPolicy::Origin),
                    "originWhenCrossOrigin" | "OriginWhenCrossOrigin" | "originwhencrossorigin" => {
                        Ok(ReferrerPolicy::OriginWhenCrossOrigin)
                    }
                    "sameOrigin" | "SameOrigin" | "sameorigin" => Ok(ReferrerPolicy::SameOrigin),
                    "strictOrigin" | "StrictOrigin" | "strictorigin" => {
                        Ok(ReferrerPolicy::StrictOrigin)
                    }
                    "strictOriginWhenCrossOrigin"
                    | "StrictOriginWhenCrossOrigin"
                    | "strictoriginwhencrossorigin" => {
                        Ok(ReferrerPolicy::StrictOriginWhenCrossOrigin)
                    }
                    "unsafeUrl" | "UnsafeUrl" | "unsafeurl" => Ok(ReferrerPolicy::UnsafeUrl),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Per-script compilation cache parameters for `Page.produceCompilationCache`\n[CompilationCacheParams](https://chromedevtools.github.io/devtools-protocol/tot/Page/#type-CompilationCacheParams)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CompilationCacheParams {
            #[doc = "The URL of the script to produce a compilation cache entry for."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "A hint to the backend whether eager compilation is recommended.\n(the actual compilation mode used is upon backend discretion)."]
            #[serde(rename = "eager")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub eager: Option<bool>,
        }
        impl CompilationCacheParams {
            pub fn new(url: impl Into<String>) -> Self {
                Self {
                    url: url.into(),
                    eager: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for CompilationCacheParams {
            fn from(url: T) -> Self {
                CompilationCacheParams::new(url)
            }
        }
        impl CompilationCacheParams {
            pub fn builder() -> CompilationCacheParamsBuilder {
                CompilationCacheParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CompilationCacheParamsBuilder {
            url: Option<String>,
            eager: Option<bool>,
        }
        impl CompilationCacheParamsBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn eager(mut self, eager: impl Into<bool>) -> Self {
                self.eager = Some(eager.into());
                self
            }
            pub fn build(self) -> Result<CompilationCacheParams, String> {
                Ok(CompilationCacheParams {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    eager: self.eager,
                })
            }
        }
        impl CompilationCacheParams {
            pub const IDENTIFIER: &'static str = "Page.CompilationCacheParams";
        }
        #[doc = "The type of a frameNavigated event."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum NavigationType {
            #[serde(rename = "Navigation")]
            Navigation,
            #[serde(rename = "BackForwardCacheRestore")]
            BackForwardCacheRestore,
        }
        impl AsRef<str> for NavigationType {
            fn as_ref(&self) -> &str {
                match self {
                    NavigationType::Navigation => "Navigation",
                    NavigationType::BackForwardCacheRestore => "BackForwardCacheRestore",
                }
            }
        }
        impl ::std::str::FromStr for NavigationType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Navigation" | "navigation" => Ok(NavigationType::Navigation),
                    "BackForwardCacheRestore" | "backforwardcacherestore" => {
                        Ok(NavigationType::BackForwardCacheRestore)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "List of not restored reasons for back-forward cache."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum BackForwardCacheNotRestoredReason {
            #[serde(rename = "NotPrimaryMainFrame")]
            NotPrimaryMainFrame,
            #[serde(rename = "BackForwardCacheDisabled")]
            BackForwardCacheDisabled,
            #[serde(rename = "RelatedActiveContentsExist")]
            RelatedActiveContentsExist,
            #[serde(rename = "HTTPStatusNotOK")]
            HttpStatusNotOk,
            #[serde(rename = "SchemeNotHTTPOrHTTPS")]
            SchemeNotHttpOrHttps,
            #[serde(rename = "Loading")]
            Loading,
            #[serde(rename = "WasGrantedMediaAccess")]
            WasGrantedMediaAccess,
            #[serde(rename = "DisableForRenderFrameHostCalled")]
            DisableForRenderFrameHostCalled,
            #[serde(rename = "DomainNotAllowed")]
            DomainNotAllowed,
            #[serde(rename = "HTTPMethodNotGET")]
            HttpMethodNotGet,
            #[serde(rename = "SubframeIsNavigating")]
            SubframeIsNavigating,
            #[serde(rename = "Timeout")]
            Timeout,
            #[serde(rename = "CacheLimit")]
            CacheLimit,
            #[serde(rename = "JavaScriptExecution")]
            JavaScriptExecution,
            #[serde(rename = "RendererProcessKilled")]
            RendererProcessKilled,
            #[serde(rename = "RendererProcessCrashed")]
            RendererProcessCrashed,
            #[serde(rename = "SchedulerTrackedFeatureUsed")]
            SchedulerTrackedFeatureUsed,
            #[serde(rename = "ConflictingBrowsingInstance")]
            ConflictingBrowsingInstance,
            #[serde(rename = "CacheFlushed")]
            CacheFlushed,
            #[serde(rename = "ServiceWorkerVersionActivation")]
            ServiceWorkerVersionActivation,
            #[serde(rename = "SessionRestored")]
            SessionRestored,
            #[serde(rename = "ServiceWorkerPostMessage")]
            ServiceWorkerPostMessage,
            #[serde(rename = "EnteredBackForwardCacheBeforeServiceWorkerHostAdded")]
            EnteredBackForwardCacheBeforeServiceWorkerHostAdded,
            #[serde(rename = "RenderFrameHostReused_SameSite")]
            RenderFrameHostReusedSameSite,
            #[serde(rename = "RenderFrameHostReused_CrossSite")]
            RenderFrameHostReusedCrossSite,
            #[serde(rename = "ServiceWorkerClaim")]
            ServiceWorkerClaim,
            #[serde(rename = "IgnoreEventAndEvict")]
            IgnoreEventAndEvict,
            #[serde(rename = "HaveInnerContents")]
            HaveInnerContents,
            #[serde(rename = "TimeoutPuttingInCache")]
            TimeoutPuttingInCache,
            #[serde(rename = "BackForwardCacheDisabledByLowMemory")]
            BackForwardCacheDisabledByLowMemory,
            #[serde(rename = "BackForwardCacheDisabledByCommandLine")]
            BackForwardCacheDisabledByCommandLine,
            #[serde(rename = "NetworkRequestDatapipeDrainedAsBytesConsumer")]
            NetworkRequestDatapipeDrainedAsBytesConsumer,
            #[serde(rename = "NetworkRequestRedirected")]
            NetworkRequestRedirected,
            #[serde(rename = "NetworkRequestTimeout")]
            NetworkRequestTimeout,
            #[serde(rename = "NetworkExceedsBufferLimit")]
            NetworkExceedsBufferLimit,
            #[serde(rename = "NavigationCancelledWhileRestoring")]
            NavigationCancelledWhileRestoring,
            #[serde(rename = "NotMostRecentNavigationEntry")]
            NotMostRecentNavigationEntry,
            #[serde(rename = "BackForwardCacheDisabledForPrerender")]
            BackForwardCacheDisabledForPrerender,
            #[serde(rename = "UserAgentOverrideDiffers")]
            UserAgentOverrideDiffers,
            #[serde(rename = "ForegroundCacheLimit")]
            ForegroundCacheLimit,
            #[serde(rename = "BrowsingInstanceNotSwapped")]
            BrowsingInstanceNotSwapped,
            #[serde(rename = "BackForwardCacheDisabledForDelegate")]
            BackForwardCacheDisabledForDelegate,
            #[serde(rename = "UnloadHandlerExistsInMainFrame")]
            UnloadHandlerExistsInMainFrame,
            #[serde(rename = "UnloadHandlerExistsInSubFrame")]
            UnloadHandlerExistsInSubFrame,
            #[serde(rename = "ServiceWorkerUnregistration")]
            ServiceWorkerUnregistration,
            #[serde(rename = "CacheControlNoStore")]
            CacheControlNoStore,
            #[serde(rename = "CacheControlNoStoreCookieModified")]
            CacheControlNoStoreCookieModified,
            #[serde(rename = "CacheControlNoStoreHTTPOnlyCookieModified")]
            CacheControlNoStoreHttpOnlyCookieModified,
            #[serde(rename = "NoResponseHead")]
            NoResponseHead,
            #[serde(rename = "Unknown")]
            Unknown,
            #[serde(rename = "ActivationNavigationsDisallowedForBug1234857")]
            ActivationNavigationsDisallowedForBug1234857,
            #[serde(rename = "ErrorDocument")]
            ErrorDocument,
            #[serde(rename = "FencedFramesEmbedder")]
            FencedFramesEmbedder,
            #[doc = "Blocklisted features"]
            #[serde(rename = "WebSocket")]
            WebSocket,
            #[serde(rename = "WebTransport")]
            WebTransport,
            #[serde(rename = "WebRTC")]
            WebRtc,
            #[serde(rename = "MainResourceHasCacheControlNoStore")]
            MainResourceHasCacheControlNoStore,
            #[serde(rename = "MainResourceHasCacheControlNoCache")]
            MainResourceHasCacheControlNoCache,
            #[serde(rename = "SubresourceHasCacheControlNoStore")]
            SubresourceHasCacheControlNoStore,
            #[serde(rename = "SubresourceHasCacheControlNoCache")]
            SubresourceHasCacheControlNoCache,
            #[serde(rename = "ContainsPlugins")]
            ContainsPlugins,
            #[serde(rename = "DocumentLoaded")]
            DocumentLoaded,
            #[serde(rename = "DedicatedWorkerOrWorklet")]
            DedicatedWorkerOrWorklet,
            #[serde(rename = "OutstandingNetworkRequestOthers")]
            OutstandingNetworkRequestOthers,
            #[serde(rename = "OutstandingIndexedDBTransaction")]
            OutstandingIndexedDbTransaction,
            #[serde(rename = "RequestedNotificationsPermission")]
            RequestedNotificationsPermission,
            #[serde(rename = "RequestedMIDIPermission")]
            RequestedMidiPermission,
            #[serde(rename = "RequestedAudioCapturePermission")]
            RequestedAudioCapturePermission,
            #[serde(rename = "RequestedVideoCapturePermission")]
            RequestedVideoCapturePermission,
            #[serde(rename = "RequestedBackForwardCacheBlockedSensors")]
            RequestedBackForwardCacheBlockedSensors,
            #[serde(rename = "RequestedBackgroundWorkPermission")]
            RequestedBackgroundWorkPermission,
            #[serde(rename = "BroadcastChannel")]
            BroadcastChannel,
            #[serde(rename = "IndexedDBConnection")]
            IndexedDbConnection,
            #[serde(rename = "WebXR")]
            WebXr,
            #[serde(rename = "SharedWorker")]
            SharedWorker,
            #[serde(rename = "WebLocks")]
            WebLocks,
            #[serde(rename = "WebHID")]
            WebHid,
            #[serde(rename = "WebShare")]
            WebShare,
            #[serde(rename = "RequestedStorageAccessGrant")]
            RequestedStorageAccessGrant,
            #[serde(rename = "WebNfc")]
            WebNfc,
            #[serde(rename = "OutstandingNetworkRequestFetch")]
            OutstandingNetworkRequestFetch,
            #[serde(rename = "OutstandingNetworkRequestXHR")]
            OutstandingNetworkRequestXhr,
            #[serde(rename = "AppBanner")]
            AppBanner,
            #[serde(rename = "Printing")]
            Printing,
            #[serde(rename = "WebDatabase")]
            WebDatabase,
            #[serde(rename = "PictureInPicture")]
            PictureInPicture,
            #[serde(rename = "Portal")]
            Portal,
            #[serde(rename = "SpeechRecognizer")]
            SpeechRecognizer,
            #[serde(rename = "IdleManager")]
            IdleManager,
            #[serde(rename = "PaymentManager")]
            PaymentManager,
            #[serde(rename = "SpeechSynthesis")]
            SpeechSynthesis,
            #[serde(rename = "KeyboardLock")]
            KeyboardLock,
            #[serde(rename = "WebOTPService")]
            WebOtpService,
            #[serde(rename = "OutstandingNetworkRequestDirectSocket")]
            OutstandingNetworkRequestDirectSocket,
            #[serde(rename = "InjectedJavascript")]
            InjectedJavascript,
            #[serde(rename = "InjectedStyleSheet")]
            InjectedStyleSheet,
            #[serde(rename = "Dummy")]
            Dummy,
            #[doc = "Disabled for render frame host reasons\nSee content/browser/renderer_host/back_forward_cache_disable.h for explanations."]
            #[serde(rename = "ContentSecurityHandler")]
            ContentSecurityHandler,
            #[serde(rename = "ContentWebAuthenticationAPI")]
            ContentWebAuthenticationApi,
            #[serde(rename = "ContentFileChooser")]
            ContentFileChooser,
            #[serde(rename = "ContentSerial")]
            ContentSerial,
            #[serde(rename = "ContentFileSystemAccess")]
            ContentFileSystemAccess,
            #[serde(rename = "ContentMediaDevicesDispatcherHost")]
            ContentMediaDevicesDispatcherHost,
            #[serde(rename = "ContentWebBluetooth")]
            ContentWebBluetooth,
            #[serde(rename = "ContentWebUSB")]
            ContentWebUsb,
            #[serde(rename = "ContentMediaSessionService")]
            ContentMediaSessionService,
            #[serde(rename = "ContentScreenReader")]
            ContentScreenReader,
            #[doc = "See components/back_forward_cache/back_forward_cache_disable.h for explanations."]
            #[serde(rename = "EmbedderPopupBlockerTabHelper")]
            EmbedderPopupBlockerTabHelper,
            #[serde(rename = "EmbedderSafeBrowsingTriggeredPopupBlocker")]
            EmbedderSafeBrowsingTriggeredPopupBlocker,
            #[serde(rename = "EmbedderSafeBrowsingThreatDetails")]
            EmbedderSafeBrowsingThreatDetails,
            #[serde(rename = "EmbedderAppBannerManager")]
            EmbedderAppBannerManager,
            #[serde(rename = "EmbedderDomDistillerViewerSource")]
            EmbedderDomDistillerViewerSource,
            #[serde(rename = "EmbedderDomDistillerSelfDeletingRequestDelegate")]
            EmbedderDomDistillerSelfDeletingRequestDelegate,
            #[serde(rename = "EmbedderOomInterventionTabHelper")]
            EmbedderOomInterventionTabHelper,
            #[serde(rename = "EmbedderOfflinePage")]
            EmbedderOfflinePage,
            #[serde(rename = "EmbedderChromePasswordManagerClientBindCredentialManager")]
            EmbedderChromePasswordManagerClientBindCredentialManager,
            #[serde(rename = "EmbedderPermissionRequestManager")]
            EmbedderPermissionRequestManager,
            #[serde(rename = "EmbedderModalDialog")]
            EmbedderModalDialog,
            #[serde(rename = "EmbedderExtensions")]
            EmbedderExtensions,
            #[serde(rename = "EmbedderExtensionMessaging")]
            EmbedderExtensionMessaging,
            #[serde(rename = "EmbedderExtensionMessagingForOpenPort")]
            EmbedderExtensionMessagingForOpenPort,
            #[serde(rename = "EmbedderExtensionSentMessageToCachedFrame")]
            EmbedderExtensionSentMessageToCachedFrame,
        }
        impl AsRef<str> for BackForwardCacheNotRestoredReason {
            fn as_ref(&self) -> &str {
                match self { BackForwardCacheNotRestoredReason :: NotPrimaryMainFrame => "NotPrimaryMainFrame" , BackForwardCacheNotRestoredReason :: BackForwardCacheDisabled => "BackForwardCacheDisabled" , BackForwardCacheNotRestoredReason :: RelatedActiveContentsExist => "RelatedActiveContentsExist" , BackForwardCacheNotRestoredReason :: HttpStatusNotOk => "HTTPStatusNotOK" , BackForwardCacheNotRestoredReason :: SchemeNotHttpOrHttps => "SchemeNotHTTPOrHTTPS" , BackForwardCacheNotRestoredReason :: Loading => "Loading" , BackForwardCacheNotRestoredReason :: WasGrantedMediaAccess => "WasGrantedMediaAccess" , BackForwardCacheNotRestoredReason :: DisableForRenderFrameHostCalled => "DisableForRenderFrameHostCalled" , BackForwardCacheNotRestoredReason :: DomainNotAllowed => "DomainNotAllowed" , BackForwardCacheNotRestoredReason :: HttpMethodNotGet => "HTTPMethodNotGET" , BackForwardCacheNotRestoredReason :: SubframeIsNavigating => "SubframeIsNavigating" , BackForwardCacheNotRestoredReason :: Timeout => "Timeout" , BackForwardCacheNotRestoredReason :: CacheLimit => "CacheLimit" , BackForwardCacheNotRestoredReason :: JavaScriptExecution => "JavaScriptExecution" , BackForwardCacheNotRestoredReason :: RendererProcessKilled => "RendererProcessKilled" , BackForwardCacheNotRestoredReason :: RendererProcessCrashed => "RendererProcessCrashed" , BackForwardCacheNotRestoredReason :: SchedulerTrackedFeatureUsed => "SchedulerTrackedFeatureUsed" , BackForwardCacheNotRestoredReason :: ConflictingBrowsingInstance => "ConflictingBrowsingInstance" , BackForwardCacheNotRestoredReason :: CacheFlushed => "CacheFlushed" , BackForwardCacheNotRestoredReason :: ServiceWorkerVersionActivation => "ServiceWorkerVersionActivation" , BackForwardCacheNotRestoredReason :: SessionRestored => "SessionRestored" , BackForwardCacheNotRestoredReason :: ServiceWorkerPostMessage => "ServiceWorkerPostMessage" , BackForwardCacheNotRestoredReason :: EnteredBackForwardCacheBeforeServiceWorkerHostAdded => "EnteredBackForwardCacheBeforeServiceWorkerHostAdded" , BackForwardCacheNotRestoredReason :: RenderFrameHostReusedSameSite => "RenderFrameHostReused_SameSite" , BackForwardCacheNotRestoredReason :: RenderFrameHostReusedCrossSite => "RenderFrameHostReused_CrossSite" , BackForwardCacheNotRestoredReason :: ServiceWorkerClaim => "ServiceWorkerClaim" , BackForwardCacheNotRestoredReason :: IgnoreEventAndEvict => "IgnoreEventAndEvict" , BackForwardCacheNotRestoredReason :: HaveInnerContents => "HaveInnerContents" , BackForwardCacheNotRestoredReason :: TimeoutPuttingInCache => "TimeoutPuttingInCache" , BackForwardCacheNotRestoredReason :: BackForwardCacheDisabledByLowMemory => "BackForwardCacheDisabledByLowMemory" , BackForwardCacheNotRestoredReason :: BackForwardCacheDisabledByCommandLine => "BackForwardCacheDisabledByCommandLine" , BackForwardCacheNotRestoredReason :: NetworkRequestDatapipeDrainedAsBytesConsumer => "NetworkRequestDatapipeDrainedAsBytesConsumer" , BackForwardCacheNotRestoredReason :: NetworkRequestRedirected => "NetworkRequestRedirected" , BackForwardCacheNotRestoredReason :: NetworkRequestTimeout => "NetworkRequestTimeout" , BackForwardCacheNotRestoredReason :: NetworkExceedsBufferLimit => "NetworkExceedsBufferLimit" , BackForwardCacheNotRestoredReason :: NavigationCancelledWhileRestoring => "NavigationCancelledWhileRestoring" , BackForwardCacheNotRestoredReason :: NotMostRecentNavigationEntry => "NotMostRecentNavigationEntry" , BackForwardCacheNotRestoredReason :: BackForwardCacheDisabledForPrerender => "BackForwardCacheDisabledForPrerender" , BackForwardCacheNotRestoredReason :: UserAgentOverrideDiffers => "UserAgentOverrideDiffers" , BackForwardCacheNotRestoredReason :: ForegroundCacheLimit => "ForegroundCacheLimit" , BackForwardCacheNotRestoredReason :: BrowsingInstanceNotSwapped => "BrowsingInstanceNotSwapped" , BackForwardCacheNotRestoredReason :: BackForwardCacheDisabledForDelegate => "BackForwardCacheDisabledForDelegate" , BackForwardCacheNotRestoredReason :: UnloadHandlerExistsInMainFrame => "UnloadHandlerExistsInMainFrame" , BackForwardCacheNotRestoredReason :: UnloadHandlerExistsInSubFrame => "UnloadHandlerExistsInSubFrame" , BackForwardCacheNotRestoredReason :: ServiceWorkerUnregistration => "ServiceWorkerUnregistration" , BackForwardCacheNotRestoredReason :: CacheControlNoStore => "CacheControlNoStore" , BackForwardCacheNotRestoredReason :: CacheControlNoStoreCookieModified => "CacheControlNoStoreCookieModified" , BackForwardCacheNotRestoredReason :: CacheControlNoStoreHttpOnlyCookieModified => "CacheControlNoStoreHTTPOnlyCookieModified" , BackForwardCacheNotRestoredReason :: NoResponseHead => "NoResponseHead" , BackForwardCacheNotRestoredReason :: Unknown => "Unknown" , BackForwardCacheNotRestoredReason :: ActivationNavigationsDisallowedForBug1234857 => "ActivationNavigationsDisallowedForBug1234857" , BackForwardCacheNotRestoredReason :: ErrorDocument => "ErrorDocument" , BackForwardCacheNotRestoredReason :: FencedFramesEmbedder => "FencedFramesEmbedder" , BackForwardCacheNotRestoredReason :: WebSocket => "WebSocket" , BackForwardCacheNotRestoredReason :: WebTransport => "WebTransport" , BackForwardCacheNotRestoredReason :: WebRtc => "WebRTC" , BackForwardCacheNotRestoredReason :: MainResourceHasCacheControlNoStore => "MainResourceHasCacheControlNoStore" , BackForwardCacheNotRestoredReason :: MainResourceHasCacheControlNoCache => "MainResourceHasCacheControlNoCache" , BackForwardCacheNotRestoredReason :: SubresourceHasCacheControlNoStore => "SubresourceHasCacheControlNoStore" , BackForwardCacheNotRestoredReason :: SubresourceHasCacheControlNoCache => "SubresourceHasCacheControlNoCache" , BackForwardCacheNotRestoredReason :: ContainsPlugins => "ContainsPlugins" , BackForwardCacheNotRestoredReason :: DocumentLoaded => "DocumentLoaded" , BackForwardCacheNotRestoredReason :: DedicatedWorkerOrWorklet => "DedicatedWorkerOrWorklet" , BackForwardCacheNotRestoredReason :: OutstandingNetworkRequestOthers => "OutstandingNetworkRequestOthers" , BackForwardCacheNotRestoredReason :: OutstandingIndexedDbTransaction => "OutstandingIndexedDBTransaction" , BackForwardCacheNotRestoredReason :: RequestedNotificationsPermission => "RequestedNotificationsPermission" , BackForwardCacheNotRestoredReason :: RequestedMidiPermission => "RequestedMIDIPermission" , BackForwardCacheNotRestoredReason :: RequestedAudioCapturePermission => "RequestedAudioCapturePermission" , BackForwardCacheNotRestoredReason :: RequestedVideoCapturePermission => "RequestedVideoCapturePermission" , BackForwardCacheNotRestoredReason :: RequestedBackForwardCacheBlockedSensors => "RequestedBackForwardCacheBlockedSensors" , BackForwardCacheNotRestoredReason :: RequestedBackgroundWorkPermission => "RequestedBackgroundWorkPermission" , BackForwardCacheNotRestoredReason :: BroadcastChannel => "BroadcastChannel" , BackForwardCacheNotRestoredReason :: IndexedDbConnection => "IndexedDBConnection" , BackForwardCacheNotRestoredReason :: WebXr => "WebXR" , BackForwardCacheNotRestoredReason :: SharedWorker => "SharedWorker" , BackForwardCacheNotRestoredReason :: WebLocks => "WebLocks" , BackForwardCacheNotRestoredReason :: WebHid => "WebHID" , BackForwardCacheNotRestoredReason :: WebShare => "WebShare" , BackForwardCacheNotRestoredReason :: RequestedStorageAccessGrant => "RequestedStorageAccessGrant" , BackForwardCacheNotRestoredReason :: WebNfc => "WebNfc" , BackForwardCacheNotRestoredReason :: OutstandingNetworkRequestFetch => "OutstandingNetworkRequestFetch" , BackForwardCacheNotRestoredReason :: OutstandingNetworkRequestXhr => "OutstandingNetworkRequestXHR" , BackForwardCacheNotRestoredReason :: AppBanner => "AppBanner" , BackForwardCacheNotRestoredReason :: Printing => "Printing" , BackForwardCacheNotRestoredReason :: WebDatabase => "WebDatabase" , BackForwardCacheNotRestoredReason :: PictureInPicture => "PictureInPicture" , BackForwardCacheNotRestoredReason :: Portal => "Portal" , BackForwardCacheNotRestoredReason :: SpeechRecognizer => "SpeechRecognizer" , BackForwardCacheNotRestoredReason :: IdleManager => "IdleManager" , BackForwardCacheNotRestoredReason :: PaymentManager => "PaymentManager" , BackForwardCacheNotRestoredReason :: SpeechSynthesis => "SpeechSynthesis" , BackForwardCacheNotRestoredReason :: KeyboardLock => "KeyboardLock" , BackForwardCacheNotRestoredReason :: WebOtpService => "WebOTPService" , BackForwardCacheNotRestoredReason :: OutstandingNetworkRequestDirectSocket => "OutstandingNetworkRequestDirectSocket" , BackForwardCacheNotRestoredReason :: InjectedJavascript => "InjectedJavascript" , BackForwardCacheNotRestoredReason :: InjectedStyleSheet => "InjectedStyleSheet" , BackForwardCacheNotRestoredReason :: Dummy => "Dummy" , BackForwardCacheNotRestoredReason :: ContentSecurityHandler => "ContentSecurityHandler" , BackForwardCacheNotRestoredReason :: ContentWebAuthenticationApi => "ContentWebAuthenticationAPI" , BackForwardCacheNotRestoredReason :: ContentFileChooser => "ContentFileChooser" , BackForwardCacheNotRestoredReason :: ContentSerial => "ContentSerial" , BackForwardCacheNotRestoredReason :: ContentFileSystemAccess => "ContentFileSystemAccess" , BackForwardCacheNotRestoredReason :: ContentMediaDevicesDispatcherHost => "ContentMediaDevicesDispatcherHost" , BackForwardCacheNotRestoredReason :: ContentWebBluetooth => "ContentWebBluetooth" , BackForwardCacheNotRestoredReason :: ContentWebUsb => "ContentWebUSB" , BackForwardCacheNotRestoredReason :: ContentMediaSessionService => "ContentMediaSessionService" , BackForwardCacheNotRestoredReason :: ContentScreenReader => "ContentScreenReader" , BackForwardCacheNotRestoredReason :: EmbedderPopupBlockerTabHelper => "EmbedderPopupBlockerTabHelper" , BackForwardCacheNotRestoredReason :: EmbedderSafeBrowsingTriggeredPopupBlocker => "EmbedderSafeBrowsingTriggeredPopupBlocker" , BackForwardCacheNotRestoredReason :: EmbedderSafeBrowsingThreatDetails => "EmbedderSafeBrowsingThreatDetails" , BackForwardCacheNotRestoredReason :: EmbedderAppBannerManager => "EmbedderAppBannerManager" , BackForwardCacheNotRestoredReason :: EmbedderDomDistillerViewerSource => "EmbedderDomDistillerViewerSource" , BackForwardCacheNotRestoredReason :: EmbedderDomDistillerSelfDeletingRequestDelegate => "EmbedderDomDistillerSelfDeletingRequestDelegate" , BackForwardCacheNotRestoredReason :: EmbedderOomInterventionTabHelper => "EmbedderOomInterventionTabHelper" , BackForwardCacheNotRestoredReason :: EmbedderOfflinePage => "EmbedderOfflinePage" , BackForwardCacheNotRestoredReason :: EmbedderChromePasswordManagerClientBindCredentialManager => "EmbedderChromePasswordManagerClientBindCredentialManager" , BackForwardCacheNotRestoredReason :: EmbedderPermissionRequestManager => "EmbedderPermissionRequestManager" , BackForwardCacheNotRestoredReason :: EmbedderModalDialog => "EmbedderModalDialog" , BackForwardCacheNotRestoredReason :: EmbedderExtensions => "EmbedderExtensions" , BackForwardCacheNotRestoredReason :: EmbedderExtensionMessaging => "EmbedderExtensionMessaging" , BackForwardCacheNotRestoredReason :: EmbedderExtensionMessagingForOpenPort => "EmbedderExtensionMessagingForOpenPort" , BackForwardCacheNotRestoredReason :: EmbedderExtensionSentMessageToCachedFrame => "EmbedderExtensionSentMessageToCachedFrame" }
            }
        }
        impl ::std::str::FromStr for BackForwardCacheNotRestoredReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s { "NotPrimaryMainFrame" | "notprimarymainframe" => Ok (BackForwardCacheNotRestoredReason :: NotPrimaryMainFrame) , "BackForwardCacheDisabled" | "backforwardcachedisabled" => Ok (BackForwardCacheNotRestoredReason :: BackForwardCacheDisabled) , "RelatedActiveContentsExist" | "relatedactivecontentsexist" => Ok (BackForwardCacheNotRestoredReason :: RelatedActiveContentsExist) , "HTTPStatusNotOK" | "HttpStatusNotOk" | "httpstatusnotok" => Ok (BackForwardCacheNotRestoredReason :: HttpStatusNotOk) , "SchemeNotHTTPOrHTTPS" | "SchemeNotHttpOrHttps" | "schemenothttporhttps" => Ok (BackForwardCacheNotRestoredReason :: SchemeNotHttpOrHttps) , "Loading" | "loading" => Ok (BackForwardCacheNotRestoredReason :: Loading) , "WasGrantedMediaAccess" | "wasgrantedmediaaccess" => Ok (BackForwardCacheNotRestoredReason :: WasGrantedMediaAccess) , "DisableForRenderFrameHostCalled" | "disableforrenderframehostcalled" => Ok (BackForwardCacheNotRestoredReason :: DisableForRenderFrameHostCalled) , "DomainNotAllowed" | "domainnotallowed" => Ok (BackForwardCacheNotRestoredReason :: DomainNotAllowed) , "HTTPMethodNotGET" | "HttpMethodNotGet" | "httpmethodnotget" => Ok (BackForwardCacheNotRestoredReason :: HttpMethodNotGet) , "SubframeIsNavigating" | "subframeisnavigating" => Ok (BackForwardCacheNotRestoredReason :: SubframeIsNavigating) , "Timeout" | "timeout" => Ok (BackForwardCacheNotRestoredReason :: Timeout) , "CacheLimit" | "cachelimit" => Ok (BackForwardCacheNotRestoredReason :: CacheLimit) , "JavaScriptExecution" | "javascriptexecution" => Ok (BackForwardCacheNotRestoredReason :: JavaScriptExecution) , "RendererProcessKilled" | "rendererprocesskilled" => Ok (BackForwardCacheNotRestoredReason :: RendererProcessKilled) , "RendererProcessCrashed" | "rendererprocesscrashed" => Ok (BackForwardCacheNotRestoredReason :: RendererProcessCrashed) , "SchedulerTrackedFeatureUsed" | "schedulertrackedfeatureused" => Ok (BackForwardCacheNotRestoredReason :: SchedulerTrackedFeatureUsed) , "ConflictingBrowsingInstance" | "conflictingbrowsinginstance" => Ok (BackForwardCacheNotRestoredReason :: ConflictingBrowsingInstance) , "CacheFlushed" | "cacheflushed" => Ok (BackForwardCacheNotRestoredReason :: CacheFlushed) , "ServiceWorkerVersionActivation" | "serviceworkerversionactivation" => Ok (BackForwardCacheNotRestoredReason :: ServiceWorkerVersionActivation) , "SessionRestored" | "sessionrestored" => Ok (BackForwardCacheNotRestoredReason :: SessionRestored) , "ServiceWorkerPostMessage" | "serviceworkerpostmessage" => Ok (BackForwardCacheNotRestoredReason :: ServiceWorkerPostMessage) , "EnteredBackForwardCacheBeforeServiceWorkerHostAdded" | "enteredbackforwardcachebeforeserviceworkerhostadded" => Ok (BackForwardCacheNotRestoredReason :: EnteredBackForwardCacheBeforeServiceWorkerHostAdded) , "RenderFrameHostReused_SameSite" | "RenderFrameHostReusedSameSite" | "renderframehostreused_samesite" => Ok (BackForwardCacheNotRestoredReason :: RenderFrameHostReusedSameSite) , "RenderFrameHostReused_CrossSite" | "RenderFrameHostReusedCrossSite" | "renderframehostreused_crosssite" => Ok (BackForwardCacheNotRestoredReason :: RenderFrameHostReusedCrossSite) , "ServiceWorkerClaim" | "serviceworkerclaim" => Ok (BackForwardCacheNotRestoredReason :: ServiceWorkerClaim) , "IgnoreEventAndEvict" | "ignoreeventandevict" => Ok (BackForwardCacheNotRestoredReason :: IgnoreEventAndEvict) , "HaveInnerContents" | "haveinnercontents" => Ok (BackForwardCacheNotRestoredReason :: HaveInnerContents) , "TimeoutPuttingInCache" | "timeoutputtingincache" => Ok (BackForwardCacheNotRestoredReason :: TimeoutPuttingInCache) , "BackForwardCacheDisabledByLowMemory" | "backforwardcachedisabledbylowmemory" => Ok (BackForwardCacheNotRestoredReason :: BackForwardCacheDisabledByLowMemory) , "BackForwardCacheDisabledByCommandLine" | "backforwardcachedisabledbycommandline" => Ok (BackForwardCacheNotRestoredReason :: BackForwardCacheDisabledByCommandLine) , "NetworkRequestDatapipeDrainedAsBytesConsumer" | "networkrequestdatapipedrainedasbytesconsumer" => Ok (BackForwardCacheNotRestoredReason :: NetworkRequestDatapipeDrainedAsBytesConsumer) , "NetworkRequestRedirected" | "networkrequestredirected" => Ok (BackForwardCacheNotRestoredReason :: NetworkRequestRedirected) , "NetworkRequestTimeout" | "networkrequesttimeout" => Ok (BackForwardCacheNotRestoredReason :: NetworkRequestTimeout) , "NetworkExceedsBufferLimit" | "networkexceedsbufferlimit" => Ok (BackForwardCacheNotRestoredReason :: NetworkExceedsBufferLimit) , "NavigationCancelledWhileRestoring" | "navigationcancelledwhilerestoring" => Ok (BackForwardCacheNotRestoredReason :: NavigationCancelledWhileRestoring) , "NotMostRecentNavigationEntry" | "notmostrecentnavigationentry" => Ok (BackForwardCacheNotRestoredReason :: NotMostRecentNavigationEntry) , "BackForwardCacheDisabledForPrerender" | "backforwardcachedisabledforprerender" => Ok (BackForwardCacheNotRestoredReason :: BackForwardCacheDisabledForPrerender) , "UserAgentOverrideDiffers" | "useragentoverridediffers" => Ok (BackForwardCacheNotRestoredReason :: UserAgentOverrideDiffers) , "ForegroundCacheLimit" | "foregroundcachelimit" => Ok (BackForwardCacheNotRestoredReason :: ForegroundCacheLimit) , "BrowsingInstanceNotSwapped" | "browsinginstancenotswapped" => Ok (BackForwardCacheNotRestoredReason :: BrowsingInstanceNotSwapped) , "BackForwardCacheDisabledForDelegate" | "backforwardcachedisabledfordelegate" => Ok (BackForwardCacheNotRestoredReason :: BackForwardCacheDisabledForDelegate) , "UnloadHandlerExistsInMainFrame" | "unloadhandlerexistsinmainframe" => Ok (BackForwardCacheNotRestoredReason :: UnloadHandlerExistsInMainFrame) , "UnloadHandlerExistsInSubFrame" | "unloadhandlerexistsinsubframe" => Ok (BackForwardCacheNotRestoredReason :: UnloadHandlerExistsInSubFrame) , "ServiceWorkerUnregistration" | "serviceworkerunregistration" => Ok (BackForwardCacheNotRestoredReason :: ServiceWorkerUnregistration) , "CacheControlNoStore" | "cachecontrolnostore" => Ok (BackForwardCacheNotRestoredReason :: CacheControlNoStore) , "CacheControlNoStoreCookieModified" | "cachecontrolnostorecookiemodified" => Ok (BackForwardCacheNotRestoredReason :: CacheControlNoStoreCookieModified) , "CacheControlNoStoreHTTPOnlyCookieModified" | "CacheControlNoStoreHttpOnlyCookieModified" | "cachecontrolnostorehttponlycookiemodified" => Ok (BackForwardCacheNotRestoredReason :: CacheControlNoStoreHttpOnlyCookieModified) , "NoResponseHead" | "noresponsehead" => Ok (BackForwardCacheNotRestoredReason :: NoResponseHead) , "Unknown" | "unknown" => Ok (BackForwardCacheNotRestoredReason :: Unknown) , "ActivationNavigationsDisallowedForBug1234857" | "activationnavigationsdisallowedforbug1234857" => Ok (BackForwardCacheNotRestoredReason :: ActivationNavigationsDisallowedForBug1234857) , "ErrorDocument" | "errordocument" => Ok (BackForwardCacheNotRestoredReason :: ErrorDocument) , "FencedFramesEmbedder" | "fencedframesembedder" => Ok (BackForwardCacheNotRestoredReason :: FencedFramesEmbedder) , "WebSocket" | "websocket" => Ok (BackForwardCacheNotRestoredReason :: WebSocket) , "WebTransport" | "webtransport" => Ok (BackForwardCacheNotRestoredReason :: WebTransport) , "WebRTC" | "WebRtc" | "webrtc" => Ok (BackForwardCacheNotRestoredReason :: WebRtc) , "MainResourceHasCacheControlNoStore" | "mainresourcehascachecontrolnostore" => Ok (BackForwardCacheNotRestoredReason :: MainResourceHasCacheControlNoStore) , "MainResourceHasCacheControlNoCache" | "mainresourcehascachecontrolnocache" => Ok (BackForwardCacheNotRestoredReason :: MainResourceHasCacheControlNoCache) , "SubresourceHasCacheControlNoStore" | "subresourcehascachecontrolnostore" => Ok (BackForwardCacheNotRestoredReason :: SubresourceHasCacheControlNoStore) , "SubresourceHasCacheControlNoCache" | "subresourcehascachecontrolnocache" => Ok (BackForwardCacheNotRestoredReason :: SubresourceHasCacheControlNoCache) , "ContainsPlugins" | "containsplugins" => Ok (BackForwardCacheNotRestoredReason :: ContainsPlugins) , "DocumentLoaded" | "documentloaded" => Ok (BackForwardCacheNotRestoredReason :: DocumentLoaded) , "DedicatedWorkerOrWorklet" | "dedicatedworkerorworklet" => Ok (BackForwardCacheNotRestoredReason :: DedicatedWorkerOrWorklet) , "OutstandingNetworkRequestOthers" | "outstandingnetworkrequestothers" => Ok (BackForwardCacheNotRestoredReason :: OutstandingNetworkRequestOthers) , "OutstandingIndexedDBTransaction" | "OutstandingIndexedDbTransaction" | "outstandingindexeddbtransaction" => Ok (BackForwardCacheNotRestoredReason :: OutstandingIndexedDbTransaction) , "RequestedNotificationsPermission" | "requestednotificationspermission" => Ok (BackForwardCacheNotRestoredReason :: RequestedNotificationsPermission) , "RequestedMIDIPermission" | "RequestedMidiPermission" | "requestedmidipermission" => Ok (BackForwardCacheNotRestoredReason :: RequestedMidiPermission) , "RequestedAudioCapturePermission" | "requestedaudiocapturepermission" => Ok (BackForwardCacheNotRestoredReason :: RequestedAudioCapturePermission) , "RequestedVideoCapturePermission" | "requestedvideocapturepermission" => Ok (BackForwardCacheNotRestoredReason :: RequestedVideoCapturePermission) , "RequestedBackForwardCacheBlockedSensors" | "requestedbackforwardcacheblockedsensors" => Ok (BackForwardCacheNotRestoredReason :: RequestedBackForwardCacheBlockedSensors) , "RequestedBackgroundWorkPermission" | "requestedbackgroundworkpermission" => Ok (BackForwardCacheNotRestoredReason :: RequestedBackgroundWorkPermission) , "BroadcastChannel" | "broadcastchannel" => Ok (BackForwardCacheNotRestoredReason :: BroadcastChannel) , "IndexedDBConnection" | "IndexedDbConnection" | "indexeddbconnection" => Ok (BackForwardCacheNotRestoredReason :: IndexedDbConnection) , "WebXR" | "WebXr" | "webxr" => Ok (BackForwardCacheNotRestoredReason :: WebXr) , "SharedWorker" | "sharedworker" => Ok (BackForwardCacheNotRestoredReason :: SharedWorker) , "WebLocks" | "weblocks" => Ok (BackForwardCacheNotRestoredReason :: WebLocks) , "WebHID" | "WebHid" | "webhid" => Ok (BackForwardCacheNotRestoredReason :: WebHid) , "WebShare" | "webshare" => Ok (BackForwardCacheNotRestoredReason :: WebShare) , "RequestedStorageAccessGrant" | "requestedstorageaccessgrant" => Ok (BackForwardCacheNotRestoredReason :: RequestedStorageAccessGrant) , "WebNfc" | "webnfc" => Ok (BackForwardCacheNotRestoredReason :: WebNfc) , "OutstandingNetworkRequestFetch" | "outstandingnetworkrequestfetch" => Ok (BackForwardCacheNotRestoredReason :: OutstandingNetworkRequestFetch) , "OutstandingNetworkRequestXHR" | "OutstandingNetworkRequestXhr" | "outstandingnetworkrequestxhr" => Ok (BackForwardCacheNotRestoredReason :: OutstandingNetworkRequestXhr) , "AppBanner" | "appbanner" => Ok (BackForwardCacheNotRestoredReason :: AppBanner) , "Printing" | "printing" => Ok (BackForwardCacheNotRestoredReason :: Printing) , "WebDatabase" | "webdatabase" => Ok (BackForwardCacheNotRestoredReason :: WebDatabase) , "PictureInPicture" | "pictureinpicture" => Ok (BackForwardCacheNotRestoredReason :: PictureInPicture) , "Portal" | "portal" => Ok (BackForwardCacheNotRestoredReason :: Portal) , "SpeechRecognizer" | "speechrecognizer" => Ok (BackForwardCacheNotRestoredReason :: SpeechRecognizer) , "IdleManager" | "idlemanager" => Ok (BackForwardCacheNotRestoredReason :: IdleManager) , "PaymentManager" | "paymentmanager" => Ok (BackForwardCacheNotRestoredReason :: PaymentManager) , "SpeechSynthesis" | "speechsynthesis" => Ok (BackForwardCacheNotRestoredReason :: SpeechSynthesis) , "KeyboardLock" | "keyboardlock" => Ok (BackForwardCacheNotRestoredReason :: KeyboardLock) , "WebOTPService" | "WebOtpService" | "webotpservice" => Ok (BackForwardCacheNotRestoredReason :: WebOtpService) , "OutstandingNetworkRequestDirectSocket" | "outstandingnetworkrequestdirectsocket" => Ok (BackForwardCacheNotRestoredReason :: OutstandingNetworkRequestDirectSocket) , "InjectedJavascript" | "injectedjavascript" => Ok (BackForwardCacheNotRestoredReason :: InjectedJavascript) , "InjectedStyleSheet" | "injectedstylesheet" => Ok (BackForwardCacheNotRestoredReason :: InjectedStyleSheet) , "Dummy" | "dummy" => Ok (BackForwardCacheNotRestoredReason :: Dummy) , "ContentSecurityHandler" | "contentsecurityhandler" => Ok (BackForwardCacheNotRestoredReason :: ContentSecurityHandler) , "ContentWebAuthenticationAPI" | "ContentWebAuthenticationApi" | "contentwebauthenticationapi" => Ok (BackForwardCacheNotRestoredReason :: ContentWebAuthenticationApi) , "ContentFileChooser" | "contentfilechooser" => Ok (BackForwardCacheNotRestoredReason :: ContentFileChooser) , "ContentSerial" | "contentserial" => Ok (BackForwardCacheNotRestoredReason :: ContentSerial) , "ContentFileSystemAccess" | "contentfilesystemaccess" => Ok (BackForwardCacheNotRestoredReason :: ContentFileSystemAccess) , "ContentMediaDevicesDispatcherHost" | "contentmediadevicesdispatcherhost" => Ok (BackForwardCacheNotRestoredReason :: ContentMediaDevicesDispatcherHost) , "ContentWebBluetooth" | "contentwebbluetooth" => Ok (BackForwardCacheNotRestoredReason :: ContentWebBluetooth) , "ContentWebUSB" | "ContentWebUsb" | "contentwebusb" => Ok (BackForwardCacheNotRestoredReason :: ContentWebUsb) , "ContentMediaSessionService" | "contentmediasessionservice" => Ok (BackForwardCacheNotRestoredReason :: ContentMediaSessionService) , "ContentScreenReader" | "contentscreenreader" => Ok (BackForwardCacheNotRestoredReason :: ContentScreenReader) , "EmbedderPopupBlockerTabHelper" | "embedderpopupblockertabhelper" => Ok (BackForwardCacheNotRestoredReason :: EmbedderPopupBlockerTabHelper) , "EmbedderSafeBrowsingTriggeredPopupBlocker" | "embeddersafebrowsingtriggeredpopupblocker" => Ok (BackForwardCacheNotRestoredReason :: EmbedderSafeBrowsingTriggeredPopupBlocker) , "EmbedderSafeBrowsingThreatDetails" | "embeddersafebrowsingthreatdetails" => Ok (BackForwardCacheNotRestoredReason :: EmbedderSafeBrowsingThreatDetails) , "EmbedderAppBannerManager" | "embedderappbannermanager" => Ok (BackForwardCacheNotRestoredReason :: EmbedderAppBannerManager) , "EmbedderDomDistillerViewerSource" | "embedderdomdistillerviewersource" => Ok (BackForwardCacheNotRestoredReason :: EmbedderDomDistillerViewerSource) , "EmbedderDomDistillerSelfDeletingRequestDelegate" | "embedderdomdistillerselfdeletingrequestdelegate" => Ok (BackForwardCacheNotRestoredReason :: EmbedderDomDistillerSelfDeletingRequestDelegate) , "EmbedderOomInterventionTabHelper" | "embedderoominterventiontabhelper" => Ok (BackForwardCacheNotRestoredReason :: EmbedderOomInterventionTabHelper) , "EmbedderOfflinePage" | "embedderofflinepage" => Ok (BackForwardCacheNotRestoredReason :: EmbedderOfflinePage) , "EmbedderChromePasswordManagerClientBindCredentialManager" | "embedderchromepasswordmanagerclientbindcredentialmanager" => Ok (BackForwardCacheNotRestoredReason :: EmbedderChromePasswordManagerClientBindCredentialManager) , "EmbedderPermissionRequestManager" | "embedderpermissionrequestmanager" => Ok (BackForwardCacheNotRestoredReason :: EmbedderPermissionRequestManager) , "EmbedderModalDialog" | "embeddermodaldialog" => Ok (BackForwardCacheNotRestoredReason :: EmbedderModalDialog) , "EmbedderExtensions" | "embedderextensions" => Ok (BackForwardCacheNotRestoredReason :: EmbedderExtensions) , "EmbedderExtensionMessaging" | "embedderextensionmessaging" => Ok (BackForwardCacheNotRestoredReason :: EmbedderExtensionMessaging) , "EmbedderExtensionMessagingForOpenPort" | "embedderextensionmessagingforopenport" => Ok (BackForwardCacheNotRestoredReason :: EmbedderExtensionMessagingForOpenPort) , "EmbedderExtensionSentMessageToCachedFrame" | "embedderextensionsentmessagetocachedframe" => Ok (BackForwardCacheNotRestoredReason :: EmbedderExtensionSentMessageToCachedFrame) , _ => Err (s . to_string ()) }
            }
        }
        #[doc = "Types of not restored reasons for back-forward cache."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum BackForwardCacheNotRestoredReasonType {
            #[serde(rename = "SupportPending")]
            SupportPending,
            #[serde(rename = "PageSupportNeeded")]
            PageSupportNeeded,
            #[serde(rename = "Circumstantial")]
            Circumstantial,
        }
        impl AsRef<str> for BackForwardCacheNotRestoredReasonType {
            fn as_ref(&self) -> &str {
                match self {
                    BackForwardCacheNotRestoredReasonType::SupportPending => "SupportPending",
                    BackForwardCacheNotRestoredReasonType::PageSupportNeeded => "PageSupportNeeded",
                    BackForwardCacheNotRestoredReasonType::Circumstantial => "Circumstantial",
                }
            }
        }
        impl ::std::str::FromStr for BackForwardCacheNotRestoredReasonType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "SupportPending" | "supportpending" => {
                        Ok(BackForwardCacheNotRestoredReasonType::SupportPending)
                    }
                    "PageSupportNeeded" | "pagesupportneeded" => {
                        Ok(BackForwardCacheNotRestoredReasonType::PageSupportNeeded)
                    }
                    "Circumstantial" | "circumstantial" => {
                        Ok(BackForwardCacheNotRestoredReasonType::Circumstantial)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct BackForwardCacheNotRestoredExplanation {
            #[doc = "Type of the reason"]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: BackForwardCacheNotRestoredReasonType,
            #[doc = "Not restored reason"]
            #[serde(rename = "reason")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub reason: BackForwardCacheNotRestoredReason,
            #[doc = "Context associated with the reason. The meaning of this context is\ndependent on the reason:\n- EmbedderExtensionSentMessageToCachedFrame: the extension ID.\n"]
            #[serde(rename = "context")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub context: Option<String>,
        }
        impl BackForwardCacheNotRestoredExplanation {
            pub fn new(
                r#type: impl Into<BackForwardCacheNotRestoredReasonType>,
                reason: impl Into<BackForwardCacheNotRestoredReason>,
            ) -> Self {
                Self {
                    r#type: r#type.into(),
                    reason: reason.into(),
                    context: None,
                }
            }
        }
        impl BackForwardCacheNotRestoredExplanation {
            pub fn builder() -> BackForwardCacheNotRestoredExplanationBuilder {
                BackForwardCacheNotRestoredExplanationBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BackForwardCacheNotRestoredExplanationBuilder {
            r#type: Option<BackForwardCacheNotRestoredReasonType>,
            reason: Option<BackForwardCacheNotRestoredReason>,
            context: Option<String>,
        }
        impl BackForwardCacheNotRestoredExplanationBuilder {
            pub fn r#type(
                mut self,
                r#type: impl Into<BackForwardCacheNotRestoredReasonType>,
            ) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn reason(mut self, reason: impl Into<BackForwardCacheNotRestoredReason>) -> Self {
                self.reason = Some(reason.into());
                self
            }
            pub fn context(mut self, context: impl Into<String>) -> Self {
                self.context = Some(context.into());
                self
            }
            pub fn build(self) -> Result<BackForwardCacheNotRestoredExplanation, String> {
                Ok(BackForwardCacheNotRestoredExplanation {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    reason: self.reason.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(reason))
                    })?,
                    context: self.context,
                })
            }
        }
        impl BackForwardCacheNotRestoredExplanation {
            pub const IDENTIFIER: &'static str = "Page.BackForwardCacheNotRestoredExplanation";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct BackForwardCacheNotRestoredExplanationTree {
            #[doc = "URL of each frame"]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Not restored reasons of each frame"]
            #[serde(rename = "explanations")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub explanations: Vec<BackForwardCacheNotRestoredExplanation>,
            #[doc = "Array of children frame"]
            #[serde(rename = "children")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub children: Vec<BackForwardCacheNotRestoredExplanationTree>,
        }
        impl BackForwardCacheNotRestoredExplanationTree {
            pub fn new(
                url: impl Into<String>,
                explanations: Vec<BackForwardCacheNotRestoredExplanation>,
                children: Vec<BackForwardCacheNotRestoredExplanationTree>,
            ) -> Self {
                Self {
                    url: url.into(),
                    explanations,
                    children,
                }
            }
        }
        impl BackForwardCacheNotRestoredExplanationTree {
            pub fn builder() -> BackForwardCacheNotRestoredExplanationTreeBuilder {
                BackForwardCacheNotRestoredExplanationTreeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BackForwardCacheNotRestoredExplanationTreeBuilder {
            url: Option<String>,
            explanations: Option<Vec<BackForwardCacheNotRestoredExplanation>>,
            children: Option<Vec<BackForwardCacheNotRestoredExplanationTree>>,
        }
        impl BackForwardCacheNotRestoredExplanationTreeBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn explanation(
                mut self,
                explanation: impl Into<BackForwardCacheNotRestoredExplanation>,
            ) -> Self {
                let v = self.explanations.get_or_insert(Vec::new());
                v.push(explanation.into());
                self
            }
            pub fn explanations<I, S>(mut self, explanations: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<BackForwardCacheNotRestoredExplanation>,
            {
                let v = self.explanations.get_or_insert(Vec::new());
                for val in explanations {
                    v.push(val.into());
                }
                self
            }
            pub fn children(
                mut self,
                children: impl Into<BackForwardCacheNotRestoredExplanationTree>,
            ) -> Self {
                let v = self.children.get_or_insert(Vec::new());
                v.push(children.into());
                self
            }
            pub fn childrens<I, S>(mut self, childrens: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<BackForwardCacheNotRestoredExplanationTree>,
            {
                let v = self.children.get_or_insert(Vec::new());
                for val in childrens {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<BackForwardCacheNotRestoredExplanationTree, String> {
                Ok(BackForwardCacheNotRestoredExplanationTree {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    explanations: self.explanations.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(explanations))
                    })?,
                    children: self.children.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(children))
                    })?,
                })
            }
        }
        impl BackForwardCacheNotRestoredExplanationTree {
            pub const IDENTIFIER: &'static str = "Page.BackForwardCacheNotRestoredExplanationTree";
        }
        #[doc = "List of FinalStatus reasons for Prerender2."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PrerenderFinalStatus {
            #[serde(rename = "Activated")]
            Activated,
            #[serde(rename = "Destroyed")]
            Destroyed,
            #[serde(rename = "LowEndDevice")]
            LowEndDevice,
            #[serde(rename = "CrossOriginRedirect")]
            CrossOriginRedirect,
            #[serde(rename = "CrossOriginNavigation")]
            CrossOriginNavigation,
            #[serde(rename = "InvalidSchemeRedirect")]
            InvalidSchemeRedirect,
            #[serde(rename = "InvalidSchemeNavigation")]
            InvalidSchemeNavigation,
            #[serde(rename = "InProgressNavigation")]
            InProgressNavigation,
            #[serde(rename = "NavigationRequestBlockedByCsp")]
            NavigationRequestBlockedByCsp,
            #[serde(rename = "MainFrameNavigation")]
            MainFrameNavigation,
            #[serde(rename = "MojoBinderPolicy")]
            MojoBinderPolicy,
            #[serde(rename = "RendererProcessCrashed")]
            RendererProcessCrashed,
            #[serde(rename = "RendererProcessKilled")]
            RendererProcessKilled,
            #[serde(rename = "Download")]
            Download,
            #[serde(rename = "TriggerDestroyed")]
            TriggerDestroyed,
            #[serde(rename = "NavigationNotCommitted")]
            NavigationNotCommitted,
            #[serde(rename = "NavigationBadHttpStatus")]
            NavigationBadHttpStatus,
            #[serde(rename = "ClientCertRequested")]
            ClientCertRequested,
            #[serde(rename = "NavigationRequestNetworkError")]
            NavigationRequestNetworkError,
            #[serde(rename = "MaxNumOfRunningPrerendersExceeded")]
            MaxNumOfRunningPrerendersExceeded,
            #[serde(rename = "CancelAllHostsForTesting")]
            CancelAllHostsForTesting,
            #[serde(rename = "DidFailLoad")]
            DidFailLoad,
            #[serde(rename = "Stop")]
            Stop,
            #[serde(rename = "SslCertificateError")]
            SslCertificateError,
            #[serde(rename = "LoginAuthRequested")]
            LoginAuthRequested,
            #[serde(rename = "UaChangeRequiresReload")]
            UaChangeRequiresReload,
            #[serde(rename = "BlockedByClient")]
            BlockedByClient,
            #[serde(rename = "AudioOutputDeviceRequested")]
            AudioOutputDeviceRequested,
            #[serde(rename = "MixedContent")]
            MixedContent,
            #[serde(rename = "TriggerBackgrounded")]
            TriggerBackgrounded,
            #[serde(rename = "EmbedderTriggeredAndSameOriginRedirected")]
            EmbedderTriggeredAndSameOriginRedirected,
            #[serde(rename = "EmbedderTriggeredAndCrossOriginRedirected")]
            EmbedderTriggeredAndCrossOriginRedirected,
            #[serde(rename = "MemoryLimitExceeded")]
            MemoryLimitExceeded,
            #[doc = "Prerenders can be cancelled when Chrome uses excessive memory. This is\nrecorded when it fails to get the memory usage."]
            #[serde(rename = "FailToGetMemoryUsage")]
            FailToGetMemoryUsage,
            #[serde(rename = "DataSaverEnabled")]
            DataSaverEnabled,
            #[serde(rename = "HasEffectiveUrl")]
            HasEffectiveUrl,
        }
        impl AsRef<str> for PrerenderFinalStatus {
            fn as_ref(&self) -> &str {
                match self {
                    PrerenderFinalStatus::Activated => "Activated",
                    PrerenderFinalStatus::Destroyed => "Destroyed",
                    PrerenderFinalStatus::LowEndDevice => "LowEndDevice",
                    PrerenderFinalStatus::CrossOriginRedirect => "CrossOriginRedirect",
                    PrerenderFinalStatus::CrossOriginNavigation => "CrossOriginNavigation",
                    PrerenderFinalStatus::InvalidSchemeRedirect => "InvalidSchemeRedirect",
                    PrerenderFinalStatus::InvalidSchemeNavigation => "InvalidSchemeNavigation",
                    PrerenderFinalStatus::InProgressNavigation => "InProgressNavigation",
                    PrerenderFinalStatus::NavigationRequestBlockedByCsp => {
                        "NavigationRequestBlockedByCsp"
                    }
                    PrerenderFinalStatus::MainFrameNavigation => "MainFrameNavigation",
                    PrerenderFinalStatus::MojoBinderPolicy => "MojoBinderPolicy",
                    PrerenderFinalStatus::RendererProcessCrashed => "RendererProcessCrashed",
                    PrerenderFinalStatus::RendererProcessKilled => "RendererProcessKilled",
                    PrerenderFinalStatus::Download => "Download",
                    PrerenderFinalStatus::TriggerDestroyed => "TriggerDestroyed",
                    PrerenderFinalStatus::NavigationNotCommitted => "NavigationNotCommitted",
                    PrerenderFinalStatus::NavigationBadHttpStatus => "NavigationBadHttpStatus",
                    PrerenderFinalStatus::ClientCertRequested => "ClientCertRequested",
                    PrerenderFinalStatus::NavigationRequestNetworkError => {
                        "NavigationRequestNetworkError"
                    }
                    PrerenderFinalStatus::MaxNumOfRunningPrerendersExceeded => {
                        "MaxNumOfRunningPrerendersExceeded"
                    }
                    PrerenderFinalStatus::CancelAllHostsForTesting => "CancelAllHostsForTesting",
                    PrerenderFinalStatus::DidFailLoad => "DidFailLoad",
                    PrerenderFinalStatus::Stop => "Stop",
                    PrerenderFinalStatus::SslCertificateError => "SslCertificateError",
                    PrerenderFinalStatus::LoginAuthRequested => "LoginAuthRequested",
                    PrerenderFinalStatus::UaChangeRequiresReload => "UaChangeRequiresReload",
                    PrerenderFinalStatus::BlockedByClient => "BlockedByClient",
                    PrerenderFinalStatus::AudioOutputDeviceRequested => {
                        "AudioOutputDeviceRequested"
                    }
                    PrerenderFinalStatus::MixedContent => "MixedContent",
                    PrerenderFinalStatus::TriggerBackgrounded => "TriggerBackgrounded",
                    PrerenderFinalStatus::EmbedderTriggeredAndSameOriginRedirected => {
                        "EmbedderTriggeredAndSameOriginRedirected"
                    }
                    PrerenderFinalStatus::EmbedderTriggeredAndCrossOriginRedirected => {
                        "EmbedderTriggeredAndCrossOriginRedirected"
                    }
                    PrerenderFinalStatus::MemoryLimitExceeded => "MemoryLimitExceeded",
                    PrerenderFinalStatus::FailToGetMemoryUsage => "FailToGetMemoryUsage",
                    PrerenderFinalStatus::DataSaverEnabled => "DataSaverEnabled",
                    PrerenderFinalStatus::HasEffectiveUrl => "HasEffectiveUrl",
                }
            }
        }
        impl ::std::str::FromStr for PrerenderFinalStatus {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Activated" | "activated" => Ok(PrerenderFinalStatus::Activated),
                    "Destroyed" | "destroyed" => Ok(PrerenderFinalStatus::Destroyed),
                    "LowEndDevice" | "lowenddevice" => Ok(PrerenderFinalStatus::LowEndDevice),
                    "CrossOriginRedirect" | "crossoriginredirect" => {
                        Ok(PrerenderFinalStatus::CrossOriginRedirect)
                    }
                    "CrossOriginNavigation" | "crossoriginnavigation" => {
                        Ok(PrerenderFinalStatus::CrossOriginNavigation)
                    }
                    "InvalidSchemeRedirect" | "invalidschemeredirect" => {
                        Ok(PrerenderFinalStatus::InvalidSchemeRedirect)
                    }
                    "InvalidSchemeNavigation" | "invalidschemenavigation" => {
                        Ok(PrerenderFinalStatus::InvalidSchemeNavigation)
                    }
                    "InProgressNavigation" | "inprogressnavigation" => {
                        Ok(PrerenderFinalStatus::InProgressNavigation)
                    }
                    "NavigationRequestBlockedByCsp" | "navigationrequestblockedbycsp" => {
                        Ok(PrerenderFinalStatus::NavigationRequestBlockedByCsp)
                    }
                    "MainFrameNavigation" | "mainframenavigation" => {
                        Ok(PrerenderFinalStatus::MainFrameNavigation)
                    }
                    "MojoBinderPolicy" | "mojobinderpolicy" => {
                        Ok(PrerenderFinalStatus::MojoBinderPolicy)
                    }
                    "RendererProcessCrashed" | "rendererprocesscrashed" => {
                        Ok(PrerenderFinalStatus::RendererProcessCrashed)
                    }
                    "RendererProcessKilled" | "rendererprocesskilled" => {
                        Ok(PrerenderFinalStatus::RendererProcessKilled)
                    }
                    "Download" | "download" => Ok(PrerenderFinalStatus::Download),
                    "TriggerDestroyed" | "triggerdestroyed" => {
                        Ok(PrerenderFinalStatus::TriggerDestroyed)
                    }
                    "NavigationNotCommitted" | "navigationnotcommitted" => {
                        Ok(PrerenderFinalStatus::NavigationNotCommitted)
                    }
                    "NavigationBadHttpStatus" | "navigationbadhttpstatus" => {
                        Ok(PrerenderFinalStatus::NavigationBadHttpStatus)
                    }
                    "ClientCertRequested" | "clientcertrequested" => {
                        Ok(PrerenderFinalStatus::ClientCertRequested)
                    }
                    "NavigationRequestNetworkError" | "navigationrequestnetworkerror" => {
                        Ok(PrerenderFinalStatus::NavigationRequestNetworkError)
                    }
                    "MaxNumOfRunningPrerendersExceeded" | "maxnumofrunningprerendersexceeded" => {
                        Ok(PrerenderFinalStatus::MaxNumOfRunningPrerendersExceeded)
                    }
                    "CancelAllHostsForTesting" | "cancelallhostsfortesting" => {
                        Ok(PrerenderFinalStatus::CancelAllHostsForTesting)
                    }
                    "DidFailLoad" | "didfailload" => Ok(PrerenderFinalStatus::DidFailLoad),
                    "Stop" | "stop" => Ok(PrerenderFinalStatus::Stop),
                    "SslCertificateError" | "sslcertificateerror" => {
                        Ok(PrerenderFinalStatus::SslCertificateError)
                    }
                    "LoginAuthRequested" | "loginauthrequested" => {
                        Ok(PrerenderFinalStatus::LoginAuthRequested)
                    }
                    "UaChangeRequiresReload" | "uachangerequiresreload" => {
                        Ok(PrerenderFinalStatus::UaChangeRequiresReload)
                    }
                    "BlockedByClient" | "blockedbyclient" => {
                        Ok(PrerenderFinalStatus::BlockedByClient)
                    }
                    "AudioOutputDeviceRequested" | "audiooutputdevicerequested" => {
                        Ok(PrerenderFinalStatus::AudioOutputDeviceRequested)
                    }
                    "MixedContent" | "mixedcontent" => Ok(PrerenderFinalStatus::MixedContent),
                    "TriggerBackgrounded" | "triggerbackgrounded" => {
                        Ok(PrerenderFinalStatus::TriggerBackgrounded)
                    }
                    "EmbedderTriggeredAndSameOriginRedirected"
                    | "embeddertriggeredandsameoriginredirected" => {
                        Ok(PrerenderFinalStatus::EmbedderTriggeredAndSameOriginRedirected)
                    }
                    "EmbedderTriggeredAndCrossOriginRedirected"
                    | "embeddertriggeredandcrossoriginredirected" => {
                        Ok(PrerenderFinalStatus::EmbedderTriggeredAndCrossOriginRedirected)
                    }
                    "MemoryLimitExceeded" | "memorylimitexceeded" => {
                        Ok(PrerenderFinalStatus::MemoryLimitExceeded)
                    }
                    "FailToGetMemoryUsage" | "failtogetmemoryusage" => {
                        Ok(PrerenderFinalStatus::FailToGetMemoryUsage)
                    }
                    "DataSaverEnabled" | "datasaverenabled" => {
                        Ok(PrerenderFinalStatus::DataSaverEnabled)
                    }
                    "HasEffectiveUrl" | "haseffectiveurl" => {
                        Ok(PrerenderFinalStatus::HasEffectiveUrl)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Evaluates given script in every frame upon creation (before loading frame's scripts).\n[addScriptToEvaluateOnNewDocument](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-addScriptToEvaluateOnNewDocument)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AddScriptToEvaluateOnNewDocumentParams {
            #[serde(rename = "source")]
            pub source: String,
            #[doc = "If specified, creates an isolated world with the given name and evaluates given script in it.\nThis world name will be used as the ExecutionContextDescription::name when the corresponding\nevent is emitted."]
            #[serde(rename = "worldName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub world_name: Option<String>,
            #[doc = "Specifies whether command line API should be available to the script, defaults\nto false."]
            #[serde(rename = "includeCommandLineAPI")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub include_command_line_api: Option<bool>,
        }
        impl AddScriptToEvaluateOnNewDocumentParams {
            pub fn new(source: impl Into<String>) -> Self {
                Self {
                    source: source.into(),
                    world_name: None,
                    include_command_line_api: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for AddScriptToEvaluateOnNewDocumentParams {
            fn from(url: T) -> Self {
                AddScriptToEvaluateOnNewDocumentParams::new(url)
            }
        }
        impl AddScriptToEvaluateOnNewDocumentParams {
            pub fn builder() -> AddScriptToEvaluateOnNewDocumentParamsBuilder {
                AddScriptToEvaluateOnNewDocumentParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AddScriptToEvaluateOnNewDocumentParamsBuilder {
            source: Option<String>,
            world_name: Option<String>,
            include_command_line_api: Option<bool>,
        }
        impl AddScriptToEvaluateOnNewDocumentParamsBuilder {
            pub fn source(mut self, source: impl Into<String>) -> Self {
                self.source = Some(source.into());
                self
            }
            pub fn world_name(mut self, world_name: impl Into<String>) -> Self {
                self.world_name = Some(world_name.into());
                self
            }
            pub fn include_command_line_api(
                mut self,
                include_command_line_api: impl Into<bool>,
            ) -> Self {
                self.include_command_line_api = Some(include_command_line_api.into());
                self
            }
            pub fn build(self) -> Result<AddScriptToEvaluateOnNewDocumentParams, String> {
                Ok(AddScriptToEvaluateOnNewDocumentParams {
                    source: self.source.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(source))
                    })?,
                    world_name: self.world_name,
                    include_command_line_api: self.include_command_line_api,
                })
            }
        }
        impl AddScriptToEvaluateOnNewDocumentParams {
            pub const IDENTIFIER: &'static str = "Page.addScriptToEvaluateOnNewDocument";
        }
        impl chromiumoxide_types::Method for AddScriptToEvaluateOnNewDocumentParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for AddScriptToEvaluateOnNewDocumentParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Evaluates given script in every frame upon creation (before loading frame's scripts).\n[addScriptToEvaluateOnNewDocument](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-addScriptToEvaluateOnNewDocument)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AddScriptToEvaluateOnNewDocumentReturns {
            #[doc = "Identifier of the added script."]
            #[serde(rename = "identifier")]
            pub identifier: ScriptIdentifier,
        }
        impl AddScriptToEvaluateOnNewDocumentReturns {
            pub fn new(identifier: impl Into<ScriptIdentifier>) -> Self {
                Self {
                    identifier: identifier.into(),
                }
            }
        }
        impl AddScriptToEvaluateOnNewDocumentReturns {
            pub fn builder() -> AddScriptToEvaluateOnNewDocumentReturnsBuilder {
                AddScriptToEvaluateOnNewDocumentReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AddScriptToEvaluateOnNewDocumentReturnsBuilder {
            identifier: Option<ScriptIdentifier>,
        }
        impl AddScriptToEvaluateOnNewDocumentReturnsBuilder {
            pub fn identifier(mut self, identifier: impl Into<ScriptIdentifier>) -> Self {
                self.identifier = Some(identifier.into());
                self
            }
            pub fn build(self) -> Result<AddScriptToEvaluateOnNewDocumentReturns, String> {
                Ok(AddScriptToEvaluateOnNewDocumentReturns {
                    identifier: self.identifier.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(identifier))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for AddScriptToEvaluateOnNewDocumentParams {
            type Response = AddScriptToEvaluateOnNewDocumentReturns;
        }
        #[doc = "Brings page to front (activates tab).\n[bringToFront](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-bringToFront)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct BringToFrontParams {}
        impl BringToFrontParams {
            pub const IDENTIFIER: &'static str = "Page.bringToFront";
        }
        impl chromiumoxide_types::Method for BringToFrontParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for BringToFrontParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Brings page to front (activates tab).\n[bringToFront](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-bringToFront)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct BringToFrontReturns {}
        impl chromiumoxide_types::Command for BringToFrontParams {
            type Response = BringToFrontReturns;
        }
        #[doc = "Capture page screenshot.\n[captureScreenshot](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-captureScreenshot)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CaptureScreenshotParams {
            #[doc = "Image compression format (defaults to png)."]
            #[serde(rename = "format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub format: Option<CaptureScreenshotFormat>,
            #[doc = "Compression quality from range [0..100] (jpeg only)."]
            #[serde(rename = "quality")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub quality: Option<i64>,
            #[doc = "Capture the screenshot of a given region only."]
            #[serde(rename = "clip")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub clip: Option<Viewport>,
            #[doc = "Capture the screenshot from the surface, rather than the view. Defaults to true."]
            #[serde(rename = "fromSurface")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub from_surface: Option<bool>,
            #[doc = "Capture the screenshot beyond the viewport. Defaults to false."]
            #[serde(rename = "captureBeyondViewport")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub capture_beyond_viewport: Option<bool>,
        }
        #[doc = "Image compression format (defaults to png)."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CaptureScreenshotFormat {
            #[serde(rename = "jpeg")]
            Jpeg,
            #[serde(rename = "png")]
            Png,
            #[serde(rename = "webp")]
            Webp,
        }
        impl AsRef<str> for CaptureScreenshotFormat {
            fn as_ref(&self) -> &str {
                match self {
                    CaptureScreenshotFormat::Jpeg => "jpeg",
                    CaptureScreenshotFormat::Png => "png",
                    CaptureScreenshotFormat::Webp => "webp",
                }
            }
        }
        impl ::std::str::FromStr for CaptureScreenshotFormat {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "jpeg" | "Jpeg" => Ok(CaptureScreenshotFormat::Jpeg),
                    "png" | "Png" => Ok(CaptureScreenshotFormat::Png),
                    "webp" | "Webp" => Ok(CaptureScreenshotFormat::Webp),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl CaptureScreenshotParams {
            pub fn builder() -> CaptureScreenshotParamsBuilder {
                CaptureScreenshotParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CaptureScreenshotParamsBuilder {
            format: Option<CaptureScreenshotFormat>,
            quality: Option<i64>,
            clip: Option<Viewport>,
            from_surface: Option<bool>,
            capture_beyond_viewport: Option<bool>,
        }
        impl CaptureScreenshotParamsBuilder {
            pub fn format(mut self, format: impl Into<CaptureScreenshotFormat>) -> Self {
                self.format = Some(format.into());
                self
            }
            pub fn quality(mut self, quality: impl Into<i64>) -> Self {
                self.quality = Some(quality.into());
                self
            }
            pub fn clip(mut self, clip: impl Into<Viewport>) -> Self {
                self.clip = Some(clip.into());
                self
            }
            pub fn from_surface(mut self, from_surface: impl Into<bool>) -> Self {
                self.from_surface = Some(from_surface.into());
                self
            }
            pub fn capture_beyond_viewport(
                mut self,
                capture_beyond_viewport: impl Into<bool>,
            ) -> Self {
                self.capture_beyond_viewport = Some(capture_beyond_viewport.into());
                self
            }
            pub fn build(self) -> CaptureScreenshotParams {
                CaptureScreenshotParams {
                    format: self.format,
                    quality: self.quality,
                    clip: self.clip,
                    from_surface: self.from_surface,
                    capture_beyond_viewport: self.capture_beyond_viewport,
                }
            }
        }
        impl CaptureScreenshotParams {
            pub const IDENTIFIER: &'static str = "Page.captureScreenshot";
        }
        impl chromiumoxide_types::Method for CaptureScreenshotParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CaptureScreenshotParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Capture page screenshot.\n[captureScreenshot](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-captureScreenshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CaptureScreenshotReturns {
            #[doc = "Base64-encoded image data."]
            #[serde(rename = "data")]
            pub data: chromiumoxide_types::Binary,
        }
        impl CaptureScreenshotReturns {
            pub fn new(data: impl Into<chromiumoxide_types::Binary>) -> Self {
                Self { data: data.into() }
            }
        }
        impl CaptureScreenshotReturns {
            pub fn builder() -> CaptureScreenshotReturnsBuilder {
                CaptureScreenshotReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CaptureScreenshotReturnsBuilder {
            data: Option<chromiumoxide_types::Binary>,
        }
        impl CaptureScreenshotReturnsBuilder {
            pub fn data(mut self, data: impl Into<chromiumoxide_types::Binary>) -> Self {
                self.data = Some(data.into());
                self
            }
            pub fn build(self) -> Result<CaptureScreenshotReturns, String> {
                Ok(CaptureScreenshotReturns {
                    data: self.data.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(data))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for CaptureScreenshotParams {
            type Response = CaptureScreenshotReturns;
        }
        #[doc = "Returns a snapshot of the page as a string. For MHTML format, the serialization includes\niframes, shadow DOM, external resources, and element-inline styles.\n[captureSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-captureSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CaptureSnapshotParams {
            #[doc = "Format (defaults to mhtml)."]
            #[serde(rename = "format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub format: Option<CaptureSnapshotFormat>,
        }
        #[doc = "Format (defaults to mhtml)."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CaptureSnapshotFormat {
            #[serde(rename = "mhtml")]
            Mhtml,
        }
        impl AsRef<str> for CaptureSnapshotFormat {
            fn as_ref(&self) -> &str {
                match self {
                    CaptureSnapshotFormat::Mhtml => "mhtml",
                }
            }
        }
        impl ::std::str::FromStr for CaptureSnapshotFormat {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "mhtml" | "Mhtml" => Ok(CaptureSnapshotFormat::Mhtml),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl CaptureSnapshotParams {
            pub fn builder() -> CaptureSnapshotParamsBuilder {
                CaptureSnapshotParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CaptureSnapshotParamsBuilder {
            format: Option<CaptureSnapshotFormat>,
        }
        impl CaptureSnapshotParamsBuilder {
            pub fn format(mut self, format: impl Into<CaptureSnapshotFormat>) -> Self {
                self.format = Some(format.into());
                self
            }
            pub fn build(self) -> CaptureSnapshotParams {
                CaptureSnapshotParams {
                    format: self.format,
                }
            }
        }
        impl CaptureSnapshotParams {
            pub const IDENTIFIER: &'static str = "Page.captureSnapshot";
        }
        impl chromiumoxide_types::Method for CaptureSnapshotParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CaptureSnapshotParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns a snapshot of the page as a string. For MHTML format, the serialization includes\niframes, shadow DOM, external resources, and element-inline styles.\n[captureSnapshot](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-captureSnapshot)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CaptureSnapshotReturns {
            #[doc = "Serialized page data."]
            #[serde(rename = "data")]
            pub data: String,
        }
        impl CaptureSnapshotReturns {
            pub fn new(data: impl Into<String>) -> Self {
                Self { data: data.into() }
            }
        }
        impl<T: Into<String>> From<T> for CaptureSnapshotReturns {
            fn from(url: T) -> Self {
                CaptureSnapshotReturns::new(url)
            }
        }
        impl CaptureSnapshotReturns {
            pub fn builder() -> CaptureSnapshotReturnsBuilder {
                CaptureSnapshotReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CaptureSnapshotReturnsBuilder {
            data: Option<String>,
        }
        impl CaptureSnapshotReturnsBuilder {
            pub fn data(mut self, data: impl Into<String>) -> Self {
                self.data = Some(data.into());
                self
            }
            pub fn build(self) -> Result<CaptureSnapshotReturns, String> {
                Ok(CaptureSnapshotReturns {
                    data: self.data.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(data))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for CaptureSnapshotParams {
            type Response = CaptureSnapshotReturns;
        }
        #[doc = "Creates an isolated world for the given frame.\n[createIsolatedWorld](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-createIsolatedWorld)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CreateIsolatedWorldParams {
            #[doc = "Id of the frame in which the isolated world should be created."]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
            #[doc = "An optional name which is reported in the Execution Context."]
            #[serde(rename = "worldName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub world_name: Option<String>,
            #[doc = "Whether or not universal access should be granted to the isolated world. This is a powerful\noption, use with caution."]
            #[serde(rename = "grantUniveralAccess")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub grant_univeral_access: Option<bool>,
        }
        impl CreateIsolatedWorldParams {
            pub fn new(frame_id: impl Into<FrameId>) -> Self {
                Self {
                    frame_id: frame_id.into(),
                    world_name: None,
                    grant_univeral_access: None,
                }
            }
        }
        impl CreateIsolatedWorldParams {
            pub fn builder() -> CreateIsolatedWorldParamsBuilder {
                CreateIsolatedWorldParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CreateIsolatedWorldParamsBuilder {
            frame_id: Option<FrameId>,
            world_name: Option<String>,
            grant_univeral_access: Option<bool>,
        }
        impl CreateIsolatedWorldParamsBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn world_name(mut self, world_name: impl Into<String>) -> Self {
                self.world_name = Some(world_name.into());
                self
            }
            pub fn grant_univeral_access(mut self, grant_univeral_access: impl Into<bool>) -> Self {
                self.grant_univeral_access = Some(grant_univeral_access.into());
                self
            }
            pub fn build(self) -> Result<CreateIsolatedWorldParams, String> {
                Ok(CreateIsolatedWorldParams {
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                    world_name: self.world_name,
                    grant_univeral_access: self.grant_univeral_access,
                })
            }
        }
        impl CreateIsolatedWorldParams {
            pub const IDENTIFIER: &'static str = "Page.createIsolatedWorld";
        }
        impl chromiumoxide_types::Method for CreateIsolatedWorldParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CreateIsolatedWorldParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Creates an isolated world for the given frame.\n[createIsolatedWorld](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-createIsolatedWorld)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CreateIsolatedWorldReturns {
            #[doc = "Execution context of the isolated world."]
            #[serde(rename = "executionContextId")]
            pub execution_context_id: super::super::js_protocol::runtime::ExecutionContextId,
        }
        impl CreateIsolatedWorldReturns {
            pub fn new(
                execution_context_id: impl Into<super::super::js_protocol::runtime::ExecutionContextId>,
            ) -> Self {
                Self {
                    execution_context_id: execution_context_id.into(),
                }
            }
        }
        impl CreateIsolatedWorldReturns {
            pub fn builder() -> CreateIsolatedWorldReturnsBuilder {
                CreateIsolatedWorldReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CreateIsolatedWorldReturnsBuilder {
            execution_context_id: Option<super::super::js_protocol::runtime::ExecutionContextId>,
        }
        impl CreateIsolatedWorldReturnsBuilder {
            pub fn execution_context_id(
                mut self,
                execution_context_id: impl Into<super::super::js_protocol::runtime::ExecutionContextId>,
            ) -> Self {
                self.execution_context_id = Some(execution_context_id.into());
                self
            }
            pub fn build(self) -> Result<CreateIsolatedWorldReturns, String> {
                Ok(CreateIsolatedWorldReturns {
                    execution_context_id: self.execution_context_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(execution_context_id)
                        )
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for CreateIsolatedWorldParams {
            type Response = CreateIsolatedWorldReturns;
        }
        #[doc = "Disables page domain notifications.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Page.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables page domain notifications.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables page domain notifications.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Page.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables page domain notifications.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetAppManifestParams {}
        impl GetAppManifestParams {
            pub const IDENTIFIER: &'static str = "Page.getAppManifest";
        }
        impl chromiumoxide_types::Method for GetAppManifestParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetAppManifestParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetAppManifestReturns {
            #[doc = "Manifest location."]
            #[serde(rename = "url")]
            pub url: String,
            #[serde(rename = "errors")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub errors: Vec<AppManifestError>,
            #[doc = "Manifest content."]
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub data: Option<String>,
            #[doc = "Parsed manifest properties"]
            #[serde(rename = "parsed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub parsed: Option<AppManifestParsedProperties>,
        }
        impl GetAppManifestReturns {
            pub fn new(url: impl Into<String>, errors: Vec<AppManifestError>) -> Self {
                Self {
                    url: url.into(),
                    errors,
                    data: None,
                    parsed: None,
                }
            }
        }
        impl GetAppManifestReturns {
            pub fn builder() -> GetAppManifestReturnsBuilder {
                GetAppManifestReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetAppManifestReturnsBuilder {
            url: Option<String>,
            errors: Option<Vec<AppManifestError>>,
            data: Option<String>,
            parsed: Option<AppManifestParsedProperties>,
        }
        impl GetAppManifestReturnsBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn error(mut self, error: impl Into<AppManifestError>) -> Self {
                let v = self.errors.get_or_insert(Vec::new());
                v.push(error.into());
                self
            }
            pub fn errors<I, S>(mut self, errors: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<AppManifestError>,
            {
                let v = self.errors.get_or_insert(Vec::new());
                for val in errors {
                    v.push(val.into());
                }
                self
            }
            pub fn data(mut self, data: impl Into<String>) -> Self {
                self.data = Some(data.into());
                self
            }
            pub fn parsed(mut self, parsed: impl Into<AppManifestParsedProperties>) -> Self {
                self.parsed = Some(parsed.into());
                self
            }
            pub fn build(self) -> Result<GetAppManifestReturns, String> {
                Ok(GetAppManifestReturns {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    errors: self.errors.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(errors))
                    })?,
                    data: self.data,
                    parsed: self.parsed,
                })
            }
        }
        impl chromiumoxide_types::Command for GetAppManifestParams {
            type Response = GetAppManifestReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetInstallabilityErrorsParams {}
        impl GetInstallabilityErrorsParams {
            pub const IDENTIFIER: &'static str = "Page.getInstallabilityErrors";
        }
        impl chromiumoxide_types::Method for GetInstallabilityErrorsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetInstallabilityErrorsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetInstallabilityErrorsReturns {
            #[serde(rename = "installabilityErrors")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub installability_errors: Vec<InstallabilityError>,
        }
        impl GetInstallabilityErrorsReturns {
            pub fn new(installability_errors: Vec<InstallabilityError>) -> Self {
                Self {
                    installability_errors,
                }
            }
        }
        impl GetInstallabilityErrorsReturns {
            pub fn builder() -> GetInstallabilityErrorsReturnsBuilder {
                GetInstallabilityErrorsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetInstallabilityErrorsReturnsBuilder {
            installability_errors: Option<Vec<InstallabilityError>>,
        }
        impl GetInstallabilityErrorsReturnsBuilder {
            pub fn installability_error(
                mut self,
                installability_error: impl Into<InstallabilityError>,
            ) -> Self {
                let v = self.installability_errors.get_or_insert(Vec::new());
                v.push(installability_error.into());
                self
            }
            pub fn installability_errors<I, S>(mut self, installability_errors: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<InstallabilityError>,
            {
                let v = self.installability_errors.get_or_insert(Vec::new());
                for val in installability_errors {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetInstallabilityErrorsReturns, String> {
                Ok(GetInstallabilityErrorsReturns {
                    installability_errors: self.installability_errors.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(installability_errors)
                        )
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetInstallabilityErrorsParams {
            type Response = GetInstallabilityErrorsReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetManifestIconsParams {}
        impl GetManifestIconsParams {
            pub const IDENTIFIER: &'static str = "Page.getManifestIcons";
        }
        impl chromiumoxide_types::Method for GetManifestIconsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetManifestIconsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetManifestIconsReturns {
            #[serde(rename = "primaryIcon")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub primary_icon: Option<chromiumoxide_types::Binary>,
        }
        impl GetManifestIconsReturns {
            pub fn builder() -> GetManifestIconsReturnsBuilder {
                GetManifestIconsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetManifestIconsReturnsBuilder {
            primary_icon: Option<chromiumoxide_types::Binary>,
        }
        impl GetManifestIconsReturnsBuilder {
            pub fn primary_icon(
                mut self,
                primary_icon: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                self.primary_icon = Some(primary_icon.into());
                self
            }
            pub fn build(self) -> GetManifestIconsReturns {
                GetManifestIconsReturns {
                    primary_icon: self.primary_icon,
                }
            }
        }
        impl chromiumoxide_types::Command for GetManifestIconsParams {
            type Response = GetManifestIconsReturns;
        }
        #[doc = "Returns the unique (PWA) app id.\nOnly returns values if the feature flag 'WebAppEnableManifestId' is enabled\n[getAppId](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getAppId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetAppIdParams {}
        impl GetAppIdParams {
            pub const IDENTIFIER: &'static str = "Page.getAppId";
        }
        impl chromiumoxide_types::Method for GetAppIdParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetAppIdParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the unique (PWA) app id.\nOnly returns values if the feature flag 'WebAppEnableManifestId' is enabled\n[getAppId](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getAppId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetAppIdReturns {
            #[doc = "App id, either from manifest's id attribute or computed from start_url"]
            #[serde(rename = "appId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub app_id: Option<String>,
            #[doc = "Recommendation for manifest's id attribute to match current id computed from start_url"]
            #[serde(rename = "recommendedId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub recommended_id: Option<String>,
        }
        impl GetAppIdReturns {
            pub fn builder() -> GetAppIdReturnsBuilder {
                GetAppIdReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetAppIdReturnsBuilder {
            app_id: Option<String>,
            recommended_id: Option<String>,
        }
        impl GetAppIdReturnsBuilder {
            pub fn app_id(mut self, app_id: impl Into<String>) -> Self {
                self.app_id = Some(app_id.into());
                self
            }
            pub fn recommended_id(mut self, recommended_id: impl Into<String>) -> Self {
                self.recommended_id = Some(recommended_id.into());
                self
            }
            pub fn build(self) -> GetAppIdReturns {
                GetAppIdReturns {
                    app_id: self.app_id,
                    recommended_id: self.recommended_id,
                }
            }
        }
        impl chromiumoxide_types::Command for GetAppIdParams {
            type Response = GetAppIdReturns;
        }
        #[doc = "Returns present frame tree structure.\n[getFrameTree](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getFrameTree)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetFrameTreeParams {}
        impl GetFrameTreeParams {
            pub const IDENTIFIER: &'static str = "Page.getFrameTree";
        }
        impl chromiumoxide_types::Method for GetFrameTreeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetFrameTreeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns present frame tree structure.\n[getFrameTree](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getFrameTree)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetFrameTreeReturns {
            #[doc = "Present frame tree structure."]
            #[serde(rename = "frameTree")]
            pub frame_tree: FrameTree,
        }
        impl GetFrameTreeReturns {
            pub fn new(frame_tree: impl Into<FrameTree>) -> Self {
                Self {
                    frame_tree: frame_tree.into(),
                }
            }
        }
        impl GetFrameTreeReturns {
            pub fn builder() -> GetFrameTreeReturnsBuilder {
                GetFrameTreeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetFrameTreeReturnsBuilder {
            frame_tree: Option<FrameTree>,
        }
        impl GetFrameTreeReturnsBuilder {
            pub fn frame_tree(mut self, frame_tree: impl Into<FrameTree>) -> Self {
                self.frame_tree = Some(frame_tree.into());
                self
            }
            pub fn build(self) -> Result<GetFrameTreeReturns, String> {
                Ok(GetFrameTreeReturns {
                    frame_tree: self.frame_tree.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_tree))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetFrameTreeParams {
            type Response = GetFrameTreeReturns;
        }
        #[doc = "Returns metrics relating to the layouting of the page, such as viewport bounds/scale.\n[getLayoutMetrics](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getLayoutMetrics)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetLayoutMetricsParams {}
        impl GetLayoutMetricsParams {
            pub const IDENTIFIER: &'static str = "Page.getLayoutMetrics";
        }
        impl chromiumoxide_types::Method for GetLayoutMetricsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetLayoutMetricsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns metrics relating to the layouting of the page, such as viewport bounds/scale.\n[getLayoutMetrics](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getLayoutMetrics)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetLayoutMetricsReturns {
            #[doc = "Metrics relating to the layout viewport in CSS pixels."]
            #[serde(rename = "cssLayoutViewport")]
            pub css_layout_viewport: LayoutViewport,
            #[doc = "Metrics relating to the visual viewport in CSS pixels."]
            #[serde(rename = "cssVisualViewport")]
            pub css_visual_viewport: VisualViewport,
            #[doc = "Size of scrollable area in CSS pixels."]
            #[serde(rename = "cssContentSize")]
            pub css_content_size: super::dom::Rect,
        }
        impl GetLayoutMetricsReturns {
            pub fn new(
                css_layout_viewport: impl Into<LayoutViewport>,
                css_visual_viewport: impl Into<VisualViewport>,
                css_content_size: impl Into<super::dom::Rect>,
            ) -> Self {
                Self {
                    css_layout_viewport: css_layout_viewport.into(),
                    css_visual_viewport: css_visual_viewport.into(),
                    css_content_size: css_content_size.into(),
                }
            }
        }
        impl GetLayoutMetricsReturns {
            pub fn builder() -> GetLayoutMetricsReturnsBuilder {
                GetLayoutMetricsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetLayoutMetricsReturnsBuilder {
            css_layout_viewport: Option<LayoutViewport>,
            css_visual_viewport: Option<VisualViewport>,
            css_content_size: Option<super::dom::Rect>,
        }
        impl GetLayoutMetricsReturnsBuilder {
            pub fn css_layout_viewport(
                mut self,
                css_layout_viewport: impl Into<LayoutViewport>,
            ) -> Self {
                self.css_layout_viewport = Some(css_layout_viewport.into());
                self
            }
            pub fn css_visual_viewport(
                mut self,
                css_visual_viewport: impl Into<VisualViewport>,
            ) -> Self {
                self.css_visual_viewport = Some(css_visual_viewport.into());
                self
            }
            pub fn css_content_size(
                mut self,
                css_content_size: impl Into<super::dom::Rect>,
            ) -> Self {
                self.css_content_size = Some(css_content_size.into());
                self
            }
            pub fn build(self) -> Result<GetLayoutMetricsReturns, String> {
                Ok(GetLayoutMetricsReturns {
                    css_layout_viewport: self.css_layout_viewport.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(css_layout_viewport)
                        )
                    })?,
                    css_visual_viewport: self.css_visual_viewport.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(css_visual_viewport)
                        )
                    })?,
                    css_content_size: self.css_content_size.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(css_content_size)
                        )
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetLayoutMetricsParams {
            type Response = GetLayoutMetricsReturns;
        }
        #[doc = "Returns navigation history for the current page.\n[getNavigationHistory](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getNavigationHistory)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetNavigationHistoryParams {}
        impl GetNavigationHistoryParams {
            pub const IDENTIFIER: &'static str = "Page.getNavigationHistory";
        }
        impl chromiumoxide_types::Method for GetNavigationHistoryParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetNavigationHistoryParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns navigation history for the current page.\n[getNavigationHistory](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getNavigationHistory)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetNavigationHistoryReturns {
            #[doc = "Index of the current navigation history entry."]
            #[serde(rename = "currentIndex")]
            pub current_index: i64,
            #[doc = "Array of navigation history entries."]
            #[serde(rename = "entries")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub entries: Vec<NavigationEntry>,
        }
        impl GetNavigationHistoryReturns {
            pub fn new(current_index: impl Into<i64>, entries: Vec<NavigationEntry>) -> Self {
                Self {
                    current_index: current_index.into(),
                    entries,
                }
            }
        }
        impl GetNavigationHistoryReturns {
            pub fn builder() -> GetNavigationHistoryReturnsBuilder {
                GetNavigationHistoryReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetNavigationHistoryReturnsBuilder {
            current_index: Option<i64>,
            entries: Option<Vec<NavigationEntry>>,
        }
        impl GetNavigationHistoryReturnsBuilder {
            pub fn current_index(mut self, current_index: impl Into<i64>) -> Self {
                self.current_index = Some(current_index.into());
                self
            }
            pub fn entrie(mut self, entrie: impl Into<NavigationEntry>) -> Self {
                let v = self.entries.get_or_insert(Vec::new());
                v.push(entrie.into());
                self
            }
            pub fn entries<I, S>(mut self, entries: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<NavigationEntry>,
            {
                let v = self.entries.get_or_insert(Vec::new());
                for val in entries {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetNavigationHistoryReturns, String> {
                Ok(GetNavigationHistoryReturns {
                    current_index: self.current_index.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(current_index))
                    })?,
                    entries: self.entries.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(entries))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetNavigationHistoryParams {
            type Response = GetNavigationHistoryReturns;
        }
        #[doc = "Resets navigation history for the current page.\n[resetNavigationHistory](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-resetNavigationHistory)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ResetNavigationHistoryParams {}
        impl ResetNavigationHistoryParams {
            pub const IDENTIFIER: &'static str = "Page.resetNavigationHistory";
        }
        impl chromiumoxide_types::Method for ResetNavigationHistoryParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ResetNavigationHistoryParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Resets navigation history for the current page.\n[resetNavigationHistory](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-resetNavigationHistory)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ResetNavigationHistoryReturns {}
        impl chromiumoxide_types::Command for ResetNavigationHistoryParams {
            type Response = ResetNavigationHistoryReturns;
        }
        #[doc = "Returns content of the given resource.\n[getResourceContent](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getResourceContent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetResourceContentParams {
            #[doc = "Frame id to get resource for."]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
            #[doc = "URL of the resource to get content for."]
            #[serde(rename = "url")]
            pub url: String,
        }
        impl GetResourceContentParams {
            pub fn new(frame_id: impl Into<FrameId>, url: impl Into<String>) -> Self {
                Self {
                    frame_id: frame_id.into(),
                    url: url.into(),
                }
            }
        }
        impl GetResourceContentParams {
            pub fn builder() -> GetResourceContentParamsBuilder {
                GetResourceContentParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetResourceContentParamsBuilder {
            frame_id: Option<FrameId>,
            url: Option<String>,
        }
        impl GetResourceContentParamsBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn build(self) -> Result<GetResourceContentParams, String> {
                Ok(GetResourceContentParams {
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                })
            }
        }
        impl GetResourceContentParams {
            pub const IDENTIFIER: &'static str = "Page.getResourceContent";
        }
        impl chromiumoxide_types::Method for GetResourceContentParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetResourceContentParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns content of the given resource.\n[getResourceContent](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getResourceContent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetResourceContentReturns {
            #[doc = "Resource content."]
            #[serde(rename = "content")]
            pub content: String,
            #[doc = "True, if content was served as base64."]
            #[serde(rename = "base64Encoded")]
            pub base64_encoded: bool,
        }
        impl GetResourceContentReturns {
            pub fn new(content: impl Into<String>, base64_encoded: impl Into<bool>) -> Self {
                Self {
                    content: content.into(),
                    base64_encoded: base64_encoded.into(),
                }
            }
        }
        impl GetResourceContentReturns {
            pub fn builder() -> GetResourceContentReturnsBuilder {
                GetResourceContentReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetResourceContentReturnsBuilder {
            content: Option<String>,
            base64_encoded: Option<bool>,
        }
        impl GetResourceContentReturnsBuilder {
            pub fn content(mut self, content: impl Into<String>) -> Self {
                self.content = Some(content.into());
                self
            }
            pub fn base64_encoded(mut self, base64_encoded: impl Into<bool>) -> Self {
                self.base64_encoded = Some(base64_encoded.into());
                self
            }
            pub fn build(self) -> Result<GetResourceContentReturns, String> {
                Ok(GetResourceContentReturns {
                    content: self.content.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(content))
                    })?,
                    base64_encoded: self.base64_encoded.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(base64_encoded))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetResourceContentParams {
            type Response = GetResourceContentReturns;
        }
        #[doc = "Returns present frame / resource tree structure.\n[getResourceTree](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getResourceTree)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetResourceTreeParams {}
        impl GetResourceTreeParams {
            pub const IDENTIFIER: &'static str = "Page.getResourceTree";
        }
        impl chromiumoxide_types::Method for GetResourceTreeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetResourceTreeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns present frame / resource tree structure.\n[getResourceTree](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getResourceTree)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetResourceTreeReturns {
            #[doc = "Present frame / resource tree structure."]
            #[serde(rename = "frameTree")]
            pub frame_tree: FrameResourceTree,
        }
        impl GetResourceTreeReturns {
            pub fn new(frame_tree: impl Into<FrameResourceTree>) -> Self {
                Self {
                    frame_tree: frame_tree.into(),
                }
            }
        }
        impl GetResourceTreeReturns {
            pub fn builder() -> GetResourceTreeReturnsBuilder {
                GetResourceTreeReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetResourceTreeReturnsBuilder {
            frame_tree: Option<FrameResourceTree>,
        }
        impl GetResourceTreeReturnsBuilder {
            pub fn frame_tree(mut self, frame_tree: impl Into<FrameResourceTree>) -> Self {
                self.frame_tree = Some(frame_tree.into());
                self
            }
            pub fn build(self) -> Result<GetResourceTreeReturns, String> {
                Ok(GetResourceTreeReturns {
                    frame_tree: self.frame_tree.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_tree))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetResourceTreeParams {
            type Response = GetResourceTreeReturns;
        }
        #[doc = "Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).\n[handleJavaScriptDialog](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-handleJavaScriptDialog)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct HandleJavaScriptDialogParams {
            #[doc = "Whether to accept or dismiss the dialog."]
            #[serde(rename = "accept")]
            pub accept: bool,
            #[doc = "The text to enter into the dialog prompt before accepting. Used only if this is a prompt\ndialog."]
            #[serde(rename = "promptText")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub prompt_text: Option<String>,
        }
        impl HandleJavaScriptDialogParams {
            pub fn new(accept: impl Into<bool>) -> Self {
                Self {
                    accept: accept.into(),
                    prompt_text: None,
                }
            }
        }
        impl HandleJavaScriptDialogParams {
            pub fn builder() -> HandleJavaScriptDialogParamsBuilder {
                HandleJavaScriptDialogParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct HandleJavaScriptDialogParamsBuilder {
            accept: Option<bool>,
            prompt_text: Option<String>,
        }
        impl HandleJavaScriptDialogParamsBuilder {
            pub fn accept(mut self, accept: impl Into<bool>) -> Self {
                self.accept = Some(accept.into());
                self
            }
            pub fn prompt_text(mut self, prompt_text: impl Into<String>) -> Self {
                self.prompt_text = Some(prompt_text.into());
                self
            }
            pub fn build(self) -> Result<HandleJavaScriptDialogParams, String> {
                Ok(HandleJavaScriptDialogParams {
                    accept: self.accept.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(accept))
                    })?,
                    prompt_text: self.prompt_text,
                })
            }
        }
        impl HandleJavaScriptDialogParams {
            pub const IDENTIFIER: &'static str = "Page.handleJavaScriptDialog";
        }
        impl chromiumoxide_types::Method for HandleJavaScriptDialogParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for HandleJavaScriptDialogParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).\n[handleJavaScriptDialog](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-handleJavaScriptDialog)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct HandleJavaScriptDialogReturns {}
        impl chromiumoxide_types::Command for HandleJavaScriptDialogParams {
            type Response = HandleJavaScriptDialogReturns;
        }
        #[doc = "Navigates current page to the given URL.\n[navigate](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-navigate)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct NavigateParams {
            #[doc = "URL to navigate the page to."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Referrer URL."]
            #[serde(rename = "referrer")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub referrer: Option<String>,
            #[doc = "Intended transition type."]
            #[serde(rename = "transitionType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub transition_type: Option<TransitionType>,
            #[doc = "Frame id to navigate, if not specified navigates the top frame."]
            #[serde(rename = "frameId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub frame_id: Option<FrameId>,
            #[doc = "Referrer-policy used for the navigation."]
            #[serde(rename = "referrerPolicy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub referrer_policy: Option<ReferrerPolicy>,
        }
        impl NavigateParams {
            pub fn new(url: impl Into<String>) -> Self {
                Self {
                    url: url.into(),
                    referrer: None,
                    transition_type: None,
                    frame_id: None,
                    referrer_policy: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for NavigateParams {
            fn from(url: T) -> Self {
                NavigateParams::new(url)
            }
        }
        impl NavigateParams {
            pub fn builder() -> NavigateParamsBuilder {
                NavigateParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct NavigateParamsBuilder {
            url: Option<String>,
            referrer: Option<String>,
            transition_type: Option<TransitionType>,
            frame_id: Option<FrameId>,
            referrer_policy: Option<ReferrerPolicy>,
        }
        impl NavigateParamsBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn referrer(mut self, referrer: impl Into<String>) -> Self {
                self.referrer = Some(referrer.into());
                self
            }
            pub fn transition_type(mut self, transition_type: impl Into<TransitionType>) -> Self {
                self.transition_type = Some(transition_type.into());
                self
            }
            pub fn frame_id(mut self, frame_id: impl Into<FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn referrer_policy(mut self, referrer_policy: impl Into<ReferrerPolicy>) -> Self {
                self.referrer_policy = Some(referrer_policy.into());
                self
            }
            pub fn build(self) -> Result<NavigateParams, String> {
                Ok(NavigateParams {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    referrer: self.referrer,
                    transition_type: self.transition_type,
                    frame_id: self.frame_id,
                    referrer_policy: self.referrer_policy,
                })
            }
        }
        impl NavigateParams {
            pub const IDENTIFIER: &'static str = "Page.navigate";
        }
        impl chromiumoxide_types::Method for NavigateParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for NavigateParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Navigates current page to the given URL.\n[navigate](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-navigate)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct NavigateReturns {
            #[doc = "Frame id that has navigated (or failed to navigate)"]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
            #[doc = "Loader identifier. This is omitted in case of same-document navigation,\nas the previously committed loaderId would not change."]
            #[serde(rename = "loaderId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub loader_id: Option<super::network::LoaderId>,
            #[doc = "User friendly error message, present if and only if navigation has failed."]
            #[serde(rename = "errorText")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub error_text: Option<String>,
        }
        impl NavigateReturns {
            pub fn new(frame_id: impl Into<FrameId>) -> Self {
                Self {
                    frame_id: frame_id.into(),
                    loader_id: None,
                    error_text: None,
                }
            }
        }
        impl NavigateReturns {
            pub fn builder() -> NavigateReturnsBuilder {
                NavigateReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct NavigateReturnsBuilder {
            frame_id: Option<FrameId>,
            loader_id: Option<super::network::LoaderId>,
            error_text: Option<String>,
        }
        impl NavigateReturnsBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn loader_id(mut self, loader_id: impl Into<super::network::LoaderId>) -> Self {
                self.loader_id = Some(loader_id.into());
                self
            }
            pub fn error_text(mut self, error_text: impl Into<String>) -> Self {
                self.error_text = Some(error_text.into());
                self
            }
            pub fn build(self) -> Result<NavigateReturns, String> {
                Ok(NavigateReturns {
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                    loader_id: self.loader_id,
                    error_text: self.error_text,
                })
            }
        }
        impl chromiumoxide_types::Command for NavigateParams {
            type Response = NavigateReturns;
        }
        #[doc = "Navigates current page to the given history entry.\n[navigateToHistoryEntry](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-navigateToHistoryEntry)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct NavigateToHistoryEntryParams {
            #[doc = "Unique id of the entry to navigate to."]
            #[serde(rename = "entryId")]
            pub entry_id: i64,
        }
        impl NavigateToHistoryEntryParams {
            pub fn new(entry_id: impl Into<i64>) -> Self {
                Self {
                    entry_id: entry_id.into(),
                }
            }
        }
        impl NavigateToHistoryEntryParams {
            pub fn builder() -> NavigateToHistoryEntryParamsBuilder {
                NavigateToHistoryEntryParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct NavigateToHistoryEntryParamsBuilder {
            entry_id: Option<i64>,
        }
        impl NavigateToHistoryEntryParamsBuilder {
            pub fn entry_id(mut self, entry_id: impl Into<i64>) -> Self {
                self.entry_id = Some(entry_id.into());
                self
            }
            pub fn build(self) -> Result<NavigateToHistoryEntryParams, String> {
                Ok(NavigateToHistoryEntryParams {
                    entry_id: self.entry_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(entry_id))
                    })?,
                })
            }
        }
        impl NavigateToHistoryEntryParams {
            pub const IDENTIFIER: &'static str = "Page.navigateToHistoryEntry";
        }
        impl chromiumoxide_types::Method for NavigateToHistoryEntryParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for NavigateToHistoryEntryParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Navigates current page to the given history entry.\n[navigateToHistoryEntry](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-navigateToHistoryEntry)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct NavigateToHistoryEntryReturns {}
        impl chromiumoxide_types::Command for NavigateToHistoryEntryParams {
            type Response = NavigateToHistoryEntryReturns;
        }
        #[doc = "Print page as PDF.\n[printToPDF](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-printToPDF)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct PrintToPdfParams {
            #[doc = "Paper orientation. Defaults to false."]
            #[serde(rename = "landscape")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub landscape: Option<bool>,
            #[doc = "Display header and footer. Defaults to false."]
            #[serde(rename = "displayHeaderFooter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub display_header_footer: Option<bool>,
            #[doc = "Print background graphics. Defaults to false."]
            #[serde(rename = "printBackground")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub print_background: Option<bool>,
            #[doc = "Scale of the webpage rendering. Defaults to 1."]
            #[serde(rename = "scale")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub scale: Option<f64>,
            #[doc = "Paper width in inches. Defaults to 8.5 inches."]
            #[serde(rename = "paperWidth")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub paper_width: Option<f64>,
            #[doc = "Paper height in inches. Defaults to 11 inches."]
            #[serde(rename = "paperHeight")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub paper_height: Option<f64>,
            #[doc = "Top margin in inches. Defaults to 1cm (~0.4 inches)."]
            #[serde(rename = "marginTop")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub margin_top: Option<f64>,
            #[doc = "Bottom margin in inches. Defaults to 1cm (~0.4 inches)."]
            #[serde(rename = "marginBottom")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub margin_bottom: Option<f64>,
            #[doc = "Left margin in inches. Defaults to 1cm (~0.4 inches)."]
            #[serde(rename = "marginLeft")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub margin_left: Option<f64>,
            #[doc = "Right margin in inches. Defaults to 1cm (~0.4 inches)."]
            #[serde(rename = "marginRight")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub margin_right: Option<f64>,
            #[doc = "Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are\nprinted in the document order, not in the order specified, and no\nmore than once.\nDefaults to empty string, which implies the entire document is printed.\nThe page numbers are quietly capped to actual page count of the\ndocument, and ranges beyond the end of the document are ignored.\nIf this results in no pages to print, an error is reported.\nIt is an error to specify a range with start greater than end."]
            #[serde(rename = "pageRanges")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub page_ranges: Option<String>,
            #[doc = "HTML template for the print header. Should be valid HTML markup with following\nclasses used to inject printing values into them:\n- `date`: formatted print date\n- `title`: document title\n- `url`: document location\n- `pageNumber`: current page number\n- `totalPages`: total pages in the document\n\nFor example, `<span class=title></span>` would generate span containing the title."]
            #[serde(rename = "headerTemplate")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub header_template: Option<String>,
            #[doc = "HTML template for the print footer. Should use the same format as the `headerTemplate`."]
            #[serde(rename = "footerTemplate")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub footer_template: Option<String>,
            #[doc = "Whether or not to prefer page size as defined by css. Defaults to false,\nin which case the content will be scaled to fit the paper size."]
            #[serde(rename = "preferCSSPageSize")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub prefer_css_page_size: Option<bool>,
            #[doc = "return as stream"]
            #[serde(rename = "transferMode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub transfer_mode: Option<PrintToPdfTransferMode>,
        }
        #[doc = "return as stream"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PrintToPdfTransferMode {
            #[serde(rename = "ReturnAsBase64")]
            ReturnAsBase64,
            #[serde(rename = "ReturnAsStream")]
            ReturnAsStream,
        }
        impl AsRef<str> for PrintToPdfTransferMode {
            fn as_ref(&self) -> &str {
                match self {
                    PrintToPdfTransferMode::ReturnAsBase64 => "ReturnAsBase64",
                    PrintToPdfTransferMode::ReturnAsStream => "ReturnAsStream",
                }
            }
        }
        impl ::std::str::FromStr for PrintToPdfTransferMode {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "ReturnAsBase64" | "returnasbase64" => {
                        Ok(PrintToPdfTransferMode::ReturnAsBase64)
                    }
                    "ReturnAsStream" | "returnasstream" => {
                        Ok(PrintToPdfTransferMode::ReturnAsStream)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl PrintToPdfParams {
            pub fn builder() -> PrintToPdfParamsBuilder {
                PrintToPdfParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PrintToPdfParamsBuilder {
            landscape: Option<bool>,
            display_header_footer: Option<bool>,
            print_background: Option<bool>,
            scale: Option<f64>,
            paper_width: Option<f64>,
            paper_height: Option<f64>,
            margin_top: Option<f64>,
            margin_bottom: Option<f64>,
            margin_left: Option<f64>,
            margin_right: Option<f64>,
            page_ranges: Option<String>,
            header_template: Option<String>,
            footer_template: Option<String>,
            prefer_css_page_size: Option<bool>,
            transfer_mode: Option<PrintToPdfTransferMode>,
        }
        impl PrintToPdfParamsBuilder {
            pub fn landscape(mut self, landscape: impl Into<bool>) -> Self {
                self.landscape = Some(landscape.into());
                self
            }
            pub fn display_header_footer(mut self, display_header_footer: impl Into<bool>) -> Self {
                self.display_header_footer = Some(display_header_footer.into());
                self
            }
            pub fn print_background(mut self, print_background: impl Into<bool>) -> Self {
                self.print_background = Some(print_background.into());
                self
            }
            pub fn scale(mut self, scale: impl Into<f64>) -> Self {
                self.scale = Some(scale.into());
                self
            }
            pub fn paper_width(mut self, paper_width: impl Into<f64>) -> Self {
                self.paper_width = Some(paper_width.into());
                self
            }
            pub fn paper_height(mut self, paper_height: impl Into<f64>) -> Self {
                self.paper_height = Some(paper_height.into());
                self
            }
            pub fn margin_top(mut self, margin_top: impl Into<f64>) -> Self {
                self.margin_top = Some(margin_top.into());
                self
            }
            pub fn margin_bottom(mut self, margin_bottom: impl Into<f64>) -> Self {
                self.margin_bottom = Some(margin_bottom.into());
                self
            }
            pub fn margin_left(mut self, margin_left: impl Into<f64>) -> Self {
                self.margin_left = Some(margin_left.into());
                self
            }
            pub fn margin_right(mut self, margin_right: impl Into<f64>) -> Self {
                self.margin_right = Some(margin_right.into());
                self
            }
            pub fn page_ranges(mut self, page_ranges: impl Into<String>) -> Self {
                self.page_ranges = Some(page_ranges.into());
                self
            }
            pub fn header_template(mut self, header_template: impl Into<String>) -> Self {
                self.header_template = Some(header_template.into());
                self
            }
            pub fn footer_template(mut self, footer_template: impl Into<String>) -> Self {
                self.footer_template = Some(footer_template.into());
                self
            }
            pub fn prefer_css_page_size(mut self, prefer_css_page_size: impl Into<bool>) -> Self {
                self.prefer_css_page_size = Some(prefer_css_page_size.into());
                self
            }
            pub fn transfer_mode(
                mut self,
                transfer_mode: impl Into<PrintToPdfTransferMode>,
            ) -> Self {
                self.transfer_mode = Some(transfer_mode.into());
                self
            }
            pub fn build(self) -> PrintToPdfParams {
                PrintToPdfParams {
                    landscape: self.landscape,
                    display_header_footer: self.display_header_footer,
                    print_background: self.print_background,
                    scale: self.scale,
                    paper_width: self.paper_width,
                    paper_height: self.paper_height,
                    margin_top: self.margin_top,
                    margin_bottom: self.margin_bottom,
                    margin_left: self.margin_left,
                    margin_right: self.margin_right,
                    page_ranges: self.page_ranges,
                    header_template: self.header_template,
                    footer_template: self.footer_template,
                    prefer_css_page_size: self.prefer_css_page_size,
                    transfer_mode: self.transfer_mode,
                }
            }
        }
        impl PrintToPdfParams {
            pub const IDENTIFIER: &'static str = "Page.printToPDF";
        }
        impl chromiumoxide_types::Method for PrintToPdfParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for PrintToPdfParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Print page as PDF.\n[printToPDF](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-printToPDF)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PrintToPdfReturns {
            #[doc = "Base64-encoded pdf data. Empty if |returnAsStream| is specified."]
            #[serde(rename = "data")]
            pub data: chromiumoxide_types::Binary,
            #[doc = "A handle of the stream that holds resulting PDF data."]
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub stream: Option<super::io::StreamHandle>,
        }
        impl PrintToPdfReturns {
            pub fn new(data: impl Into<chromiumoxide_types::Binary>) -> Self {
                Self {
                    data: data.into(),
                    stream: None,
                }
            }
        }
        impl PrintToPdfReturns {
            pub fn builder() -> PrintToPdfReturnsBuilder {
                PrintToPdfReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PrintToPdfReturnsBuilder {
            data: Option<chromiumoxide_types::Binary>,
            stream: Option<super::io::StreamHandle>,
        }
        impl PrintToPdfReturnsBuilder {
            pub fn data(mut self, data: impl Into<chromiumoxide_types::Binary>) -> Self {
                self.data = Some(data.into());
                self
            }
            pub fn stream(mut self, stream: impl Into<super::io::StreamHandle>) -> Self {
                self.stream = Some(stream.into());
                self
            }
            pub fn build(self) -> Result<PrintToPdfReturns, String> {
                Ok(PrintToPdfReturns {
                    data: self.data.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(data))
                    })?,
                    stream: self.stream,
                })
            }
        }
        impl chromiumoxide_types::Command for PrintToPdfParams {
            type Response = PrintToPdfReturns;
        }
        #[doc = "Reloads given page optionally ignoring the cache.\n[reload](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-reload)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ReloadParams {
            #[doc = "If true, browser cache is ignored (as if the user pressed Shift+refresh)."]
            #[serde(rename = "ignoreCache")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub ignore_cache: Option<bool>,
            #[doc = "If set, the script will be injected into all frames of the inspected page after reload.\nArgument will be ignored if reloading dataURL origin."]
            #[serde(rename = "scriptToEvaluateOnLoad")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub script_to_evaluate_on_load: Option<String>,
        }
        impl ReloadParams {
            pub fn builder() -> ReloadParamsBuilder {
                ReloadParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ReloadParamsBuilder {
            ignore_cache: Option<bool>,
            script_to_evaluate_on_load: Option<String>,
        }
        impl ReloadParamsBuilder {
            pub fn ignore_cache(mut self, ignore_cache: impl Into<bool>) -> Self {
                self.ignore_cache = Some(ignore_cache.into());
                self
            }
            pub fn script_to_evaluate_on_load(
                mut self,
                script_to_evaluate_on_load: impl Into<String>,
            ) -> Self {
                self.script_to_evaluate_on_load = Some(script_to_evaluate_on_load.into());
                self
            }
            pub fn build(self) -> ReloadParams {
                ReloadParams {
                    ignore_cache: self.ignore_cache,
                    script_to_evaluate_on_load: self.script_to_evaluate_on_load,
                }
            }
        }
        impl ReloadParams {
            pub const IDENTIFIER: &'static str = "Page.reload";
        }
        impl chromiumoxide_types::Method for ReloadParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ReloadParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Reloads given page optionally ignoring the cache.\n[reload](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-reload)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ReloadReturns {}
        impl chromiumoxide_types::Command for ReloadParams {
            type Response = ReloadReturns;
        }
        #[doc = "Removes given script from the list.\n[removeScriptToEvaluateOnNewDocument](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-removeScriptToEvaluateOnNewDocument)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoveScriptToEvaluateOnNewDocumentParams {
            #[serde(rename = "identifier")]
            pub identifier: ScriptIdentifier,
        }
        impl RemoveScriptToEvaluateOnNewDocumentParams {
            pub fn new(identifier: impl Into<ScriptIdentifier>) -> Self {
                Self {
                    identifier: identifier.into(),
                }
            }
        }
        impl RemoveScriptToEvaluateOnNewDocumentParams {
            pub fn builder() -> RemoveScriptToEvaluateOnNewDocumentParamsBuilder {
                RemoveScriptToEvaluateOnNewDocumentParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoveScriptToEvaluateOnNewDocumentParamsBuilder {
            identifier: Option<ScriptIdentifier>,
        }
        impl RemoveScriptToEvaluateOnNewDocumentParamsBuilder {
            pub fn identifier(mut self, identifier: impl Into<ScriptIdentifier>) -> Self {
                self.identifier = Some(identifier.into());
                self
            }
            pub fn build(self) -> Result<RemoveScriptToEvaluateOnNewDocumentParams, String> {
                Ok(RemoveScriptToEvaluateOnNewDocumentParams {
                    identifier: self.identifier.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(identifier))
                    })?,
                })
            }
        }
        impl RemoveScriptToEvaluateOnNewDocumentParams {
            pub const IDENTIFIER: &'static str = "Page.removeScriptToEvaluateOnNewDocument";
        }
        impl chromiumoxide_types::Method for RemoveScriptToEvaluateOnNewDocumentParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RemoveScriptToEvaluateOnNewDocumentParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Removes given script from the list.\n[removeScriptToEvaluateOnNewDocument](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-removeScriptToEvaluateOnNewDocument)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RemoveScriptToEvaluateOnNewDocumentReturns {}
        impl chromiumoxide_types::Command for RemoveScriptToEvaluateOnNewDocumentParams {
            type Response = RemoveScriptToEvaluateOnNewDocumentReturns;
        }
        #[doc = "Acknowledges that a screencast frame has been received by the frontend.\n[screencastFrameAck](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-screencastFrameAck)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ScreencastFrameAckParams {
            #[doc = "Frame number."]
            #[serde(rename = "sessionId")]
            pub session_id: i64,
        }
        impl ScreencastFrameAckParams {
            pub fn new(session_id: impl Into<i64>) -> Self {
                Self {
                    session_id: session_id.into(),
                }
            }
        }
        impl ScreencastFrameAckParams {
            pub fn builder() -> ScreencastFrameAckParamsBuilder {
                ScreencastFrameAckParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ScreencastFrameAckParamsBuilder {
            session_id: Option<i64>,
        }
        impl ScreencastFrameAckParamsBuilder {
            pub fn session_id(mut self, session_id: impl Into<i64>) -> Self {
                self.session_id = Some(session_id.into());
                self
            }
            pub fn build(self) -> Result<ScreencastFrameAckParams, String> {
                Ok(ScreencastFrameAckParams {
                    session_id: self.session_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(session_id))
                    })?,
                })
            }
        }
        impl ScreencastFrameAckParams {
            pub const IDENTIFIER: &'static str = "Page.screencastFrameAck";
        }
        impl chromiumoxide_types::Method for ScreencastFrameAckParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ScreencastFrameAckParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Acknowledges that a screencast frame has been received by the frontend.\n[screencastFrameAck](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-screencastFrameAck)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ScreencastFrameAckReturns {}
        impl chromiumoxide_types::Command for ScreencastFrameAckParams {
            type Response = ScreencastFrameAckReturns;
        }
        #[doc = "Searches for given string in resource content.\n[searchInResource](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-searchInResource)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SearchInResourceParams {
            #[doc = "Frame id for resource to search in."]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
            #[doc = "URL of the resource to search in."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "String to search for."]
            #[serde(rename = "query")]
            pub query: String,
            #[doc = "If true, search is case sensitive."]
            #[serde(rename = "caseSensitive")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub case_sensitive: Option<bool>,
            #[doc = "If true, treats string parameter as regex."]
            #[serde(rename = "isRegex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_regex: Option<bool>,
        }
        impl SearchInResourceParams {
            pub fn new(
                frame_id: impl Into<FrameId>,
                url: impl Into<String>,
                query: impl Into<String>,
            ) -> Self {
                Self {
                    frame_id: frame_id.into(),
                    url: url.into(),
                    query: query.into(),
                    case_sensitive: None,
                    is_regex: None,
                }
            }
        }
        impl SearchInResourceParams {
            pub fn builder() -> SearchInResourceParamsBuilder {
                SearchInResourceParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SearchInResourceParamsBuilder {
            frame_id: Option<FrameId>,
            url: Option<String>,
            query: Option<String>,
            case_sensitive: Option<bool>,
            is_regex: Option<bool>,
        }
        impl SearchInResourceParamsBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn query(mut self, query: impl Into<String>) -> Self {
                self.query = Some(query.into());
                self
            }
            pub fn case_sensitive(mut self, case_sensitive: impl Into<bool>) -> Self {
                self.case_sensitive = Some(case_sensitive.into());
                self
            }
            pub fn is_regex(mut self, is_regex: impl Into<bool>) -> Self {
                self.is_regex = Some(is_regex.into());
                self
            }
            pub fn build(self) -> Result<SearchInResourceParams, String> {
                Ok(SearchInResourceParams {
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    query: self.query.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(query))
                    })?,
                    case_sensitive: self.case_sensitive,
                    is_regex: self.is_regex,
                })
            }
        }
        impl SearchInResourceParams {
            pub const IDENTIFIER: &'static str = "Page.searchInResource";
        }
        impl chromiumoxide_types::Method for SearchInResourceParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SearchInResourceParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Searches for given string in resource content.\n[searchInResource](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-searchInResource)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SearchInResourceReturns {
            #[doc = "List of search matches."]
            #[serde(rename = "result")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub result: Vec<super::super::js_protocol::debugger::SearchMatch>,
        }
        impl SearchInResourceReturns {
            pub fn new(result: Vec<super::super::js_protocol::debugger::SearchMatch>) -> Self {
                Self { result }
            }
        }
        impl SearchInResourceReturns {
            pub fn builder() -> SearchInResourceReturnsBuilder {
                SearchInResourceReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SearchInResourceReturnsBuilder {
            result: Option<Vec<super::super::js_protocol::debugger::SearchMatch>>,
        }
        impl SearchInResourceReturnsBuilder {
            pub fn result(
                mut self,
                result: impl Into<super::super::js_protocol::debugger::SearchMatch>,
            ) -> Self {
                let v = self.result.get_or_insert(Vec::new());
                v.push(result.into());
                self
            }
            pub fn results<I, S>(mut self, results: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<super::super::js_protocol::debugger::SearchMatch>,
            {
                let v = self.result.get_or_insert(Vec::new());
                for val in results {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SearchInResourceReturns, String> {
                Ok(SearchInResourceReturns {
                    result: self.result.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(result))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for SearchInResourceParams {
            type Response = SearchInResourceReturns;
        }
        #[doc = "Enable Chrome's experimental ad filter on all sites.\n[setAdBlockingEnabled](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setAdBlockingEnabled)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetAdBlockingEnabledParams {
            #[doc = "Whether to block ads."]
            #[serde(rename = "enabled")]
            pub enabled: bool,
        }
        impl SetAdBlockingEnabledParams {
            pub fn new(enabled: impl Into<bool>) -> Self {
                Self {
                    enabled: enabled.into(),
                }
            }
        }
        impl SetAdBlockingEnabledParams {
            pub fn builder() -> SetAdBlockingEnabledParamsBuilder {
                SetAdBlockingEnabledParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetAdBlockingEnabledParamsBuilder {
            enabled: Option<bool>,
        }
        impl SetAdBlockingEnabledParamsBuilder {
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn build(self) -> Result<SetAdBlockingEnabledParams, String> {
                Ok(SetAdBlockingEnabledParams {
                    enabled: self.enabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enabled))
                    })?,
                })
            }
        }
        impl SetAdBlockingEnabledParams {
            pub const IDENTIFIER: &'static str = "Page.setAdBlockingEnabled";
        }
        impl chromiumoxide_types::Method for SetAdBlockingEnabledParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetAdBlockingEnabledParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enable Chrome's experimental ad filter on all sites.\n[setAdBlockingEnabled](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setAdBlockingEnabled)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetAdBlockingEnabledReturns {}
        impl chromiumoxide_types::Command for SetAdBlockingEnabledParams {
            type Response = SetAdBlockingEnabledReturns;
        }
        #[doc = "Enable page Content Security Policy by-passing.\n[setBypassCSP](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setBypassCSP)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetBypassCspParams {
            #[doc = "Whether to bypass page CSP."]
            #[serde(rename = "enabled")]
            pub enabled: bool,
        }
        impl SetBypassCspParams {
            pub fn new(enabled: impl Into<bool>) -> Self {
                Self {
                    enabled: enabled.into(),
                }
            }
        }
        impl SetBypassCspParams {
            pub fn builder() -> SetBypassCspParamsBuilder {
                SetBypassCspParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetBypassCspParamsBuilder {
            enabled: Option<bool>,
        }
        impl SetBypassCspParamsBuilder {
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn build(self) -> Result<SetBypassCspParams, String> {
                Ok(SetBypassCspParams {
                    enabled: self.enabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enabled))
                    })?,
                })
            }
        }
        impl SetBypassCspParams {
            pub const IDENTIFIER: &'static str = "Page.setBypassCSP";
        }
        impl chromiumoxide_types::Method for SetBypassCspParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetBypassCspParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enable page Content Security Policy by-passing.\n[setBypassCSP](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setBypassCSP)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetBypassCspReturns {}
        impl chromiumoxide_types::Command for SetBypassCspParams {
            type Response = SetBypassCspReturns;
        }
        #[doc = "Get Permissions Policy state on given frame.\n[getPermissionsPolicyState](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getPermissionsPolicyState)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetPermissionsPolicyStateParams {
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
        }
        impl GetPermissionsPolicyStateParams {
            pub fn new(frame_id: impl Into<FrameId>) -> Self {
                Self {
                    frame_id: frame_id.into(),
                }
            }
        }
        impl GetPermissionsPolicyStateParams {
            pub fn builder() -> GetPermissionsPolicyStateParamsBuilder {
                GetPermissionsPolicyStateParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetPermissionsPolicyStateParamsBuilder {
            frame_id: Option<FrameId>,
        }
        impl GetPermissionsPolicyStateParamsBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn build(self) -> Result<GetPermissionsPolicyStateParams, String> {
                Ok(GetPermissionsPolicyStateParams {
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                })
            }
        }
        impl GetPermissionsPolicyStateParams {
            pub const IDENTIFIER: &'static str = "Page.getPermissionsPolicyState";
        }
        impl chromiumoxide_types::Method for GetPermissionsPolicyStateParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetPermissionsPolicyStateParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Get Permissions Policy state on given frame.\n[getPermissionsPolicyState](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getPermissionsPolicyState)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetPermissionsPolicyStateReturns {
            #[serde(rename = "states")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub states: Vec<PermissionsPolicyFeatureState>,
        }
        impl GetPermissionsPolicyStateReturns {
            pub fn new(states: Vec<PermissionsPolicyFeatureState>) -> Self {
                Self { states }
            }
        }
        impl GetPermissionsPolicyStateReturns {
            pub fn builder() -> GetPermissionsPolicyStateReturnsBuilder {
                GetPermissionsPolicyStateReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetPermissionsPolicyStateReturnsBuilder {
            states: Option<Vec<PermissionsPolicyFeatureState>>,
        }
        impl GetPermissionsPolicyStateReturnsBuilder {
            pub fn state(mut self, state: impl Into<PermissionsPolicyFeatureState>) -> Self {
                let v = self.states.get_or_insert(Vec::new());
                v.push(state.into());
                self
            }
            pub fn states<I, S>(mut self, states: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PermissionsPolicyFeatureState>,
            {
                let v = self.states.get_or_insert(Vec::new());
                for val in states {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetPermissionsPolicyStateReturns, String> {
                Ok(GetPermissionsPolicyStateReturns {
                    states: self.states.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(states))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetPermissionsPolicyStateParams {
            type Response = GetPermissionsPolicyStateReturns;
        }
        #[doc = "Get Origin Trials on given frame.\n[getOriginTrials](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getOriginTrials)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetOriginTrialsParams {
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
        }
        impl GetOriginTrialsParams {
            pub fn new(frame_id: impl Into<FrameId>) -> Self {
                Self {
                    frame_id: frame_id.into(),
                }
            }
        }
        impl GetOriginTrialsParams {
            pub fn builder() -> GetOriginTrialsParamsBuilder {
                GetOriginTrialsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetOriginTrialsParamsBuilder {
            frame_id: Option<FrameId>,
        }
        impl GetOriginTrialsParamsBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn build(self) -> Result<GetOriginTrialsParams, String> {
                Ok(GetOriginTrialsParams {
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                })
            }
        }
        impl GetOriginTrialsParams {
            pub const IDENTIFIER: &'static str = "Page.getOriginTrials";
        }
        impl chromiumoxide_types::Method for GetOriginTrialsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetOriginTrialsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Get Origin Trials on given frame.\n[getOriginTrials](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getOriginTrials)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetOriginTrialsReturns {
            #[serde(rename = "originTrials")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub origin_trials: Vec<OriginTrial>,
        }
        impl GetOriginTrialsReturns {
            pub fn new(origin_trials: Vec<OriginTrial>) -> Self {
                Self { origin_trials }
            }
        }
        impl GetOriginTrialsReturns {
            pub fn builder() -> GetOriginTrialsReturnsBuilder {
                GetOriginTrialsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetOriginTrialsReturnsBuilder {
            origin_trials: Option<Vec<OriginTrial>>,
        }
        impl GetOriginTrialsReturnsBuilder {
            pub fn origin_trial(mut self, origin_trial: impl Into<OriginTrial>) -> Self {
                let v = self.origin_trials.get_or_insert(Vec::new());
                v.push(origin_trial.into());
                self
            }
            pub fn origin_trials<I, S>(mut self, origin_trials: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<OriginTrial>,
            {
                let v = self.origin_trials.get_or_insert(Vec::new());
                for val in origin_trials {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetOriginTrialsReturns, String> {
                Ok(GetOriginTrialsReturns {
                    origin_trials: self.origin_trials.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin_trials))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetOriginTrialsParams {
            type Response = GetOriginTrialsReturns;
        }
        #[doc = "Set generic font families.\n[setFontFamilies](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setFontFamilies)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetFontFamiliesParams {
            #[doc = "Specifies font families to set. If a font family is not specified, it won't be changed."]
            #[serde(rename = "fontFamilies")]
            pub font_families: FontFamilies,
            #[doc = "Specifies font families to set for individual scripts."]
            #[serde(rename = "forScripts")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub for_scripts: Option<Vec<ScriptFontFamilies>>,
        }
        impl SetFontFamiliesParams {
            pub fn new(font_families: impl Into<FontFamilies>) -> Self {
                Self {
                    font_families: font_families.into(),
                    for_scripts: None,
                }
            }
        }
        impl SetFontFamiliesParams {
            pub fn builder() -> SetFontFamiliesParamsBuilder {
                SetFontFamiliesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetFontFamiliesParamsBuilder {
            font_families: Option<FontFamilies>,
            for_scripts: Option<Vec<ScriptFontFamilies>>,
        }
        impl SetFontFamiliesParamsBuilder {
            pub fn font_families(mut self, font_families: impl Into<FontFamilies>) -> Self {
                self.font_families = Some(font_families.into());
                self
            }
            pub fn for_script(mut self, for_script: impl Into<ScriptFontFamilies>) -> Self {
                let v = self.for_scripts.get_or_insert(Vec::new());
                v.push(for_script.into());
                self
            }
            pub fn for_scripts<I, S>(mut self, for_scripts: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ScriptFontFamilies>,
            {
                let v = self.for_scripts.get_or_insert(Vec::new());
                for val in for_scripts {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetFontFamiliesParams, String> {
                Ok(SetFontFamiliesParams {
                    font_families: self.font_families.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(font_families))
                    })?,
                    for_scripts: self.for_scripts,
                })
            }
        }
        impl SetFontFamiliesParams {
            pub const IDENTIFIER: &'static str = "Page.setFontFamilies";
        }
        impl chromiumoxide_types::Method for SetFontFamiliesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetFontFamiliesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Set generic font families.\n[setFontFamilies](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setFontFamilies)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetFontFamiliesReturns {}
        impl chromiumoxide_types::Command for SetFontFamiliesParams {
            type Response = SetFontFamiliesReturns;
        }
        #[doc = "Set default font sizes.\n[setFontSizes](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setFontSizes)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetFontSizesParams {
            #[doc = "Specifies font sizes to set. If a font size is not specified, it won't be changed."]
            #[serde(rename = "fontSizes")]
            pub font_sizes: FontSizes,
        }
        impl SetFontSizesParams {
            pub fn new(font_sizes: impl Into<FontSizes>) -> Self {
                Self {
                    font_sizes: font_sizes.into(),
                }
            }
        }
        impl SetFontSizesParams {
            pub fn builder() -> SetFontSizesParamsBuilder {
                SetFontSizesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetFontSizesParamsBuilder {
            font_sizes: Option<FontSizes>,
        }
        impl SetFontSizesParamsBuilder {
            pub fn font_sizes(mut self, font_sizes: impl Into<FontSizes>) -> Self {
                self.font_sizes = Some(font_sizes.into());
                self
            }
            pub fn build(self) -> Result<SetFontSizesParams, String> {
                Ok(SetFontSizesParams {
                    font_sizes: self.font_sizes.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(font_sizes))
                    })?,
                })
            }
        }
        impl SetFontSizesParams {
            pub const IDENTIFIER: &'static str = "Page.setFontSizes";
        }
        impl chromiumoxide_types::Method for SetFontSizesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetFontSizesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Set default font sizes.\n[setFontSizes](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setFontSizes)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetFontSizesReturns {}
        impl chromiumoxide_types::Command for SetFontSizesParams {
            type Response = SetFontSizesReturns;
        }
        #[doc = "Sets given markup as the document's HTML.\n[setDocumentContent](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setDocumentContent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetDocumentContentParams {
            #[doc = "Frame id to set HTML for."]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
            #[doc = "HTML content to set."]
            #[serde(rename = "html")]
            pub html: String,
        }
        impl SetDocumentContentParams {
            pub fn new(frame_id: impl Into<FrameId>, html: impl Into<String>) -> Self {
                Self {
                    frame_id: frame_id.into(),
                    html: html.into(),
                }
            }
        }
        impl SetDocumentContentParams {
            pub fn builder() -> SetDocumentContentParamsBuilder {
                SetDocumentContentParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetDocumentContentParamsBuilder {
            frame_id: Option<FrameId>,
            html: Option<String>,
        }
        impl SetDocumentContentParamsBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn html(mut self, html: impl Into<String>) -> Self {
                self.html = Some(html.into());
                self
            }
            pub fn build(self) -> Result<SetDocumentContentParams, String> {
                Ok(SetDocumentContentParams {
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                    html: self.html.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(html))
                    })?,
                })
            }
        }
        impl SetDocumentContentParams {
            pub const IDENTIFIER: &'static str = "Page.setDocumentContent";
        }
        impl chromiumoxide_types::Method for SetDocumentContentParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetDocumentContentParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets given markup as the document's HTML.\n[setDocumentContent](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setDocumentContent)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetDocumentContentReturns {}
        impl chromiumoxide_types::Command for SetDocumentContentParams {
            type Response = SetDocumentContentReturns;
        }
        #[doc = "Controls whether page will emit lifecycle events.\n[setLifecycleEventsEnabled](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setLifecycleEventsEnabled)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetLifecycleEventsEnabledParams {
            #[doc = "If true, starts emitting lifecycle events."]
            #[serde(rename = "enabled")]
            pub enabled: bool,
        }
        impl SetLifecycleEventsEnabledParams {
            pub fn new(enabled: impl Into<bool>) -> Self {
                Self {
                    enabled: enabled.into(),
                }
            }
        }
        impl SetLifecycleEventsEnabledParams {
            pub fn builder() -> SetLifecycleEventsEnabledParamsBuilder {
                SetLifecycleEventsEnabledParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetLifecycleEventsEnabledParamsBuilder {
            enabled: Option<bool>,
        }
        impl SetLifecycleEventsEnabledParamsBuilder {
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn build(self) -> Result<SetLifecycleEventsEnabledParams, String> {
                Ok(SetLifecycleEventsEnabledParams {
                    enabled: self.enabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enabled))
                    })?,
                })
            }
        }
        impl SetLifecycleEventsEnabledParams {
            pub const IDENTIFIER: &'static str = "Page.setLifecycleEventsEnabled";
        }
        impl chromiumoxide_types::Method for SetLifecycleEventsEnabledParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetLifecycleEventsEnabledParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Controls whether page will emit lifecycle events.\n[setLifecycleEventsEnabled](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setLifecycleEventsEnabled)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetLifecycleEventsEnabledReturns {}
        impl chromiumoxide_types::Command for SetLifecycleEventsEnabledParams {
            type Response = SetLifecycleEventsEnabledReturns;
        }
        #[doc = "Starts sending each frame using the `screencastFrame` event.\n[startScreencast](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-startScreencast)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartScreencastParams {
            #[doc = "Image compression format."]
            #[serde(rename = "format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub format: Option<StartScreencastFormat>,
            #[doc = "Compression quality from range [0..100]."]
            #[serde(rename = "quality")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub quality: Option<i64>,
            #[doc = "Maximum screenshot width."]
            #[serde(rename = "maxWidth")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub max_width: Option<i64>,
            #[doc = "Maximum screenshot height."]
            #[serde(rename = "maxHeight")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub max_height: Option<i64>,
            #[doc = "Send every n-th frame."]
            #[serde(rename = "everyNthFrame")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub every_nth_frame: Option<i64>,
        }
        #[doc = "Image compression format."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum StartScreencastFormat {
            #[serde(rename = "jpeg")]
            Jpeg,
            #[serde(rename = "png")]
            Png,
        }
        impl AsRef<str> for StartScreencastFormat {
            fn as_ref(&self) -> &str {
                match self {
                    StartScreencastFormat::Jpeg => "jpeg",
                    StartScreencastFormat::Png => "png",
                }
            }
        }
        impl ::std::str::FromStr for StartScreencastFormat {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "jpeg" | "Jpeg" => Ok(StartScreencastFormat::Jpeg),
                    "png" | "Png" => Ok(StartScreencastFormat::Png),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl StartScreencastParams {
            pub fn builder() -> StartScreencastParamsBuilder {
                StartScreencastParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StartScreencastParamsBuilder {
            format: Option<StartScreencastFormat>,
            quality: Option<i64>,
            max_width: Option<i64>,
            max_height: Option<i64>,
            every_nth_frame: Option<i64>,
        }
        impl StartScreencastParamsBuilder {
            pub fn format(mut self, format: impl Into<StartScreencastFormat>) -> Self {
                self.format = Some(format.into());
                self
            }
            pub fn quality(mut self, quality: impl Into<i64>) -> Self {
                self.quality = Some(quality.into());
                self
            }
            pub fn max_width(mut self, max_width: impl Into<i64>) -> Self {
                self.max_width = Some(max_width.into());
                self
            }
            pub fn max_height(mut self, max_height: impl Into<i64>) -> Self {
                self.max_height = Some(max_height.into());
                self
            }
            pub fn every_nth_frame(mut self, every_nth_frame: impl Into<i64>) -> Self {
                self.every_nth_frame = Some(every_nth_frame.into());
                self
            }
            pub fn build(self) -> StartScreencastParams {
                StartScreencastParams {
                    format: self.format,
                    quality: self.quality,
                    max_width: self.max_width,
                    max_height: self.max_height,
                    every_nth_frame: self.every_nth_frame,
                }
            }
        }
        impl StartScreencastParams {
            pub const IDENTIFIER: &'static str = "Page.startScreencast";
        }
        impl chromiumoxide_types::Method for StartScreencastParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartScreencastParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Starts sending each frame using the `screencastFrame` event.\n[startScreencast](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-startScreencast)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartScreencastReturns {}
        impl chromiumoxide_types::Command for StartScreencastParams {
            type Response = StartScreencastReturns;
        }
        #[doc = "Force the page stop all navigations and pending resource fetches.\n[stopLoading](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-stopLoading)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopLoadingParams {}
        impl StopLoadingParams {
            pub const IDENTIFIER: &'static str = "Page.stopLoading";
        }
        impl chromiumoxide_types::Method for StopLoadingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopLoadingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Force the page stop all navigations and pending resource fetches.\n[stopLoading](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-stopLoading)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopLoadingReturns {}
        impl chromiumoxide_types::Command for StopLoadingParams {
            type Response = StopLoadingReturns;
        }
        #[doc = "Crashes renderer on the IO thread, generates minidumps.\n[crash](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-crash)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CrashParams {}
        impl CrashParams {
            pub const IDENTIFIER: &'static str = "Page.crash";
        }
        impl chromiumoxide_types::Method for CrashParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CrashParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Crashes renderer on the IO thread, generates minidumps.\n[crash](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-crash)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CrashReturns {}
        impl chromiumoxide_types::Command for CrashParams {
            type Response = CrashReturns;
        }
        #[doc = "Tries to close page, running its beforeunload hooks, if any.\n[close](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-close)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CloseParams {}
        impl CloseParams {
            pub const IDENTIFIER: &'static str = "Page.close";
        }
        impl chromiumoxide_types::Method for CloseParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CloseParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Tries to close page, running its beforeunload hooks, if any.\n[close](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-close)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CloseReturns {}
        impl chromiumoxide_types::Command for CloseParams {
            type Response = CloseReturns;
        }
        #[doc = "Tries to update the web lifecycle state of the page.\nIt will transition the page to the given state according to:\nhttps://github.com/WICG/web-lifecycle/\n[setWebLifecycleState](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setWebLifecycleState)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetWebLifecycleStateParams {
            #[doc = "Target lifecycle state"]
            #[serde(rename = "state")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub state: SetWebLifecycleStateState,
        }
        #[doc = "Target lifecycle state"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SetWebLifecycleStateState {
            #[serde(rename = "frozen")]
            Frozen,
            #[serde(rename = "active")]
            Active,
        }
        impl AsRef<str> for SetWebLifecycleStateState {
            fn as_ref(&self) -> &str {
                match self {
                    SetWebLifecycleStateState::Frozen => "frozen",
                    SetWebLifecycleStateState::Active => "active",
                }
            }
        }
        impl ::std::str::FromStr for SetWebLifecycleStateState {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "frozen" | "Frozen" => Ok(SetWebLifecycleStateState::Frozen),
                    "active" | "Active" => Ok(SetWebLifecycleStateState::Active),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl SetWebLifecycleStateParams {
            pub fn new(state: impl Into<SetWebLifecycleStateState>) -> Self {
                Self {
                    state: state.into(),
                }
            }
        }
        impl SetWebLifecycleStateParams {
            pub fn builder() -> SetWebLifecycleStateParamsBuilder {
                SetWebLifecycleStateParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetWebLifecycleStateParamsBuilder {
            state: Option<SetWebLifecycleStateState>,
        }
        impl SetWebLifecycleStateParamsBuilder {
            pub fn state(mut self, state: impl Into<SetWebLifecycleStateState>) -> Self {
                self.state = Some(state.into());
                self
            }
            pub fn build(self) -> Result<SetWebLifecycleStateParams, String> {
                Ok(SetWebLifecycleStateParams {
                    state: self.state.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(state))
                    })?,
                })
            }
        }
        impl SetWebLifecycleStateParams {
            pub const IDENTIFIER: &'static str = "Page.setWebLifecycleState";
        }
        impl chromiumoxide_types::Method for SetWebLifecycleStateParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetWebLifecycleStateParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Tries to update the web lifecycle state of the page.\nIt will transition the page to the given state according to:\nhttps://github.com/WICG/web-lifecycle/\n[setWebLifecycleState](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setWebLifecycleState)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetWebLifecycleStateReturns {}
        impl chromiumoxide_types::Command for SetWebLifecycleStateParams {
            type Response = SetWebLifecycleStateReturns;
        }
        #[doc = "Stops sending each frame in the `screencastFrame`.\n[stopScreencast](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-stopScreencast)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopScreencastParams {}
        impl StopScreencastParams {
            pub const IDENTIFIER: &'static str = "Page.stopScreencast";
        }
        impl chromiumoxide_types::Method for StopScreencastParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopScreencastParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Stops sending each frame in the `screencastFrame`.\n[stopScreencast](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-stopScreencast)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopScreencastReturns {}
        impl chromiumoxide_types::Command for StopScreencastParams {
            type Response = StopScreencastReturns;
        }
        #[doc = "Requests backend to produce compilation cache for the specified scripts.\n`scripts` are appeneded to the list of scripts for which the cache\nwould be produced. The list may be reset during page navigation.\nWhen script with a matching URL is encountered, the cache is optionally\nproduced upon backend discretion, based on internal heuristics.\nSee also: `Page.compilationCacheProduced`.\n[produceCompilationCache](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-produceCompilationCache)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ProduceCompilationCacheParams {
            #[serde(rename = "scripts")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub scripts: Vec<CompilationCacheParams>,
        }
        impl ProduceCompilationCacheParams {
            pub fn new(scripts: Vec<CompilationCacheParams>) -> Self {
                Self { scripts }
            }
        }
        impl ProduceCompilationCacheParams {
            pub fn builder() -> ProduceCompilationCacheParamsBuilder {
                ProduceCompilationCacheParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ProduceCompilationCacheParamsBuilder {
            scripts: Option<Vec<CompilationCacheParams>>,
        }
        impl ProduceCompilationCacheParamsBuilder {
            pub fn script(mut self, script: impl Into<CompilationCacheParams>) -> Self {
                let v = self.scripts.get_or_insert(Vec::new());
                v.push(script.into());
                self
            }
            pub fn scripts<I, S>(mut self, scripts: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<CompilationCacheParams>,
            {
                let v = self.scripts.get_or_insert(Vec::new());
                for val in scripts {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<ProduceCompilationCacheParams, String> {
                Ok(ProduceCompilationCacheParams {
                    scripts: self.scripts.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scripts))
                    })?,
                })
            }
        }
        impl ProduceCompilationCacheParams {
            pub const IDENTIFIER: &'static str = "Page.produceCompilationCache";
        }
        impl chromiumoxide_types::Method for ProduceCompilationCacheParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ProduceCompilationCacheParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Requests backend to produce compilation cache for the specified scripts.\n`scripts` are appeneded to the list of scripts for which the cache\nwould be produced. The list may be reset during page navigation.\nWhen script with a matching URL is encountered, the cache is optionally\nproduced upon backend discretion, based on internal heuristics.\nSee also: `Page.compilationCacheProduced`.\n[produceCompilationCache](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-produceCompilationCache)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ProduceCompilationCacheReturns {}
        impl chromiumoxide_types::Command for ProduceCompilationCacheParams {
            type Response = ProduceCompilationCacheReturns;
        }
        #[doc = "Seeds compilation cache for given url. Compilation cache does not survive\ncross-process navigation.\n[addCompilationCache](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-addCompilationCache)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AddCompilationCacheParams {
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Base64-encoded data"]
            #[serde(rename = "data")]
            pub data: chromiumoxide_types::Binary,
        }
        impl AddCompilationCacheParams {
            pub fn new(
                url: impl Into<String>,
                data: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                Self {
                    url: url.into(),
                    data: data.into(),
                }
            }
        }
        impl AddCompilationCacheParams {
            pub fn builder() -> AddCompilationCacheParamsBuilder {
                AddCompilationCacheParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AddCompilationCacheParamsBuilder {
            url: Option<String>,
            data: Option<chromiumoxide_types::Binary>,
        }
        impl AddCompilationCacheParamsBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn data(mut self, data: impl Into<chromiumoxide_types::Binary>) -> Self {
                self.data = Some(data.into());
                self
            }
            pub fn build(self) -> Result<AddCompilationCacheParams, String> {
                Ok(AddCompilationCacheParams {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    data: self.data.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(data))
                    })?,
                })
            }
        }
        impl AddCompilationCacheParams {
            pub const IDENTIFIER: &'static str = "Page.addCompilationCache";
        }
        impl chromiumoxide_types::Method for AddCompilationCacheParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for AddCompilationCacheParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Seeds compilation cache for given url. Compilation cache does not survive\ncross-process navigation.\n[addCompilationCache](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-addCompilationCache)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct AddCompilationCacheReturns {}
        impl chromiumoxide_types::Command for AddCompilationCacheParams {
            type Response = AddCompilationCacheReturns;
        }
        #[doc = "Clears seeded compilation cache.\n[clearCompilationCache](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-clearCompilationCache)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearCompilationCacheParams {}
        impl ClearCompilationCacheParams {
            pub const IDENTIFIER: &'static str = "Page.clearCompilationCache";
        }
        impl chromiumoxide_types::Method for ClearCompilationCacheParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearCompilationCacheParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears seeded compilation cache.\n[clearCompilationCache](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-clearCompilationCache)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearCompilationCacheReturns {}
        impl chromiumoxide_types::Command for ClearCompilationCacheParams {
            type Response = ClearCompilationCacheReturns;
        }
        #[doc = "Sets the Secure Payment Confirmation transaction mode.\nhttps://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode\n[setSPCTransactionMode](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setSPCTransactionMode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetSpcTransactionModeParams {
            #[serde(rename = "mode")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub mode: SetSpcTransactionModeMode,
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SetSpcTransactionModeMode {
            #[serde(rename = "none")]
            None,
            #[serde(rename = "autoaccept")]
            Autoaccept,
            #[serde(rename = "autoreject")]
            Autoreject,
        }
        impl AsRef<str> for SetSpcTransactionModeMode {
            fn as_ref(&self) -> &str {
                match self {
                    SetSpcTransactionModeMode::None => "none",
                    SetSpcTransactionModeMode::Autoaccept => "autoaccept",
                    SetSpcTransactionModeMode::Autoreject => "autoreject",
                }
            }
        }
        impl ::std::str::FromStr for SetSpcTransactionModeMode {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "none" | "None" => Ok(SetSpcTransactionModeMode::None),
                    "autoaccept" | "Autoaccept" => Ok(SetSpcTransactionModeMode::Autoaccept),
                    "autoreject" | "Autoreject" => Ok(SetSpcTransactionModeMode::Autoreject),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl SetSpcTransactionModeParams {
            pub fn new(mode: impl Into<SetSpcTransactionModeMode>) -> Self {
                Self { mode: mode.into() }
            }
        }
        impl SetSpcTransactionModeParams {
            pub fn builder() -> SetSpcTransactionModeParamsBuilder {
                SetSpcTransactionModeParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetSpcTransactionModeParamsBuilder {
            mode: Option<SetSpcTransactionModeMode>,
        }
        impl SetSpcTransactionModeParamsBuilder {
            pub fn mode(mut self, mode: impl Into<SetSpcTransactionModeMode>) -> Self {
                self.mode = Some(mode.into());
                self
            }
            pub fn build(self) -> Result<SetSpcTransactionModeParams, String> {
                Ok(SetSpcTransactionModeParams {
                    mode: self.mode.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(mode))
                    })?,
                })
            }
        }
        impl SetSpcTransactionModeParams {
            pub const IDENTIFIER: &'static str = "Page.setSPCTransactionMode";
        }
        impl chromiumoxide_types::Method for SetSpcTransactionModeParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetSpcTransactionModeParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets the Secure Payment Confirmation transaction mode.\nhttps://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode\n[setSPCTransactionMode](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setSPCTransactionMode)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetSpcTransactionModeReturns {}
        impl chromiumoxide_types::Command for SetSpcTransactionModeParams {
            type Response = SetSpcTransactionModeReturns;
        }
        #[doc = "Generates a report for testing.\n[generateTestReport](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-generateTestReport)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GenerateTestReportParams {
            #[doc = "Message to be displayed in the report."]
            #[serde(rename = "message")]
            pub message: String,
            #[doc = "Specifies the endpoint group to deliver the report to."]
            #[serde(rename = "group")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub group: Option<String>,
        }
        impl GenerateTestReportParams {
            pub fn new(message: impl Into<String>) -> Self {
                Self {
                    message: message.into(),
                    group: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for GenerateTestReportParams {
            fn from(url: T) -> Self {
                GenerateTestReportParams::new(url)
            }
        }
        impl GenerateTestReportParams {
            pub fn builder() -> GenerateTestReportParamsBuilder {
                GenerateTestReportParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GenerateTestReportParamsBuilder {
            message: Option<String>,
            group: Option<String>,
        }
        impl GenerateTestReportParamsBuilder {
            pub fn message(mut self, message: impl Into<String>) -> Self {
                self.message = Some(message.into());
                self
            }
            pub fn group(mut self, group: impl Into<String>) -> Self {
                self.group = Some(group.into());
                self
            }
            pub fn build(self) -> Result<GenerateTestReportParams, String> {
                Ok(GenerateTestReportParams {
                    message: self.message.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(message))
                    })?,
                    group: self.group,
                })
            }
        }
        impl GenerateTestReportParams {
            pub const IDENTIFIER: &'static str = "Page.generateTestReport";
        }
        impl chromiumoxide_types::Method for GenerateTestReportParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GenerateTestReportParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Generates a report for testing.\n[generateTestReport](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-generateTestReport)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GenerateTestReportReturns {}
        impl chromiumoxide_types::Command for GenerateTestReportParams {
            type Response = GenerateTestReportReturns;
        }
        #[doc = "Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.\n[waitForDebugger](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-waitForDebugger)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct WaitForDebuggerParams {}
        impl WaitForDebuggerParams {
            pub const IDENTIFIER: &'static str = "Page.waitForDebugger";
        }
        impl chromiumoxide_types::Method for WaitForDebuggerParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for WaitForDebuggerParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.\n[waitForDebugger](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-waitForDebugger)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct WaitForDebuggerReturns {}
        impl chromiumoxide_types::Command for WaitForDebuggerParams {
            type Response = WaitForDebuggerReturns;
        }
        #[doc = "Intercept file chooser requests and transfer control to protocol clients.\nWhen file chooser interception is enabled, native file chooser dialog is not shown.\nInstead, a protocol event `Page.fileChooserOpened` is emitted.\n[setInterceptFileChooserDialog](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setInterceptFileChooserDialog)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetInterceptFileChooserDialogParams {
            #[serde(rename = "enabled")]
            pub enabled: bool,
        }
        impl SetInterceptFileChooserDialogParams {
            pub fn new(enabled: impl Into<bool>) -> Self {
                Self {
                    enabled: enabled.into(),
                }
            }
        }
        impl SetInterceptFileChooserDialogParams {
            pub fn builder() -> SetInterceptFileChooserDialogParamsBuilder {
                SetInterceptFileChooserDialogParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetInterceptFileChooserDialogParamsBuilder {
            enabled: Option<bool>,
        }
        impl SetInterceptFileChooserDialogParamsBuilder {
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn build(self) -> Result<SetInterceptFileChooserDialogParams, String> {
                Ok(SetInterceptFileChooserDialogParams {
                    enabled: self.enabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enabled))
                    })?,
                })
            }
        }
        impl SetInterceptFileChooserDialogParams {
            pub const IDENTIFIER: &'static str = "Page.setInterceptFileChooserDialog";
        }
        impl chromiumoxide_types::Method for SetInterceptFileChooserDialogParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetInterceptFileChooserDialogParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Intercept file chooser requests and transfer control to protocol clients.\nWhen file chooser interception is enabled, native file chooser dialog is not shown.\nInstead, a protocol event `Page.fileChooserOpened` is emitted.\n[setInterceptFileChooserDialog](https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setInterceptFileChooserDialog)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetInterceptFileChooserDialogReturns {}
        impl chromiumoxide_types::Command for SetInterceptFileChooserDialogParams {
            type Response = SetInterceptFileChooserDialogReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDomContentEventFired {
            #[serde(rename = "timestamp")]
            pub timestamp: super::network::MonotonicTime,
        }
        impl EventDomContentEventFired {
            pub const IDENTIFIER: &'static str = "Page.domContentEventFired";
        }
        impl chromiumoxide_types::Method for EventDomContentEventFired {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDomContentEventFired {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Emitted only when `page.interceptFileChooser` is enabled.\n[fileChooserOpened](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-fileChooserOpened)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventFileChooserOpened {
            #[doc = "Id of the frame containing input node."]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
            #[doc = "Input mode."]
            #[serde(rename = "mode")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub mode: FileChooserOpenedMode,
            #[doc = "Input node id. Only present for file choosers opened via an <input type=\"file\"> element."]
            #[serde(rename = "backendNodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub backend_node_id: Option<super::dom::BackendNodeId>,
        }
        #[doc = "Input mode."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum FileChooserOpenedMode {
            #[serde(rename = "selectSingle")]
            SelectSingle,
            #[serde(rename = "selectMultiple")]
            SelectMultiple,
        }
        impl AsRef<str> for FileChooserOpenedMode {
            fn as_ref(&self) -> &str {
                match self {
                    FileChooserOpenedMode::SelectSingle => "selectSingle",
                    FileChooserOpenedMode::SelectMultiple => "selectMultiple",
                }
            }
        }
        impl ::std::str::FromStr for FileChooserOpenedMode {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "selectSingle" | "SelectSingle" | "selectsingle" => {
                        Ok(FileChooserOpenedMode::SelectSingle)
                    }
                    "selectMultiple" | "SelectMultiple" | "selectmultiple" => {
                        Ok(FileChooserOpenedMode::SelectMultiple)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl EventFileChooserOpened {
            pub const IDENTIFIER: &'static str = "Page.fileChooserOpened";
        }
        impl chromiumoxide_types::Method for EventFileChooserOpened {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventFileChooserOpened {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when frame has been attached to its parent.\n[frameAttached](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameAttached)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventFrameAttached {
            #[doc = "Id of the frame that has been attached."]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
            #[doc = "Parent frame identifier."]
            #[serde(rename = "parentFrameId")]
            pub parent_frame_id: FrameId,
            #[doc = "JavaScript stack trace of when frame was attached, only set if frame initiated from script."]
            #[serde(rename = "stack")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub stack: Option<super::super::js_protocol::runtime::StackTrace>,
            #[doc = "Identifies the bottom-most script which caused the frame to be labelled\nas an ad. Only sent if frame is labelled as an ad and id is available."]
            #[serde(rename = "adScriptId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub ad_script_id: Option<AdScriptId>,
        }
        impl EventFrameAttached {
            pub const IDENTIFIER: &'static str = "Page.frameAttached";
        }
        impl chromiumoxide_types::Method for EventFrameAttached {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventFrameAttached {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when frame has been detached from its parent.\n[frameDetached](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameDetached)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventFrameDetached {
            #[doc = "Id of the frame that has been detached."]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
            #[serde(rename = "reason")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub reason: FrameDetachedReason,
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum FrameDetachedReason {
            #[doc = "The frame is removed from the DOM."]
            #[serde(rename = "remove")]
            Remove,
            #[doc = "The frame is being swapped out in favor of an out-of-process iframe.\nA new frame target will be created (see Target.attachedToTarget)."]
            #[serde(rename = "swap")]
            Swap,
        }
        impl AsRef<str> for FrameDetachedReason {
            fn as_ref(&self) -> &str {
                match self {
                    FrameDetachedReason::Remove => "remove",
                    FrameDetachedReason::Swap => "swap",
                }
            }
        }
        impl ::std::str::FromStr for FrameDetachedReason {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "remove" | "Remove" => Ok(FrameDetachedReason::Remove),
                    "swap" | "Swap" => Ok(FrameDetachedReason::Swap),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl EventFrameDetached {
            pub const IDENTIFIER: &'static str = "Page.frameDetached";
        }
        impl chromiumoxide_types::Method for EventFrameDetached {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventFrameDetached {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired once navigation of the frame has completed. Frame is now associated with the new loader.\n[frameNavigated](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameNavigated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventFrameNavigated {
            #[doc = "Frame object."]
            #[serde(rename = "frame")]
            pub frame: Frame,
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: NavigationType,
        }
        impl EventFrameNavigated {
            pub const IDENTIFIER: &'static str = "Page.frameNavigated";
        }
        impl chromiumoxide_types::Method for EventFrameNavigated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventFrameNavigated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when opening document to write to.\n[documentOpened](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-documentOpened)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDocumentOpened {
            #[doc = "Frame object."]
            #[serde(rename = "frame")]
            pub frame: Frame,
        }
        impl EventDocumentOpened {
            pub const IDENTIFIER: &'static str = "Page.documentOpened";
        }
        impl chromiumoxide_types::Method for EventDocumentOpened {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDocumentOpened {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventFrameResized {}
        impl EventFrameResized {
            pub const IDENTIFIER: &'static str = "Page.frameResized";
        }
        impl chromiumoxide_types::Method for EventFrameResized {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventFrameResized {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when a renderer-initiated navigation is requested.\nNavigation may still be cancelled after the event is issued.\n[frameRequestedNavigation](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameRequestedNavigation)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventFrameRequestedNavigation {
            #[doc = "Id of the frame that is being navigated."]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
            #[doc = "The reason for the navigation."]
            #[serde(rename = "reason")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub reason: ClientNavigationReason,
            #[doc = "The destination URL for the requested navigation."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "The disposition for the navigation."]
            #[serde(rename = "disposition")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub disposition: ClientNavigationDisposition,
        }
        impl EventFrameRequestedNavigation {
            pub const IDENTIFIER: &'static str = "Page.frameRequestedNavigation";
        }
        impl chromiumoxide_types::Method for EventFrameRequestedNavigation {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventFrameRequestedNavigation {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when frame has started loading.\n[frameStartedLoading](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameStartedLoading)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventFrameStartedLoading {
            #[doc = "Id of the frame that has started loading."]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
        }
        impl EventFrameStartedLoading {
            pub const IDENTIFIER: &'static str = "Page.frameStartedLoading";
        }
        impl chromiumoxide_types::Method for EventFrameStartedLoading {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventFrameStartedLoading {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when frame has stopped loading.\n[frameStoppedLoading](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameStoppedLoading)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventFrameStoppedLoading {
            #[doc = "Id of the frame that has stopped loading."]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
        }
        impl EventFrameStoppedLoading {
            pub const IDENTIFIER: &'static str = "Page.frameStoppedLoading";
        }
        impl chromiumoxide_types::Method for EventFrameStoppedLoading {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventFrameStoppedLoading {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when interstitial page was hidden\n[interstitialHidden](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-interstitialHidden)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventInterstitialHidden {}
        impl EventInterstitialHidden {
            pub const IDENTIFIER: &'static str = "Page.interstitialHidden";
        }
        impl chromiumoxide_types::Method for EventInterstitialHidden {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventInterstitialHidden {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when interstitial page was shown\n[interstitialShown](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-interstitialShown)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventInterstitialShown {}
        impl EventInterstitialShown {
            pub const IDENTIFIER: &'static str = "Page.interstitialShown";
        }
        impl chromiumoxide_types::Method for EventInterstitialShown {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventInterstitialShown {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been\nclosed.\n[javascriptDialogClosed](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-javascriptDialogClosed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventJavascriptDialogClosed {
            #[doc = "Whether dialog was confirmed."]
            #[serde(rename = "result")]
            pub result: bool,
            #[doc = "User input in case of prompt."]
            #[serde(rename = "userInput")]
            pub user_input: String,
        }
        impl EventJavascriptDialogClosed {
            pub const IDENTIFIER: &'static str = "Page.javascriptDialogClosed";
        }
        impl chromiumoxide_types::Method for EventJavascriptDialogClosed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventJavascriptDialogClosed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to\nopen.\n[javascriptDialogOpening](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-javascriptDialogOpening)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventJavascriptDialogOpening {
            #[doc = "Frame url."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Message that will be displayed by the dialog."]
            #[serde(rename = "message")]
            pub message: String,
            #[doc = "Dialog type."]
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: DialogType,
            #[doc = "True iff browser is capable showing or acting on the given dialog. When browser has no\ndialog handler for given target, calling alert while Page domain is engaged will stall\nthe page execution. Execution can be resumed via calling Page.handleJavaScriptDialog."]
            #[serde(rename = "hasBrowserHandler")]
            pub has_browser_handler: bool,
            #[doc = "Default dialog prompt."]
            #[serde(rename = "defaultPrompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub default_prompt: Option<String>,
        }
        impl EventJavascriptDialogOpening {
            pub const IDENTIFIER: &'static str = "Page.javascriptDialogOpening";
        }
        impl chromiumoxide_types::Method for EventJavascriptDialogOpening {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventJavascriptDialogOpening {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired for top level page lifecycle events such as navigation, load, paint, etc.\n[lifecycleEvent](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-lifecycleEvent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventLifecycleEvent {
            #[doc = "Id of the frame."]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
            #[doc = "Loader identifier. Empty string if the request is fetched from worker."]
            #[serde(rename = "loaderId")]
            pub loader_id: super::network::LoaderId,
            #[serde(rename = "name")]
            pub name: String,
            #[serde(rename = "timestamp")]
            pub timestamp: super::network::MonotonicTime,
        }
        impl EventLifecycleEvent {
            pub const IDENTIFIER: &'static str = "Page.lifecycleEvent";
        }
        impl chromiumoxide_types::Method for EventLifecycleEvent {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventLifecycleEvent {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do\nnot assume any ordering with the Page.frameNavigated event. This event is fired only for\nmain-frame history navigation where the document changes (non-same-document navigations),\nwhen bfcache navigation fails.\n[backForwardCacheNotUsed](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-backForwardCacheNotUsed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventBackForwardCacheNotUsed {
            #[doc = "The loader id for the associated navgation."]
            #[serde(rename = "loaderId")]
            pub loader_id: super::network::LoaderId,
            #[doc = "The frame id of the associated frame."]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
            #[doc = "Array of reasons why the page could not be cached. This must not be empty."]
            #[serde(rename = "notRestoredExplanations")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub not_restored_explanations: Vec<BackForwardCacheNotRestoredExplanation>,
            #[doc = "Tree structure of reasons why the page could not be cached for each frame."]
            #[serde(rename = "notRestoredExplanationsTree")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub not_restored_explanations_tree: Option<BackForwardCacheNotRestoredExplanationTree>,
        }
        impl EventBackForwardCacheNotUsed {
            pub const IDENTIFIER: &'static str = "Page.backForwardCacheNotUsed";
        }
        impl chromiumoxide_types::Method for EventBackForwardCacheNotUsed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventBackForwardCacheNotUsed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when a prerender attempt is completed.\n[prerenderAttemptCompleted](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-prerenderAttemptCompleted)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventPrerenderAttemptCompleted {
            #[doc = "The frame id of the frame initiating prerendering."]
            #[serde(rename = "initiatingFrameId")]
            pub initiating_frame_id: FrameId,
            #[serde(rename = "prerenderingUrl")]
            pub prerendering_url: String,
            #[serde(rename = "finalStatus")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub final_status: PrerenderFinalStatus,
            #[doc = "This is used to give users more information about the cancellation details,\nand this will be formatted for display."]
            #[serde(rename = "reasonDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub reason_details: Option<String>,
        }
        impl EventPrerenderAttemptCompleted {
            pub const IDENTIFIER: &'static str = "Page.prerenderAttemptCompleted";
        }
        impl chromiumoxide_types::Method for EventPrerenderAttemptCompleted {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventPrerenderAttemptCompleted {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventLoadEventFired {
            #[serde(rename = "timestamp")]
            pub timestamp: super::network::MonotonicTime,
        }
        impl EventLoadEventFired {
            pub const IDENTIFIER: &'static str = "Page.loadEventFired";
        }
        impl chromiumoxide_types::Method for EventLoadEventFired {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventLoadEventFired {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.\n[navigatedWithinDocument](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-navigatedWithinDocument)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventNavigatedWithinDocument {
            #[doc = "Id of the frame."]
            #[serde(rename = "frameId")]
            pub frame_id: FrameId,
            #[doc = "Frame's new url."]
            #[serde(rename = "url")]
            pub url: String,
        }
        impl EventNavigatedWithinDocument {
            pub const IDENTIFIER: &'static str = "Page.navigatedWithinDocument";
        }
        impl chromiumoxide_types::Method for EventNavigatedWithinDocument {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventNavigatedWithinDocument {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Compressed image data requested by the `startScreencast`.\n[screencastFrame](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-screencastFrame)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventScreencastFrame {
            #[doc = "Base64-encoded compressed image."]
            #[serde(rename = "data")]
            pub data: chromiumoxide_types::Binary,
            #[doc = "Screencast frame metadata."]
            #[serde(rename = "metadata")]
            pub metadata: ScreencastFrameMetadata,
            #[doc = "Frame number."]
            #[serde(rename = "sessionId")]
            pub session_id: i64,
        }
        impl EventScreencastFrame {
            pub const IDENTIFIER: &'static str = "Page.screencastFrame";
        }
        impl chromiumoxide_types::Method for EventScreencastFrame {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventScreencastFrame {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when the page with currently enabled screencast was shown or hidden `.\n[screencastVisibilityChanged](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-screencastVisibilityChanged)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventScreencastVisibilityChanged {
            #[doc = "True if the page is visible."]
            #[serde(rename = "visible")]
            pub visible: bool,
        }
        impl EventScreencastVisibilityChanged {
            pub const IDENTIFIER: &'static str = "Page.screencastVisibilityChanged";
        }
        impl chromiumoxide_types::Method for EventScreencastVisibilityChanged {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventScreencastVisibilityChanged {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fired when a new window is going to be opened, via window.open(), link click, form submission,\netc.\n[windowOpen](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-windowOpen)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWindowOpen {
            #[doc = "The URL for the new window."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Window name."]
            #[serde(rename = "windowName")]
            pub window_name: String,
            #[doc = "An array of enabled window features."]
            #[serde(rename = "windowFeatures")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub window_features: Vec<String>,
            #[doc = "Whether or not it was triggered by user gesture."]
            #[serde(rename = "userGesture")]
            pub user_gesture: bool,
        }
        impl EventWindowOpen {
            pub const IDENTIFIER: &'static str = "Page.windowOpen";
        }
        impl chromiumoxide_types::Method for EventWindowOpen {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWindowOpen {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued for every compilation cache generated. Is only available\nif Page.setGenerateCompilationCache is enabled.\n[compilationCacheProduced](https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-compilationCacheProduced)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventCompilationCacheProduced {
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Base64-encoded data"]
            #[serde(rename = "data")]
            pub data: chromiumoxide_types::Binary,
        }
        impl EventCompilationCacheProduced {
            pub const IDENTIFIER: &'static str = "Page.compilationCacheProduced";
        }
        impl chromiumoxide_types::Method for EventCompilationCacheProduced {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventCompilationCacheProduced {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    pub mod performance {
        use serde::{Deserialize, Serialize};
        #[doc = "Run-time execution metric.\n[Metric](https://chromedevtools.github.io/devtools-protocol/tot/Performance/#type-Metric)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Metric {
            #[doc = "Metric name."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Metric value."]
            #[serde(rename = "value")]
            pub value: f64,
        }
        impl Metric {
            pub fn new(name: impl Into<String>, value: impl Into<f64>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                }
            }
        }
        impl Metric {
            pub fn builder() -> MetricBuilder {
                MetricBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct MetricBuilder {
            name: Option<String>,
            value: Option<f64>,
        }
        impl MetricBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<f64>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<Metric, String> {
                Ok(Metric {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl Metric {
            pub const IDENTIFIER: &'static str = "Performance.Metric";
        }
        #[doc = "Disable collecting and reporting metrics.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Performance/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Performance.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disable collecting and reporting metrics.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Performance/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enable collecting and reporting metrics.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Performance/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {
            #[doc = "Time domain to use for collecting and reporting duration metrics."]
            #[serde(rename = "timeDomain")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub time_domain: Option<EnableTimeDomain>,
        }
        #[doc = "Time domain to use for collecting and reporting duration metrics."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum EnableTimeDomain {
            #[doc = "Use monotonically increasing abstract time (default)."]
            #[serde(rename = "timeTicks")]
            TimeTicks,
            #[doc = "Use thread running time."]
            #[serde(rename = "threadTicks")]
            ThreadTicks,
        }
        impl AsRef<str> for EnableTimeDomain {
            fn as_ref(&self) -> &str {
                match self {
                    EnableTimeDomain::TimeTicks => "timeTicks",
                    EnableTimeDomain::ThreadTicks => "threadTicks",
                }
            }
        }
        impl ::std::str::FromStr for EnableTimeDomain {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "timeTicks" | "TimeTicks" | "timeticks" => Ok(EnableTimeDomain::TimeTicks),
                    "threadTicks" | "ThreadTicks" | "threadticks" => {
                        Ok(EnableTimeDomain::ThreadTicks)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl EnableParams {
            pub fn builder() -> EnableParamsBuilder {
                EnableParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EnableParamsBuilder {
            time_domain: Option<EnableTimeDomain>,
        }
        impl EnableParamsBuilder {
            pub fn time_domain(mut self, time_domain: impl Into<EnableTimeDomain>) -> Self {
                self.time_domain = Some(time_domain.into());
                self
            }
            pub fn build(self) -> EnableParams {
                EnableParams {
                    time_domain: self.time_domain,
                }
            }
        }
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Performance.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enable collecting and reporting metrics.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Performance/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Retrieve current values of run-time metrics.\n[getMetrics](https://chromedevtools.github.io/devtools-protocol/tot/Performance/#method-getMetrics)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetMetricsParams {}
        impl GetMetricsParams {
            pub const IDENTIFIER: &'static str = "Performance.getMetrics";
        }
        impl chromiumoxide_types::Method for GetMetricsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetMetricsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Retrieve current values of run-time metrics.\n[getMetrics](https://chromedevtools.github.io/devtools-protocol/tot/Performance/#method-getMetrics)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetMetricsReturns {
            #[doc = "Current values for run-time metrics."]
            #[serde(rename = "metrics")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub metrics: Vec<Metric>,
        }
        impl GetMetricsReturns {
            pub fn new(metrics: Vec<Metric>) -> Self {
                Self { metrics }
            }
        }
        impl GetMetricsReturns {
            pub fn builder() -> GetMetricsReturnsBuilder {
                GetMetricsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetMetricsReturnsBuilder {
            metrics: Option<Vec<Metric>>,
        }
        impl GetMetricsReturnsBuilder {
            pub fn metric(mut self, metric: impl Into<Metric>) -> Self {
                let v = self.metrics.get_or_insert(Vec::new());
                v.push(metric.into());
                self
            }
            pub fn metrics<I, S>(mut self, metrics: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Metric>,
            {
                let v = self.metrics.get_or_insert(Vec::new());
                for val in metrics {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetMetricsReturns, String> {
                Ok(GetMetricsReturns {
                    metrics: self.metrics.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(metrics))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetMetricsParams {
            type Response = GetMetricsReturns;
        }
        #[doc = "Current values of the metrics.\n[metrics](https://chromedevtools.github.io/devtools-protocol/tot/Performance/#event-metrics)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventMetrics {
            #[doc = "Current values of the metrics."]
            #[serde(rename = "metrics")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub metrics: Vec<Metric>,
            #[doc = "Timestamp title."]
            #[serde(rename = "title")]
            pub title: String,
        }
        impl EventMetrics {
            pub const IDENTIFIER: &'static str = "Performance.metrics";
        }
        impl chromiumoxide_types::Method for EventMetrics {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventMetrics {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "Reporting of performance timeline events, as specified in\nhttps://w3c.github.io/performance-timeline/#dom-performanceobserver."]
    pub mod performance_timeline {
        use serde::{Deserialize, Serialize};
        #[doc = "See https://github.com/WICG/LargestContentfulPaint and largest_contentful_paint.idl\n[LargestContentfulPaint](https://chromedevtools.github.io/devtools-protocol/tot/PerformanceTimeline/#type-LargestContentfulPaint)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LargestContentfulPaint {
            #[serde(rename = "renderTime")]
            pub render_time: super::network::TimeSinceEpoch,
            #[serde(rename = "loadTime")]
            pub load_time: super::network::TimeSinceEpoch,
            #[doc = "The number of pixels being painted."]
            #[serde(rename = "size")]
            pub size: f64,
            #[doc = "The id attribute of the element, if available."]
            #[serde(rename = "elementId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub element_id: Option<String>,
            #[doc = "The URL of the image (may be trimmed)."]
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url: Option<String>,
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<super::dom::BackendNodeId>,
        }
        impl LargestContentfulPaint {
            pub fn new(
                render_time: impl Into<super::network::TimeSinceEpoch>,
                load_time: impl Into<super::network::TimeSinceEpoch>,
                size: impl Into<f64>,
            ) -> Self {
                Self {
                    render_time: render_time.into(),
                    load_time: load_time.into(),
                    size: size.into(),
                    element_id: None,
                    url: None,
                    node_id: None,
                }
            }
        }
        impl LargestContentfulPaint {
            pub fn builder() -> LargestContentfulPaintBuilder {
                LargestContentfulPaintBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LargestContentfulPaintBuilder {
            render_time: Option<super::network::TimeSinceEpoch>,
            load_time: Option<super::network::TimeSinceEpoch>,
            size: Option<f64>,
            element_id: Option<String>,
            url: Option<String>,
            node_id: Option<super::dom::BackendNodeId>,
        }
        impl LargestContentfulPaintBuilder {
            pub fn render_time(
                mut self,
                render_time: impl Into<super::network::TimeSinceEpoch>,
            ) -> Self {
                self.render_time = Some(render_time.into());
                self
            }
            pub fn load_time(
                mut self,
                load_time: impl Into<super::network::TimeSinceEpoch>,
            ) -> Self {
                self.load_time = Some(load_time.into());
                self
            }
            pub fn size(mut self, size: impl Into<f64>) -> Self {
                self.size = Some(size.into());
                self
            }
            pub fn element_id(mut self, element_id: impl Into<String>) -> Self {
                self.element_id = Some(element_id.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn node_id(mut self, node_id: impl Into<super::dom::BackendNodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<LargestContentfulPaint, String> {
                Ok(LargestContentfulPaint {
                    render_time: self.render_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(render_time))
                    })?,
                    load_time: self.load_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(load_time))
                    })?,
                    size: self.size.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(size))
                    })?,
                    element_id: self.element_id,
                    url: self.url,
                    node_id: self.node_id,
                })
            }
        }
        impl LargestContentfulPaint {
            pub const IDENTIFIER: &'static str = "PerformanceTimeline.LargestContentfulPaint";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LayoutShiftAttribution {
            #[serde(rename = "previousRect")]
            pub previous_rect: super::dom::Rect,
            #[serde(rename = "currentRect")]
            pub current_rect: super::dom::Rect,
            #[serde(rename = "nodeId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub node_id: Option<super::dom::BackendNodeId>,
        }
        impl LayoutShiftAttribution {
            pub fn new(
                previous_rect: impl Into<super::dom::Rect>,
                current_rect: impl Into<super::dom::Rect>,
            ) -> Self {
                Self {
                    previous_rect: previous_rect.into(),
                    current_rect: current_rect.into(),
                    node_id: None,
                }
            }
        }
        impl LayoutShiftAttribution {
            pub fn builder() -> LayoutShiftAttributionBuilder {
                LayoutShiftAttributionBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LayoutShiftAttributionBuilder {
            previous_rect: Option<super::dom::Rect>,
            current_rect: Option<super::dom::Rect>,
            node_id: Option<super::dom::BackendNodeId>,
        }
        impl LayoutShiftAttributionBuilder {
            pub fn previous_rect(mut self, previous_rect: impl Into<super::dom::Rect>) -> Self {
                self.previous_rect = Some(previous_rect.into());
                self
            }
            pub fn current_rect(mut self, current_rect: impl Into<super::dom::Rect>) -> Self {
                self.current_rect = Some(current_rect.into());
                self
            }
            pub fn node_id(mut self, node_id: impl Into<super::dom::BackendNodeId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn build(self) -> Result<LayoutShiftAttribution, String> {
                Ok(LayoutShiftAttribution {
                    previous_rect: self.previous_rect.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(previous_rect))
                    })?,
                    current_rect: self.current_rect.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(current_rect))
                    })?,
                    node_id: self.node_id,
                })
            }
        }
        impl LayoutShiftAttribution {
            pub const IDENTIFIER: &'static str = "PerformanceTimeline.LayoutShiftAttribution";
        }
        #[doc = "See https://wicg.github.io/layout-instability/#sec-layout-shift and layout_shift.idl\n[LayoutShift](https://chromedevtools.github.io/devtools-protocol/tot/PerformanceTimeline/#type-LayoutShift)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct LayoutShift {
            #[doc = "Score increment produced by this event."]
            #[serde(rename = "value")]
            pub value: f64,
            #[serde(rename = "hadRecentInput")]
            pub had_recent_input: bool,
            #[serde(rename = "lastInputTime")]
            pub last_input_time: super::network::TimeSinceEpoch,
            #[serde(rename = "sources")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub sources: Vec<LayoutShiftAttribution>,
        }
        impl LayoutShift {
            pub fn new(
                value: impl Into<f64>,
                had_recent_input: impl Into<bool>,
                last_input_time: impl Into<super::network::TimeSinceEpoch>,
                sources: Vec<LayoutShiftAttribution>,
            ) -> Self {
                Self {
                    value: value.into(),
                    had_recent_input: had_recent_input.into(),
                    last_input_time: last_input_time.into(),
                    sources,
                }
            }
        }
        impl LayoutShift {
            pub fn builder() -> LayoutShiftBuilder {
                LayoutShiftBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct LayoutShiftBuilder {
            value: Option<f64>,
            had_recent_input: Option<bool>,
            last_input_time: Option<super::network::TimeSinceEpoch>,
            sources: Option<Vec<LayoutShiftAttribution>>,
        }
        impl LayoutShiftBuilder {
            pub fn value(mut self, value: impl Into<f64>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn had_recent_input(mut self, had_recent_input: impl Into<bool>) -> Self {
                self.had_recent_input = Some(had_recent_input.into());
                self
            }
            pub fn last_input_time(
                mut self,
                last_input_time: impl Into<super::network::TimeSinceEpoch>,
            ) -> Self {
                self.last_input_time = Some(last_input_time.into());
                self
            }
            pub fn source(mut self, source: impl Into<LayoutShiftAttribution>) -> Self {
                let v = self.sources.get_or_insert(Vec::new());
                v.push(source.into());
                self
            }
            pub fn sources<I, S>(mut self, sources: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<LayoutShiftAttribution>,
            {
                let v = self.sources.get_or_insert(Vec::new());
                for val in sources {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<LayoutShift, String> {
                Ok(LayoutShift {
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                    had_recent_input: self.had_recent_input.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(had_recent_input)
                        )
                    })?,
                    last_input_time: self.last_input_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(last_input_time))
                    })?,
                    sources: self.sources.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(sources))
                    })?,
                })
            }
        }
        impl LayoutShift {
            pub const IDENTIFIER: &'static str = "PerformanceTimeline.LayoutShift";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TimelineEvent {
            #[doc = "Identifies the frame that this event is related to. Empty for non-frame targets."]
            #[serde(rename = "frameId")]
            pub frame_id: super::page::FrameId,
            #[doc = "The event type, as specified in https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype\nThis determines which of the optional \"details\" fiedls is present."]
            #[serde(rename = "type")]
            pub r#type: String,
            #[doc = "Name may be empty depending on the type."]
            #[serde(rename = "name")]
            pub name: String,
            #[doc = "Time in seconds since Epoch, monotonically increasing within document lifetime."]
            #[serde(rename = "time")]
            pub time: super::network::TimeSinceEpoch,
            #[doc = "Event duration, if applicable."]
            #[serde(rename = "duration")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub duration: Option<f64>,
            #[serde(rename = "lcpDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub lcp_details: Option<LargestContentfulPaint>,
            #[serde(rename = "layoutShiftDetails")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub layout_shift_details: Option<LayoutShift>,
        }
        impl TimelineEvent {
            pub fn new(
                frame_id: impl Into<super::page::FrameId>,
                r#type: impl Into<String>,
                name: impl Into<String>,
                time: impl Into<super::network::TimeSinceEpoch>,
            ) -> Self {
                Self {
                    frame_id: frame_id.into(),
                    r#type: r#type.into(),
                    name: name.into(),
                    time: time.into(),
                    duration: None,
                    lcp_details: None,
                    layout_shift_details: None,
                }
            }
        }
        impl TimelineEvent {
            pub fn builder() -> TimelineEventBuilder {
                TimelineEventBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TimelineEventBuilder {
            frame_id: Option<super::page::FrameId>,
            r#type: Option<String>,
            name: Option<String>,
            time: Option<super::network::TimeSinceEpoch>,
            duration: Option<f64>,
            lcp_details: Option<LargestContentfulPaint>,
            layout_shift_details: Option<LayoutShift>,
        }
        impl TimelineEventBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn time(mut self, time: impl Into<super::network::TimeSinceEpoch>) -> Self {
                self.time = Some(time.into());
                self
            }
            pub fn duration(mut self, duration: impl Into<f64>) -> Self {
                self.duration = Some(duration.into());
                self
            }
            pub fn lcp_details(mut self, lcp_details: impl Into<LargestContentfulPaint>) -> Self {
                self.lcp_details = Some(lcp_details.into());
                self
            }
            pub fn layout_shift_details(
                mut self,
                layout_shift_details: impl Into<LayoutShift>,
            ) -> Self {
                self.layout_shift_details = Some(layout_shift_details.into());
                self
            }
            pub fn build(self) -> Result<TimelineEvent, String> {
                Ok(TimelineEvent {
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    time: self.time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(time))
                    })?,
                    duration: self.duration,
                    lcp_details: self.lcp_details,
                    layout_shift_details: self.layout_shift_details,
                })
            }
        }
        impl TimelineEvent {
            pub const IDENTIFIER: &'static str = "PerformanceTimeline.TimelineEvent";
        }
        #[doc = "Previously buffered events would be reported before method returns.\nSee also: timelineEventAdded\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/PerformanceTimeline/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EnableParams {
            #[doc = "The types of event to report, as specified in\nhttps://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype\nThe specified filter overrides any previous filters, passing empty\nfilter disables recording.\nNote that not all types exposed to the web platform are currently supported."]
            #[serde(rename = "eventTypes")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub event_types: Vec<String>,
        }
        impl EnableParams {
            pub fn new(event_types: Vec<String>) -> Self {
                Self { event_types }
            }
        }
        impl EnableParams {
            pub fn builder() -> EnableParamsBuilder {
                EnableParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EnableParamsBuilder {
            event_types: Option<Vec<String>>,
        }
        impl EnableParamsBuilder {
            pub fn event_type(mut self, event_type: impl Into<String>) -> Self {
                let v = self.event_types.get_or_insert(Vec::new());
                v.push(event_type.into());
                self
            }
            pub fn event_types<I, S>(mut self, event_types: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.event_types.get_or_insert(Vec::new());
                for val in event_types {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<EnableParams, String> {
                Ok(EnableParams {
                    event_types: self.event_types.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(event_types))
                    })?,
                })
            }
        }
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "PerformanceTimeline.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Previously buffered events would be reported before method returns.\nSee also: timelineEventAdded\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/PerformanceTimeline/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Sent when a performance timeline event is added. See reportPerformanceTimeline method.\n[timelineEventAdded](https://chromedevtools.github.io/devtools-protocol/tot/PerformanceTimeline/#event-timelineEventAdded)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventTimelineEventAdded {
            #[serde(rename = "event")]
            pub event: TimelineEvent,
        }
        impl EventTimelineEventAdded {
            pub const IDENTIFIER: &'static str = "PerformanceTimeline.timelineEventAdded";
        }
        impl chromiumoxide_types::Method for EventTimelineEventAdded {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventTimelineEventAdded {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "Security"]
    pub mod security {
        use serde::{Deserialize, Serialize};
        #[doc = "An internal certificate ID value.\n[CertificateId](https://chromedevtools.github.io/devtools-protocol/tot/Security/#type-CertificateId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Copy, Hash)]
        pub struct CertificateId(i64);
        impl CertificateId {
            pub fn new(val: impl Into<i64>) -> Self {
                CertificateId(val.into())
            }
            pub fn inner(&self) -> &i64 {
                &self.0
            }
        }
        impl CertificateId {
            pub const IDENTIFIER: &'static str = "Security.CertificateId";
        }
        #[doc = "A description of mixed content (HTTP resources on HTTPS pages), as defined by\nhttps://www.w3.org/TR/mixed-content/#categories"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum MixedContentType {
            #[serde(rename = "blockable")]
            Blockable,
            #[serde(rename = "optionally-blockable")]
            OptionallyBlockable,
            #[serde(rename = "none")]
            None,
        }
        impl AsRef<str> for MixedContentType {
            fn as_ref(&self) -> &str {
                match self {
                    MixedContentType::Blockable => "blockable",
                    MixedContentType::OptionallyBlockable => "optionally-blockable",
                    MixedContentType::None => "none",
                }
            }
        }
        impl ::std::str::FromStr for MixedContentType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "blockable" | "Blockable" => Ok(MixedContentType::Blockable),
                    "optionally-blockable" | "OptionallyBlockable" => {
                        Ok(MixedContentType::OptionallyBlockable)
                    }
                    "none" | "None" => Ok(MixedContentType::None),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "The security level of a page or resource."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SecurityState {
            #[serde(rename = "unknown")]
            Unknown,
            #[serde(rename = "neutral")]
            Neutral,
            #[serde(rename = "insecure")]
            Insecure,
            #[serde(rename = "secure")]
            Secure,
            #[serde(rename = "info")]
            Info,
            #[serde(rename = "insecure-broken")]
            InsecureBroken,
        }
        impl AsRef<str> for SecurityState {
            fn as_ref(&self) -> &str {
                match self {
                    SecurityState::Unknown => "unknown",
                    SecurityState::Neutral => "neutral",
                    SecurityState::Insecure => "insecure",
                    SecurityState::Secure => "secure",
                    SecurityState::Info => "info",
                    SecurityState::InsecureBroken => "insecure-broken",
                }
            }
        }
        impl ::std::str::FromStr for SecurityState {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "unknown" | "Unknown" => Ok(SecurityState::Unknown),
                    "neutral" | "Neutral" => Ok(SecurityState::Neutral),
                    "insecure" | "Insecure" => Ok(SecurityState::Insecure),
                    "secure" | "Secure" => Ok(SecurityState::Secure),
                    "info" | "Info" => Ok(SecurityState::Info),
                    "insecure-broken" | "InsecureBroken" => Ok(SecurityState::InsecureBroken),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Details about the security state of the page certificate.\n[CertificateSecurityState](https://chromedevtools.github.io/devtools-protocol/tot/Security/#type-CertificateSecurityState)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CertificateSecurityState {
            #[doc = "Protocol name (e.g. \"TLS 1.2\" or \"QUIC\")."]
            #[serde(rename = "protocol")]
            pub protocol: String,
            #[doc = "Key Exchange used by the connection, or the empty string if not applicable."]
            #[serde(rename = "keyExchange")]
            pub key_exchange: String,
            #[doc = "(EC)DH group used by the connection, if applicable."]
            #[serde(rename = "keyExchangeGroup")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub key_exchange_group: Option<String>,
            #[doc = "Cipher name."]
            #[serde(rename = "cipher")]
            pub cipher: String,
            #[doc = "TLS MAC. Note that AEAD ciphers do not have separate MACs."]
            #[serde(rename = "mac")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub mac: Option<String>,
            #[doc = "Page certificate."]
            #[serde(rename = "certificate")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub certificate: Vec<String>,
            #[doc = "Certificate subject name."]
            #[serde(rename = "subjectName")]
            pub subject_name: String,
            #[doc = "Name of the issuing CA."]
            #[serde(rename = "issuer")]
            pub issuer: String,
            #[doc = "Certificate valid from date."]
            #[serde(rename = "validFrom")]
            pub valid_from: super::network::TimeSinceEpoch,
            #[doc = "Certificate valid to (expiration) date"]
            #[serde(rename = "validTo")]
            pub valid_to: super::network::TimeSinceEpoch,
            #[doc = "The highest priority network error code, if the certificate has an error."]
            #[serde(rename = "certificateNetworkError")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub certificate_network_error: Option<String>,
            #[doc = "True if the certificate uses a weak signature aglorithm."]
            #[serde(rename = "certificateHasWeakSignature")]
            pub certificate_has_weak_signature: bool,
            #[doc = "True if the certificate has a SHA1 signature in the chain."]
            #[serde(rename = "certificateHasSha1Signature")]
            pub certificate_has_sha1_signature: bool,
            #[doc = "True if modern SSL"]
            #[serde(rename = "modernSSL")]
            pub modern_ssl: bool,
            #[doc = "True if the connection is using an obsolete SSL protocol."]
            #[serde(rename = "obsoleteSslProtocol")]
            pub obsolete_ssl_protocol: bool,
            #[doc = "True if the connection is using an obsolete SSL key exchange."]
            #[serde(rename = "obsoleteSslKeyExchange")]
            pub obsolete_ssl_key_exchange: bool,
            #[doc = "True if the connection is using an obsolete SSL cipher."]
            #[serde(rename = "obsoleteSslCipher")]
            pub obsolete_ssl_cipher: bool,
            #[doc = "True if the connection is using an obsolete SSL signature."]
            #[serde(rename = "obsoleteSslSignature")]
            pub obsolete_ssl_signature: bool,
        }
        impl CertificateSecurityState {
            pub fn builder() -> CertificateSecurityStateBuilder {
                CertificateSecurityStateBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CertificateSecurityStateBuilder {
            protocol: Option<String>,
            key_exchange: Option<String>,
            key_exchange_group: Option<String>,
            cipher: Option<String>,
            mac: Option<String>,
            certificate: Option<Vec<String>>,
            subject_name: Option<String>,
            issuer: Option<String>,
            valid_from: Option<super::network::TimeSinceEpoch>,
            valid_to: Option<super::network::TimeSinceEpoch>,
            certificate_network_error: Option<String>,
            certificate_has_weak_signature: Option<bool>,
            certificate_has_sha1_signature: Option<bool>,
            modern_ssl: Option<bool>,
            obsolete_ssl_protocol: Option<bool>,
            obsolete_ssl_key_exchange: Option<bool>,
            obsolete_ssl_cipher: Option<bool>,
            obsolete_ssl_signature: Option<bool>,
        }
        impl CertificateSecurityStateBuilder {
            pub fn protocol(mut self, protocol: impl Into<String>) -> Self {
                self.protocol = Some(protocol.into());
                self
            }
            pub fn key_exchange(mut self, key_exchange: impl Into<String>) -> Self {
                self.key_exchange = Some(key_exchange.into());
                self
            }
            pub fn key_exchange_group(mut self, key_exchange_group: impl Into<String>) -> Self {
                self.key_exchange_group = Some(key_exchange_group.into());
                self
            }
            pub fn cipher(mut self, cipher: impl Into<String>) -> Self {
                self.cipher = Some(cipher.into());
                self
            }
            pub fn mac(mut self, mac: impl Into<String>) -> Self {
                self.mac = Some(mac.into());
                self
            }
            pub fn certificate(mut self, certificate: impl Into<String>) -> Self {
                let v = self.certificate.get_or_insert(Vec::new());
                v.push(certificate.into());
                self
            }
            pub fn certificates<I, S>(mut self, certificates: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.certificate.get_or_insert(Vec::new());
                for val in certificates {
                    v.push(val.into());
                }
                self
            }
            pub fn subject_name(mut self, subject_name: impl Into<String>) -> Self {
                self.subject_name = Some(subject_name.into());
                self
            }
            pub fn issuer(mut self, issuer: impl Into<String>) -> Self {
                self.issuer = Some(issuer.into());
                self
            }
            pub fn valid_from(
                mut self,
                valid_from: impl Into<super::network::TimeSinceEpoch>,
            ) -> Self {
                self.valid_from = Some(valid_from.into());
                self
            }
            pub fn valid_to(mut self, valid_to: impl Into<super::network::TimeSinceEpoch>) -> Self {
                self.valid_to = Some(valid_to.into());
                self
            }
            pub fn certificate_network_error(
                mut self,
                certificate_network_error: impl Into<String>,
            ) -> Self {
                self.certificate_network_error = Some(certificate_network_error.into());
                self
            }
            pub fn certificate_has_weak_signature(
                mut self,
                certificate_has_weak_signature: impl Into<bool>,
            ) -> Self {
                self.certificate_has_weak_signature = Some(certificate_has_weak_signature.into());
                self
            }
            pub fn certificate_has_sha1_signature(
                mut self,
                certificate_has_sha1_signature: impl Into<bool>,
            ) -> Self {
                self.certificate_has_sha1_signature = Some(certificate_has_sha1_signature.into());
                self
            }
            pub fn modern_ssl(mut self, modern_ssl: impl Into<bool>) -> Self {
                self.modern_ssl = Some(modern_ssl.into());
                self
            }
            pub fn obsolete_ssl_protocol(mut self, obsolete_ssl_protocol: impl Into<bool>) -> Self {
                self.obsolete_ssl_protocol = Some(obsolete_ssl_protocol.into());
                self
            }
            pub fn obsolete_ssl_key_exchange(
                mut self,
                obsolete_ssl_key_exchange: impl Into<bool>,
            ) -> Self {
                self.obsolete_ssl_key_exchange = Some(obsolete_ssl_key_exchange.into());
                self
            }
            pub fn obsolete_ssl_cipher(mut self, obsolete_ssl_cipher: impl Into<bool>) -> Self {
                self.obsolete_ssl_cipher = Some(obsolete_ssl_cipher.into());
                self
            }
            pub fn obsolete_ssl_signature(
                mut self,
                obsolete_ssl_signature: impl Into<bool>,
            ) -> Self {
                self.obsolete_ssl_signature = Some(obsolete_ssl_signature.into());
                self
            }
            pub fn build(self) -> Result<CertificateSecurityState, String> {
                Ok(CertificateSecurityState {
                    protocol: self.protocol.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(protocol))
                    })?,
                    key_exchange: self.key_exchange.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(key_exchange))
                    })?,
                    key_exchange_group: self.key_exchange_group,
                    cipher: self.cipher.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cipher))
                    })?,
                    mac: self.mac,
                    certificate: self.certificate.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(certificate))
                    })?,
                    subject_name: self.subject_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(subject_name))
                    })?,
                    issuer: self.issuer.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(issuer))
                    })?,
                    valid_from: self.valid_from.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(valid_from))
                    })?,
                    valid_to: self.valid_to.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(valid_to))
                    })?,
                    certificate_network_error: self.certificate_network_error,
                    certificate_has_weak_signature: self
                        .certificate_has_weak_signature
                        .ok_or_else(|| {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(certificate_has_weak_signature)
                            )
                        })?,
                    certificate_has_sha1_signature: self
                        .certificate_has_sha1_signature
                        .ok_or_else(|| {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(certificate_has_sha1_signature)
                            )
                        })?,
                    modern_ssl: self.modern_ssl.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(modern_ssl))
                    })?,
                    obsolete_ssl_protocol: self.obsolete_ssl_protocol.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(obsolete_ssl_protocol)
                        )
                    })?,
                    obsolete_ssl_key_exchange: self.obsolete_ssl_key_exchange.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(obsolete_ssl_key_exchange)
                        )
                    })?,
                    obsolete_ssl_cipher: self.obsolete_ssl_cipher.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(obsolete_ssl_cipher)
                        )
                    })?,
                    obsolete_ssl_signature: self.obsolete_ssl_signature.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(obsolete_ssl_signature)
                        )
                    })?,
                })
            }
        }
        impl CertificateSecurityState {
            pub const IDENTIFIER: &'static str = "Security.CertificateSecurityState";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SafetyTipStatus {
            #[serde(rename = "badReputation")]
            BadReputation,
            #[serde(rename = "lookalike")]
            Lookalike,
        }
        impl AsRef<str> for SafetyTipStatus {
            fn as_ref(&self) -> &str {
                match self {
                    SafetyTipStatus::BadReputation => "badReputation",
                    SafetyTipStatus::Lookalike => "lookalike",
                }
            }
        }
        impl ::std::str::FromStr for SafetyTipStatus {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "badReputation" | "BadReputation" | "badreputation" => {
                        Ok(SafetyTipStatus::BadReputation)
                    }
                    "lookalike" | "Lookalike" => Ok(SafetyTipStatus::Lookalike),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SafetyTipInfo {
            #[doc = "Describes whether the page triggers any safety tips or reputation warnings. Default is unknown."]
            #[serde(rename = "safetyTipStatus")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub safety_tip_status: SafetyTipStatus,
            #[doc = "The URL the safety tip suggested (\"Did you mean?\"). Only filled in for lookalike matches."]
            #[serde(rename = "safeUrl")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub safe_url: Option<String>,
        }
        impl SafetyTipInfo {
            pub fn new(safety_tip_status: impl Into<SafetyTipStatus>) -> Self {
                Self {
                    safety_tip_status: safety_tip_status.into(),
                    safe_url: None,
                }
            }
        }
        impl SafetyTipInfo {
            pub fn builder() -> SafetyTipInfoBuilder {
                SafetyTipInfoBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SafetyTipInfoBuilder {
            safety_tip_status: Option<SafetyTipStatus>,
            safe_url: Option<String>,
        }
        impl SafetyTipInfoBuilder {
            pub fn safety_tip_status(
                mut self,
                safety_tip_status: impl Into<SafetyTipStatus>,
            ) -> Self {
                self.safety_tip_status = Some(safety_tip_status.into());
                self
            }
            pub fn safe_url(mut self, safe_url: impl Into<String>) -> Self {
                self.safe_url = Some(safe_url.into());
                self
            }
            pub fn build(self) -> Result<SafetyTipInfo, String> {
                Ok(SafetyTipInfo {
                    safety_tip_status: self.safety_tip_status.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(safety_tip_status)
                        )
                    })?,
                    safe_url: self.safe_url,
                })
            }
        }
        impl SafetyTipInfo {
            pub const IDENTIFIER: &'static str = "Security.SafetyTipInfo";
        }
        #[doc = "Security state information about the page.\n[VisibleSecurityState](https://chromedevtools.github.io/devtools-protocol/tot/Security/#type-VisibleSecurityState)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct VisibleSecurityState {
            #[doc = "The security level of the page."]
            #[serde(rename = "securityState")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub security_state: SecurityState,
            #[doc = "Security state details about the page certificate."]
            #[serde(rename = "certificateSecurityState")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub certificate_security_state: Option<CertificateSecurityState>,
            #[doc = "The type of Safety Tip triggered on the page. Note that this field will be set even if the Safety Tip UI was not actually shown."]
            #[serde(rename = "safetyTipInfo")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub safety_tip_info: Option<SafetyTipInfo>,
            #[doc = "Array of security state issues ids."]
            #[serde(rename = "securityStateIssueIds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub security_state_issue_ids: Vec<String>,
        }
        impl VisibleSecurityState {
            pub fn new(
                security_state: impl Into<SecurityState>,
                security_state_issue_ids: Vec<String>,
            ) -> Self {
                Self {
                    security_state: security_state.into(),
                    security_state_issue_ids,
                    certificate_security_state: None,
                    safety_tip_info: None,
                }
            }
        }
        impl VisibleSecurityState {
            pub fn builder() -> VisibleSecurityStateBuilder {
                VisibleSecurityStateBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct VisibleSecurityStateBuilder {
            security_state: Option<SecurityState>,
            certificate_security_state: Option<CertificateSecurityState>,
            safety_tip_info: Option<SafetyTipInfo>,
            security_state_issue_ids: Option<Vec<String>>,
        }
        impl VisibleSecurityStateBuilder {
            pub fn security_state(mut self, security_state: impl Into<SecurityState>) -> Self {
                self.security_state = Some(security_state.into());
                self
            }
            pub fn certificate_security_state(
                mut self,
                certificate_security_state: impl Into<CertificateSecurityState>,
            ) -> Self {
                self.certificate_security_state = Some(certificate_security_state.into());
                self
            }
            pub fn safety_tip_info(mut self, safety_tip_info: impl Into<SafetyTipInfo>) -> Self {
                self.safety_tip_info = Some(safety_tip_info.into());
                self
            }
            pub fn security_state_issue_id(
                mut self,
                security_state_issue_id: impl Into<String>,
            ) -> Self {
                let v = self.security_state_issue_ids.get_or_insert(Vec::new());
                v.push(security_state_issue_id.into());
                self
            }
            pub fn security_state_issue_ids<I, S>(mut self, security_state_issue_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.security_state_issue_ids.get_or_insert(Vec::new());
                for val in security_state_issue_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<VisibleSecurityState, String> {
                Ok(VisibleSecurityState {
                    security_state: self.security_state.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(security_state))
                    })?,
                    certificate_security_state: self.certificate_security_state,
                    safety_tip_info: self.safety_tip_info,
                    security_state_issue_ids: self.security_state_issue_ids.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(security_state_issue_ids)
                        )
                    })?,
                })
            }
        }
        impl VisibleSecurityState {
            pub const IDENTIFIER: &'static str = "Security.VisibleSecurityState";
        }
        #[doc = "An explanation of an factor contributing to the security state.\n[SecurityStateExplanation](https://chromedevtools.github.io/devtools-protocol/tot/Security/#type-SecurityStateExplanation)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SecurityStateExplanation {
            #[doc = "Security state representing the severity of the factor being explained."]
            #[serde(rename = "securityState")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub security_state: SecurityState,
            #[doc = "Title describing the type of factor."]
            #[serde(rename = "title")]
            pub title: String,
            #[doc = "Short phrase describing the type of factor."]
            #[serde(rename = "summary")]
            pub summary: String,
            #[doc = "Full text explanation of the factor."]
            #[serde(rename = "description")]
            pub description: String,
            #[doc = "The type of mixed content described by the explanation."]
            #[serde(rename = "mixedContentType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub mixed_content_type: MixedContentType,
            #[doc = "Page certificate."]
            #[serde(rename = "certificate")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub certificate: Vec<String>,
            #[doc = "Recommendations to fix any issues."]
            #[serde(rename = "recommendations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub recommendations: Option<Vec<String>>,
        }
        impl SecurityStateExplanation {
            pub fn builder() -> SecurityStateExplanationBuilder {
                SecurityStateExplanationBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SecurityStateExplanationBuilder {
            security_state: Option<SecurityState>,
            title: Option<String>,
            summary: Option<String>,
            description: Option<String>,
            mixed_content_type: Option<MixedContentType>,
            certificate: Option<Vec<String>>,
            recommendations: Option<Vec<String>>,
        }
        impl SecurityStateExplanationBuilder {
            pub fn security_state(mut self, security_state: impl Into<SecurityState>) -> Self {
                self.security_state = Some(security_state.into());
                self
            }
            pub fn title(mut self, title: impl Into<String>) -> Self {
                self.title = Some(title.into());
                self
            }
            pub fn summary(mut self, summary: impl Into<String>) -> Self {
                self.summary = Some(summary.into());
                self
            }
            pub fn description(mut self, description: impl Into<String>) -> Self {
                self.description = Some(description.into());
                self
            }
            pub fn mixed_content_type(
                mut self,
                mixed_content_type: impl Into<MixedContentType>,
            ) -> Self {
                self.mixed_content_type = Some(mixed_content_type.into());
                self
            }
            pub fn certificate(mut self, certificate: impl Into<String>) -> Self {
                let v = self.certificate.get_or_insert(Vec::new());
                v.push(certificate.into());
                self
            }
            pub fn certificates<I, S>(mut self, certificates: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.certificate.get_or_insert(Vec::new());
                for val in certificates {
                    v.push(val.into());
                }
                self
            }
            pub fn recommendation(mut self, recommendation: impl Into<String>) -> Self {
                let v = self.recommendations.get_or_insert(Vec::new());
                v.push(recommendation.into());
                self
            }
            pub fn recommendations<I, S>(mut self, recommendations: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.recommendations.get_or_insert(Vec::new());
                for val in recommendations {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SecurityStateExplanation, String> {
                Ok(SecurityStateExplanation {
                    security_state: self.security_state.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(security_state))
                    })?,
                    title: self.title.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(title))
                    })?,
                    summary: self.summary.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(summary))
                    })?,
                    description: self.description.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(description))
                    })?,
                    mixed_content_type: self.mixed_content_type.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(mixed_content_type)
                        )
                    })?,
                    certificate: self.certificate.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(certificate))
                    })?,
                    recommendations: self.recommendations,
                })
            }
        }
        impl SecurityStateExplanation {
            pub const IDENTIFIER: &'static str = "Security.SecurityStateExplanation";
        }
        #[doc = "The action to take when a certificate error occurs. continue will continue processing the\nrequest and cancel will cancel the request."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum CertificateErrorAction {
            #[serde(rename = "continue")]
            Continue,
            #[serde(rename = "cancel")]
            Cancel,
        }
        impl AsRef<str> for CertificateErrorAction {
            fn as_ref(&self) -> &str {
                match self {
                    CertificateErrorAction::Continue => "continue",
                    CertificateErrorAction::Cancel => "cancel",
                }
            }
        }
        impl ::std::str::FromStr for CertificateErrorAction {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "continue" | "Continue" => Ok(CertificateErrorAction::Continue),
                    "cancel" | "Cancel" => Ok(CertificateErrorAction::Cancel),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Disables tracking security state changes.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Security/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Security.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables tracking security state changes.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Security/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables tracking security state changes.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Security/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Security.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables tracking security state changes.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Security/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Enable/disable whether all certificate errors should be ignored.\n[setIgnoreCertificateErrors](https://chromedevtools.github.io/devtools-protocol/tot/Security/#method-setIgnoreCertificateErrors)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetIgnoreCertificateErrorsParams {
            #[doc = "If true, all certificate errors will be ignored."]
            #[serde(rename = "ignore")]
            pub ignore: bool,
        }
        impl SetIgnoreCertificateErrorsParams {
            pub fn new(ignore: impl Into<bool>) -> Self {
                Self {
                    ignore: ignore.into(),
                }
            }
        }
        impl SetIgnoreCertificateErrorsParams {
            pub fn builder() -> SetIgnoreCertificateErrorsParamsBuilder {
                SetIgnoreCertificateErrorsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetIgnoreCertificateErrorsParamsBuilder {
            ignore: Option<bool>,
        }
        impl SetIgnoreCertificateErrorsParamsBuilder {
            pub fn ignore(mut self, ignore: impl Into<bool>) -> Self {
                self.ignore = Some(ignore.into());
                self
            }
            pub fn build(self) -> Result<SetIgnoreCertificateErrorsParams, String> {
                Ok(SetIgnoreCertificateErrorsParams {
                    ignore: self.ignore.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(ignore))
                    })?,
                })
            }
        }
        impl SetIgnoreCertificateErrorsParams {
            pub const IDENTIFIER: &'static str = "Security.setIgnoreCertificateErrors";
        }
        impl chromiumoxide_types::Method for SetIgnoreCertificateErrorsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetIgnoreCertificateErrorsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enable/disable whether all certificate errors should be ignored.\n[setIgnoreCertificateErrors](https://chromedevtools.github.io/devtools-protocol/tot/Security/#method-setIgnoreCertificateErrors)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetIgnoreCertificateErrorsReturns {}
        impl chromiumoxide_types::Command for SetIgnoreCertificateErrorsParams {
            type Response = SetIgnoreCertificateErrorsReturns;
        }
        #[doc = "The security state of the page changed.\n[visibleSecurityStateChanged](https://chromedevtools.github.io/devtools-protocol/tot/Security/#event-visibleSecurityStateChanged)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventVisibleSecurityStateChanged {
            #[doc = "Security state information about the page."]
            #[serde(rename = "visibleSecurityState")]
            pub visible_security_state: VisibleSecurityState,
        }
        impl EventVisibleSecurityStateChanged {
            pub const IDENTIFIER: &'static str = "Security.visibleSecurityStateChanged";
        }
        impl chromiumoxide_types::Method for EventVisibleSecurityStateChanged {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventVisibleSecurityStateChanged {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    pub mod service_worker {
        use serde::{Deserialize, Serialize};
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct RegistrationId(String);
        impl RegistrationId {
            pub fn new(val: impl Into<String>) -> Self {
                RegistrationId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for RegistrationId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<RegistrationId> for String {
            fn from(el: RegistrationId) -> String {
                el.0
            }
        }
        impl From<String> for RegistrationId {
            fn from(expr: String) -> Self {
                RegistrationId(expr)
            }
        }
        impl std::borrow::Borrow<str> for RegistrationId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl RegistrationId {
            pub const IDENTIFIER: &'static str = "ServiceWorker.RegistrationID";
        }
        #[doc = "ServiceWorker registration.\n[ServiceWorkerRegistration](https://chromedevtools.github.io/devtools-protocol/tot/ServiceWorker/#type-ServiceWorkerRegistration)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ServiceWorkerRegistration {
            #[serde(rename = "registrationId")]
            pub registration_id: RegistrationId,
            #[serde(rename = "scopeURL")]
            pub scope_url: String,
            #[serde(rename = "isDeleted")]
            pub is_deleted: bool,
        }
        impl ServiceWorkerRegistration {
            pub fn new(
                registration_id: impl Into<RegistrationId>,
                scope_url: impl Into<String>,
                is_deleted: impl Into<bool>,
            ) -> Self {
                Self {
                    registration_id: registration_id.into(),
                    scope_url: scope_url.into(),
                    is_deleted: is_deleted.into(),
                }
            }
        }
        impl ServiceWorkerRegistration {
            pub fn builder() -> ServiceWorkerRegistrationBuilder {
                ServiceWorkerRegistrationBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ServiceWorkerRegistrationBuilder {
            registration_id: Option<RegistrationId>,
            scope_url: Option<String>,
            is_deleted: Option<bool>,
        }
        impl ServiceWorkerRegistrationBuilder {
            pub fn registration_id(mut self, registration_id: impl Into<RegistrationId>) -> Self {
                self.registration_id = Some(registration_id.into());
                self
            }
            pub fn scope_url(mut self, scope_url: impl Into<String>) -> Self {
                self.scope_url = Some(scope_url.into());
                self
            }
            pub fn is_deleted(mut self, is_deleted: impl Into<bool>) -> Self {
                self.is_deleted = Some(is_deleted.into());
                self
            }
            pub fn build(self) -> Result<ServiceWorkerRegistration, String> {
                Ok(ServiceWorkerRegistration {
                    registration_id: self.registration_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(registration_id))
                    })?,
                    scope_url: self.scope_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scope_url))
                    })?,
                    is_deleted: self.is_deleted.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(is_deleted))
                    })?,
                })
            }
        }
        impl ServiceWorkerRegistration {
            pub const IDENTIFIER: &'static str = "ServiceWorker.ServiceWorkerRegistration";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ServiceWorkerVersionRunningStatus {
            #[serde(rename = "stopped")]
            Stopped,
            #[serde(rename = "starting")]
            Starting,
            #[serde(rename = "running")]
            Running,
            #[serde(rename = "stopping")]
            Stopping,
        }
        impl AsRef<str> for ServiceWorkerVersionRunningStatus {
            fn as_ref(&self) -> &str {
                match self {
                    ServiceWorkerVersionRunningStatus::Stopped => "stopped",
                    ServiceWorkerVersionRunningStatus::Starting => "starting",
                    ServiceWorkerVersionRunningStatus::Running => "running",
                    ServiceWorkerVersionRunningStatus::Stopping => "stopping",
                }
            }
        }
        impl ::std::str::FromStr for ServiceWorkerVersionRunningStatus {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "stopped" | "Stopped" => Ok(ServiceWorkerVersionRunningStatus::Stopped),
                    "starting" | "Starting" => Ok(ServiceWorkerVersionRunningStatus::Starting),
                    "running" | "Running" => Ok(ServiceWorkerVersionRunningStatus::Running),
                    "stopping" | "Stopping" => Ok(ServiceWorkerVersionRunningStatus::Stopping),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ServiceWorkerVersionStatus {
            #[serde(rename = "new")]
            New,
            #[serde(rename = "installing")]
            Installing,
            #[serde(rename = "installed")]
            Installed,
            #[serde(rename = "activating")]
            Activating,
            #[serde(rename = "activated")]
            Activated,
            #[serde(rename = "redundant")]
            Redundant,
        }
        impl AsRef<str> for ServiceWorkerVersionStatus {
            fn as_ref(&self) -> &str {
                match self {
                    ServiceWorkerVersionStatus::New => "new",
                    ServiceWorkerVersionStatus::Installing => "installing",
                    ServiceWorkerVersionStatus::Installed => "installed",
                    ServiceWorkerVersionStatus::Activating => "activating",
                    ServiceWorkerVersionStatus::Activated => "activated",
                    ServiceWorkerVersionStatus::Redundant => "redundant",
                }
            }
        }
        impl ::std::str::FromStr for ServiceWorkerVersionStatus {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "new" | "New" => Ok(ServiceWorkerVersionStatus::New),
                    "installing" | "Installing" => Ok(ServiceWorkerVersionStatus::Installing),
                    "installed" | "Installed" => Ok(ServiceWorkerVersionStatus::Installed),
                    "activating" | "Activating" => Ok(ServiceWorkerVersionStatus::Activating),
                    "activated" | "Activated" => Ok(ServiceWorkerVersionStatus::Activated),
                    "redundant" | "Redundant" => Ok(ServiceWorkerVersionStatus::Redundant),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "ServiceWorker version.\n[ServiceWorkerVersion](https://chromedevtools.github.io/devtools-protocol/tot/ServiceWorker/#type-ServiceWorkerVersion)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ServiceWorkerVersion {
            #[serde(rename = "versionId")]
            pub version_id: String,
            #[serde(rename = "registrationId")]
            pub registration_id: RegistrationId,
            #[serde(rename = "scriptURL")]
            pub script_url: String,
            #[serde(rename = "runningStatus")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub running_status: ServiceWorkerVersionRunningStatus,
            #[serde(rename = "status")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub status: ServiceWorkerVersionStatus,
            #[doc = "The Last-Modified header value of the main script."]
            #[serde(rename = "scriptLastModified")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub script_last_modified: Option<f64>,
            #[doc = "The time at which the response headers of the main script were received from the server.\nFor cached script it is the last time the cache entry was validated."]
            #[serde(rename = "scriptResponseTime")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub script_response_time: Option<f64>,
            #[serde(rename = "controlledClients")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub controlled_clients: Option<Vec<super::target::TargetId>>,
            #[serde(rename = "targetId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub target_id: Option<super::target::TargetId>,
        }
        impl ServiceWorkerVersion {
            pub fn builder() -> ServiceWorkerVersionBuilder {
                ServiceWorkerVersionBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ServiceWorkerVersionBuilder {
            version_id: Option<String>,
            registration_id: Option<RegistrationId>,
            script_url: Option<String>,
            running_status: Option<ServiceWorkerVersionRunningStatus>,
            status: Option<ServiceWorkerVersionStatus>,
            script_last_modified: Option<f64>,
            script_response_time: Option<f64>,
            controlled_clients: Option<Vec<super::target::TargetId>>,
            target_id: Option<super::target::TargetId>,
        }
        impl ServiceWorkerVersionBuilder {
            pub fn version_id(mut self, version_id: impl Into<String>) -> Self {
                self.version_id = Some(version_id.into());
                self
            }
            pub fn registration_id(mut self, registration_id: impl Into<RegistrationId>) -> Self {
                self.registration_id = Some(registration_id.into());
                self
            }
            pub fn script_url(mut self, script_url: impl Into<String>) -> Self {
                self.script_url = Some(script_url.into());
                self
            }
            pub fn running_status(
                mut self,
                running_status: impl Into<ServiceWorkerVersionRunningStatus>,
            ) -> Self {
                self.running_status = Some(running_status.into());
                self
            }
            pub fn status(mut self, status: impl Into<ServiceWorkerVersionStatus>) -> Self {
                self.status = Some(status.into());
                self
            }
            pub fn script_last_modified(mut self, script_last_modified: impl Into<f64>) -> Self {
                self.script_last_modified = Some(script_last_modified.into());
                self
            }
            pub fn script_response_time(mut self, script_response_time: impl Into<f64>) -> Self {
                self.script_response_time = Some(script_response_time.into());
                self
            }
            pub fn controlled_client(
                mut self,
                controlled_client: impl Into<super::target::TargetId>,
            ) -> Self {
                let v = self.controlled_clients.get_or_insert(Vec::new());
                v.push(controlled_client.into());
                self
            }
            pub fn controlled_clients<I, S>(mut self, controlled_clients: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<super::target::TargetId>,
            {
                let v = self.controlled_clients.get_or_insert(Vec::new());
                for val in controlled_clients {
                    v.push(val.into());
                }
                self
            }
            pub fn target_id(mut self, target_id: impl Into<super::target::TargetId>) -> Self {
                self.target_id = Some(target_id.into());
                self
            }
            pub fn build(self) -> Result<ServiceWorkerVersion, String> {
                Ok(ServiceWorkerVersion {
                    version_id: self.version_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(version_id))
                    })?,
                    registration_id: self.registration_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(registration_id))
                    })?,
                    script_url: self.script_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(script_url))
                    })?,
                    running_status: self.running_status.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(running_status))
                    })?,
                    status: self.status.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(status))
                    })?,
                    script_last_modified: self.script_last_modified,
                    script_response_time: self.script_response_time,
                    controlled_clients: self.controlled_clients,
                    target_id: self.target_id,
                })
            }
        }
        impl ServiceWorkerVersion {
            pub const IDENTIFIER: &'static str = "ServiceWorker.ServiceWorkerVersion";
        }
        #[doc = "ServiceWorker error message.\n[ServiceWorkerErrorMessage](https://chromedevtools.github.io/devtools-protocol/tot/ServiceWorker/#type-ServiceWorkerErrorMessage)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ServiceWorkerErrorMessage {
            #[serde(rename = "errorMessage")]
            pub error_message: String,
            #[serde(rename = "registrationId")]
            pub registration_id: RegistrationId,
            #[serde(rename = "versionId")]
            pub version_id: String,
            #[serde(rename = "sourceURL")]
            pub source_url: String,
            #[serde(rename = "lineNumber")]
            pub line_number: i64,
            #[serde(rename = "columnNumber")]
            pub column_number: i64,
        }
        impl ServiceWorkerErrorMessage {
            pub fn builder() -> ServiceWorkerErrorMessageBuilder {
                ServiceWorkerErrorMessageBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ServiceWorkerErrorMessageBuilder {
            error_message: Option<String>,
            registration_id: Option<RegistrationId>,
            version_id: Option<String>,
            source_url: Option<String>,
            line_number: Option<i64>,
            column_number: Option<i64>,
        }
        impl ServiceWorkerErrorMessageBuilder {
            pub fn error_message(mut self, error_message: impl Into<String>) -> Self {
                self.error_message = Some(error_message.into());
                self
            }
            pub fn registration_id(mut self, registration_id: impl Into<RegistrationId>) -> Self {
                self.registration_id = Some(registration_id.into());
                self
            }
            pub fn version_id(mut self, version_id: impl Into<String>) -> Self {
                self.version_id = Some(version_id.into());
                self
            }
            pub fn source_url(mut self, source_url: impl Into<String>) -> Self {
                self.source_url = Some(source_url.into());
                self
            }
            pub fn line_number(mut self, line_number: impl Into<i64>) -> Self {
                self.line_number = Some(line_number.into());
                self
            }
            pub fn column_number(mut self, column_number: impl Into<i64>) -> Self {
                self.column_number = Some(column_number.into());
                self
            }
            pub fn build(self) -> Result<ServiceWorkerErrorMessage, String> {
                Ok(ServiceWorkerErrorMessage {
                    error_message: self.error_message.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(error_message))
                    })?,
                    registration_id: self.registration_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(registration_id))
                    })?,
                    version_id: self.version_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(version_id))
                    })?,
                    source_url: self.source_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(source_url))
                    })?,
                    line_number: self.line_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line_number))
                    })?,
                    column_number: self.column_number.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(column_number))
                    })?,
                })
            }
        }
        impl ServiceWorkerErrorMessage {
            pub const IDENTIFIER: &'static str = "ServiceWorker.ServiceWorkerErrorMessage";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DeliverPushMessageParams {
            #[serde(rename = "origin")]
            pub origin: String,
            #[serde(rename = "registrationId")]
            pub registration_id: RegistrationId,
            #[serde(rename = "data")]
            pub data: String,
        }
        impl DeliverPushMessageParams {
            pub fn new(
                origin: impl Into<String>,
                registration_id: impl Into<RegistrationId>,
                data: impl Into<String>,
            ) -> Self {
                Self {
                    origin: origin.into(),
                    registration_id: registration_id.into(),
                    data: data.into(),
                }
            }
        }
        impl DeliverPushMessageParams {
            pub fn builder() -> DeliverPushMessageParamsBuilder {
                DeliverPushMessageParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DeliverPushMessageParamsBuilder {
            origin: Option<String>,
            registration_id: Option<RegistrationId>,
            data: Option<String>,
        }
        impl DeliverPushMessageParamsBuilder {
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn registration_id(mut self, registration_id: impl Into<RegistrationId>) -> Self {
                self.registration_id = Some(registration_id.into());
                self
            }
            pub fn data(mut self, data: impl Into<String>) -> Self {
                self.data = Some(data.into());
                self
            }
            pub fn build(self) -> Result<DeliverPushMessageParams, String> {
                Ok(DeliverPushMessageParams {
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    registration_id: self.registration_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(registration_id))
                    })?,
                    data: self.data.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(data))
                    })?,
                })
            }
        }
        impl DeliverPushMessageParams {
            pub const IDENTIFIER: &'static str = "ServiceWorker.deliverPushMessage";
        }
        impl chromiumoxide_types::Method for DeliverPushMessageParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DeliverPushMessageParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DeliverPushMessageReturns {}
        impl chromiumoxide_types::Command for DeliverPushMessageParams {
            type Response = DeliverPushMessageReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "ServiceWorker.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DispatchSyncEventParams {
            #[serde(rename = "origin")]
            pub origin: String,
            #[serde(rename = "registrationId")]
            pub registration_id: RegistrationId,
            #[serde(rename = "tag")]
            pub tag: String,
            #[serde(rename = "lastChance")]
            pub last_chance: bool,
        }
        impl DispatchSyncEventParams {
            pub fn new(
                origin: impl Into<String>,
                registration_id: impl Into<RegistrationId>,
                tag: impl Into<String>,
                last_chance: impl Into<bool>,
            ) -> Self {
                Self {
                    origin: origin.into(),
                    registration_id: registration_id.into(),
                    tag: tag.into(),
                    last_chance: last_chance.into(),
                }
            }
        }
        impl DispatchSyncEventParams {
            pub fn builder() -> DispatchSyncEventParamsBuilder {
                DispatchSyncEventParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DispatchSyncEventParamsBuilder {
            origin: Option<String>,
            registration_id: Option<RegistrationId>,
            tag: Option<String>,
            last_chance: Option<bool>,
        }
        impl DispatchSyncEventParamsBuilder {
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn registration_id(mut self, registration_id: impl Into<RegistrationId>) -> Self {
                self.registration_id = Some(registration_id.into());
                self
            }
            pub fn tag(mut self, tag: impl Into<String>) -> Self {
                self.tag = Some(tag.into());
                self
            }
            pub fn last_chance(mut self, last_chance: impl Into<bool>) -> Self {
                self.last_chance = Some(last_chance.into());
                self
            }
            pub fn build(self) -> Result<DispatchSyncEventParams, String> {
                Ok(DispatchSyncEventParams {
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    registration_id: self.registration_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(registration_id))
                    })?,
                    tag: self
                        .tag
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(tag)))?,
                    last_chance: self.last_chance.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(last_chance))
                    })?,
                })
            }
        }
        impl DispatchSyncEventParams {
            pub const IDENTIFIER: &'static str = "ServiceWorker.dispatchSyncEvent";
        }
        impl chromiumoxide_types::Method for DispatchSyncEventParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DispatchSyncEventParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DispatchSyncEventReturns {}
        impl chromiumoxide_types::Command for DispatchSyncEventParams {
            type Response = DispatchSyncEventReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DispatchPeriodicSyncEventParams {
            #[serde(rename = "origin")]
            pub origin: String,
            #[serde(rename = "registrationId")]
            pub registration_id: RegistrationId,
            #[serde(rename = "tag")]
            pub tag: String,
        }
        impl DispatchPeriodicSyncEventParams {
            pub fn new(
                origin: impl Into<String>,
                registration_id: impl Into<RegistrationId>,
                tag: impl Into<String>,
            ) -> Self {
                Self {
                    origin: origin.into(),
                    registration_id: registration_id.into(),
                    tag: tag.into(),
                }
            }
        }
        impl DispatchPeriodicSyncEventParams {
            pub fn builder() -> DispatchPeriodicSyncEventParamsBuilder {
                DispatchPeriodicSyncEventParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DispatchPeriodicSyncEventParamsBuilder {
            origin: Option<String>,
            registration_id: Option<RegistrationId>,
            tag: Option<String>,
        }
        impl DispatchPeriodicSyncEventParamsBuilder {
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn registration_id(mut self, registration_id: impl Into<RegistrationId>) -> Self {
                self.registration_id = Some(registration_id.into());
                self
            }
            pub fn tag(mut self, tag: impl Into<String>) -> Self {
                self.tag = Some(tag.into());
                self
            }
            pub fn build(self) -> Result<DispatchPeriodicSyncEventParams, String> {
                Ok(DispatchPeriodicSyncEventParams {
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    registration_id: self.registration_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(registration_id))
                    })?,
                    tag: self
                        .tag
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(tag)))?,
                })
            }
        }
        impl DispatchPeriodicSyncEventParams {
            pub const IDENTIFIER: &'static str = "ServiceWorker.dispatchPeriodicSyncEvent";
        }
        impl chromiumoxide_types::Method for DispatchPeriodicSyncEventParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DispatchPeriodicSyncEventParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DispatchPeriodicSyncEventReturns {}
        impl chromiumoxide_types::Command for DispatchPeriodicSyncEventParams {
            type Response = DispatchPeriodicSyncEventReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "ServiceWorker.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InspectWorkerParams {
            #[serde(rename = "versionId")]
            pub version_id: String,
        }
        impl InspectWorkerParams {
            pub fn new(version_id: impl Into<String>) -> Self {
                Self {
                    version_id: version_id.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for InspectWorkerParams {
            fn from(url: T) -> Self {
                InspectWorkerParams::new(url)
            }
        }
        impl InspectWorkerParams {
            pub fn builder() -> InspectWorkerParamsBuilder {
                InspectWorkerParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct InspectWorkerParamsBuilder {
            version_id: Option<String>,
        }
        impl InspectWorkerParamsBuilder {
            pub fn version_id(mut self, version_id: impl Into<String>) -> Self {
                self.version_id = Some(version_id.into());
                self
            }
            pub fn build(self) -> Result<InspectWorkerParams, String> {
                Ok(InspectWorkerParams {
                    version_id: self.version_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(version_id))
                    })?,
                })
            }
        }
        impl InspectWorkerParams {
            pub const IDENTIFIER: &'static str = "ServiceWorker.inspectWorker";
        }
        impl chromiumoxide_types::Method for InspectWorkerParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for InspectWorkerParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct InspectWorkerReturns {}
        impl chromiumoxide_types::Command for InspectWorkerParams {
            type Response = InspectWorkerReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetForceUpdateOnPageLoadParams {
            #[serde(rename = "forceUpdateOnPageLoad")]
            pub force_update_on_page_load: bool,
        }
        impl SetForceUpdateOnPageLoadParams {
            pub fn new(force_update_on_page_load: impl Into<bool>) -> Self {
                Self {
                    force_update_on_page_load: force_update_on_page_load.into(),
                }
            }
        }
        impl SetForceUpdateOnPageLoadParams {
            pub fn builder() -> SetForceUpdateOnPageLoadParamsBuilder {
                SetForceUpdateOnPageLoadParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetForceUpdateOnPageLoadParamsBuilder {
            force_update_on_page_load: Option<bool>,
        }
        impl SetForceUpdateOnPageLoadParamsBuilder {
            pub fn force_update_on_page_load(
                mut self,
                force_update_on_page_load: impl Into<bool>,
            ) -> Self {
                self.force_update_on_page_load = Some(force_update_on_page_load.into());
                self
            }
            pub fn build(self) -> Result<SetForceUpdateOnPageLoadParams, String> {
                Ok(SetForceUpdateOnPageLoadParams {
                    force_update_on_page_load: self.force_update_on_page_load.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(force_update_on_page_load)
                        )
                    })?,
                })
            }
        }
        impl SetForceUpdateOnPageLoadParams {
            pub const IDENTIFIER: &'static str = "ServiceWorker.setForceUpdateOnPageLoad";
        }
        impl chromiumoxide_types::Method for SetForceUpdateOnPageLoadParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetForceUpdateOnPageLoadParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetForceUpdateOnPageLoadReturns {}
        impl chromiumoxide_types::Command for SetForceUpdateOnPageLoadParams {
            type Response = SetForceUpdateOnPageLoadReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SkipWaitingParams {
            #[serde(rename = "scopeURL")]
            pub scope_url: String,
        }
        impl SkipWaitingParams {
            pub fn new(scope_url: impl Into<String>) -> Self {
                Self {
                    scope_url: scope_url.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for SkipWaitingParams {
            fn from(url: T) -> Self {
                SkipWaitingParams::new(url)
            }
        }
        impl SkipWaitingParams {
            pub fn builder() -> SkipWaitingParamsBuilder {
                SkipWaitingParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SkipWaitingParamsBuilder {
            scope_url: Option<String>,
        }
        impl SkipWaitingParamsBuilder {
            pub fn scope_url(mut self, scope_url: impl Into<String>) -> Self {
                self.scope_url = Some(scope_url.into());
                self
            }
            pub fn build(self) -> Result<SkipWaitingParams, String> {
                Ok(SkipWaitingParams {
                    scope_url: self.scope_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scope_url))
                    })?,
                })
            }
        }
        impl SkipWaitingParams {
            pub const IDENTIFIER: &'static str = "ServiceWorker.skipWaiting";
        }
        impl chromiumoxide_types::Method for SkipWaitingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SkipWaitingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SkipWaitingReturns {}
        impl chromiumoxide_types::Command for SkipWaitingParams {
            type Response = SkipWaitingReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StartWorkerParams {
            #[serde(rename = "scopeURL")]
            pub scope_url: String,
        }
        impl StartWorkerParams {
            pub fn new(scope_url: impl Into<String>) -> Self {
                Self {
                    scope_url: scope_url.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for StartWorkerParams {
            fn from(url: T) -> Self {
                StartWorkerParams::new(url)
            }
        }
        impl StartWorkerParams {
            pub fn builder() -> StartWorkerParamsBuilder {
                StartWorkerParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StartWorkerParamsBuilder {
            scope_url: Option<String>,
        }
        impl StartWorkerParamsBuilder {
            pub fn scope_url(mut self, scope_url: impl Into<String>) -> Self {
                self.scope_url = Some(scope_url.into());
                self
            }
            pub fn build(self) -> Result<StartWorkerParams, String> {
                Ok(StartWorkerParams {
                    scope_url: self.scope_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scope_url))
                    })?,
                })
            }
        }
        impl StartWorkerParams {
            pub const IDENTIFIER: &'static str = "ServiceWorker.startWorker";
        }
        impl chromiumoxide_types::Method for StartWorkerParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartWorkerParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartWorkerReturns {}
        impl chromiumoxide_types::Command for StartWorkerParams {
            type Response = StartWorkerReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopAllWorkersParams {}
        impl StopAllWorkersParams {
            pub const IDENTIFIER: &'static str = "ServiceWorker.stopAllWorkers";
        }
        impl chromiumoxide_types::Method for StopAllWorkersParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopAllWorkersParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopAllWorkersReturns {}
        impl chromiumoxide_types::Command for StopAllWorkersParams {
            type Response = StopAllWorkersReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct StopWorkerParams {
            #[serde(rename = "versionId")]
            pub version_id: String,
        }
        impl StopWorkerParams {
            pub fn new(version_id: impl Into<String>) -> Self {
                Self {
                    version_id: version_id.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for StopWorkerParams {
            fn from(url: T) -> Self {
                StopWorkerParams::new(url)
            }
        }
        impl StopWorkerParams {
            pub fn builder() -> StopWorkerParamsBuilder {
                StopWorkerParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StopWorkerParamsBuilder {
            version_id: Option<String>,
        }
        impl StopWorkerParamsBuilder {
            pub fn version_id(mut self, version_id: impl Into<String>) -> Self {
                self.version_id = Some(version_id.into());
                self
            }
            pub fn build(self) -> Result<StopWorkerParams, String> {
                Ok(StopWorkerParams {
                    version_id: self.version_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(version_id))
                    })?,
                })
            }
        }
        impl StopWorkerParams {
            pub const IDENTIFIER: &'static str = "ServiceWorker.stopWorker";
        }
        impl chromiumoxide_types::Method for StopWorkerParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StopWorkerParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StopWorkerReturns {}
        impl chromiumoxide_types::Command for StopWorkerParams {
            type Response = StopWorkerReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct UnregisterParams {
            #[serde(rename = "scopeURL")]
            pub scope_url: String,
        }
        impl UnregisterParams {
            pub fn new(scope_url: impl Into<String>) -> Self {
                Self {
                    scope_url: scope_url.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for UnregisterParams {
            fn from(url: T) -> Self {
                UnregisterParams::new(url)
            }
        }
        impl UnregisterParams {
            pub fn builder() -> UnregisterParamsBuilder {
                UnregisterParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct UnregisterParamsBuilder {
            scope_url: Option<String>,
        }
        impl UnregisterParamsBuilder {
            pub fn scope_url(mut self, scope_url: impl Into<String>) -> Self {
                self.scope_url = Some(scope_url.into());
                self
            }
            pub fn build(self) -> Result<UnregisterParams, String> {
                Ok(UnregisterParams {
                    scope_url: self.scope_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scope_url))
                    })?,
                })
            }
        }
        impl UnregisterParams {
            pub const IDENTIFIER: &'static str = "ServiceWorker.unregister";
        }
        impl chromiumoxide_types::Method for UnregisterParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for UnregisterParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct UnregisterReturns {}
        impl chromiumoxide_types::Command for UnregisterParams {
            type Response = UnregisterReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct UpdateRegistrationParams {
            #[serde(rename = "scopeURL")]
            pub scope_url: String,
        }
        impl UpdateRegistrationParams {
            pub fn new(scope_url: impl Into<String>) -> Self {
                Self {
                    scope_url: scope_url.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for UpdateRegistrationParams {
            fn from(url: T) -> Self {
                UpdateRegistrationParams::new(url)
            }
        }
        impl UpdateRegistrationParams {
            pub fn builder() -> UpdateRegistrationParamsBuilder {
                UpdateRegistrationParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct UpdateRegistrationParamsBuilder {
            scope_url: Option<String>,
        }
        impl UpdateRegistrationParamsBuilder {
            pub fn scope_url(mut self, scope_url: impl Into<String>) -> Self {
                self.scope_url = Some(scope_url.into());
                self
            }
            pub fn build(self) -> Result<UpdateRegistrationParams, String> {
                Ok(UpdateRegistrationParams {
                    scope_url: self.scope_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scope_url))
                    })?,
                })
            }
        }
        impl UpdateRegistrationParams {
            pub const IDENTIFIER: &'static str = "ServiceWorker.updateRegistration";
        }
        impl chromiumoxide_types::Method for UpdateRegistrationParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for UpdateRegistrationParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct UpdateRegistrationReturns {}
        impl chromiumoxide_types::Command for UpdateRegistrationParams {
            type Response = UpdateRegistrationReturns;
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWorkerErrorReported {
            #[serde(rename = "errorMessage")]
            pub error_message: ServiceWorkerErrorMessage,
        }
        impl EventWorkerErrorReported {
            pub const IDENTIFIER: &'static str = "ServiceWorker.workerErrorReported";
        }
        impl chromiumoxide_types::Method for EventWorkerErrorReported {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWorkerErrorReported {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWorkerRegistrationUpdated {
            #[serde(rename = "registrations")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub registrations: Vec<ServiceWorkerRegistration>,
        }
        impl EventWorkerRegistrationUpdated {
            pub const IDENTIFIER: &'static str = "ServiceWorker.workerRegistrationUpdated";
        }
        impl chromiumoxide_types::Method for EventWorkerRegistrationUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWorkerRegistrationUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventWorkerVersionUpdated {
            #[serde(rename = "versions")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub versions: Vec<ServiceWorkerVersion>,
        }
        impl EventWorkerVersionUpdated {
            pub const IDENTIFIER: &'static str = "ServiceWorker.workerVersionUpdated";
        }
        impl chromiumoxide_types::Method for EventWorkerVersionUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventWorkerVersionUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    pub mod storage {
        use serde::{Deserialize, Serialize};
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct SerializedStorageKey(String);
        impl SerializedStorageKey {
            pub fn new(val: impl Into<String>) -> Self {
                SerializedStorageKey(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for SerializedStorageKey {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<SerializedStorageKey> for String {
            fn from(el: SerializedStorageKey) -> String {
                el.0
            }
        }
        impl From<String> for SerializedStorageKey {
            fn from(expr: String) -> Self {
                SerializedStorageKey(expr)
            }
        }
        impl SerializedStorageKey {
            pub const IDENTIFIER: &'static str = "Storage.SerializedStorageKey";
        }
        #[doc = "Enum of possible storage types."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum StorageType {
            #[serde(rename = "appcache")]
            Appcache,
            #[serde(rename = "cookies")]
            Cookies,
            #[serde(rename = "file_systems")]
            FileSystems,
            #[serde(rename = "indexeddb")]
            Indexeddb,
            #[serde(rename = "local_storage")]
            LocalStorage,
            #[serde(rename = "shader_cache")]
            ShaderCache,
            #[serde(rename = "websql")]
            Websql,
            #[serde(rename = "service_workers")]
            ServiceWorkers,
            #[serde(rename = "cache_storage")]
            CacheStorage,
            #[serde(rename = "interest_groups")]
            InterestGroups,
            #[serde(rename = "all")]
            All,
            #[serde(rename = "other")]
            Other,
        }
        impl AsRef<str> for StorageType {
            fn as_ref(&self) -> &str {
                match self {
                    StorageType::Appcache => "appcache",
                    StorageType::Cookies => "cookies",
                    StorageType::FileSystems => "file_systems",
                    StorageType::Indexeddb => "indexeddb",
                    StorageType::LocalStorage => "local_storage",
                    StorageType::ShaderCache => "shader_cache",
                    StorageType::Websql => "websql",
                    StorageType::ServiceWorkers => "service_workers",
                    StorageType::CacheStorage => "cache_storage",
                    StorageType::InterestGroups => "interest_groups",
                    StorageType::All => "all",
                    StorageType::Other => "other",
                }
            }
        }
        impl ::std::str::FromStr for StorageType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "appcache" | "Appcache" => Ok(StorageType::Appcache),
                    "cookies" | "Cookies" => Ok(StorageType::Cookies),
                    "file_systems" | "FileSystems" => Ok(StorageType::FileSystems),
                    "indexeddb" | "Indexeddb" => Ok(StorageType::Indexeddb),
                    "local_storage" | "LocalStorage" => Ok(StorageType::LocalStorage),
                    "shader_cache" | "ShaderCache" => Ok(StorageType::ShaderCache),
                    "websql" | "Websql" => Ok(StorageType::Websql),
                    "service_workers" | "ServiceWorkers" => Ok(StorageType::ServiceWorkers),
                    "cache_storage" | "CacheStorage" => Ok(StorageType::CacheStorage),
                    "interest_groups" | "InterestGroups" => Ok(StorageType::InterestGroups),
                    "all" | "All" => Ok(StorageType::All),
                    "other" | "Other" => Ok(StorageType::Other),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Usage for a storage type.\n[UsageForType](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#type-UsageForType)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct UsageForType {
            #[doc = "Name of storage type."]
            #[serde(rename = "storageType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub storage_type: StorageType,
            #[doc = "Storage usage (bytes)."]
            #[serde(rename = "usage")]
            pub usage: f64,
        }
        impl UsageForType {
            pub fn new(storage_type: impl Into<StorageType>, usage: impl Into<f64>) -> Self {
                Self {
                    storage_type: storage_type.into(),
                    usage: usage.into(),
                }
            }
        }
        impl UsageForType {
            pub fn builder() -> UsageForTypeBuilder {
                UsageForTypeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct UsageForTypeBuilder {
            storage_type: Option<StorageType>,
            usage: Option<f64>,
        }
        impl UsageForTypeBuilder {
            pub fn storage_type(mut self, storage_type: impl Into<StorageType>) -> Self {
                self.storage_type = Some(storage_type.into());
                self
            }
            pub fn usage(mut self, usage: impl Into<f64>) -> Self {
                self.usage = Some(usage.into());
                self
            }
            pub fn build(self) -> Result<UsageForType, String> {
                Ok(UsageForType {
                    storage_type: self.storage_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(storage_type))
                    })?,
                    usage: self.usage.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(usage))
                    })?,
                })
            }
        }
        impl UsageForType {
            pub const IDENTIFIER: &'static str = "Storage.UsageForType";
        }
        #[doc = "Pair of issuer origin and number of available (signed, but not used) Trust\nTokens from that issuer.\n[TrustTokens](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#type-TrustTokens)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TrustTokens {
            #[serde(rename = "issuerOrigin")]
            pub issuer_origin: String,
            #[serde(rename = "count")]
            pub count: f64,
        }
        impl TrustTokens {
            pub fn new(issuer_origin: impl Into<String>, count: impl Into<f64>) -> Self {
                Self {
                    issuer_origin: issuer_origin.into(),
                    count: count.into(),
                }
            }
        }
        impl TrustTokens {
            pub fn builder() -> TrustTokensBuilder {
                TrustTokensBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TrustTokensBuilder {
            issuer_origin: Option<String>,
            count: Option<f64>,
        }
        impl TrustTokensBuilder {
            pub fn issuer_origin(mut self, issuer_origin: impl Into<String>) -> Self {
                self.issuer_origin = Some(issuer_origin.into());
                self
            }
            pub fn count(mut self, count: impl Into<f64>) -> Self {
                self.count = Some(count.into());
                self
            }
            pub fn build(self) -> Result<TrustTokens, String> {
                Ok(TrustTokens {
                    issuer_origin: self.issuer_origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(issuer_origin))
                    })?,
                    count: self.count.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(count))
                    })?,
                })
            }
        }
        impl TrustTokens {
            pub const IDENTIFIER: &'static str = "Storage.TrustTokens";
        }
        #[doc = "Enum of interest group access types."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum InterestGroupAccessType {
            #[serde(rename = "join")]
            Join,
            #[serde(rename = "leave")]
            Leave,
            #[serde(rename = "update")]
            Update,
            #[serde(rename = "bid")]
            Bid,
            #[serde(rename = "win")]
            Win,
        }
        impl AsRef<str> for InterestGroupAccessType {
            fn as_ref(&self) -> &str {
                match self {
                    InterestGroupAccessType::Join => "join",
                    InterestGroupAccessType::Leave => "leave",
                    InterestGroupAccessType::Update => "update",
                    InterestGroupAccessType::Bid => "bid",
                    InterestGroupAccessType::Win => "win",
                }
            }
        }
        impl ::std::str::FromStr for InterestGroupAccessType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "join" | "Join" => Ok(InterestGroupAccessType::Join),
                    "leave" | "Leave" => Ok(InterestGroupAccessType::Leave),
                    "update" | "Update" => Ok(InterestGroupAccessType::Update),
                    "bid" | "Bid" => Ok(InterestGroupAccessType::Bid),
                    "win" | "Win" => Ok(InterestGroupAccessType::Win),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Ad advertising element inside an interest group.\n[InterestGroupAd](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#type-InterestGroupAd)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InterestGroupAd {
            #[serde(rename = "renderUrl")]
            pub render_url: String,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub metadata: Option<String>,
        }
        impl InterestGroupAd {
            pub fn new(render_url: impl Into<String>) -> Self {
                Self {
                    render_url: render_url.into(),
                    metadata: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for InterestGroupAd {
            fn from(url: T) -> Self {
                InterestGroupAd::new(url)
            }
        }
        impl InterestGroupAd {
            pub fn builder() -> InterestGroupAdBuilder {
                InterestGroupAdBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct InterestGroupAdBuilder {
            render_url: Option<String>,
            metadata: Option<String>,
        }
        impl InterestGroupAdBuilder {
            pub fn render_url(mut self, render_url: impl Into<String>) -> Self {
                self.render_url = Some(render_url.into());
                self
            }
            pub fn metadata(mut self, metadata: impl Into<String>) -> Self {
                self.metadata = Some(metadata.into());
                self
            }
            pub fn build(self) -> Result<InterestGroupAd, String> {
                Ok(InterestGroupAd {
                    render_url: self.render_url.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(render_url))
                    })?,
                    metadata: self.metadata,
                })
            }
        }
        impl InterestGroupAd {
            pub const IDENTIFIER: &'static str = "Storage.InterestGroupAd";
        }
        #[doc = "The full details of an interest group.\n[InterestGroupDetails](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#type-InterestGroupDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InterestGroupDetails {
            #[serde(rename = "ownerOrigin")]
            pub owner_origin: String,
            #[serde(rename = "name")]
            pub name: String,
            #[serde(rename = "expirationTime")]
            pub expiration_time: super::network::TimeSinceEpoch,
            #[serde(rename = "joiningOrigin")]
            pub joining_origin: String,
            #[serde(rename = "biddingUrl")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub bidding_url: Option<String>,
            #[serde(rename = "biddingWasmHelperUrl")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub bidding_wasm_helper_url: Option<String>,
            #[serde(rename = "updateUrl")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub update_url: Option<String>,
            #[serde(rename = "trustedBiddingSignalsUrl")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub trusted_bidding_signals_url: Option<String>,
            #[serde(rename = "trustedBiddingSignalsKeys")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub trusted_bidding_signals_keys: Vec<String>,
            #[serde(rename = "userBiddingSignals")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub user_bidding_signals: Option<String>,
            #[serde(rename = "ads")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub ads: Vec<InterestGroupAd>,
            #[serde(rename = "adComponents")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub ad_components: Vec<InterestGroupAd>,
        }
        impl InterestGroupDetails {
            pub fn builder() -> InterestGroupDetailsBuilder {
                InterestGroupDetailsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct InterestGroupDetailsBuilder {
            owner_origin: Option<String>,
            name: Option<String>,
            expiration_time: Option<super::network::TimeSinceEpoch>,
            joining_origin: Option<String>,
            bidding_url: Option<String>,
            bidding_wasm_helper_url: Option<String>,
            update_url: Option<String>,
            trusted_bidding_signals_url: Option<String>,
            trusted_bidding_signals_keys: Option<Vec<String>>,
            user_bidding_signals: Option<String>,
            ads: Option<Vec<InterestGroupAd>>,
            ad_components: Option<Vec<InterestGroupAd>>,
        }
        impl InterestGroupDetailsBuilder {
            pub fn owner_origin(mut self, owner_origin: impl Into<String>) -> Self {
                self.owner_origin = Some(owner_origin.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn expiration_time(
                mut self,
                expiration_time: impl Into<super::network::TimeSinceEpoch>,
            ) -> Self {
                self.expiration_time = Some(expiration_time.into());
                self
            }
            pub fn joining_origin(mut self, joining_origin: impl Into<String>) -> Self {
                self.joining_origin = Some(joining_origin.into());
                self
            }
            pub fn bidding_url(mut self, bidding_url: impl Into<String>) -> Self {
                self.bidding_url = Some(bidding_url.into());
                self
            }
            pub fn bidding_wasm_helper_url(
                mut self,
                bidding_wasm_helper_url: impl Into<String>,
            ) -> Self {
                self.bidding_wasm_helper_url = Some(bidding_wasm_helper_url.into());
                self
            }
            pub fn update_url(mut self, update_url: impl Into<String>) -> Self {
                self.update_url = Some(update_url.into());
                self
            }
            pub fn trusted_bidding_signals_url(
                mut self,
                trusted_bidding_signals_url: impl Into<String>,
            ) -> Self {
                self.trusted_bidding_signals_url = Some(trusted_bidding_signals_url.into());
                self
            }
            pub fn trusted_bidding_signals_key(
                mut self,
                trusted_bidding_signals_key: impl Into<String>,
            ) -> Self {
                let v = self.trusted_bidding_signals_keys.get_or_insert(Vec::new());
                v.push(trusted_bidding_signals_key.into());
                self
            }
            pub fn trusted_bidding_signals_keys<I, S>(
                mut self,
                trusted_bidding_signals_keys: I,
            ) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.trusted_bidding_signals_keys.get_or_insert(Vec::new());
                for val in trusted_bidding_signals_keys {
                    v.push(val.into());
                }
                self
            }
            pub fn user_bidding_signals(mut self, user_bidding_signals: impl Into<String>) -> Self {
                self.user_bidding_signals = Some(user_bidding_signals.into());
                self
            }
            pub fn ad(mut self, ad: impl Into<InterestGroupAd>) -> Self {
                let v = self.ads.get_or_insert(Vec::new());
                v.push(ad.into());
                self
            }
            pub fn ads<I, S>(mut self, ads: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<InterestGroupAd>,
            {
                let v = self.ads.get_or_insert(Vec::new());
                for val in ads {
                    v.push(val.into());
                }
                self
            }
            pub fn ad_component(mut self, ad_component: impl Into<InterestGroupAd>) -> Self {
                let v = self.ad_components.get_or_insert(Vec::new());
                v.push(ad_component.into());
                self
            }
            pub fn ad_components<I, S>(mut self, ad_components: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<InterestGroupAd>,
            {
                let v = self.ad_components.get_or_insert(Vec::new());
                for val in ad_components {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<InterestGroupDetails, String> {
                Ok(InterestGroupDetails {
                    owner_origin: self.owner_origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(owner_origin))
                    })?,
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    expiration_time: self.expiration_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(expiration_time))
                    })?,
                    joining_origin: self.joining_origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(joining_origin))
                    })?,
                    bidding_url: self.bidding_url,
                    bidding_wasm_helper_url: self.bidding_wasm_helper_url,
                    update_url: self.update_url,
                    trusted_bidding_signals_url: self.trusted_bidding_signals_url,
                    trusted_bidding_signals_keys: self.trusted_bidding_signals_keys.ok_or_else(
                        || {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(trusted_bidding_signals_keys)
                            )
                        },
                    )?,
                    user_bidding_signals: self.user_bidding_signals,
                    ads: self
                        .ads
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(ads)))?,
                    ad_components: self.ad_components.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(ad_components))
                    })?,
                })
            }
        }
        impl InterestGroupDetails {
            pub const IDENTIFIER: &'static str = "Storage.InterestGroupDetails";
        }
        #[doc = "Returns a storage key given a frame id.\n[getStorageKeyForFrame](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getStorageKeyForFrame)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetStorageKeyForFrameParams {
            #[serde(rename = "frameId")]
            pub frame_id: super::page::FrameId,
        }
        impl GetStorageKeyForFrameParams {
            pub fn new(frame_id: impl Into<super::page::FrameId>) -> Self {
                Self {
                    frame_id: frame_id.into(),
                }
            }
        }
        impl GetStorageKeyForFrameParams {
            pub fn builder() -> GetStorageKeyForFrameParamsBuilder {
                GetStorageKeyForFrameParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetStorageKeyForFrameParamsBuilder {
            frame_id: Option<super::page::FrameId>,
        }
        impl GetStorageKeyForFrameParamsBuilder {
            pub fn frame_id(mut self, frame_id: impl Into<super::page::FrameId>) -> Self {
                self.frame_id = Some(frame_id.into());
                self
            }
            pub fn build(self) -> Result<GetStorageKeyForFrameParams, String> {
                Ok(GetStorageKeyForFrameParams {
                    frame_id: self.frame_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(frame_id))
                    })?,
                })
            }
        }
        impl GetStorageKeyForFrameParams {
            pub const IDENTIFIER: &'static str = "Storage.getStorageKeyForFrame";
        }
        impl chromiumoxide_types::Method for GetStorageKeyForFrameParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetStorageKeyForFrameParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns a storage key given a frame id.\n[getStorageKeyForFrame](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getStorageKeyForFrame)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetStorageKeyForFrameReturns {
            #[serde(rename = "storageKey")]
            pub storage_key: SerializedStorageKey,
        }
        impl GetStorageKeyForFrameReturns {
            pub fn new(storage_key: impl Into<SerializedStorageKey>) -> Self {
                Self {
                    storage_key: storage_key.into(),
                }
            }
        }
        impl GetStorageKeyForFrameReturns {
            pub fn builder() -> GetStorageKeyForFrameReturnsBuilder {
                GetStorageKeyForFrameReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetStorageKeyForFrameReturnsBuilder {
            storage_key: Option<SerializedStorageKey>,
        }
        impl GetStorageKeyForFrameReturnsBuilder {
            pub fn storage_key(mut self, storage_key: impl Into<SerializedStorageKey>) -> Self {
                self.storage_key = Some(storage_key.into());
                self
            }
            pub fn build(self) -> Result<GetStorageKeyForFrameReturns, String> {
                Ok(GetStorageKeyForFrameReturns {
                    storage_key: self.storage_key.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(storage_key))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetStorageKeyForFrameParams {
            type Response = GetStorageKeyForFrameReturns;
        }
        #[doc = "Clears storage for origin.\n[clearDataForOrigin](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-clearDataForOrigin)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ClearDataForOriginParams {
            #[doc = "Security origin."]
            #[serde(rename = "origin")]
            pub origin: String,
            #[doc = "Comma separated list of StorageType to clear."]
            #[serde(rename = "storageTypes")]
            pub storage_types: String,
        }
        impl ClearDataForOriginParams {
            pub fn new(origin: impl Into<String>, storage_types: impl Into<String>) -> Self {
                Self {
                    origin: origin.into(),
                    storage_types: storage_types.into(),
                }
            }
        }
        impl ClearDataForOriginParams {
            pub fn builder() -> ClearDataForOriginParamsBuilder {
                ClearDataForOriginParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ClearDataForOriginParamsBuilder {
            origin: Option<String>,
            storage_types: Option<String>,
        }
        impl ClearDataForOriginParamsBuilder {
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn storage_types(mut self, storage_types: impl Into<String>) -> Self {
                self.storage_types = Some(storage_types.into());
                self
            }
            pub fn build(self) -> Result<ClearDataForOriginParams, String> {
                Ok(ClearDataForOriginParams {
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    storage_types: self.storage_types.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(storage_types))
                    })?,
                })
            }
        }
        impl ClearDataForOriginParams {
            pub const IDENTIFIER: &'static str = "Storage.clearDataForOrigin";
        }
        impl chromiumoxide_types::Method for ClearDataForOriginParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearDataForOriginParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears storage for origin.\n[clearDataForOrigin](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-clearDataForOrigin)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearDataForOriginReturns {}
        impl chromiumoxide_types::Command for ClearDataForOriginParams {
            type Response = ClearDataForOriginReturns;
        }
        #[doc = "Clears storage for storage key.\n[clearDataForStorageKey](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-clearDataForStorageKey)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ClearDataForStorageKeyParams {
            #[doc = "Storage key."]
            #[serde(rename = "storageKey")]
            pub storage_key: String,
            #[doc = "Comma separated list of StorageType to clear."]
            #[serde(rename = "storageTypes")]
            pub storage_types: String,
        }
        impl ClearDataForStorageKeyParams {
            pub fn new(storage_key: impl Into<String>, storage_types: impl Into<String>) -> Self {
                Self {
                    storage_key: storage_key.into(),
                    storage_types: storage_types.into(),
                }
            }
        }
        impl ClearDataForStorageKeyParams {
            pub fn builder() -> ClearDataForStorageKeyParamsBuilder {
                ClearDataForStorageKeyParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ClearDataForStorageKeyParamsBuilder {
            storage_key: Option<String>,
            storage_types: Option<String>,
        }
        impl ClearDataForStorageKeyParamsBuilder {
            pub fn storage_key(mut self, storage_key: impl Into<String>) -> Self {
                self.storage_key = Some(storage_key.into());
                self
            }
            pub fn storage_types(mut self, storage_types: impl Into<String>) -> Self {
                self.storage_types = Some(storage_types.into());
                self
            }
            pub fn build(self) -> Result<ClearDataForStorageKeyParams, String> {
                Ok(ClearDataForStorageKeyParams {
                    storage_key: self.storage_key.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(storage_key))
                    })?,
                    storage_types: self.storage_types.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(storage_types))
                    })?,
                })
            }
        }
        impl ClearDataForStorageKeyParams {
            pub const IDENTIFIER: &'static str = "Storage.clearDataForStorageKey";
        }
        impl chromiumoxide_types::Method for ClearDataForStorageKeyParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearDataForStorageKeyParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears storage for storage key.\n[clearDataForStorageKey](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-clearDataForStorageKey)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearDataForStorageKeyReturns {}
        impl chromiumoxide_types::Command for ClearDataForStorageKeyParams {
            type Response = ClearDataForStorageKeyReturns;
        }
        #[doc = "Returns all browser cookies.\n[getCookies](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getCookies)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetCookiesParams {
            #[doc = "Browser context to use when called on the browser endpoint."]
            #[serde(rename = "browserContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub browser_context_id: Option<super::browser::BrowserContextId>,
        }
        impl GetCookiesParams {
            pub fn builder() -> GetCookiesParamsBuilder {
                GetCookiesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetCookiesParamsBuilder {
            browser_context_id: Option<super::browser::BrowserContextId>,
        }
        impl GetCookiesParamsBuilder {
            pub fn browser_context_id(
                mut self,
                browser_context_id: impl Into<super::browser::BrowserContextId>,
            ) -> Self {
                self.browser_context_id = Some(browser_context_id.into());
                self
            }
            pub fn build(self) -> GetCookiesParams {
                GetCookiesParams {
                    browser_context_id: self.browser_context_id,
                }
            }
        }
        impl GetCookiesParams {
            pub const IDENTIFIER: &'static str = "Storage.getCookies";
        }
        impl chromiumoxide_types::Method for GetCookiesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetCookiesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns all browser cookies.\n[getCookies](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getCookies)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetCookiesReturns {
            #[doc = "Array of cookie objects."]
            #[serde(rename = "cookies")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub cookies: Vec<super::network::Cookie>,
        }
        impl GetCookiesReturns {
            pub fn new(cookies: Vec<super::network::Cookie>) -> Self {
                Self { cookies }
            }
        }
        impl GetCookiesReturns {
            pub fn builder() -> GetCookiesReturnsBuilder {
                GetCookiesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetCookiesReturnsBuilder {
            cookies: Option<Vec<super::network::Cookie>>,
        }
        impl GetCookiesReturnsBuilder {
            pub fn cookie(mut self, cookie: impl Into<super::network::Cookie>) -> Self {
                let v = self.cookies.get_or_insert(Vec::new());
                v.push(cookie.into());
                self
            }
            pub fn cookies<I, S>(mut self, cookies: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<super::network::Cookie>,
            {
                let v = self.cookies.get_or_insert(Vec::new());
                for val in cookies {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetCookiesReturns, String> {
                Ok(GetCookiesReturns {
                    cookies: self.cookies.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cookies))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetCookiesParams {
            type Response = GetCookiesReturns;
        }
        #[doc = "Sets given cookies.\n[setCookies](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-setCookies)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetCookiesParams {
            #[doc = "Cookies to be set."]
            #[serde(rename = "cookies")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub cookies: Vec<super::network::CookieParam>,
            #[doc = "Browser context to use when called on the browser endpoint."]
            #[serde(rename = "browserContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub browser_context_id: Option<super::browser::BrowserContextId>,
        }
        impl SetCookiesParams {
            pub fn new(cookies: Vec<super::network::CookieParam>) -> Self {
                Self {
                    cookies,
                    browser_context_id: None,
                }
            }
        }
        impl SetCookiesParams {
            pub fn builder() -> SetCookiesParamsBuilder {
                SetCookiesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetCookiesParamsBuilder {
            cookies: Option<Vec<super::network::CookieParam>>,
            browser_context_id: Option<super::browser::BrowserContextId>,
        }
        impl SetCookiesParamsBuilder {
            pub fn cookie(mut self, cookie: impl Into<super::network::CookieParam>) -> Self {
                let v = self.cookies.get_or_insert(Vec::new());
                v.push(cookie.into());
                self
            }
            pub fn cookies<I, S>(mut self, cookies: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<super::network::CookieParam>,
            {
                let v = self.cookies.get_or_insert(Vec::new());
                for val in cookies {
                    v.push(val.into());
                }
                self
            }
            pub fn browser_context_id(
                mut self,
                browser_context_id: impl Into<super::browser::BrowserContextId>,
            ) -> Self {
                self.browser_context_id = Some(browser_context_id.into());
                self
            }
            pub fn build(self) -> Result<SetCookiesParams, String> {
                Ok(SetCookiesParams {
                    cookies: self.cookies.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cookies))
                    })?,
                    browser_context_id: self.browser_context_id,
                })
            }
        }
        impl SetCookiesParams {
            pub const IDENTIFIER: &'static str = "Storage.setCookies";
        }
        impl chromiumoxide_types::Method for SetCookiesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetCookiesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets given cookies.\n[setCookies](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-setCookies)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetCookiesReturns {}
        impl chromiumoxide_types::Command for SetCookiesParams {
            type Response = SetCookiesReturns;
        }
        #[doc = "Clears cookies.\n[clearCookies](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-clearCookies)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearCookiesParams {
            #[doc = "Browser context to use when called on the browser endpoint."]
            #[serde(rename = "browserContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub browser_context_id: Option<super::browser::BrowserContextId>,
        }
        impl ClearCookiesParams {
            pub fn builder() -> ClearCookiesParamsBuilder {
                ClearCookiesParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ClearCookiesParamsBuilder {
            browser_context_id: Option<super::browser::BrowserContextId>,
        }
        impl ClearCookiesParamsBuilder {
            pub fn browser_context_id(
                mut self,
                browser_context_id: impl Into<super::browser::BrowserContextId>,
            ) -> Self {
                self.browser_context_id = Some(browser_context_id.into());
                self
            }
            pub fn build(self) -> ClearCookiesParams {
                ClearCookiesParams {
                    browser_context_id: self.browser_context_id,
                }
            }
        }
        impl ClearCookiesParams {
            pub const IDENTIFIER: &'static str = "Storage.clearCookies";
        }
        impl chromiumoxide_types::Method for ClearCookiesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearCookiesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears cookies.\n[clearCookies](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-clearCookies)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearCookiesReturns {}
        impl chromiumoxide_types::Command for ClearCookiesParams {
            type Response = ClearCookiesReturns;
        }
        #[doc = "Returns usage and quota in bytes.\n[getUsageAndQuota](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getUsageAndQuota)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetUsageAndQuotaParams {
            #[doc = "Security origin."]
            #[serde(rename = "origin")]
            pub origin: String,
        }
        impl GetUsageAndQuotaParams {
            pub fn new(origin: impl Into<String>) -> Self {
                Self {
                    origin: origin.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for GetUsageAndQuotaParams {
            fn from(url: T) -> Self {
                GetUsageAndQuotaParams::new(url)
            }
        }
        impl GetUsageAndQuotaParams {
            pub fn builder() -> GetUsageAndQuotaParamsBuilder {
                GetUsageAndQuotaParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetUsageAndQuotaParamsBuilder {
            origin: Option<String>,
        }
        impl GetUsageAndQuotaParamsBuilder {
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn build(self) -> Result<GetUsageAndQuotaParams, String> {
                Ok(GetUsageAndQuotaParams {
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                })
            }
        }
        impl GetUsageAndQuotaParams {
            pub const IDENTIFIER: &'static str = "Storage.getUsageAndQuota";
        }
        impl chromiumoxide_types::Method for GetUsageAndQuotaParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetUsageAndQuotaParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns usage and quota in bytes.\n[getUsageAndQuota](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getUsageAndQuota)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetUsageAndQuotaReturns {
            #[doc = "Storage usage (bytes)."]
            #[serde(rename = "usage")]
            pub usage: f64,
            #[doc = "Storage quota (bytes)."]
            #[serde(rename = "quota")]
            pub quota: f64,
            #[doc = "Whether or not the origin has an active storage quota override"]
            #[serde(rename = "overrideActive")]
            pub override_active: bool,
            #[doc = "Storage usage per type (bytes)."]
            #[serde(rename = "usageBreakdown")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub usage_breakdown: Vec<UsageForType>,
        }
        impl GetUsageAndQuotaReturns {
            pub fn new(
                usage: impl Into<f64>,
                quota: impl Into<f64>,
                override_active: impl Into<bool>,
                usage_breakdown: Vec<UsageForType>,
            ) -> Self {
                Self {
                    usage: usage.into(),
                    quota: quota.into(),
                    override_active: override_active.into(),
                    usage_breakdown,
                }
            }
        }
        impl GetUsageAndQuotaReturns {
            pub fn builder() -> GetUsageAndQuotaReturnsBuilder {
                GetUsageAndQuotaReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetUsageAndQuotaReturnsBuilder {
            usage: Option<f64>,
            quota: Option<f64>,
            override_active: Option<bool>,
            usage_breakdown: Option<Vec<UsageForType>>,
        }
        impl GetUsageAndQuotaReturnsBuilder {
            pub fn usage(mut self, usage: impl Into<f64>) -> Self {
                self.usage = Some(usage.into());
                self
            }
            pub fn quota(mut self, quota: impl Into<f64>) -> Self {
                self.quota = Some(quota.into());
                self
            }
            pub fn override_active(mut self, override_active: impl Into<bool>) -> Self {
                self.override_active = Some(override_active.into());
                self
            }
            pub fn usage_breakdown(mut self, usage_breakdown: impl Into<UsageForType>) -> Self {
                let v = self.usage_breakdown.get_or_insert(Vec::new());
                v.push(usage_breakdown.into());
                self
            }
            pub fn usage_breakdowns<I, S>(mut self, usage_breakdowns: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<UsageForType>,
            {
                let v = self.usage_breakdown.get_or_insert(Vec::new());
                for val in usage_breakdowns {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetUsageAndQuotaReturns, String> {
                Ok(GetUsageAndQuotaReturns {
                    usage: self.usage.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(usage))
                    })?,
                    quota: self.quota.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(quota))
                    })?,
                    override_active: self.override_active.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(override_active))
                    })?,
                    usage_breakdown: self.usage_breakdown.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(usage_breakdown))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetUsageAndQuotaParams {
            type Response = GetUsageAndQuotaReturns;
        }
        #[doc = "Override quota for the specified origin\n[overrideQuotaForOrigin](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-overrideQuotaForOrigin)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct OverrideQuotaForOriginParams {
            #[doc = "Security origin."]
            #[serde(rename = "origin")]
            pub origin: String,
            #[doc = "The quota size (in bytes) to override the original quota with.\nIf this is called multiple times, the overridden quota will be equal to\nthe quotaSize provided in the final call. If this is called without\nspecifying a quotaSize, the quota will be reset to the default value for\nthe specified origin. If this is called multiple times with different\norigins, the override will be maintained for each origin until it is\ndisabled (called without a quotaSize)."]
            #[serde(rename = "quotaSize")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub quota_size: Option<f64>,
        }
        impl OverrideQuotaForOriginParams {
            pub fn new(origin: impl Into<String>) -> Self {
                Self {
                    origin: origin.into(),
                    quota_size: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for OverrideQuotaForOriginParams {
            fn from(url: T) -> Self {
                OverrideQuotaForOriginParams::new(url)
            }
        }
        impl OverrideQuotaForOriginParams {
            pub fn builder() -> OverrideQuotaForOriginParamsBuilder {
                OverrideQuotaForOriginParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct OverrideQuotaForOriginParamsBuilder {
            origin: Option<String>,
            quota_size: Option<f64>,
        }
        impl OverrideQuotaForOriginParamsBuilder {
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn quota_size(mut self, quota_size: impl Into<f64>) -> Self {
                self.quota_size = Some(quota_size.into());
                self
            }
            pub fn build(self) -> Result<OverrideQuotaForOriginParams, String> {
                Ok(OverrideQuotaForOriginParams {
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    quota_size: self.quota_size,
                })
            }
        }
        impl OverrideQuotaForOriginParams {
            pub const IDENTIFIER: &'static str = "Storage.overrideQuotaForOrigin";
        }
        impl chromiumoxide_types::Method for OverrideQuotaForOriginParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for OverrideQuotaForOriginParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Override quota for the specified origin\n[overrideQuotaForOrigin](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-overrideQuotaForOrigin)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct OverrideQuotaForOriginReturns {}
        impl chromiumoxide_types::Command for OverrideQuotaForOriginParams {
            type Response = OverrideQuotaForOriginReturns;
        }
        #[doc = "Registers origin to be notified when an update occurs to its cache storage list.\n[trackCacheStorageForOrigin](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-trackCacheStorageForOrigin)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TrackCacheStorageForOriginParams {
            #[doc = "Security origin."]
            #[serde(rename = "origin")]
            pub origin: String,
        }
        impl TrackCacheStorageForOriginParams {
            pub fn new(origin: impl Into<String>) -> Self {
                Self {
                    origin: origin.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for TrackCacheStorageForOriginParams {
            fn from(url: T) -> Self {
                TrackCacheStorageForOriginParams::new(url)
            }
        }
        impl TrackCacheStorageForOriginParams {
            pub fn builder() -> TrackCacheStorageForOriginParamsBuilder {
                TrackCacheStorageForOriginParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TrackCacheStorageForOriginParamsBuilder {
            origin: Option<String>,
        }
        impl TrackCacheStorageForOriginParamsBuilder {
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn build(self) -> Result<TrackCacheStorageForOriginParams, String> {
                Ok(TrackCacheStorageForOriginParams {
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                })
            }
        }
        impl TrackCacheStorageForOriginParams {
            pub const IDENTIFIER: &'static str = "Storage.trackCacheStorageForOrigin";
        }
        impl chromiumoxide_types::Method for TrackCacheStorageForOriginParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for TrackCacheStorageForOriginParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Registers origin to be notified when an update occurs to its cache storage list.\n[trackCacheStorageForOrigin](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-trackCacheStorageForOrigin)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TrackCacheStorageForOriginReturns {}
        impl chromiumoxide_types::Command for TrackCacheStorageForOriginParams {
            type Response = TrackCacheStorageForOriginReturns;
        }
        #[doc = "Registers origin to be notified when an update occurs to its IndexedDB.\n[trackIndexedDBForOrigin](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-trackIndexedDBForOrigin)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TrackIndexedDbForOriginParams {
            #[doc = "Security origin."]
            #[serde(rename = "origin")]
            pub origin: String,
        }
        impl TrackIndexedDbForOriginParams {
            pub fn new(origin: impl Into<String>) -> Self {
                Self {
                    origin: origin.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for TrackIndexedDbForOriginParams {
            fn from(url: T) -> Self {
                TrackIndexedDbForOriginParams::new(url)
            }
        }
        impl TrackIndexedDbForOriginParams {
            pub fn builder() -> TrackIndexedDbForOriginParamsBuilder {
                TrackIndexedDbForOriginParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TrackIndexedDbForOriginParamsBuilder {
            origin: Option<String>,
        }
        impl TrackIndexedDbForOriginParamsBuilder {
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn build(self) -> Result<TrackIndexedDbForOriginParams, String> {
                Ok(TrackIndexedDbForOriginParams {
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                })
            }
        }
        impl TrackIndexedDbForOriginParams {
            pub const IDENTIFIER: &'static str = "Storage.trackIndexedDBForOrigin";
        }
        impl chromiumoxide_types::Method for TrackIndexedDbForOriginParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for TrackIndexedDbForOriginParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Registers origin to be notified when an update occurs to its IndexedDB.\n[trackIndexedDBForOrigin](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-trackIndexedDBForOrigin)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TrackIndexedDbForOriginReturns {}
        impl chromiumoxide_types::Command for TrackIndexedDbForOriginParams {
            type Response = TrackIndexedDbForOriginReturns;
        }
        #[doc = "Registers storage key to be notified when an update occurs to its IndexedDB.\n[trackIndexedDBForStorageKey](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-trackIndexedDBForStorageKey)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TrackIndexedDbForStorageKeyParams {
            #[doc = "Storage key."]
            #[serde(rename = "storageKey")]
            pub storage_key: String,
        }
        impl TrackIndexedDbForStorageKeyParams {
            pub fn new(storage_key: impl Into<String>) -> Self {
                Self {
                    storage_key: storage_key.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for TrackIndexedDbForStorageKeyParams {
            fn from(url: T) -> Self {
                TrackIndexedDbForStorageKeyParams::new(url)
            }
        }
        impl TrackIndexedDbForStorageKeyParams {
            pub fn builder() -> TrackIndexedDbForStorageKeyParamsBuilder {
                TrackIndexedDbForStorageKeyParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TrackIndexedDbForStorageKeyParamsBuilder {
            storage_key: Option<String>,
        }
        impl TrackIndexedDbForStorageKeyParamsBuilder {
            pub fn storage_key(mut self, storage_key: impl Into<String>) -> Self {
                self.storage_key = Some(storage_key.into());
                self
            }
            pub fn build(self) -> Result<TrackIndexedDbForStorageKeyParams, String> {
                Ok(TrackIndexedDbForStorageKeyParams {
                    storage_key: self.storage_key.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(storage_key))
                    })?,
                })
            }
        }
        impl TrackIndexedDbForStorageKeyParams {
            pub const IDENTIFIER: &'static str = "Storage.trackIndexedDBForStorageKey";
        }
        impl chromiumoxide_types::Method for TrackIndexedDbForStorageKeyParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for TrackIndexedDbForStorageKeyParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Registers storage key to be notified when an update occurs to its IndexedDB.\n[trackIndexedDBForStorageKey](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-trackIndexedDBForStorageKey)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TrackIndexedDbForStorageKeyReturns {}
        impl chromiumoxide_types::Command for TrackIndexedDbForStorageKeyParams {
            type Response = TrackIndexedDbForStorageKeyReturns;
        }
        #[doc = "Unregisters origin from receiving notifications for cache storage.\n[untrackCacheStorageForOrigin](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-untrackCacheStorageForOrigin)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct UntrackCacheStorageForOriginParams {
            #[doc = "Security origin."]
            #[serde(rename = "origin")]
            pub origin: String,
        }
        impl UntrackCacheStorageForOriginParams {
            pub fn new(origin: impl Into<String>) -> Self {
                Self {
                    origin: origin.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for UntrackCacheStorageForOriginParams {
            fn from(url: T) -> Self {
                UntrackCacheStorageForOriginParams::new(url)
            }
        }
        impl UntrackCacheStorageForOriginParams {
            pub fn builder() -> UntrackCacheStorageForOriginParamsBuilder {
                UntrackCacheStorageForOriginParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct UntrackCacheStorageForOriginParamsBuilder {
            origin: Option<String>,
        }
        impl UntrackCacheStorageForOriginParamsBuilder {
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn build(self) -> Result<UntrackCacheStorageForOriginParams, String> {
                Ok(UntrackCacheStorageForOriginParams {
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                })
            }
        }
        impl UntrackCacheStorageForOriginParams {
            pub const IDENTIFIER: &'static str = "Storage.untrackCacheStorageForOrigin";
        }
        impl chromiumoxide_types::Method for UntrackCacheStorageForOriginParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for UntrackCacheStorageForOriginParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Unregisters origin from receiving notifications for cache storage.\n[untrackCacheStorageForOrigin](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-untrackCacheStorageForOrigin)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct UntrackCacheStorageForOriginReturns {}
        impl chromiumoxide_types::Command for UntrackCacheStorageForOriginParams {
            type Response = UntrackCacheStorageForOriginReturns;
        }
        #[doc = "Unregisters origin from receiving notifications for IndexedDB.\n[untrackIndexedDBForOrigin](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-untrackIndexedDBForOrigin)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct UntrackIndexedDbForOriginParams {
            #[doc = "Security origin."]
            #[serde(rename = "origin")]
            pub origin: String,
        }
        impl UntrackIndexedDbForOriginParams {
            pub fn new(origin: impl Into<String>) -> Self {
                Self {
                    origin: origin.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for UntrackIndexedDbForOriginParams {
            fn from(url: T) -> Self {
                UntrackIndexedDbForOriginParams::new(url)
            }
        }
        impl UntrackIndexedDbForOriginParams {
            pub fn builder() -> UntrackIndexedDbForOriginParamsBuilder {
                UntrackIndexedDbForOriginParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct UntrackIndexedDbForOriginParamsBuilder {
            origin: Option<String>,
        }
        impl UntrackIndexedDbForOriginParamsBuilder {
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn build(self) -> Result<UntrackIndexedDbForOriginParams, String> {
                Ok(UntrackIndexedDbForOriginParams {
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                })
            }
        }
        impl UntrackIndexedDbForOriginParams {
            pub const IDENTIFIER: &'static str = "Storage.untrackIndexedDBForOrigin";
        }
        impl chromiumoxide_types::Method for UntrackIndexedDbForOriginParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for UntrackIndexedDbForOriginParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Unregisters origin from receiving notifications for IndexedDB.\n[untrackIndexedDBForOrigin](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-untrackIndexedDBForOrigin)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct UntrackIndexedDbForOriginReturns {}
        impl chromiumoxide_types::Command for UntrackIndexedDbForOriginParams {
            type Response = UntrackIndexedDbForOriginReturns;
        }
        #[doc = "Unregisters storage key from receiving notifications for IndexedDB.\n[untrackIndexedDBForStorageKey](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-untrackIndexedDBForStorageKey)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct UntrackIndexedDbForStorageKeyParams {
            #[doc = "Storage key."]
            #[serde(rename = "storageKey")]
            pub storage_key: String,
        }
        impl UntrackIndexedDbForStorageKeyParams {
            pub fn new(storage_key: impl Into<String>) -> Self {
                Self {
                    storage_key: storage_key.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for UntrackIndexedDbForStorageKeyParams {
            fn from(url: T) -> Self {
                UntrackIndexedDbForStorageKeyParams::new(url)
            }
        }
        impl UntrackIndexedDbForStorageKeyParams {
            pub fn builder() -> UntrackIndexedDbForStorageKeyParamsBuilder {
                UntrackIndexedDbForStorageKeyParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct UntrackIndexedDbForStorageKeyParamsBuilder {
            storage_key: Option<String>,
        }
        impl UntrackIndexedDbForStorageKeyParamsBuilder {
            pub fn storage_key(mut self, storage_key: impl Into<String>) -> Self {
                self.storage_key = Some(storage_key.into());
                self
            }
            pub fn build(self) -> Result<UntrackIndexedDbForStorageKeyParams, String> {
                Ok(UntrackIndexedDbForStorageKeyParams {
                    storage_key: self.storage_key.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(storage_key))
                    })?,
                })
            }
        }
        impl UntrackIndexedDbForStorageKeyParams {
            pub const IDENTIFIER: &'static str = "Storage.untrackIndexedDBForStorageKey";
        }
        impl chromiumoxide_types::Method for UntrackIndexedDbForStorageKeyParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for UntrackIndexedDbForStorageKeyParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Unregisters storage key from receiving notifications for IndexedDB.\n[untrackIndexedDBForStorageKey](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-untrackIndexedDBForStorageKey)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct UntrackIndexedDbForStorageKeyReturns {}
        impl chromiumoxide_types::Command for UntrackIndexedDbForStorageKeyParams {
            type Response = UntrackIndexedDbForStorageKeyReturns;
        }
        #[doc = "Returns the number of stored Trust Tokens per issuer for the\ncurrent browsing context.\n[getTrustTokens](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getTrustTokens)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetTrustTokensParams {}
        impl GetTrustTokensParams {
            pub const IDENTIFIER: &'static str = "Storage.getTrustTokens";
        }
        impl chromiumoxide_types::Method for GetTrustTokensParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetTrustTokensParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns the number of stored Trust Tokens per issuer for the\ncurrent browsing context.\n[getTrustTokens](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getTrustTokens)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetTrustTokensReturns {
            #[serde(rename = "tokens")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub tokens: Vec<TrustTokens>,
        }
        impl GetTrustTokensReturns {
            pub fn new(tokens: Vec<TrustTokens>) -> Self {
                Self { tokens }
            }
        }
        impl GetTrustTokensReturns {
            pub fn builder() -> GetTrustTokensReturnsBuilder {
                GetTrustTokensReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetTrustTokensReturnsBuilder {
            tokens: Option<Vec<TrustTokens>>,
        }
        impl GetTrustTokensReturnsBuilder {
            pub fn token(mut self, token: impl Into<TrustTokens>) -> Self {
                let v = self.tokens.get_or_insert(Vec::new());
                v.push(token.into());
                self
            }
            pub fn tokens<I, S>(mut self, tokens: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<TrustTokens>,
            {
                let v = self.tokens.get_or_insert(Vec::new());
                for val in tokens {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetTrustTokensReturns, String> {
                Ok(GetTrustTokensReturns {
                    tokens: self.tokens.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(tokens))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetTrustTokensParams {
            type Response = GetTrustTokensReturns;
        }
        #[doc = "Removes all Trust Tokens issued by the provided issuerOrigin.\nLeaves other stored data, including the issuer's Redemption Records, intact.\n[clearTrustTokens](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-clearTrustTokens)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ClearTrustTokensParams {
            #[serde(rename = "issuerOrigin")]
            pub issuer_origin: String,
        }
        impl ClearTrustTokensParams {
            pub fn new(issuer_origin: impl Into<String>) -> Self {
                Self {
                    issuer_origin: issuer_origin.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for ClearTrustTokensParams {
            fn from(url: T) -> Self {
                ClearTrustTokensParams::new(url)
            }
        }
        impl ClearTrustTokensParams {
            pub fn builder() -> ClearTrustTokensParamsBuilder {
                ClearTrustTokensParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ClearTrustTokensParamsBuilder {
            issuer_origin: Option<String>,
        }
        impl ClearTrustTokensParamsBuilder {
            pub fn issuer_origin(mut self, issuer_origin: impl Into<String>) -> Self {
                self.issuer_origin = Some(issuer_origin.into());
                self
            }
            pub fn build(self) -> Result<ClearTrustTokensParams, String> {
                Ok(ClearTrustTokensParams {
                    issuer_origin: self.issuer_origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(issuer_origin))
                    })?,
                })
            }
        }
        impl ClearTrustTokensParams {
            pub const IDENTIFIER: &'static str = "Storage.clearTrustTokens";
        }
        impl chromiumoxide_types::Method for ClearTrustTokensParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearTrustTokensParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Removes all Trust Tokens issued by the provided issuerOrigin.\nLeaves other stored data, including the issuer's Redemption Records, intact.\n[clearTrustTokens](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-clearTrustTokens)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ClearTrustTokensReturns {
            #[doc = "True if any tokens were deleted, false otherwise."]
            #[serde(rename = "didDeleteTokens")]
            pub did_delete_tokens: bool,
        }
        impl ClearTrustTokensReturns {
            pub fn new(did_delete_tokens: impl Into<bool>) -> Self {
                Self {
                    did_delete_tokens: did_delete_tokens.into(),
                }
            }
        }
        impl ClearTrustTokensReturns {
            pub fn builder() -> ClearTrustTokensReturnsBuilder {
                ClearTrustTokensReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ClearTrustTokensReturnsBuilder {
            did_delete_tokens: Option<bool>,
        }
        impl ClearTrustTokensReturnsBuilder {
            pub fn did_delete_tokens(mut self, did_delete_tokens: impl Into<bool>) -> Self {
                self.did_delete_tokens = Some(did_delete_tokens.into());
                self
            }
            pub fn build(self) -> Result<ClearTrustTokensReturns, String> {
                Ok(ClearTrustTokensReturns {
                    did_delete_tokens: self.did_delete_tokens.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(did_delete_tokens)
                        )
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for ClearTrustTokensParams {
            type Response = ClearTrustTokensReturns;
        }
        #[doc = "Gets details for a named interest group.\n[getInterestGroupDetails](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getInterestGroupDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetInterestGroupDetailsParams {
            #[serde(rename = "ownerOrigin")]
            pub owner_origin: String,
            #[serde(rename = "name")]
            pub name: String,
        }
        impl GetInterestGroupDetailsParams {
            pub fn new(owner_origin: impl Into<String>, name: impl Into<String>) -> Self {
                Self {
                    owner_origin: owner_origin.into(),
                    name: name.into(),
                }
            }
        }
        impl GetInterestGroupDetailsParams {
            pub fn builder() -> GetInterestGroupDetailsParamsBuilder {
                GetInterestGroupDetailsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetInterestGroupDetailsParamsBuilder {
            owner_origin: Option<String>,
            name: Option<String>,
        }
        impl GetInterestGroupDetailsParamsBuilder {
            pub fn owner_origin(mut self, owner_origin: impl Into<String>) -> Self {
                self.owner_origin = Some(owner_origin.into());
                self
            }
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn build(self) -> Result<GetInterestGroupDetailsParams, String> {
                Ok(GetInterestGroupDetailsParams {
                    owner_origin: self.owner_origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(owner_origin))
                    })?,
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                })
            }
        }
        impl GetInterestGroupDetailsParams {
            pub const IDENTIFIER: &'static str = "Storage.getInterestGroupDetails";
        }
        impl chromiumoxide_types::Method for GetInterestGroupDetailsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetInterestGroupDetailsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Gets details for a named interest group.\n[getInterestGroupDetails](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getInterestGroupDetails)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetInterestGroupDetailsReturns {
            #[serde(rename = "details")]
            pub details: InterestGroupDetails,
        }
        impl GetInterestGroupDetailsReturns {
            pub fn new(details: impl Into<InterestGroupDetails>) -> Self {
                Self {
                    details: details.into(),
                }
            }
        }
        impl GetInterestGroupDetailsReturns {
            pub fn builder() -> GetInterestGroupDetailsReturnsBuilder {
                GetInterestGroupDetailsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetInterestGroupDetailsReturnsBuilder {
            details: Option<InterestGroupDetails>,
        }
        impl GetInterestGroupDetailsReturnsBuilder {
            pub fn details(mut self, details: impl Into<InterestGroupDetails>) -> Self {
                self.details = Some(details.into());
                self
            }
            pub fn build(self) -> Result<GetInterestGroupDetailsReturns, String> {
                Ok(GetInterestGroupDetailsReturns {
                    details: self.details.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(details))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetInterestGroupDetailsParams {
            type Response = GetInterestGroupDetailsReturns;
        }
        #[doc = "Enables/Disables issuing of interestGroupAccessed events.\n[setInterestGroupTracking](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-setInterestGroupTracking)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetInterestGroupTrackingParams {
            #[serde(rename = "enable")]
            pub enable: bool,
        }
        impl SetInterestGroupTrackingParams {
            pub fn new(enable: impl Into<bool>) -> Self {
                Self {
                    enable: enable.into(),
                }
            }
        }
        impl SetInterestGroupTrackingParams {
            pub fn builder() -> SetInterestGroupTrackingParamsBuilder {
                SetInterestGroupTrackingParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetInterestGroupTrackingParamsBuilder {
            enable: Option<bool>,
        }
        impl SetInterestGroupTrackingParamsBuilder {
            pub fn enable(mut self, enable: impl Into<bool>) -> Self {
                self.enable = Some(enable.into());
                self
            }
            pub fn build(self) -> Result<SetInterestGroupTrackingParams, String> {
                Ok(SetInterestGroupTrackingParams {
                    enable: self.enable.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enable))
                    })?,
                })
            }
        }
        impl SetInterestGroupTrackingParams {
            pub const IDENTIFIER: &'static str = "Storage.setInterestGroupTracking";
        }
        impl chromiumoxide_types::Method for SetInterestGroupTrackingParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetInterestGroupTrackingParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables/Disables issuing of interestGroupAccessed events.\n[setInterestGroupTracking](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-setInterestGroupTracking)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetInterestGroupTrackingReturns {}
        impl chromiumoxide_types::Command for SetInterestGroupTrackingParams {
            type Response = SetInterestGroupTrackingReturns;
        }
        #[doc = "A cache's contents have been modified.\n[cacheStorageContentUpdated](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#event-cacheStorageContentUpdated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventCacheStorageContentUpdated {
            #[doc = "Origin to update."]
            #[serde(rename = "origin")]
            pub origin: String,
            #[doc = "Name of cache in origin."]
            #[serde(rename = "cacheName")]
            pub cache_name: String,
        }
        impl EventCacheStorageContentUpdated {
            pub const IDENTIFIER: &'static str = "Storage.cacheStorageContentUpdated";
        }
        impl chromiumoxide_types::Method for EventCacheStorageContentUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventCacheStorageContentUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "A cache has been added/deleted.\n[cacheStorageListUpdated](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#event-cacheStorageListUpdated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventCacheStorageListUpdated {
            #[doc = "Origin to update."]
            #[serde(rename = "origin")]
            pub origin: String,
        }
        impl EventCacheStorageListUpdated {
            pub const IDENTIFIER: &'static str = "Storage.cacheStorageListUpdated";
        }
        impl chromiumoxide_types::Method for EventCacheStorageListUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventCacheStorageListUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "The origin's IndexedDB object store has been modified.\n[indexedDBContentUpdated](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#event-indexedDBContentUpdated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventIndexedDbContentUpdated {
            #[doc = "Origin to update."]
            #[serde(rename = "origin")]
            pub origin: String,
            #[doc = "Storage key to update."]
            #[serde(rename = "storageKey")]
            pub storage_key: String,
            #[doc = "Database to update."]
            #[serde(rename = "databaseName")]
            pub database_name: String,
            #[doc = "ObjectStore to update."]
            #[serde(rename = "objectStoreName")]
            pub object_store_name: String,
        }
        impl EventIndexedDbContentUpdated {
            pub const IDENTIFIER: &'static str = "Storage.indexedDBContentUpdated";
        }
        impl chromiumoxide_types::Method for EventIndexedDbContentUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventIndexedDbContentUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "The origin's IndexedDB database list has been modified.\n[indexedDBListUpdated](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#event-indexedDBListUpdated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventIndexedDbListUpdated {
            #[doc = "Origin to update."]
            #[serde(rename = "origin")]
            pub origin: String,
            #[doc = "Storage key to update."]
            #[serde(rename = "storageKey")]
            pub storage_key: String,
        }
        impl EventIndexedDbListUpdated {
            pub const IDENTIFIER: &'static str = "Storage.indexedDBListUpdated";
        }
        impl chromiumoxide_types::Method for EventIndexedDbListUpdated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventIndexedDbListUpdated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "One of the interest groups was accessed by the associated page.\n[interestGroupAccessed](https://chromedevtools.github.io/devtools-protocol/tot/Storage/#event-interestGroupAccessed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventInterestGroupAccessed {
            #[serde(rename = "accessTime")]
            pub access_time: super::network::TimeSinceEpoch,
            #[serde(rename = "type")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub r#type: InterestGroupAccessType,
            #[serde(rename = "ownerOrigin")]
            pub owner_origin: String,
            #[serde(rename = "name")]
            pub name: String,
        }
        impl EventInterestGroupAccessed {
            pub const IDENTIFIER: &'static str = "Storage.interestGroupAccessed";
        }
        impl chromiumoxide_types::Method for EventInterestGroupAccessed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventInterestGroupAccessed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "The SystemInfo domain defines methods and events for querying low-level system information."]
    pub mod system_info {
        use serde::{Deserialize, Serialize};
        #[doc = "Describes a single graphics processor (GPU).\n[GPUDevice](https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#type-GPUDevice)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GpuDevice {
            #[doc = "PCI ID of the GPU vendor, if available; 0 otherwise."]
            #[serde(rename = "vendorId")]
            pub vendor_id: f64,
            #[doc = "PCI ID of the GPU device, if available; 0 otherwise."]
            #[serde(rename = "deviceId")]
            pub device_id: f64,
            #[doc = "Sub sys ID of the GPU, only available on Windows."]
            #[serde(rename = "subSysId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub sub_sys_id: Option<f64>,
            #[doc = "Revision of the GPU, only available on Windows."]
            #[serde(rename = "revision")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub revision: Option<f64>,
            #[doc = "String description of the GPU vendor, if the PCI ID is not available."]
            #[serde(rename = "vendorString")]
            pub vendor_string: String,
            #[doc = "String description of the GPU device, if the PCI ID is not available."]
            #[serde(rename = "deviceString")]
            pub device_string: String,
            #[doc = "String description of the GPU driver vendor."]
            #[serde(rename = "driverVendor")]
            pub driver_vendor: String,
            #[doc = "String description of the GPU driver version."]
            #[serde(rename = "driverVersion")]
            pub driver_version: String,
        }
        impl GpuDevice {
            pub fn builder() -> GpuDeviceBuilder {
                GpuDeviceBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GpuDeviceBuilder {
            vendor_id: Option<f64>,
            device_id: Option<f64>,
            sub_sys_id: Option<f64>,
            revision: Option<f64>,
            vendor_string: Option<String>,
            device_string: Option<String>,
            driver_vendor: Option<String>,
            driver_version: Option<String>,
        }
        impl GpuDeviceBuilder {
            pub fn vendor_id(mut self, vendor_id: impl Into<f64>) -> Self {
                self.vendor_id = Some(vendor_id.into());
                self
            }
            pub fn device_id(mut self, device_id: impl Into<f64>) -> Self {
                self.device_id = Some(device_id.into());
                self
            }
            pub fn sub_sys_id(mut self, sub_sys_id: impl Into<f64>) -> Self {
                self.sub_sys_id = Some(sub_sys_id.into());
                self
            }
            pub fn revision(mut self, revision: impl Into<f64>) -> Self {
                self.revision = Some(revision.into());
                self
            }
            pub fn vendor_string(mut self, vendor_string: impl Into<String>) -> Self {
                self.vendor_string = Some(vendor_string.into());
                self
            }
            pub fn device_string(mut self, device_string: impl Into<String>) -> Self {
                self.device_string = Some(device_string.into());
                self
            }
            pub fn driver_vendor(mut self, driver_vendor: impl Into<String>) -> Self {
                self.driver_vendor = Some(driver_vendor.into());
                self
            }
            pub fn driver_version(mut self, driver_version: impl Into<String>) -> Self {
                self.driver_version = Some(driver_version.into());
                self
            }
            pub fn build(self) -> Result<GpuDevice, String> {
                Ok(GpuDevice {
                    vendor_id: self.vendor_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(vendor_id))
                    })?,
                    device_id: self.device_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(device_id))
                    })?,
                    sub_sys_id: self.sub_sys_id,
                    revision: self.revision,
                    vendor_string: self.vendor_string.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(vendor_string))
                    })?,
                    device_string: self.device_string.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(device_string))
                    })?,
                    driver_vendor: self.driver_vendor.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(driver_vendor))
                    })?,
                    driver_version: self.driver_version.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(driver_version))
                    })?,
                })
            }
        }
        impl GpuDevice {
            pub const IDENTIFIER: &'static str = "SystemInfo.GPUDevice";
        }
        #[doc = "Describes the width and height dimensions of an entity.\n[Size](https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#type-Size)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Size {
            #[doc = "Width in pixels."]
            #[serde(rename = "width")]
            pub width: i64,
            #[doc = "Height in pixels."]
            #[serde(rename = "height")]
            pub height: i64,
        }
        impl Size {
            pub fn new(width: impl Into<i64>, height: impl Into<i64>) -> Self {
                Self {
                    width: width.into(),
                    height: height.into(),
                }
            }
        }
        impl Size {
            pub fn builder() -> SizeBuilder {
                SizeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SizeBuilder {
            width: Option<i64>,
            height: Option<i64>,
        }
        impl SizeBuilder {
            pub fn width(mut self, width: impl Into<i64>) -> Self {
                self.width = Some(width.into());
                self
            }
            pub fn height(mut self, height: impl Into<i64>) -> Self {
                self.height = Some(height.into());
                self
            }
            pub fn build(self) -> Result<Size, String> {
                Ok(Size {
                    width: self.width.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(width))
                    })?,
                    height: self.height.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(height))
                    })?,
                })
            }
        }
        impl Size {
            pub const IDENTIFIER: &'static str = "SystemInfo.Size";
        }
        #[doc = "Describes a supported video decoding profile with its associated minimum and\nmaximum resolutions.\n[VideoDecodeAcceleratorCapability](https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#type-VideoDecodeAcceleratorCapability)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct VideoDecodeAcceleratorCapability {
            #[doc = "Video codec profile that is supported, e.g. VP9 Profile 2."]
            #[serde(rename = "profile")]
            pub profile: String,
            #[doc = "Maximum video dimensions in pixels supported for this |profile|."]
            #[serde(rename = "maxResolution")]
            pub max_resolution: Size,
            #[doc = "Minimum video dimensions in pixels supported for this |profile|."]
            #[serde(rename = "minResolution")]
            pub min_resolution: Size,
        }
        impl VideoDecodeAcceleratorCapability {
            pub fn new(
                profile: impl Into<String>,
                max_resolution: impl Into<Size>,
                min_resolution: impl Into<Size>,
            ) -> Self {
                Self {
                    profile: profile.into(),
                    max_resolution: max_resolution.into(),
                    min_resolution: min_resolution.into(),
                }
            }
        }
        impl VideoDecodeAcceleratorCapability {
            pub fn builder() -> VideoDecodeAcceleratorCapabilityBuilder {
                VideoDecodeAcceleratorCapabilityBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct VideoDecodeAcceleratorCapabilityBuilder {
            profile: Option<String>,
            max_resolution: Option<Size>,
            min_resolution: Option<Size>,
        }
        impl VideoDecodeAcceleratorCapabilityBuilder {
            pub fn profile(mut self, profile: impl Into<String>) -> Self {
                self.profile = Some(profile.into());
                self
            }
            pub fn max_resolution(mut self, max_resolution: impl Into<Size>) -> Self {
                self.max_resolution = Some(max_resolution.into());
                self
            }
            pub fn min_resolution(mut self, min_resolution: impl Into<Size>) -> Self {
                self.min_resolution = Some(min_resolution.into());
                self
            }
            pub fn build(self) -> Result<VideoDecodeAcceleratorCapability, String> {
                Ok(VideoDecodeAcceleratorCapability {
                    profile: self.profile.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(profile))
                    })?,
                    max_resolution: self.max_resolution.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(max_resolution))
                    })?,
                    min_resolution: self.min_resolution.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(min_resolution))
                    })?,
                })
            }
        }
        impl VideoDecodeAcceleratorCapability {
            pub const IDENTIFIER: &'static str = "SystemInfo.VideoDecodeAcceleratorCapability";
        }
        #[doc = "Describes a supported video encoding profile with its associated maximum\nresolution and maximum framerate.\n[VideoEncodeAcceleratorCapability](https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#type-VideoEncodeAcceleratorCapability)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct VideoEncodeAcceleratorCapability {
            #[doc = "Video codec profile that is supported, e.g H264 Main."]
            #[serde(rename = "profile")]
            pub profile: String,
            #[doc = "Maximum video dimensions in pixels supported for this |profile|."]
            #[serde(rename = "maxResolution")]
            pub max_resolution: Size,
            #[doc = "Maximum encoding framerate in frames per second supported for this\n|profile|, as fraction's numerator and denominator, e.g. 24/1 fps,\n24000/1001 fps, etc."]
            #[serde(rename = "maxFramerateNumerator")]
            pub max_framerate_numerator: i64,
            #[serde(rename = "maxFramerateDenominator")]
            pub max_framerate_denominator: i64,
        }
        impl VideoEncodeAcceleratorCapability {
            pub fn new(
                profile: impl Into<String>,
                max_resolution: impl Into<Size>,
                max_framerate_numerator: impl Into<i64>,
                max_framerate_denominator: impl Into<i64>,
            ) -> Self {
                Self {
                    profile: profile.into(),
                    max_resolution: max_resolution.into(),
                    max_framerate_numerator: max_framerate_numerator.into(),
                    max_framerate_denominator: max_framerate_denominator.into(),
                }
            }
        }
        impl VideoEncodeAcceleratorCapability {
            pub fn builder() -> VideoEncodeAcceleratorCapabilityBuilder {
                VideoEncodeAcceleratorCapabilityBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct VideoEncodeAcceleratorCapabilityBuilder {
            profile: Option<String>,
            max_resolution: Option<Size>,
            max_framerate_numerator: Option<i64>,
            max_framerate_denominator: Option<i64>,
        }
        impl VideoEncodeAcceleratorCapabilityBuilder {
            pub fn profile(mut self, profile: impl Into<String>) -> Self {
                self.profile = Some(profile.into());
                self
            }
            pub fn max_resolution(mut self, max_resolution: impl Into<Size>) -> Self {
                self.max_resolution = Some(max_resolution.into());
                self
            }
            pub fn max_framerate_numerator(
                mut self,
                max_framerate_numerator: impl Into<i64>,
            ) -> Self {
                self.max_framerate_numerator = Some(max_framerate_numerator.into());
                self
            }
            pub fn max_framerate_denominator(
                mut self,
                max_framerate_denominator: impl Into<i64>,
            ) -> Self {
                self.max_framerate_denominator = Some(max_framerate_denominator.into());
                self
            }
            pub fn build(self) -> Result<VideoEncodeAcceleratorCapability, String> {
                Ok(VideoEncodeAcceleratorCapability {
                    profile: self.profile.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(profile))
                    })?,
                    max_resolution: self.max_resolution.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(max_resolution))
                    })?,
                    max_framerate_numerator: self.max_framerate_numerator.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(max_framerate_numerator)
                        )
                    })?,
                    max_framerate_denominator: self.max_framerate_denominator.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(max_framerate_denominator)
                        )
                    })?,
                })
            }
        }
        impl VideoEncodeAcceleratorCapability {
            pub const IDENTIFIER: &'static str = "SystemInfo.VideoEncodeAcceleratorCapability";
        }
        #[doc = "YUV subsampling type of the pixels of a given image."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SubsamplingFormat {
            #[serde(rename = "yuv420")]
            Yuv420,
            #[serde(rename = "yuv422")]
            Yuv422,
            #[serde(rename = "yuv444")]
            Yuv444,
        }
        impl AsRef<str> for SubsamplingFormat {
            fn as_ref(&self) -> &str {
                match self {
                    SubsamplingFormat::Yuv420 => "yuv420",
                    SubsamplingFormat::Yuv422 => "yuv422",
                    SubsamplingFormat::Yuv444 => "yuv444",
                }
            }
        }
        impl ::std::str::FromStr for SubsamplingFormat {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "yuv420" | "Yuv420" => Ok(SubsamplingFormat::Yuv420),
                    "yuv422" | "Yuv422" => Ok(SubsamplingFormat::Yuv422),
                    "yuv444" | "Yuv444" => Ok(SubsamplingFormat::Yuv444),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Image format of a given image."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ImageType {
            #[serde(rename = "jpeg")]
            Jpeg,
            #[serde(rename = "webp")]
            Webp,
            #[serde(rename = "unknown")]
            Unknown,
        }
        impl AsRef<str> for ImageType {
            fn as_ref(&self) -> &str {
                match self {
                    ImageType::Jpeg => "jpeg",
                    ImageType::Webp => "webp",
                    ImageType::Unknown => "unknown",
                }
            }
        }
        impl ::std::str::FromStr for ImageType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "jpeg" | "Jpeg" => Ok(ImageType::Jpeg),
                    "webp" | "Webp" => Ok(ImageType::Webp),
                    "unknown" | "Unknown" => Ok(ImageType::Unknown),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Describes a supported image decoding profile with its associated minimum and\nmaximum resolutions and subsampling.\n[ImageDecodeAcceleratorCapability](https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#type-ImageDecodeAcceleratorCapability)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ImageDecodeAcceleratorCapability {
            #[doc = "Image coded, e.g. Jpeg."]
            #[serde(rename = "imageType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub image_type: ImageType,
            #[doc = "Maximum supported dimensions of the image in pixels."]
            #[serde(rename = "maxDimensions")]
            pub max_dimensions: Size,
            #[doc = "Minimum supported dimensions of the image in pixels."]
            #[serde(rename = "minDimensions")]
            pub min_dimensions: Size,
            #[doc = "Optional array of supported subsampling formats, e.g. 4:2:0, if known."]
            #[serde(rename = "subsamplings")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub subsamplings: Vec<SubsamplingFormat>,
        }
        impl ImageDecodeAcceleratorCapability {
            pub fn new(
                image_type: impl Into<ImageType>,
                max_dimensions: impl Into<Size>,
                min_dimensions: impl Into<Size>,
                subsamplings: Vec<SubsamplingFormat>,
            ) -> Self {
                Self {
                    image_type: image_type.into(),
                    max_dimensions: max_dimensions.into(),
                    min_dimensions: min_dimensions.into(),
                    subsamplings,
                }
            }
        }
        impl ImageDecodeAcceleratorCapability {
            pub fn builder() -> ImageDecodeAcceleratorCapabilityBuilder {
                ImageDecodeAcceleratorCapabilityBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ImageDecodeAcceleratorCapabilityBuilder {
            image_type: Option<ImageType>,
            max_dimensions: Option<Size>,
            min_dimensions: Option<Size>,
            subsamplings: Option<Vec<SubsamplingFormat>>,
        }
        impl ImageDecodeAcceleratorCapabilityBuilder {
            pub fn image_type(mut self, image_type: impl Into<ImageType>) -> Self {
                self.image_type = Some(image_type.into());
                self
            }
            pub fn max_dimensions(mut self, max_dimensions: impl Into<Size>) -> Self {
                self.max_dimensions = Some(max_dimensions.into());
                self
            }
            pub fn min_dimensions(mut self, min_dimensions: impl Into<Size>) -> Self {
                self.min_dimensions = Some(min_dimensions.into());
                self
            }
            pub fn subsampling(mut self, subsampling: impl Into<SubsamplingFormat>) -> Self {
                let v = self.subsamplings.get_or_insert(Vec::new());
                v.push(subsampling.into());
                self
            }
            pub fn subsamplings<I, S>(mut self, subsamplings: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<SubsamplingFormat>,
            {
                let v = self.subsamplings.get_or_insert(Vec::new());
                for val in subsamplings {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<ImageDecodeAcceleratorCapability, String> {
                Ok(ImageDecodeAcceleratorCapability {
                    image_type: self.image_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(image_type))
                    })?,
                    max_dimensions: self.max_dimensions.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(max_dimensions))
                    })?,
                    min_dimensions: self.min_dimensions.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(min_dimensions))
                    })?,
                    subsamplings: self.subsamplings.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(subsamplings))
                    })?,
                })
            }
        }
        impl ImageDecodeAcceleratorCapability {
            pub const IDENTIFIER: &'static str = "SystemInfo.ImageDecodeAcceleratorCapability";
        }
        #[doc = "Provides information about the GPU(s) on the system.\n[GPUInfo](https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#type-GPUInfo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GpuInfo {
            #[doc = "The graphics devices on the system. Element 0 is the primary GPU."]
            #[serde(rename = "devices")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub devices: Vec<GpuDevice>,
            #[doc = "An optional dictionary of additional GPU related attributes."]
            #[serde(rename = "auxAttributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub aux_attributes: Option<serde_json::Value>,
            #[doc = "An optional dictionary of graphics features and their status."]
            #[serde(rename = "featureStatus")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub feature_status: Option<serde_json::Value>,
            #[doc = "An optional array of GPU driver bug workarounds."]
            #[serde(rename = "driverBugWorkarounds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub driver_bug_workarounds: Vec<String>,
            #[doc = "Supported accelerated video decoding capabilities."]
            #[serde(rename = "videoDecoding")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub video_decoding: Vec<VideoDecodeAcceleratorCapability>,
            #[doc = "Supported accelerated video encoding capabilities."]
            #[serde(rename = "videoEncoding")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub video_encoding: Vec<VideoEncodeAcceleratorCapability>,
            #[doc = "Supported accelerated image decoding capabilities."]
            #[serde(rename = "imageDecoding")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub image_decoding: Vec<ImageDecodeAcceleratorCapability>,
        }
        impl GpuInfo {
            pub fn builder() -> GpuInfoBuilder {
                GpuInfoBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GpuInfoBuilder {
            devices: Option<Vec<GpuDevice>>,
            aux_attributes: Option<serde_json::Value>,
            feature_status: Option<serde_json::Value>,
            driver_bug_workarounds: Option<Vec<String>>,
            video_decoding: Option<Vec<VideoDecodeAcceleratorCapability>>,
            video_encoding: Option<Vec<VideoEncodeAcceleratorCapability>>,
            image_decoding: Option<Vec<ImageDecodeAcceleratorCapability>>,
        }
        impl GpuInfoBuilder {
            pub fn device(mut self, device: impl Into<GpuDevice>) -> Self {
                let v = self.devices.get_or_insert(Vec::new());
                v.push(device.into());
                self
            }
            pub fn devices<I, S>(mut self, devices: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<GpuDevice>,
            {
                let v = self.devices.get_or_insert(Vec::new());
                for val in devices {
                    v.push(val.into());
                }
                self
            }
            pub fn aux_attributes(mut self, aux_attributes: impl Into<serde_json::Value>) -> Self {
                self.aux_attributes = Some(aux_attributes.into());
                self
            }
            pub fn feature_status(mut self, feature_status: impl Into<serde_json::Value>) -> Self {
                self.feature_status = Some(feature_status.into());
                self
            }
            pub fn driver_bug_workaround(
                mut self,
                driver_bug_workaround: impl Into<String>,
            ) -> Self {
                let v = self.driver_bug_workarounds.get_or_insert(Vec::new());
                v.push(driver_bug_workaround.into());
                self
            }
            pub fn driver_bug_workarounds<I, S>(mut self, driver_bug_workarounds: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.driver_bug_workarounds.get_or_insert(Vec::new());
                for val in driver_bug_workarounds {
                    v.push(val.into());
                }
                self
            }
            pub fn video_decoding(
                mut self,
                video_decoding: impl Into<VideoDecodeAcceleratorCapability>,
            ) -> Self {
                let v = self.video_decoding.get_or_insert(Vec::new());
                v.push(video_decoding.into());
                self
            }
            pub fn video_decodings<I, S>(mut self, video_decodings: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<VideoDecodeAcceleratorCapability>,
            {
                let v = self.video_decoding.get_or_insert(Vec::new());
                for val in video_decodings {
                    v.push(val.into());
                }
                self
            }
            pub fn video_encoding(
                mut self,
                video_encoding: impl Into<VideoEncodeAcceleratorCapability>,
            ) -> Self {
                let v = self.video_encoding.get_or_insert(Vec::new());
                v.push(video_encoding.into());
                self
            }
            pub fn video_encodings<I, S>(mut self, video_encodings: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<VideoEncodeAcceleratorCapability>,
            {
                let v = self.video_encoding.get_or_insert(Vec::new());
                for val in video_encodings {
                    v.push(val.into());
                }
                self
            }
            pub fn image_decoding(
                mut self,
                image_decoding: impl Into<ImageDecodeAcceleratorCapability>,
            ) -> Self {
                let v = self.image_decoding.get_or_insert(Vec::new());
                v.push(image_decoding.into());
                self
            }
            pub fn image_decodings<I, S>(mut self, image_decodings: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ImageDecodeAcceleratorCapability>,
            {
                let v = self.image_decoding.get_or_insert(Vec::new());
                for val in image_decodings {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GpuInfo, String> {
                Ok(GpuInfo {
                    devices: self.devices.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(devices))
                    })?,
                    aux_attributes: self.aux_attributes,
                    feature_status: self.feature_status,
                    driver_bug_workarounds: self.driver_bug_workarounds.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(driver_bug_workarounds)
                        )
                    })?,
                    video_decoding: self.video_decoding.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(video_decoding))
                    })?,
                    video_encoding: self.video_encoding.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(video_encoding))
                    })?,
                    image_decoding: self.image_decoding.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(image_decoding))
                    })?,
                })
            }
        }
        impl GpuInfo {
            pub const IDENTIFIER: &'static str = "SystemInfo.GPUInfo";
        }
        #[doc = "Represents process info.\n[ProcessInfo](https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#type-ProcessInfo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ProcessInfo {
            #[doc = "Specifies process type."]
            #[serde(rename = "type")]
            pub r#type: String,
            #[doc = "Specifies process id."]
            #[serde(rename = "id")]
            pub id: i64,
            #[doc = "Specifies cumulative CPU usage in seconds across all threads of the\nprocess since the process start."]
            #[serde(rename = "cpuTime")]
            pub cpu_time: f64,
        }
        impl ProcessInfo {
            pub fn new(
                r#type: impl Into<String>,
                id: impl Into<i64>,
                cpu_time: impl Into<f64>,
            ) -> Self {
                Self {
                    r#type: r#type.into(),
                    id: id.into(),
                    cpu_time: cpu_time.into(),
                }
            }
        }
        impl ProcessInfo {
            pub fn builder() -> ProcessInfoBuilder {
                ProcessInfoBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ProcessInfoBuilder {
            r#type: Option<String>,
            id: Option<i64>,
            cpu_time: Option<f64>,
        }
        impl ProcessInfoBuilder {
            pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn id(mut self, id: impl Into<i64>) -> Self {
                self.id = Some(id.into());
                self
            }
            pub fn cpu_time(mut self, cpu_time: impl Into<f64>) -> Self {
                self.cpu_time = Some(cpu_time.into());
                self
            }
            pub fn build(self) -> Result<ProcessInfo, String> {
                Ok(ProcessInfo {
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    id: self
                        .id
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(id)))?,
                    cpu_time: self.cpu_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cpu_time))
                    })?,
                })
            }
        }
        impl ProcessInfo {
            pub const IDENTIFIER: &'static str = "SystemInfo.ProcessInfo";
        }
        #[doc = "Returns information about the system.\n[getInfo](https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#method-getInfo)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetInfoParams {}
        impl GetInfoParams {
            pub const IDENTIFIER: &'static str = "SystemInfo.getInfo";
        }
        impl chromiumoxide_types::Method for GetInfoParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetInfoParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns information about the system.\n[getInfo](https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#method-getInfo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetInfoReturns {
            #[doc = "Information about the GPUs on the system."]
            #[serde(rename = "gpu")]
            pub gpu: GpuInfo,
            #[doc = "A platform-dependent description of the model of the machine. On Mac OS, this is, for\nexample, 'MacBookPro'. Will be the empty string if not supported."]
            #[serde(rename = "modelName")]
            pub model_name: String,
            #[doc = "A platform-dependent description of the version of the machine. On Mac OS, this is, for\nexample, '10.1'. Will be the empty string if not supported."]
            #[serde(rename = "modelVersion")]
            pub model_version: String,
            #[doc = "The command line string used to launch the browser. Will be the empty string if not\nsupported."]
            #[serde(rename = "commandLine")]
            pub command_line: String,
        }
        impl GetInfoReturns {
            pub fn new(
                gpu: impl Into<GpuInfo>,
                model_name: impl Into<String>,
                model_version: impl Into<String>,
                command_line: impl Into<String>,
            ) -> Self {
                Self {
                    gpu: gpu.into(),
                    model_name: model_name.into(),
                    model_version: model_version.into(),
                    command_line: command_line.into(),
                }
            }
        }
        impl GetInfoReturns {
            pub fn builder() -> GetInfoReturnsBuilder {
                GetInfoReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetInfoReturnsBuilder {
            gpu: Option<GpuInfo>,
            model_name: Option<String>,
            model_version: Option<String>,
            command_line: Option<String>,
        }
        impl GetInfoReturnsBuilder {
            pub fn gpu(mut self, gpu: impl Into<GpuInfo>) -> Self {
                self.gpu = Some(gpu.into());
                self
            }
            pub fn model_name(mut self, model_name: impl Into<String>) -> Self {
                self.model_name = Some(model_name.into());
                self
            }
            pub fn model_version(mut self, model_version: impl Into<String>) -> Self {
                self.model_version = Some(model_version.into());
                self
            }
            pub fn command_line(mut self, command_line: impl Into<String>) -> Self {
                self.command_line = Some(command_line.into());
                self
            }
            pub fn build(self) -> Result<GetInfoReturns, String> {
                Ok(GetInfoReturns {
                    gpu: self
                        .gpu
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(gpu)))?,
                    model_name: self.model_name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(model_name))
                    })?,
                    model_version: self.model_version.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(model_version))
                    })?,
                    command_line: self.command_line.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(command_line))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetInfoParams {
            type Response = GetInfoReturns;
        }
        #[doc = "Returns information about all running processes.\n[getProcessInfo](https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#method-getProcessInfo)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetProcessInfoParams {}
        impl GetProcessInfoParams {
            pub const IDENTIFIER: &'static str = "SystemInfo.getProcessInfo";
        }
        impl chromiumoxide_types::Method for GetProcessInfoParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetProcessInfoParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns information about all running processes.\n[getProcessInfo](https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#method-getProcessInfo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetProcessInfoReturns {
            #[doc = "An array of process info blocks."]
            #[serde(rename = "processInfo")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub process_info: Vec<ProcessInfo>,
        }
        impl GetProcessInfoReturns {
            pub fn new(process_info: Vec<ProcessInfo>) -> Self {
                Self { process_info }
            }
        }
        impl GetProcessInfoReturns {
            pub fn builder() -> GetProcessInfoReturnsBuilder {
                GetProcessInfoReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetProcessInfoReturnsBuilder {
            process_info: Option<Vec<ProcessInfo>>,
        }
        impl GetProcessInfoReturnsBuilder {
            pub fn process_info(mut self, process_info: impl Into<ProcessInfo>) -> Self {
                let v = self.process_info.get_or_insert(Vec::new());
                v.push(process_info.into());
                self
            }
            pub fn process_infos<I, S>(mut self, process_infos: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<ProcessInfo>,
            {
                let v = self.process_info.get_or_insert(Vec::new());
                for val in process_infos {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetProcessInfoReturns, String> {
                Ok(GetProcessInfoReturns {
                    process_info: self.process_info.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(process_info))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetProcessInfoParams {
            type Response = GetProcessInfoReturns;
        }
    }
    #[doc = "Supports additional targets discovery and allows to attach to them."]
    pub mod target {
        use serde::{Deserialize, Serialize};
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct TargetId(String);
        impl TargetId {
            pub fn new(val: impl Into<String>) -> Self {
                TargetId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for TargetId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<TargetId> for String {
            fn from(el: TargetId) -> String {
                el.0
            }
        }
        impl From<String> for TargetId {
            fn from(expr: String) -> Self {
                TargetId(expr)
            }
        }
        impl std::borrow::Borrow<str> for TargetId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl TargetId {
            pub const IDENTIFIER: &'static str = "Target.TargetID";
        }
        #[doc = "Unique identifier of attached debugging session.\n[SessionID](https://chromedevtools.github.io/devtools-protocol/tot/Target/#type-SessionID)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct SessionId(String);
        impl SessionId {
            pub fn new(val: impl Into<String>) -> Self {
                SessionId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for SessionId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<SessionId> for String {
            fn from(el: SessionId) -> String {
                el.0
            }
        }
        impl From<String> for SessionId {
            fn from(expr: String) -> Self {
                SessionId(expr)
            }
        }
        impl std::borrow::Borrow<str> for SessionId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl SessionId {
            pub const IDENTIFIER: &'static str = "Target.SessionID";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TargetInfo {
            #[serde(rename = "targetId")]
            pub target_id: TargetId,
            #[serde(rename = "type")]
            pub r#type: String,
            #[serde(rename = "title")]
            pub title: String,
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Whether the target has an attached client."]
            #[serde(rename = "attached")]
            pub attached: bool,
            #[doc = "Opener target Id"]
            #[serde(rename = "openerId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub opener_id: Option<TargetId>,
            #[doc = "Whether the target has access to the originating window."]
            #[serde(rename = "canAccessOpener")]
            pub can_access_opener: bool,
            #[doc = "Frame id of originating window (is only set if target has an opener)."]
            #[serde(rename = "openerFrameId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub opener_frame_id: Option<super::page::FrameId>,
            #[serde(rename = "browserContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub browser_context_id: Option<super::browser::BrowserContextId>,
        }
        impl TargetInfo {
            pub fn builder() -> TargetInfoBuilder {
                TargetInfoBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TargetInfoBuilder {
            target_id: Option<TargetId>,
            r#type: Option<String>,
            title: Option<String>,
            url: Option<String>,
            attached: Option<bool>,
            opener_id: Option<TargetId>,
            can_access_opener: Option<bool>,
            opener_frame_id: Option<super::page::FrameId>,
            browser_context_id: Option<super::browser::BrowserContextId>,
        }
        impl TargetInfoBuilder {
            pub fn target_id(mut self, target_id: impl Into<TargetId>) -> Self {
                self.target_id = Some(target_id.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn title(mut self, title: impl Into<String>) -> Self {
                self.title = Some(title.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn attached(mut self, attached: impl Into<bool>) -> Self {
                self.attached = Some(attached.into());
                self
            }
            pub fn opener_id(mut self, opener_id: impl Into<TargetId>) -> Self {
                self.opener_id = Some(opener_id.into());
                self
            }
            pub fn can_access_opener(mut self, can_access_opener: impl Into<bool>) -> Self {
                self.can_access_opener = Some(can_access_opener.into());
                self
            }
            pub fn opener_frame_id(
                mut self,
                opener_frame_id: impl Into<super::page::FrameId>,
            ) -> Self {
                self.opener_frame_id = Some(opener_frame_id.into());
                self
            }
            pub fn browser_context_id(
                mut self,
                browser_context_id: impl Into<super::browser::BrowserContextId>,
            ) -> Self {
                self.browser_context_id = Some(browser_context_id.into());
                self
            }
            pub fn build(self) -> Result<TargetInfo, String> {
                Ok(TargetInfo {
                    target_id: self.target_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(target_id))
                    })?,
                    r#type: self.r#type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(r#type))
                    })?,
                    title: self.title.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(title))
                    })?,
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    attached: self.attached.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(attached))
                    })?,
                    opener_id: self.opener_id,
                    can_access_opener: self.can_access_opener.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(can_access_opener)
                        )
                    })?,
                    opener_frame_id: self.opener_frame_id,
                    browser_context_id: self.browser_context_id,
                })
            }
        }
        impl TargetInfo {
            pub const IDENTIFIER: &'static str = "Target.TargetInfo";
        }
        #[doc = "A filter used by target query/discovery/auto-attach operations.\n[FilterEntry](https://chromedevtools.github.io/devtools-protocol/tot/Target/#type-FilterEntry)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct FilterEntry {
            #[doc = "If set, causes exclusion of mathcing targets from the list."]
            #[serde(rename = "exclude")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub exclude: Option<bool>,
            #[doc = "If not present, matches any type."]
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub r#type: Option<String>,
        }
        impl FilterEntry {
            pub fn builder() -> FilterEntryBuilder {
                FilterEntryBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FilterEntryBuilder {
            exclude: Option<bool>,
            r#type: Option<String>,
        }
        impl FilterEntryBuilder {
            pub fn exclude(mut self, exclude: impl Into<bool>) -> Self {
                self.exclude = Some(exclude.into());
                self
            }
            pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
                self.r#type = Some(r#type.into());
                self
            }
            pub fn build(self) -> FilterEntry {
                FilterEntry {
                    exclude: self.exclude,
                    r#type: self.r#type,
                }
            }
        }
        impl FilterEntry {
            pub const IDENTIFIER: &'static str = "Target.FilterEntry";
        }
        #[doc = "The entries in TargetFilter are matched sequentially against targets and\nthe first entry that matches determines if the target is included or not,\ndepending on the value of `exclude` field in the entry.\nIf filter is not specified, the one assumed is\n[{type: \"browser\", exclude: true}, {type: \"tab\", exclude: true}, {}]\n(i.e. include everything but `browser` and `tab`).\n[TargetFilter](https://chromedevtools.github.io/devtools-protocol/tot/Target/#type-TargetFilter)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TargetFilter(Vec<FilterEntry>);
        impl TargetFilter {
            pub fn new(val: impl Into<Vec<FilterEntry>>) -> Self {
                TargetFilter(val.into())
            }
            pub fn inner(&self) -> &Vec<FilterEntry> {
                &self.0
            }
        }
        impl TargetFilter {
            pub const IDENTIFIER: &'static str = "Target.TargetFilter";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoteLocation {
            #[serde(rename = "host")]
            pub host: String,
            #[serde(rename = "port")]
            pub port: i64,
        }
        impl RemoteLocation {
            pub fn new(host: impl Into<String>, port: impl Into<i64>) -> Self {
                Self {
                    host: host.into(),
                    port: port.into(),
                }
            }
        }
        impl RemoteLocation {
            pub fn builder() -> RemoteLocationBuilder {
                RemoteLocationBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoteLocationBuilder {
            host: Option<String>,
            port: Option<i64>,
        }
        impl RemoteLocationBuilder {
            pub fn host(mut self, host: impl Into<String>) -> Self {
                self.host = Some(host.into());
                self
            }
            pub fn port(mut self, port: impl Into<i64>) -> Self {
                self.port = Some(port.into());
                self
            }
            pub fn build(self) -> Result<RemoteLocation, String> {
                Ok(RemoteLocation {
                    host: self.host.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(host))
                    })?,
                    port: self.port.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(port))
                    })?,
                })
            }
        }
        impl RemoteLocation {
            pub const IDENTIFIER: &'static str = "Target.RemoteLocation";
        }
        #[doc = "Activates (focuses) the target.\n[activateTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-activateTarget)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ActivateTargetParams {
            #[serde(rename = "targetId")]
            pub target_id: TargetId,
        }
        impl ActivateTargetParams {
            pub fn new(target_id: impl Into<TargetId>) -> Self {
                Self {
                    target_id: target_id.into(),
                }
            }
        }
        impl ActivateTargetParams {
            pub fn builder() -> ActivateTargetParamsBuilder {
                ActivateTargetParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ActivateTargetParamsBuilder {
            target_id: Option<TargetId>,
        }
        impl ActivateTargetParamsBuilder {
            pub fn target_id(mut self, target_id: impl Into<TargetId>) -> Self {
                self.target_id = Some(target_id.into());
                self
            }
            pub fn build(self) -> Result<ActivateTargetParams, String> {
                Ok(ActivateTargetParams {
                    target_id: self.target_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(target_id))
                    })?,
                })
            }
        }
        impl ActivateTargetParams {
            pub const IDENTIFIER: &'static str = "Target.activateTarget";
        }
        impl chromiumoxide_types::Method for ActivateTargetParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ActivateTargetParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Activates (focuses) the target.\n[activateTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-activateTarget)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ActivateTargetReturns {}
        impl chromiumoxide_types::Command for ActivateTargetParams {
            type Response = ActivateTargetReturns;
        }
        #[doc = "Attaches to the target with given id.\n[attachToTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-attachToTarget)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AttachToTargetParams {
            #[serde(rename = "targetId")]
            pub target_id: TargetId,
            #[doc = "Enables \"flat\" access to the session via specifying sessionId attribute in the commands.\nWe plan to make this the default, deprecate non-flattened mode,\nand eventually retire it. See crbug.com/991325."]
            #[serde(rename = "flatten")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub flatten: Option<bool>,
        }
        impl AttachToTargetParams {
            pub fn new(target_id: impl Into<TargetId>) -> Self {
                Self {
                    target_id: target_id.into(),
                    flatten: None,
                }
            }
        }
        impl AttachToTargetParams {
            pub fn builder() -> AttachToTargetParamsBuilder {
                AttachToTargetParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AttachToTargetParamsBuilder {
            target_id: Option<TargetId>,
            flatten: Option<bool>,
        }
        impl AttachToTargetParamsBuilder {
            pub fn target_id(mut self, target_id: impl Into<TargetId>) -> Self {
                self.target_id = Some(target_id.into());
                self
            }
            pub fn flatten(mut self, flatten: impl Into<bool>) -> Self {
                self.flatten = Some(flatten.into());
                self
            }
            pub fn build(self) -> Result<AttachToTargetParams, String> {
                Ok(AttachToTargetParams {
                    target_id: self.target_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(target_id))
                    })?,
                    flatten: self.flatten,
                })
            }
        }
        impl AttachToTargetParams {
            pub const IDENTIFIER: &'static str = "Target.attachToTarget";
        }
        impl chromiumoxide_types::Method for AttachToTargetParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for AttachToTargetParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Attaches to the target with given id.\n[attachToTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-attachToTarget)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AttachToTargetReturns {
            #[doc = "Id assigned to the session."]
            #[serde(rename = "sessionId")]
            pub session_id: SessionId,
        }
        impl AttachToTargetReturns {
            pub fn new(session_id: impl Into<SessionId>) -> Self {
                Self {
                    session_id: session_id.into(),
                }
            }
        }
        impl AttachToTargetReturns {
            pub fn builder() -> AttachToTargetReturnsBuilder {
                AttachToTargetReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AttachToTargetReturnsBuilder {
            session_id: Option<SessionId>,
        }
        impl AttachToTargetReturnsBuilder {
            pub fn session_id(mut self, session_id: impl Into<SessionId>) -> Self {
                self.session_id = Some(session_id.into());
                self
            }
            pub fn build(self) -> Result<AttachToTargetReturns, String> {
                Ok(AttachToTargetReturns {
                    session_id: self.session_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(session_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for AttachToTargetParams {
            type Response = AttachToTargetReturns;
        }
        #[doc = "Attaches to the browser target, only uses flat sessionId mode.\n[attachToBrowserTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-attachToBrowserTarget)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct AttachToBrowserTargetParams {}
        impl AttachToBrowserTargetParams {
            pub const IDENTIFIER: &'static str = "Target.attachToBrowserTarget";
        }
        impl chromiumoxide_types::Method for AttachToBrowserTargetParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for AttachToBrowserTargetParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Attaches to the browser target, only uses flat sessionId mode.\n[attachToBrowserTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-attachToBrowserTarget)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AttachToBrowserTargetReturns {
            #[doc = "Id assigned to the session."]
            #[serde(rename = "sessionId")]
            pub session_id: SessionId,
        }
        impl AttachToBrowserTargetReturns {
            pub fn new(session_id: impl Into<SessionId>) -> Self {
                Self {
                    session_id: session_id.into(),
                }
            }
        }
        impl AttachToBrowserTargetReturns {
            pub fn builder() -> AttachToBrowserTargetReturnsBuilder {
                AttachToBrowserTargetReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AttachToBrowserTargetReturnsBuilder {
            session_id: Option<SessionId>,
        }
        impl AttachToBrowserTargetReturnsBuilder {
            pub fn session_id(mut self, session_id: impl Into<SessionId>) -> Self {
                self.session_id = Some(session_id.into());
                self
            }
            pub fn build(self) -> Result<AttachToBrowserTargetReturns, String> {
                Ok(AttachToBrowserTargetReturns {
                    session_id: self.session_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(session_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for AttachToBrowserTargetParams {
            type Response = AttachToBrowserTargetReturns;
        }
        #[doc = "Closes the target. If the target is a page that gets closed too.\n[closeTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-closeTarget)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CloseTargetParams {
            #[serde(rename = "targetId")]
            pub target_id: TargetId,
        }
        impl CloseTargetParams {
            pub fn new(target_id: impl Into<TargetId>) -> Self {
                Self {
                    target_id: target_id.into(),
                }
            }
        }
        impl CloseTargetParams {
            pub fn builder() -> CloseTargetParamsBuilder {
                CloseTargetParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CloseTargetParamsBuilder {
            target_id: Option<TargetId>,
        }
        impl CloseTargetParamsBuilder {
            pub fn target_id(mut self, target_id: impl Into<TargetId>) -> Self {
                self.target_id = Some(target_id.into());
                self
            }
            pub fn build(self) -> Result<CloseTargetParams, String> {
                Ok(CloseTargetParams {
                    target_id: self.target_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(target_id))
                    })?,
                })
            }
        }
        impl CloseTargetParams {
            pub const IDENTIFIER: &'static str = "Target.closeTarget";
        }
        impl chromiumoxide_types::Method for CloseTargetParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CloseTargetParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Closes the target. If the target is a page that gets closed too.\n[closeTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-closeTarget)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CloseTargetReturns {}
        impl chromiumoxide_types::Command for CloseTargetParams {
            type Response = CloseTargetReturns;
        }
        #[doc = "Inject object to the target's main frame that provides a communication\nchannel with browser target.\n\nInjected object will be available as `window[bindingName]`.\n\nThe object has the follwing API:\n- `binding.send(json)` - a method to send messages over the remote debugging protocol\n- `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.\n[exposeDevToolsProtocol](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-exposeDevToolsProtocol)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ExposeDevToolsProtocolParams {
            #[serde(rename = "targetId")]
            pub target_id: TargetId,
            #[doc = "Binding name, 'cdp' if not specified."]
            #[serde(rename = "bindingName")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub binding_name: Option<String>,
        }
        impl ExposeDevToolsProtocolParams {
            pub fn new(target_id: impl Into<TargetId>) -> Self {
                Self {
                    target_id: target_id.into(),
                    binding_name: None,
                }
            }
        }
        impl ExposeDevToolsProtocolParams {
            pub fn builder() -> ExposeDevToolsProtocolParamsBuilder {
                ExposeDevToolsProtocolParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ExposeDevToolsProtocolParamsBuilder {
            target_id: Option<TargetId>,
            binding_name: Option<String>,
        }
        impl ExposeDevToolsProtocolParamsBuilder {
            pub fn target_id(mut self, target_id: impl Into<TargetId>) -> Self {
                self.target_id = Some(target_id.into());
                self
            }
            pub fn binding_name(mut self, binding_name: impl Into<String>) -> Self {
                self.binding_name = Some(binding_name.into());
                self
            }
            pub fn build(self) -> Result<ExposeDevToolsProtocolParams, String> {
                Ok(ExposeDevToolsProtocolParams {
                    target_id: self.target_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(target_id))
                    })?,
                    binding_name: self.binding_name,
                })
            }
        }
        impl ExposeDevToolsProtocolParams {
            pub const IDENTIFIER: &'static str = "Target.exposeDevToolsProtocol";
        }
        impl chromiumoxide_types::Method for ExposeDevToolsProtocolParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ExposeDevToolsProtocolParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Inject object to the target's main frame that provides a communication\nchannel with browser target.\n\nInjected object will be available as `window[bindingName]`.\n\nThe object has the follwing API:\n- `binding.send(json)` - a method to send messages over the remote debugging protocol\n- `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.\n[exposeDevToolsProtocol](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-exposeDevToolsProtocol)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ExposeDevToolsProtocolReturns {}
        impl chromiumoxide_types::Command for ExposeDevToolsProtocolParams {
            type Response = ExposeDevToolsProtocolReturns;
        }
        #[doc = "Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than\none.\n[createBrowserContext](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-createBrowserContext)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct CreateBrowserContextParams {
            #[doc = "If specified, disposes this context when debugging session disconnects."]
            #[serde(rename = "disposeOnDetach")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub dispose_on_detach: Option<bool>,
            #[doc = "Proxy server, similar to the one passed to --proxy-server"]
            #[serde(rename = "proxyServer")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub proxy_server: Option<String>,
            #[doc = "Proxy bypass list, similar to the one passed to --proxy-bypass-list"]
            #[serde(rename = "proxyBypassList")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub proxy_bypass_list: Option<String>,
            #[doc = "An optional list of origins to grant unlimited cross-origin access to.\nParts of the URL other than those constituting origin are ignored."]
            #[serde(rename = "originsWithUniversalNetworkAccess")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub origins_with_universal_network_access: Option<Vec<String>>,
        }
        impl CreateBrowserContextParams {
            pub fn builder() -> CreateBrowserContextParamsBuilder {
                CreateBrowserContextParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CreateBrowserContextParamsBuilder {
            dispose_on_detach: Option<bool>,
            proxy_server: Option<String>,
            proxy_bypass_list: Option<String>,
            origins_with_universal_network_access: Option<Vec<String>>,
        }
        impl CreateBrowserContextParamsBuilder {
            pub fn dispose_on_detach(mut self, dispose_on_detach: impl Into<bool>) -> Self {
                self.dispose_on_detach = Some(dispose_on_detach.into());
                self
            }
            pub fn proxy_server(mut self, proxy_server: impl Into<String>) -> Self {
                self.proxy_server = Some(proxy_server.into());
                self
            }
            pub fn proxy_bypass_list(mut self, proxy_bypass_list: impl Into<String>) -> Self {
                self.proxy_bypass_list = Some(proxy_bypass_list.into());
                self
            }
            pub fn origins_with_universal_network_acces(
                mut self,
                origins_with_universal_network_acces: impl Into<String>,
            ) -> Self {
                let v = self
                    .origins_with_universal_network_access
                    .get_or_insert(Vec::new());
                v.push(origins_with_universal_network_acces.into());
                self
            }
            pub fn origins_with_universal_network_access<I, S>(
                mut self,
                origins_with_universal_network_access: I,
            ) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self
                    .origins_with_universal_network_access
                    .get_or_insert(Vec::new());
                for val in origins_with_universal_network_access {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> CreateBrowserContextParams {
                CreateBrowserContextParams {
                    dispose_on_detach: self.dispose_on_detach,
                    proxy_server: self.proxy_server,
                    proxy_bypass_list: self.proxy_bypass_list,
                    origins_with_universal_network_access: self
                        .origins_with_universal_network_access,
                }
            }
        }
        impl CreateBrowserContextParams {
            pub const IDENTIFIER: &'static str = "Target.createBrowserContext";
        }
        impl chromiumoxide_types::Method for CreateBrowserContextParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CreateBrowserContextParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than\none.\n[createBrowserContext](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-createBrowserContext)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CreateBrowserContextReturns {
            #[doc = "The id of the context created."]
            #[serde(rename = "browserContextId")]
            pub browser_context_id: super::browser::BrowserContextId,
        }
        impl CreateBrowserContextReturns {
            pub fn new(browser_context_id: impl Into<super::browser::BrowserContextId>) -> Self {
                Self {
                    browser_context_id: browser_context_id.into(),
                }
            }
        }
        impl CreateBrowserContextReturns {
            pub fn builder() -> CreateBrowserContextReturnsBuilder {
                CreateBrowserContextReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CreateBrowserContextReturnsBuilder {
            browser_context_id: Option<super::browser::BrowserContextId>,
        }
        impl CreateBrowserContextReturnsBuilder {
            pub fn browser_context_id(
                mut self,
                browser_context_id: impl Into<super::browser::BrowserContextId>,
            ) -> Self {
                self.browser_context_id = Some(browser_context_id.into());
                self
            }
            pub fn build(self) -> Result<CreateBrowserContextReturns, String> {
                Ok(CreateBrowserContextReturns {
                    browser_context_id: self.browser_context_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(browser_context_id)
                        )
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for CreateBrowserContextParams {
            type Response = CreateBrowserContextReturns;
        }
        #[doc = "Returns all browser contexts created with `Target.createBrowserContext` method.\n[getBrowserContexts](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-getBrowserContexts)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetBrowserContextsParams {}
        impl GetBrowserContextsParams {
            pub const IDENTIFIER: &'static str = "Target.getBrowserContexts";
        }
        impl chromiumoxide_types::Method for GetBrowserContextsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetBrowserContextsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns all browser contexts created with `Target.createBrowserContext` method.\n[getBrowserContexts](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-getBrowserContexts)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetBrowserContextsReturns {
            #[doc = "An array of browser context ids."]
            #[serde(rename = "browserContextIds")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub browser_context_ids: Vec<super::browser::BrowserContextId>,
        }
        impl GetBrowserContextsReturns {
            pub fn new(browser_context_ids: Vec<super::browser::BrowserContextId>) -> Self {
                Self {
                    browser_context_ids,
                }
            }
        }
        impl GetBrowserContextsReturns {
            pub fn builder() -> GetBrowserContextsReturnsBuilder {
                GetBrowserContextsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetBrowserContextsReturnsBuilder {
            browser_context_ids: Option<Vec<super::browser::BrowserContextId>>,
        }
        impl GetBrowserContextsReturnsBuilder {
            pub fn browser_context_id(
                mut self,
                browser_context_id: impl Into<super::browser::BrowserContextId>,
            ) -> Self {
                let v = self.browser_context_ids.get_or_insert(Vec::new());
                v.push(browser_context_id.into());
                self
            }
            pub fn browser_context_ids<I, S>(mut self, browser_context_ids: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<super::browser::BrowserContextId>,
            {
                let v = self.browser_context_ids.get_or_insert(Vec::new());
                for val in browser_context_ids {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetBrowserContextsReturns, String> {
                Ok(GetBrowserContextsReturns {
                    browser_context_ids: self.browser_context_ids.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(browser_context_ids)
                        )
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetBrowserContextsParams {
            type Response = GetBrowserContextsReturns;
        }
        #[doc = "Creates a new page.\n[createTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-createTarget)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CreateTargetParams {
            #[doc = "The initial URL the page will be navigated to. An empty string indicates about:blank."]
            #[serde(rename = "url")]
            pub url: String,
            #[doc = "Frame width in DIP (headless chrome only)."]
            #[serde(rename = "width")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub width: Option<i64>,
            #[doc = "Frame height in DIP (headless chrome only)."]
            #[serde(rename = "height")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub height: Option<i64>,
            #[doc = "The browser context to create the page in."]
            #[serde(rename = "browserContextId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub browser_context_id: Option<super::browser::BrowserContextId>,
            #[doc = "Whether BeginFrames for this target will be controlled via DevTools (headless chrome only,\nnot supported on MacOS yet, false by default)."]
            #[serde(rename = "enableBeginFrameControl")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub enable_begin_frame_control: Option<bool>,
            #[doc = "Whether to create a new Window or Tab (chrome-only, false by default)."]
            #[serde(rename = "newWindow")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub new_window: Option<bool>,
            #[doc = "Whether to create the target in background or foreground (chrome-only,\nfalse by default)."]
            #[serde(rename = "background")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub background: Option<bool>,
        }
        impl CreateTargetParams {
            pub fn new(url: impl Into<String>) -> Self {
                Self {
                    url: url.into(),
                    width: None,
                    height: None,
                    browser_context_id: None,
                    enable_begin_frame_control: None,
                    new_window: None,
                    background: None,
                }
            }
        }
        impl<T: Into<String>> From<T> for CreateTargetParams {
            fn from(url: T) -> Self {
                CreateTargetParams::new(url)
            }
        }
        impl CreateTargetParams {
            pub fn builder() -> CreateTargetParamsBuilder {
                CreateTargetParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CreateTargetParamsBuilder {
            url: Option<String>,
            width: Option<i64>,
            height: Option<i64>,
            browser_context_id: Option<super::browser::BrowserContextId>,
            enable_begin_frame_control: Option<bool>,
            new_window: Option<bool>,
            background: Option<bool>,
        }
        impl CreateTargetParamsBuilder {
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn width(mut self, width: impl Into<i64>) -> Self {
                self.width = Some(width.into());
                self
            }
            pub fn height(mut self, height: impl Into<i64>) -> Self {
                self.height = Some(height.into());
                self
            }
            pub fn browser_context_id(
                mut self,
                browser_context_id: impl Into<super::browser::BrowserContextId>,
            ) -> Self {
                self.browser_context_id = Some(browser_context_id.into());
                self
            }
            pub fn enable_begin_frame_control(
                mut self,
                enable_begin_frame_control: impl Into<bool>,
            ) -> Self {
                self.enable_begin_frame_control = Some(enable_begin_frame_control.into());
                self
            }
            pub fn new_window(mut self, new_window: impl Into<bool>) -> Self {
                self.new_window = Some(new_window.into());
                self
            }
            pub fn background(mut self, background: impl Into<bool>) -> Self {
                self.background = Some(background.into());
                self
            }
            pub fn build(self) -> Result<CreateTargetParams, String> {
                Ok(CreateTargetParams {
                    url: self
                        .url
                        .ok_or_else(|| format!("Field `{}` is mandatory.", std::stringify!(url)))?,
                    width: self.width,
                    height: self.height,
                    browser_context_id: self.browser_context_id,
                    enable_begin_frame_control: self.enable_begin_frame_control,
                    new_window: self.new_window,
                    background: self.background,
                })
            }
        }
        impl CreateTargetParams {
            pub const IDENTIFIER: &'static str = "Target.createTarget";
        }
        impl chromiumoxide_types::Method for CreateTargetParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for CreateTargetParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Creates a new page.\n[createTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-createTarget)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct CreateTargetReturns {
            #[doc = "The id of the page opened."]
            #[serde(rename = "targetId")]
            pub target_id: TargetId,
        }
        impl CreateTargetReturns {
            pub fn new(target_id: impl Into<TargetId>) -> Self {
                Self {
                    target_id: target_id.into(),
                }
            }
        }
        impl CreateTargetReturns {
            pub fn builder() -> CreateTargetReturnsBuilder {
                CreateTargetReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CreateTargetReturnsBuilder {
            target_id: Option<TargetId>,
        }
        impl CreateTargetReturnsBuilder {
            pub fn target_id(mut self, target_id: impl Into<TargetId>) -> Self {
                self.target_id = Some(target_id.into());
                self
            }
            pub fn build(self) -> Result<CreateTargetReturns, String> {
                Ok(CreateTargetReturns {
                    target_id: self.target_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(target_id))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for CreateTargetParams {
            type Response = CreateTargetReturns;
        }
        #[doc = "Detaches session with given id.\n[detachFromTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-detachFromTarget)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DetachFromTargetParams {
            #[doc = "Session to detach."]
            #[serde(rename = "sessionId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub session_id: Option<SessionId>,
        }
        impl DetachFromTargetParams {
            pub fn builder() -> DetachFromTargetParamsBuilder {
                DetachFromTargetParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DetachFromTargetParamsBuilder {
            session_id: Option<SessionId>,
        }
        impl DetachFromTargetParamsBuilder {
            pub fn session_id(mut self, session_id: impl Into<SessionId>) -> Self {
                self.session_id = Some(session_id.into());
                self
            }
            pub fn build(self) -> DetachFromTargetParams {
                DetachFromTargetParams {
                    session_id: self.session_id,
                }
            }
        }
        impl DetachFromTargetParams {
            pub const IDENTIFIER: &'static str = "Target.detachFromTarget";
        }
        impl chromiumoxide_types::Method for DetachFromTargetParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DetachFromTargetParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Detaches session with given id.\n[detachFromTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-detachFromTarget)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DetachFromTargetReturns {}
        impl chromiumoxide_types::Command for DetachFromTargetParams {
            type Response = DetachFromTargetReturns;
        }
        #[doc = "Deletes a BrowserContext. All the belonging pages will be closed without calling their\nbeforeunload hooks.\n[disposeBrowserContext](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-disposeBrowserContext)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct DisposeBrowserContextParams {
            #[serde(rename = "browserContextId")]
            pub browser_context_id: super::browser::BrowserContextId,
        }
        impl DisposeBrowserContextParams {
            pub fn new(browser_context_id: impl Into<super::browser::BrowserContextId>) -> Self {
                Self {
                    browser_context_id: browser_context_id.into(),
                }
            }
        }
        impl DisposeBrowserContextParams {
            pub fn builder() -> DisposeBrowserContextParamsBuilder {
                DisposeBrowserContextParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct DisposeBrowserContextParamsBuilder {
            browser_context_id: Option<super::browser::BrowserContextId>,
        }
        impl DisposeBrowserContextParamsBuilder {
            pub fn browser_context_id(
                mut self,
                browser_context_id: impl Into<super::browser::BrowserContextId>,
            ) -> Self {
                self.browser_context_id = Some(browser_context_id.into());
                self
            }
            pub fn build(self) -> Result<DisposeBrowserContextParams, String> {
                Ok(DisposeBrowserContextParams {
                    browser_context_id: self.browser_context_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(browser_context_id)
                        )
                    })?,
                })
            }
        }
        impl DisposeBrowserContextParams {
            pub const IDENTIFIER: &'static str = "Target.disposeBrowserContext";
        }
        impl chromiumoxide_types::Method for DisposeBrowserContextParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisposeBrowserContextParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Deletes a BrowserContext. All the belonging pages will be closed without calling their\nbeforeunload hooks.\n[disposeBrowserContext](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-disposeBrowserContext)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisposeBrowserContextReturns {}
        impl chromiumoxide_types::Command for DisposeBrowserContextParams {
            type Response = DisposeBrowserContextReturns;
        }
        #[doc = "Returns information about a target.\n[getTargetInfo](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-getTargetInfo)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetTargetInfoParams {
            #[serde(rename = "targetId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub target_id: Option<TargetId>,
        }
        impl GetTargetInfoParams {
            pub fn builder() -> GetTargetInfoParamsBuilder {
                GetTargetInfoParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetTargetInfoParamsBuilder {
            target_id: Option<TargetId>,
        }
        impl GetTargetInfoParamsBuilder {
            pub fn target_id(mut self, target_id: impl Into<TargetId>) -> Self {
                self.target_id = Some(target_id.into());
                self
            }
            pub fn build(self) -> GetTargetInfoParams {
                GetTargetInfoParams {
                    target_id: self.target_id,
                }
            }
        }
        impl GetTargetInfoParams {
            pub const IDENTIFIER: &'static str = "Target.getTargetInfo";
        }
        impl chromiumoxide_types::Method for GetTargetInfoParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetTargetInfoParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns information about a target.\n[getTargetInfo](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-getTargetInfo)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetTargetInfoReturns {
            #[serde(rename = "targetInfo")]
            pub target_info: TargetInfo,
        }
        impl GetTargetInfoReturns {
            pub fn new(target_info: impl Into<TargetInfo>) -> Self {
                Self {
                    target_info: target_info.into(),
                }
            }
        }
        impl GetTargetInfoReturns {
            pub fn builder() -> GetTargetInfoReturnsBuilder {
                GetTargetInfoReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetTargetInfoReturnsBuilder {
            target_info: Option<TargetInfo>,
        }
        impl GetTargetInfoReturnsBuilder {
            pub fn target_info(mut self, target_info: impl Into<TargetInfo>) -> Self {
                self.target_info = Some(target_info.into());
                self
            }
            pub fn build(self) -> Result<GetTargetInfoReturns, String> {
                Ok(GetTargetInfoReturns {
                    target_info: self.target_info.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(target_info))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetTargetInfoParams {
            type Response = GetTargetInfoReturns;
        }
        #[doc = "Retrieves a list of available targets.\n[getTargets](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-getTargets)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetTargetsParams {
            #[doc = "Only targets matching filter will be reported. If filter is not specified\nand target discovery is currently enabled, a filter used for target discovery\nis used for consistency."]
            #[serde(rename = "filter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub filter: Option<TargetFilter>,
        }
        impl GetTargetsParams {
            pub fn builder() -> GetTargetsParamsBuilder {
                GetTargetsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetTargetsParamsBuilder {
            filter: Option<TargetFilter>,
        }
        impl GetTargetsParamsBuilder {
            pub fn filter(mut self, filter: impl Into<TargetFilter>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn build(self) -> GetTargetsParams {
                GetTargetsParams {
                    filter: self.filter,
                }
            }
        }
        impl GetTargetsParams {
            pub const IDENTIFIER: &'static str = "Target.getTargets";
        }
        impl chromiumoxide_types::Method for GetTargetsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetTargetsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Retrieves a list of available targets.\n[getTargets](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-getTargets)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetTargetsReturns {
            #[doc = "The list of targets."]
            #[serde(rename = "targetInfos")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub target_infos: Vec<TargetInfo>,
        }
        impl GetTargetsReturns {
            pub fn new(target_infos: Vec<TargetInfo>) -> Self {
                Self { target_infos }
            }
        }
        impl GetTargetsReturns {
            pub fn builder() -> GetTargetsReturnsBuilder {
                GetTargetsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetTargetsReturnsBuilder {
            target_infos: Option<Vec<TargetInfo>>,
        }
        impl GetTargetsReturnsBuilder {
            pub fn target_info(mut self, target_info: impl Into<TargetInfo>) -> Self {
                let v = self.target_infos.get_or_insert(Vec::new());
                v.push(target_info.into());
                self
            }
            pub fn target_infos<I, S>(mut self, target_infos: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<TargetInfo>,
            {
                let v = self.target_infos.get_or_insert(Vec::new());
                for val in target_infos {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetTargetsReturns, String> {
                Ok(GetTargetsReturns {
                    target_infos: self.target_infos.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(target_infos))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetTargetsParams {
            type Response = GetTargetsReturns;
        }
        #[doc = "Controls whether to automatically attach to new targets which are considered to be related to\nthis one. When turned on, attaches to all existing related targets as well. When turned off,\nautomatically detaches from all currently attached targets.\nThis also clears all targets added by `autoAttachRelated` from the list of targets to watch\nfor creation of related targets.\n[setAutoAttach](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-setAutoAttach)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetAutoAttachParams {
            #[doc = "Whether to auto-attach to related targets."]
            #[serde(rename = "autoAttach")]
            pub auto_attach: bool,
            #[doc = "Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`\nto run paused targets."]
            #[serde(rename = "waitForDebuggerOnStart")]
            pub wait_for_debugger_on_start: bool,
            #[doc = "Enables \"flat\" access to the session via specifying sessionId attribute in the commands.\nWe plan to make this the default, deprecate non-flattened mode,\nand eventually retire it. See crbug.com/991325."]
            #[serde(rename = "flatten")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub flatten: Option<bool>,
            #[doc = "Only targets matching filter will be attached."]
            #[serde(rename = "filter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub filter: Option<TargetFilter>,
        }
        impl SetAutoAttachParams {
            pub fn new(
                auto_attach: impl Into<bool>,
                wait_for_debugger_on_start: impl Into<bool>,
            ) -> Self {
                Self {
                    auto_attach: auto_attach.into(),
                    wait_for_debugger_on_start: wait_for_debugger_on_start.into(),
                    flatten: None,
                    filter: None,
                }
            }
        }
        impl SetAutoAttachParams {
            pub fn builder() -> SetAutoAttachParamsBuilder {
                SetAutoAttachParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetAutoAttachParamsBuilder {
            auto_attach: Option<bool>,
            wait_for_debugger_on_start: Option<bool>,
            flatten: Option<bool>,
            filter: Option<TargetFilter>,
        }
        impl SetAutoAttachParamsBuilder {
            pub fn auto_attach(mut self, auto_attach: impl Into<bool>) -> Self {
                self.auto_attach = Some(auto_attach.into());
                self
            }
            pub fn wait_for_debugger_on_start(
                mut self,
                wait_for_debugger_on_start: impl Into<bool>,
            ) -> Self {
                self.wait_for_debugger_on_start = Some(wait_for_debugger_on_start.into());
                self
            }
            pub fn flatten(mut self, flatten: impl Into<bool>) -> Self {
                self.flatten = Some(flatten.into());
                self
            }
            pub fn filter(mut self, filter: impl Into<TargetFilter>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn build(self) -> Result<SetAutoAttachParams, String> {
                Ok(SetAutoAttachParams {
                    auto_attach: self.auto_attach.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(auto_attach))
                    })?,
                    wait_for_debugger_on_start: self.wait_for_debugger_on_start.ok_or_else(
                        || {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(wait_for_debugger_on_start)
                            )
                        },
                    )?,
                    flatten: self.flatten,
                    filter: self.filter,
                })
            }
        }
        impl SetAutoAttachParams {
            pub const IDENTIFIER: &'static str = "Target.setAutoAttach";
        }
        impl chromiumoxide_types::Method for SetAutoAttachParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetAutoAttachParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Controls whether to automatically attach to new targets which are considered to be related to\nthis one. When turned on, attaches to all existing related targets as well. When turned off,\nautomatically detaches from all currently attached targets.\nThis also clears all targets added by `autoAttachRelated` from the list of targets to watch\nfor creation of related targets.\n[setAutoAttach](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-setAutoAttach)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetAutoAttachReturns {}
        impl chromiumoxide_types::Command for SetAutoAttachParams {
            type Response = SetAutoAttachReturns;
        }
        #[doc = "Adds the specified target to the list of targets that will be monitored for any related target\ncreation (such as child frames, child workers and new versions of service worker) and reported\nthrough `attachedToTarget`. The specified target is also auto-attached.\nThis cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent\n`setAutoAttach`. Only available at the Browser target.\n[autoAttachRelated](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-autoAttachRelated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AutoAttachRelatedParams {
            #[serde(rename = "targetId")]
            pub target_id: TargetId,
            #[doc = "Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`\nto run paused targets."]
            #[serde(rename = "waitForDebuggerOnStart")]
            pub wait_for_debugger_on_start: bool,
            #[doc = "Only targets matching filter will be attached."]
            #[serde(rename = "filter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub filter: Option<TargetFilter>,
        }
        impl AutoAttachRelatedParams {
            pub fn new(
                target_id: impl Into<TargetId>,
                wait_for_debugger_on_start: impl Into<bool>,
            ) -> Self {
                Self {
                    target_id: target_id.into(),
                    wait_for_debugger_on_start: wait_for_debugger_on_start.into(),
                    filter: None,
                }
            }
        }
        impl AutoAttachRelatedParams {
            pub fn builder() -> AutoAttachRelatedParamsBuilder {
                AutoAttachRelatedParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AutoAttachRelatedParamsBuilder {
            target_id: Option<TargetId>,
            wait_for_debugger_on_start: Option<bool>,
            filter: Option<TargetFilter>,
        }
        impl AutoAttachRelatedParamsBuilder {
            pub fn target_id(mut self, target_id: impl Into<TargetId>) -> Self {
                self.target_id = Some(target_id.into());
                self
            }
            pub fn wait_for_debugger_on_start(
                mut self,
                wait_for_debugger_on_start: impl Into<bool>,
            ) -> Self {
                self.wait_for_debugger_on_start = Some(wait_for_debugger_on_start.into());
                self
            }
            pub fn filter(mut self, filter: impl Into<TargetFilter>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn build(self) -> Result<AutoAttachRelatedParams, String> {
                Ok(AutoAttachRelatedParams {
                    target_id: self.target_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(target_id))
                    })?,
                    wait_for_debugger_on_start: self.wait_for_debugger_on_start.ok_or_else(
                        || {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(wait_for_debugger_on_start)
                            )
                        },
                    )?,
                    filter: self.filter,
                })
            }
        }
        impl AutoAttachRelatedParams {
            pub const IDENTIFIER: &'static str = "Target.autoAttachRelated";
        }
        impl chromiumoxide_types::Method for AutoAttachRelatedParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for AutoAttachRelatedParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Adds the specified target to the list of targets that will be monitored for any related target\ncreation (such as child frames, child workers and new versions of service worker) and reported\nthrough `attachedToTarget`. The specified target is also auto-attached.\nThis cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent\n`setAutoAttach`. Only available at the Browser target.\n[autoAttachRelated](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-autoAttachRelated)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct AutoAttachRelatedReturns {}
        impl chromiumoxide_types::Command for AutoAttachRelatedParams {
            type Response = AutoAttachRelatedReturns;
        }
        #[doc = "Controls whether to discover available targets and notify via\n`targetCreated/targetInfoChanged/targetDestroyed` events.\n[setDiscoverTargets](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-setDiscoverTargets)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetDiscoverTargetsParams {
            #[doc = "Whether to discover available targets."]
            #[serde(rename = "discover")]
            pub discover: bool,
            #[doc = "Only targets matching filter will be attached. If `discover` is false,\n`filter` must be omitted or empty."]
            #[serde(rename = "filter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub filter: Option<TargetFilter>,
        }
        impl SetDiscoverTargetsParams {
            pub fn new(discover: impl Into<bool>) -> Self {
                Self {
                    discover: discover.into(),
                    filter: None,
                }
            }
        }
        impl SetDiscoverTargetsParams {
            pub fn builder() -> SetDiscoverTargetsParamsBuilder {
                SetDiscoverTargetsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetDiscoverTargetsParamsBuilder {
            discover: Option<bool>,
            filter: Option<TargetFilter>,
        }
        impl SetDiscoverTargetsParamsBuilder {
            pub fn discover(mut self, discover: impl Into<bool>) -> Self {
                self.discover = Some(discover.into());
                self
            }
            pub fn filter(mut self, filter: impl Into<TargetFilter>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn build(self) -> Result<SetDiscoverTargetsParams, String> {
                Ok(SetDiscoverTargetsParams {
                    discover: self.discover.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(discover))
                    })?,
                    filter: self.filter,
                })
            }
        }
        impl SetDiscoverTargetsParams {
            pub const IDENTIFIER: &'static str = "Target.setDiscoverTargets";
        }
        impl chromiumoxide_types::Method for SetDiscoverTargetsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetDiscoverTargetsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Controls whether to discover available targets and notify via\n`targetCreated/targetInfoChanged/targetDestroyed` events.\n[setDiscoverTargets](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-setDiscoverTargets)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetDiscoverTargetsReturns {}
        impl chromiumoxide_types::Command for SetDiscoverTargetsParams {
            type Response = SetDiscoverTargetsReturns;
        }
        #[doc = "Enables target discovery for the specified locations, when `setDiscoverTargets` was set to\n`true`.\n[setRemoteLocations](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-setRemoteLocations)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetRemoteLocationsParams {
            #[doc = "List of remote locations."]
            #[serde(rename = "locations")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub locations: Vec<RemoteLocation>,
        }
        impl SetRemoteLocationsParams {
            pub fn new(locations: Vec<RemoteLocation>) -> Self {
                Self { locations }
            }
        }
        impl SetRemoteLocationsParams {
            pub fn builder() -> SetRemoteLocationsParamsBuilder {
                SetRemoteLocationsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetRemoteLocationsParamsBuilder {
            locations: Option<Vec<RemoteLocation>>,
        }
        impl SetRemoteLocationsParamsBuilder {
            pub fn location(mut self, location: impl Into<RemoteLocation>) -> Self {
                let v = self.locations.get_or_insert(Vec::new());
                v.push(location.into());
                self
            }
            pub fn locations<I, S>(mut self, locations: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<RemoteLocation>,
            {
                let v = self.locations.get_or_insert(Vec::new());
                for val in locations {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<SetRemoteLocationsParams, String> {
                Ok(SetRemoteLocationsParams {
                    locations: self.locations.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(locations))
                    })?,
                })
            }
        }
        impl SetRemoteLocationsParams {
            pub const IDENTIFIER: &'static str = "Target.setRemoteLocations";
        }
        impl chromiumoxide_types::Method for SetRemoteLocationsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetRemoteLocationsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables target discovery for the specified locations, when `setDiscoverTargets` was set to\n`true`.\n[setRemoteLocations](https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-setRemoteLocations)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetRemoteLocationsReturns {}
        impl chromiumoxide_types::Command for SetRemoteLocationsParams {
            type Response = SetRemoteLocationsReturns;
        }
        #[doc = "Issued when attached to target because of auto-attach or `attachToTarget` command.\n[attachedToTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-attachedToTarget)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAttachedToTarget {
            #[doc = "Identifier assigned to the session used to send/receive messages."]
            #[serde(rename = "sessionId")]
            pub session_id: SessionId,
            #[serde(rename = "targetInfo")]
            pub target_info: TargetInfo,
            #[serde(rename = "waitingForDebugger")]
            pub waiting_for_debugger: bool,
        }
        impl EventAttachedToTarget {
            pub const IDENTIFIER: &'static str = "Target.attachedToTarget";
        }
        impl chromiumoxide_types::Method for EventAttachedToTarget {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAttachedToTarget {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued when detached from target for any reason (including `detachFromTarget` command). Can be\nissued multiple times per target if multiple sessions have been attached to it.\n[detachedFromTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-detachedFromTarget)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDetachedFromTarget {
            #[doc = "Detached session identifier."]
            #[serde(rename = "sessionId")]
            pub session_id: SessionId,
        }
        impl EventDetachedFromTarget {
            pub const IDENTIFIER: &'static str = "Target.detachedFromTarget";
        }
        impl chromiumoxide_types::Method for EventDetachedFromTarget {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDetachedFromTarget {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Notifies about a new protocol message received from the session (as reported in\n`attachedToTarget` event).\n[receivedMessageFromTarget](https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-receivedMessageFromTarget)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventReceivedMessageFromTarget {
            #[doc = "Identifier of a session which sends a message."]
            #[serde(rename = "sessionId")]
            pub session_id: SessionId,
            #[serde(rename = "message")]
            pub message: String,
        }
        impl EventReceivedMessageFromTarget {
            pub const IDENTIFIER: &'static str = "Target.receivedMessageFromTarget";
        }
        impl chromiumoxide_types::Method for EventReceivedMessageFromTarget {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventReceivedMessageFromTarget {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued when a possible inspection target is created.\n[targetCreated](https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-targetCreated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventTargetCreated {
            #[serde(rename = "targetInfo")]
            pub target_info: TargetInfo,
        }
        impl EventTargetCreated {
            pub const IDENTIFIER: &'static str = "Target.targetCreated";
        }
        impl chromiumoxide_types::Method for EventTargetCreated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventTargetCreated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued when a target is destroyed.\n[targetDestroyed](https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-targetDestroyed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventTargetDestroyed {
            #[serde(rename = "targetId")]
            pub target_id: TargetId,
        }
        impl EventTargetDestroyed {
            pub const IDENTIFIER: &'static str = "Target.targetDestroyed";
        }
        impl chromiumoxide_types::Method for EventTargetDestroyed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventTargetDestroyed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued when a target has crashed.\n[targetCrashed](https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-targetCrashed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventTargetCrashed {
            #[serde(rename = "targetId")]
            pub target_id: TargetId,
            #[doc = "Termination status type."]
            #[serde(rename = "status")]
            pub status: String,
            #[doc = "Termination error code."]
            #[serde(rename = "errorCode")]
            pub error_code: i64,
        }
        impl EventTargetCrashed {
            pub const IDENTIFIER: &'static str = "Target.targetCrashed";
        }
        impl chromiumoxide_types::Method for EventTargetCrashed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventTargetCrashed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued when some information about a target has changed. This only happens between\n`targetCreated` and `targetDestroyed`.\n[targetInfoChanged](https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-targetInfoChanged)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventTargetInfoChanged {
            #[serde(rename = "targetInfo")]
            pub target_info: TargetInfo,
        }
        impl EventTargetInfoChanged {
            pub const IDENTIFIER: &'static str = "Target.targetInfoChanged";
        }
        impl chromiumoxide_types::Method for EventTargetInfoChanged {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventTargetInfoChanged {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "The Tethering domain defines methods and events for browser port binding."]
    pub mod tethering {
        use serde::{Deserialize, Serialize};
        #[doc = "Request browser port binding.\n[bind](https://chromedevtools.github.io/devtools-protocol/tot/Tethering/#method-bind)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct BindParams {
            #[doc = "Port number to bind."]
            #[serde(rename = "port")]
            pub port: i64,
        }
        impl BindParams {
            pub fn new(port: impl Into<i64>) -> Self {
                Self { port: port.into() }
            }
        }
        impl BindParams {
            pub fn builder() -> BindParamsBuilder {
                BindParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BindParamsBuilder {
            port: Option<i64>,
        }
        impl BindParamsBuilder {
            pub fn port(mut self, port: impl Into<i64>) -> Self {
                self.port = Some(port.into());
                self
            }
            pub fn build(self) -> Result<BindParams, String> {
                Ok(BindParams {
                    port: self.port.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(port))
                    })?,
                })
            }
        }
        impl BindParams {
            pub const IDENTIFIER: &'static str = "Tethering.bind";
        }
        impl chromiumoxide_types::Method for BindParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for BindParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Request browser port binding.\n[bind](https://chromedevtools.github.io/devtools-protocol/tot/Tethering/#method-bind)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct BindReturns {}
        impl chromiumoxide_types::Command for BindParams {
            type Response = BindReturns;
        }
        #[doc = "Request browser port unbinding.\n[unbind](https://chromedevtools.github.io/devtools-protocol/tot/Tethering/#method-unbind)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct UnbindParams {
            #[doc = "Port number to unbind."]
            #[serde(rename = "port")]
            pub port: i64,
        }
        impl UnbindParams {
            pub fn new(port: impl Into<i64>) -> Self {
                Self { port: port.into() }
            }
        }
        impl UnbindParams {
            pub fn builder() -> UnbindParamsBuilder {
                UnbindParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct UnbindParamsBuilder {
            port: Option<i64>,
        }
        impl UnbindParamsBuilder {
            pub fn port(mut self, port: impl Into<i64>) -> Self {
                self.port = Some(port.into());
                self
            }
            pub fn build(self) -> Result<UnbindParams, String> {
                Ok(UnbindParams {
                    port: self.port.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(port))
                    })?,
                })
            }
        }
        impl UnbindParams {
            pub const IDENTIFIER: &'static str = "Tethering.unbind";
        }
        impl chromiumoxide_types::Method for UnbindParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for UnbindParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Request browser port unbinding.\n[unbind](https://chromedevtools.github.io/devtools-protocol/tot/Tethering/#method-unbind)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct UnbindReturns {}
        impl chromiumoxide_types::Command for UnbindParams {
            type Response = UnbindReturns;
        }
        #[doc = "Informs that port was successfully bound and got a specified connection id.\n[accepted](https://chromedevtools.github.io/devtools-protocol/tot/Tethering/#event-accepted)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAccepted {
            #[doc = "Port number that was successfully bound."]
            #[serde(rename = "port")]
            pub port: i64,
            #[doc = "Connection id to be used."]
            #[serde(rename = "connectionId")]
            pub connection_id: String,
        }
        impl EventAccepted {
            pub const IDENTIFIER: &'static str = "Tethering.accepted";
        }
        impl chromiumoxide_types::Method for EventAccepted {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAccepted {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    pub mod tracing {
        use serde::{Deserialize, Serialize};
        #[doc = "Configuration for memory dump. Used only when \"memory-infra\" category is enabled.\n[MemoryDumpConfig](https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#type-MemoryDumpConfig)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct MemoryDumpConfig(serde_json::Value);
        impl MemoryDumpConfig {
            pub fn new(val: impl Into<serde_json::Value>) -> Self {
                MemoryDumpConfig(val.into())
            }
            pub fn inner(&self) -> &serde_json::Value {
                &self.0
            }
        }
        impl MemoryDumpConfig {
            pub const IDENTIFIER: &'static str = "Tracing.MemoryDumpConfig";
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct TraceConfig {
            #[doc = "Controls how the trace buffer stores data."]
            #[serde(rename = "recordMode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub record_mode: Option<TraceConfigRecordMode>,
            #[doc = "Size of the trace buffer in kilobytes. If not specified or zero is passed, a default value\nof 200 MB would be used."]
            #[serde(rename = "traceBufferSizeInKb")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub trace_buffer_size_in_kb: Option<f64>,
            #[doc = "Turns on JavaScript stack sampling."]
            #[serde(rename = "enableSampling")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub enable_sampling: Option<bool>,
            #[doc = "Turns on system tracing."]
            #[serde(rename = "enableSystrace")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub enable_systrace: Option<bool>,
            #[doc = "Turns on argument filter."]
            #[serde(rename = "enableArgumentFilter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub enable_argument_filter: Option<bool>,
            #[doc = "Included category filters."]
            #[serde(rename = "includedCategories")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub included_categories: Option<Vec<String>>,
            #[doc = "Excluded category filters."]
            #[serde(rename = "excludedCategories")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub excluded_categories: Option<Vec<String>>,
            #[doc = "Configuration to synthesize the delays in tracing."]
            #[serde(rename = "syntheticDelays")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub synthetic_delays: Option<Vec<String>>,
            #[doc = "Configuration for memory dump triggers. Used only when \"memory-infra\" category is enabled."]
            #[serde(rename = "memoryDumpConfig")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub memory_dump_config: Option<MemoryDumpConfig>,
        }
        #[doc = "Controls how the trace buffer stores data."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum TraceConfigRecordMode {
            #[serde(rename = "recordUntilFull")]
            RecordUntilFull,
            #[serde(rename = "recordContinuously")]
            RecordContinuously,
            #[serde(rename = "recordAsMuchAsPossible")]
            RecordAsMuchAsPossible,
            #[serde(rename = "echoToConsole")]
            EchoToConsole,
        }
        impl AsRef<str> for TraceConfigRecordMode {
            fn as_ref(&self) -> &str {
                match self {
                    TraceConfigRecordMode::RecordUntilFull => "recordUntilFull",
                    TraceConfigRecordMode::RecordContinuously => "recordContinuously",
                    TraceConfigRecordMode::RecordAsMuchAsPossible => "recordAsMuchAsPossible",
                    TraceConfigRecordMode::EchoToConsole => "echoToConsole",
                }
            }
        }
        impl ::std::str::FromStr for TraceConfigRecordMode {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "recordUntilFull" | "RecordUntilFull" | "recorduntilfull" => {
                        Ok(TraceConfigRecordMode::RecordUntilFull)
                    }
                    "recordContinuously" | "RecordContinuously" | "recordcontinuously" => {
                        Ok(TraceConfigRecordMode::RecordContinuously)
                    }
                    "recordAsMuchAsPossible"
                    | "RecordAsMuchAsPossible"
                    | "recordasmuchaspossible" => Ok(TraceConfigRecordMode::RecordAsMuchAsPossible),
                    "echoToConsole" | "EchoToConsole" | "echotoconsole" => {
                        Ok(TraceConfigRecordMode::EchoToConsole)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl TraceConfig {
            pub fn builder() -> TraceConfigBuilder {
                TraceConfigBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TraceConfigBuilder {
            record_mode: Option<TraceConfigRecordMode>,
            trace_buffer_size_in_kb: Option<f64>,
            enable_sampling: Option<bool>,
            enable_systrace: Option<bool>,
            enable_argument_filter: Option<bool>,
            included_categories: Option<Vec<String>>,
            excluded_categories: Option<Vec<String>>,
            synthetic_delays: Option<Vec<String>>,
            memory_dump_config: Option<MemoryDumpConfig>,
        }
        impl TraceConfigBuilder {
            pub fn record_mode(mut self, record_mode: impl Into<TraceConfigRecordMode>) -> Self {
                self.record_mode = Some(record_mode.into());
                self
            }
            pub fn trace_buffer_size_in_kb(
                mut self,
                trace_buffer_size_in_kb: impl Into<f64>,
            ) -> Self {
                self.trace_buffer_size_in_kb = Some(trace_buffer_size_in_kb.into());
                self
            }
            pub fn enable_sampling(mut self, enable_sampling: impl Into<bool>) -> Self {
                self.enable_sampling = Some(enable_sampling.into());
                self
            }
            pub fn enable_systrace(mut self, enable_systrace: impl Into<bool>) -> Self {
                self.enable_systrace = Some(enable_systrace.into());
                self
            }
            pub fn enable_argument_filter(
                mut self,
                enable_argument_filter: impl Into<bool>,
            ) -> Self {
                self.enable_argument_filter = Some(enable_argument_filter.into());
                self
            }
            pub fn included_categorie(mut self, included_categorie: impl Into<String>) -> Self {
                let v = self.included_categories.get_or_insert(Vec::new());
                v.push(included_categorie.into());
                self
            }
            pub fn included_categories<I, S>(mut self, included_categories: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.included_categories.get_or_insert(Vec::new());
                for val in included_categories {
                    v.push(val.into());
                }
                self
            }
            pub fn excluded_categorie(mut self, excluded_categorie: impl Into<String>) -> Self {
                let v = self.excluded_categories.get_or_insert(Vec::new());
                v.push(excluded_categorie.into());
                self
            }
            pub fn excluded_categories<I, S>(mut self, excluded_categories: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.excluded_categories.get_or_insert(Vec::new());
                for val in excluded_categories {
                    v.push(val.into());
                }
                self
            }
            pub fn synthetic_delay(mut self, synthetic_delay: impl Into<String>) -> Self {
                let v = self.synthetic_delays.get_or_insert(Vec::new());
                v.push(synthetic_delay.into());
                self
            }
            pub fn synthetic_delays<I, S>(mut self, synthetic_delays: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.synthetic_delays.get_or_insert(Vec::new());
                for val in synthetic_delays {
                    v.push(val.into());
                }
                self
            }
            pub fn memory_dump_config(
                mut self,
                memory_dump_config: impl Into<MemoryDumpConfig>,
            ) -> Self {
                self.memory_dump_config = Some(memory_dump_config.into());
                self
            }
            pub fn build(self) -> TraceConfig {
                TraceConfig {
                    record_mode: self.record_mode,
                    trace_buffer_size_in_kb: self.trace_buffer_size_in_kb,
                    enable_sampling: self.enable_sampling,
                    enable_systrace: self.enable_systrace,
                    enable_argument_filter: self.enable_argument_filter,
                    included_categories: self.included_categories,
                    excluded_categories: self.excluded_categories,
                    synthetic_delays: self.synthetic_delays,
                    memory_dump_config: self.memory_dump_config,
                }
            }
        }
        impl TraceConfig {
            pub const IDENTIFIER: &'static str = "Tracing.TraceConfig";
        }
        #[doc = "Data format of a trace. Can be either the legacy JSON format or the\nprotocol buffer format. Note that the JSON format will be deprecated soon."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum StreamFormat {
            #[serde(rename = "json")]
            Json,
            #[serde(rename = "proto")]
            Proto,
        }
        impl AsRef<str> for StreamFormat {
            fn as_ref(&self) -> &str {
                match self {
                    StreamFormat::Json => "json",
                    StreamFormat::Proto => "proto",
                }
            }
        }
        impl ::std::str::FromStr for StreamFormat {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "json" | "Json" => Ok(StreamFormat::Json),
                    "proto" | "Proto" => Ok(StreamFormat::Proto),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Compression type to use for traces returned via streams."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum StreamCompression {
            #[serde(rename = "none")]
            None,
            #[serde(rename = "gzip")]
            Gzip,
        }
        impl AsRef<str> for StreamCompression {
            fn as_ref(&self) -> &str {
                match self {
                    StreamCompression::None => "none",
                    StreamCompression::Gzip => "gzip",
                }
            }
        }
        impl ::std::str::FromStr for StreamCompression {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "none" | "None" => Ok(StreamCompression::None),
                    "gzip" | "Gzip" => Ok(StreamCompression::Gzip),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Details exposed when memory request explicitly declared.\nKeep consistent with memory_dump_request_args.h and\nmemory_instrumentation.mojom"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum MemoryDumpLevelOfDetail {
            #[serde(rename = "background")]
            Background,
            #[serde(rename = "light")]
            Light,
            #[serde(rename = "detailed")]
            Detailed,
        }
        impl AsRef<str> for MemoryDumpLevelOfDetail {
            fn as_ref(&self) -> &str {
                match self {
                    MemoryDumpLevelOfDetail::Background => "background",
                    MemoryDumpLevelOfDetail::Light => "light",
                    MemoryDumpLevelOfDetail::Detailed => "detailed",
                }
            }
        }
        impl ::std::str::FromStr for MemoryDumpLevelOfDetail {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "background" | "Background" => Ok(MemoryDumpLevelOfDetail::Background),
                    "light" | "Light" => Ok(MemoryDumpLevelOfDetail::Light),
                    "detailed" | "Detailed" => Ok(MemoryDumpLevelOfDetail::Detailed),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Backend type to use for tracing. `chrome` uses the Chrome-integrated\ntracing service and is supported on all platforms. `system` is only\nsupported on Chrome OS and uses the Perfetto system tracing service.\n`auto` chooses `system` when the perfettoConfig provided to Tracing.start\nspecifies at least one non-Chrome data source; otherwise uses `chrome`."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum TracingBackend {
            #[serde(rename = "auto")]
            Auto,
            #[serde(rename = "chrome")]
            Chrome,
            #[serde(rename = "system")]
            System,
        }
        impl AsRef<str> for TracingBackend {
            fn as_ref(&self) -> &str {
                match self {
                    TracingBackend::Auto => "auto",
                    TracingBackend::Chrome => "chrome",
                    TracingBackend::System => "system",
                }
            }
        }
        impl ::std::str::FromStr for TracingBackend {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "auto" | "Auto" => Ok(TracingBackend::Auto),
                    "chrome" | "Chrome" => Ok(TracingBackend::Chrome),
                    "system" | "System" => Ok(TracingBackend::System),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Stop trace events collection.\n[end](https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-end)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EndParams {}
        impl EndParams {
            pub const IDENTIFIER: &'static str = "Tracing.end";
        }
        impl chromiumoxide_types::Method for EndParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EndParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Stop trace events collection.\n[end](https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-end)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EndReturns {}
        impl chromiumoxide_types::Command for EndParams {
            type Response = EndReturns;
        }
        #[doc = "Gets supported tracing categories.\n[getCategories](https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-getCategories)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct GetCategoriesParams {}
        impl GetCategoriesParams {
            pub const IDENTIFIER: &'static str = "Tracing.getCategories";
        }
        impl chromiumoxide_types::Method for GetCategoriesParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetCategoriesParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Gets supported tracing categories.\n[getCategories](https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-getCategories)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetCategoriesReturns {
            #[doc = "A list of supported tracing categories."]
            #[serde(rename = "categories")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub categories: Vec<String>,
        }
        impl GetCategoriesReturns {
            pub fn new(categories: Vec<String>) -> Self {
                Self { categories }
            }
        }
        impl GetCategoriesReturns {
            pub fn builder() -> GetCategoriesReturnsBuilder {
                GetCategoriesReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetCategoriesReturnsBuilder {
            categories: Option<Vec<String>>,
        }
        impl GetCategoriesReturnsBuilder {
            pub fn categorie(mut self, categorie: impl Into<String>) -> Self {
                let v = self.categories.get_or_insert(Vec::new());
                v.push(categorie.into());
                self
            }
            pub fn categories<I, S>(mut self, categories: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<String>,
            {
                let v = self.categories.get_or_insert(Vec::new());
                for val in categories {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetCategoriesReturns, String> {
                Ok(GetCategoriesReturns {
                    categories: self.categories.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(categories))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetCategoriesParams {
            type Response = GetCategoriesReturns;
        }
        #[doc = "Record a clock sync marker in the trace.\n[recordClockSyncMarker](https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-recordClockSyncMarker)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RecordClockSyncMarkerParams {
            #[doc = "The ID of this clock sync marker"]
            #[serde(rename = "syncId")]
            pub sync_id: String,
        }
        impl RecordClockSyncMarkerParams {
            pub fn new(sync_id: impl Into<String>) -> Self {
                Self {
                    sync_id: sync_id.into(),
                }
            }
        }
        impl<T: Into<String>> From<T> for RecordClockSyncMarkerParams {
            fn from(url: T) -> Self {
                RecordClockSyncMarkerParams::new(url)
            }
        }
        impl RecordClockSyncMarkerParams {
            pub fn builder() -> RecordClockSyncMarkerParamsBuilder {
                RecordClockSyncMarkerParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RecordClockSyncMarkerParamsBuilder {
            sync_id: Option<String>,
        }
        impl RecordClockSyncMarkerParamsBuilder {
            pub fn sync_id(mut self, sync_id: impl Into<String>) -> Self {
                self.sync_id = Some(sync_id.into());
                self
            }
            pub fn build(self) -> Result<RecordClockSyncMarkerParams, String> {
                Ok(RecordClockSyncMarkerParams {
                    sync_id: self.sync_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(sync_id))
                    })?,
                })
            }
        }
        impl RecordClockSyncMarkerParams {
            pub const IDENTIFIER: &'static str = "Tracing.recordClockSyncMarker";
        }
        impl chromiumoxide_types::Method for RecordClockSyncMarkerParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RecordClockSyncMarkerParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Record a clock sync marker in the trace.\n[recordClockSyncMarker](https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-recordClockSyncMarker)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RecordClockSyncMarkerReturns {}
        impl chromiumoxide_types::Command for RecordClockSyncMarkerParams {
            type Response = RecordClockSyncMarkerReturns;
        }
        #[doc = "Request a global memory dump.\n[requestMemoryDump](https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-requestMemoryDump)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RequestMemoryDumpParams {
            #[doc = "Enables more deterministic results by forcing garbage collection"]
            #[serde(rename = "deterministic")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub deterministic: Option<bool>,
            #[doc = "Specifies level of details in memory dump. Defaults to \"detailed\"."]
            #[serde(rename = "levelOfDetail")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub level_of_detail: Option<MemoryDumpLevelOfDetail>,
        }
        impl RequestMemoryDumpParams {
            pub fn builder() -> RequestMemoryDumpParamsBuilder {
                RequestMemoryDumpParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestMemoryDumpParamsBuilder {
            deterministic: Option<bool>,
            level_of_detail: Option<MemoryDumpLevelOfDetail>,
        }
        impl RequestMemoryDumpParamsBuilder {
            pub fn deterministic(mut self, deterministic: impl Into<bool>) -> Self {
                self.deterministic = Some(deterministic.into());
                self
            }
            pub fn level_of_detail(
                mut self,
                level_of_detail: impl Into<MemoryDumpLevelOfDetail>,
            ) -> Self {
                self.level_of_detail = Some(level_of_detail.into());
                self
            }
            pub fn build(self) -> RequestMemoryDumpParams {
                RequestMemoryDumpParams {
                    deterministic: self.deterministic,
                    level_of_detail: self.level_of_detail,
                }
            }
        }
        impl RequestMemoryDumpParams {
            pub const IDENTIFIER: &'static str = "Tracing.requestMemoryDump";
        }
        impl chromiumoxide_types::Method for RequestMemoryDumpParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RequestMemoryDumpParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Request a global memory dump.\n[requestMemoryDump](https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-requestMemoryDump)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RequestMemoryDumpReturns {
            #[doc = "GUID of the resulting global memory dump."]
            #[serde(rename = "dumpGuid")]
            pub dump_guid: String,
            #[doc = "True iff the global memory dump succeeded."]
            #[serde(rename = "success")]
            pub success: bool,
        }
        impl RequestMemoryDumpReturns {
            pub fn new(dump_guid: impl Into<String>, success: impl Into<bool>) -> Self {
                Self {
                    dump_guid: dump_guid.into(),
                    success: success.into(),
                }
            }
        }
        impl RequestMemoryDumpReturns {
            pub fn builder() -> RequestMemoryDumpReturnsBuilder {
                RequestMemoryDumpReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestMemoryDumpReturnsBuilder {
            dump_guid: Option<String>,
            success: Option<bool>,
        }
        impl RequestMemoryDumpReturnsBuilder {
            pub fn dump_guid(mut self, dump_guid: impl Into<String>) -> Self {
                self.dump_guid = Some(dump_guid.into());
                self
            }
            pub fn success(mut self, success: impl Into<bool>) -> Self {
                self.success = Some(success.into());
                self
            }
            pub fn build(self) -> Result<RequestMemoryDumpReturns, String> {
                Ok(RequestMemoryDumpReturns {
                    dump_guid: self.dump_guid.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(dump_guid))
                    })?,
                    success: self.success.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(success))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for RequestMemoryDumpParams {
            type Response = RequestMemoryDumpReturns;
        }
        #[doc = "Start trace events collection.\n[start](https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-start)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartParams {
            #[doc = "If set, the agent will issue bufferUsage events at this interval, specified in milliseconds"]
            #[serde(rename = "bufferUsageReportingInterval")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub buffer_usage_reporting_interval: Option<f64>,
            #[doc = "Whether to report trace events as series of dataCollected events or to save trace to a\nstream (defaults to `ReportEvents`)."]
            #[serde(rename = "transferMode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub transfer_mode: Option<StartTransferMode>,
            #[doc = "Trace data format to use. This only applies when using `ReturnAsStream`\ntransfer mode (defaults to `json`)."]
            #[serde(rename = "streamFormat")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub stream_format: Option<StreamFormat>,
            #[doc = "Compression format to use. This only applies when using `ReturnAsStream`\ntransfer mode (defaults to `none`)"]
            #[serde(rename = "streamCompression")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub stream_compression: Option<StreamCompression>,
            #[serde(rename = "traceConfig")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub trace_config: Option<TraceConfig>,
            #[doc = "Base64-encoded serialized perfetto.protos.TraceConfig protobuf message\nWhen specified, the parameters `categories`, `options`, `traceConfig`\nare ignored."]
            #[serde(rename = "perfettoConfig")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub perfetto_config: Option<chromiumoxide_types::Binary>,
            #[doc = "Backend type (defaults to `auto`)"]
            #[serde(rename = "tracingBackend")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub tracing_backend: Option<TracingBackend>,
        }
        #[doc = "Whether to report trace events as series of dataCollected events or to save trace to a\nstream (defaults to `ReportEvents`)."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum StartTransferMode {
            #[serde(rename = "ReportEvents")]
            ReportEvents,
            #[serde(rename = "ReturnAsStream")]
            ReturnAsStream,
        }
        impl AsRef<str> for StartTransferMode {
            fn as_ref(&self) -> &str {
                match self {
                    StartTransferMode::ReportEvents => "ReportEvents",
                    StartTransferMode::ReturnAsStream => "ReturnAsStream",
                }
            }
        }
        impl ::std::str::FromStr for StartTransferMode {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "ReportEvents" | "reportevents" => Ok(StartTransferMode::ReportEvents),
                    "ReturnAsStream" | "returnasstream" => Ok(StartTransferMode::ReturnAsStream),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl StartParams {
            pub fn builder() -> StartParamsBuilder {
                StartParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct StartParamsBuilder {
            buffer_usage_reporting_interval: Option<f64>,
            transfer_mode: Option<StartTransferMode>,
            stream_format: Option<StreamFormat>,
            stream_compression: Option<StreamCompression>,
            trace_config: Option<TraceConfig>,
            perfetto_config: Option<chromiumoxide_types::Binary>,
            tracing_backend: Option<TracingBackend>,
        }
        impl StartParamsBuilder {
            pub fn buffer_usage_reporting_interval(
                mut self,
                buffer_usage_reporting_interval: impl Into<f64>,
            ) -> Self {
                self.buffer_usage_reporting_interval = Some(buffer_usage_reporting_interval.into());
                self
            }
            pub fn transfer_mode(mut self, transfer_mode: impl Into<StartTransferMode>) -> Self {
                self.transfer_mode = Some(transfer_mode.into());
                self
            }
            pub fn stream_format(mut self, stream_format: impl Into<StreamFormat>) -> Self {
                self.stream_format = Some(stream_format.into());
                self
            }
            pub fn stream_compression(
                mut self,
                stream_compression: impl Into<StreamCompression>,
            ) -> Self {
                self.stream_compression = Some(stream_compression.into());
                self
            }
            pub fn trace_config(mut self, trace_config: impl Into<TraceConfig>) -> Self {
                self.trace_config = Some(trace_config.into());
                self
            }
            pub fn perfetto_config(
                mut self,
                perfetto_config: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                self.perfetto_config = Some(perfetto_config.into());
                self
            }
            pub fn tracing_backend(mut self, tracing_backend: impl Into<TracingBackend>) -> Self {
                self.tracing_backend = Some(tracing_backend.into());
                self
            }
            pub fn build(self) -> StartParams {
                StartParams {
                    buffer_usage_reporting_interval: self.buffer_usage_reporting_interval,
                    transfer_mode: self.transfer_mode,
                    stream_format: self.stream_format,
                    stream_compression: self.stream_compression,
                    trace_config: self.trace_config,
                    perfetto_config: self.perfetto_config,
                    tracing_backend: self.tracing_backend,
                }
            }
        }
        impl StartParams {
            pub const IDENTIFIER: &'static str = "Tracing.start";
        }
        impl chromiumoxide_types::Method for StartParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for StartParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Start trace events collection.\n[start](https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-start)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct StartReturns {}
        impl chromiumoxide_types::Command for StartParams {
            type Response = StartReturns;
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EventBufferUsage {
            #[doc = "A number in range [0..1] that indicates the used size of event buffer as a fraction of its\ntotal size."]
            #[serde(rename = "percentFull")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub percent_full: Option<f64>,
            #[doc = "An approximate number of events in the trace log."]
            #[serde(rename = "eventCount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub event_count: Option<f64>,
            #[doc = "A number in range [0..1] that indicates the used size of event buffer as a fraction of its\ntotal size."]
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value: Option<f64>,
        }
        impl EventBufferUsage {
            pub const IDENTIFIER: &'static str = "Tracing.bufferUsage";
        }
        impl chromiumoxide_types::Method for EventBufferUsage {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventBufferUsage {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Contains an bucket of collected trace events. When tracing is stopped collected events will be\nsend as a sequence of dataCollected events followed by tracingComplete event.\n[dataCollected](https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#event-dataCollected)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventDataCollected {
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub value: Vec<serde_json::Value>,
        }
        impl EventDataCollected {
            pub const IDENTIFIER: &'static str = "Tracing.dataCollected";
        }
        impl chromiumoxide_types::Method for EventDataCollected {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventDataCollected {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Signals that tracing is stopped and there is no trace buffers pending flush, all data were\ndelivered via dataCollected events.\n[tracingComplete](https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#event-tracingComplete)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventTracingComplete {
            #[doc = "Indicates whether some trace data is known to have been lost, e.g. because the trace ring\nbuffer wrapped around."]
            #[serde(rename = "dataLossOccurred")]
            pub data_loss_occurred: bool,
            #[doc = "A handle of the stream that holds resulting trace data."]
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub stream: Option<super::io::StreamHandle>,
            #[doc = "Trace data format of returned stream."]
            #[serde(rename = "traceFormat")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub trace_format: Option<StreamFormat>,
            #[doc = "Compression format of returned stream."]
            #[serde(rename = "streamCompression")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub stream_compression: Option<StreamCompression>,
        }
        impl EventTracingComplete {
            pub const IDENTIFIER: &'static str = "Tracing.tracingComplete";
        }
        impl chromiumoxide_types::Method for EventTracingComplete {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventTracingComplete {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "A domain for letting clients substitute browser's network layer with client code."]
    pub mod fetch {
        use serde::{Deserialize, Serialize};
        #[doc = "Unique request identifier.\n[RequestId](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#type-RequestId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct RequestId(String);
        impl RequestId {
            pub fn new(val: impl Into<String>) -> Self {
                RequestId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for RequestId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<RequestId> for String {
            fn from(el: RequestId) -> String {
                el.0
            }
        }
        impl From<String> for RequestId {
            fn from(expr: String) -> Self {
                RequestId(expr)
            }
        }
        impl std::borrow::Borrow<str> for RequestId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl RequestId {
            pub const IDENTIFIER: &'static str = "Fetch.RequestId";
        }
        #[doc = "Stages of the request to handle. Request will intercept before the request is\nsent. Response will intercept after the response is received (but before response\nbody is received)."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum RequestStage {
            #[serde(rename = "Request")]
            Request,
            #[serde(rename = "Response")]
            Response,
        }
        impl AsRef<str> for RequestStage {
            fn as_ref(&self) -> &str {
                match self {
                    RequestStage::Request => "Request",
                    RequestStage::Response => "Response",
                }
            }
        }
        impl ::std::str::FromStr for RequestStage {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Request" | "request" => Ok(RequestStage::Request),
                    "Response" | "response" => Ok(RequestStage::Response),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RequestPattern {
            #[doc = "Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is\nbackslash. Omitting is equivalent to `\"*\"`."]
            #[serde(rename = "urlPattern")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url_pattern: Option<String>,
            #[doc = "If set, only requests for matching resource types will be intercepted."]
            #[serde(rename = "resourceType")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub resource_type: Option<super::network::ResourceType>,
            #[doc = "Stage at which to begin intercepting requests. Default is Request."]
            #[serde(rename = "requestStage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub request_stage: Option<RequestStage>,
        }
        impl RequestPattern {
            pub fn builder() -> RequestPatternBuilder {
                RequestPatternBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RequestPatternBuilder {
            url_pattern: Option<String>,
            resource_type: Option<super::network::ResourceType>,
            request_stage: Option<RequestStage>,
        }
        impl RequestPatternBuilder {
            pub fn url_pattern(mut self, url_pattern: impl Into<String>) -> Self {
                self.url_pattern = Some(url_pattern.into());
                self
            }
            pub fn resource_type(
                mut self,
                resource_type: impl Into<super::network::ResourceType>,
            ) -> Self {
                self.resource_type = Some(resource_type.into());
                self
            }
            pub fn request_stage(mut self, request_stage: impl Into<RequestStage>) -> Self {
                self.request_stage = Some(request_stage.into());
                self
            }
            pub fn build(self) -> RequestPattern {
                RequestPattern {
                    url_pattern: self.url_pattern,
                    resource_type: self.resource_type,
                    request_stage: self.request_stage,
                }
            }
        }
        impl RequestPattern {
            pub const IDENTIFIER: &'static str = "Fetch.RequestPattern";
        }
        #[doc = "Response HTTP header entry\n[HeaderEntry](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#type-HeaderEntry)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct HeaderEntry {
            #[serde(rename = "name")]
            pub name: String,
            #[serde(rename = "value")]
            pub value: String,
        }
        impl HeaderEntry {
            pub fn new(name: impl Into<String>, value: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                }
            }
        }
        impl HeaderEntry {
            pub fn builder() -> HeaderEntryBuilder {
                HeaderEntryBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct HeaderEntryBuilder {
            name: Option<String>,
            value: Option<String>,
        }
        impl HeaderEntryBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<HeaderEntry, String> {
                Ok(HeaderEntry {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl HeaderEntry {
            pub const IDENTIFIER: &'static str = "Fetch.HeaderEntry";
        }
        #[doc = "Authorization challenge for HTTP status code 401 or 407.\n[AuthChallenge](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#type-AuthChallenge)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AuthChallenge {
            #[doc = "Source of the authentication challenge."]
            #[serde(rename = "source")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub source: Option<AuthChallengeSource>,
            #[doc = "Origin of the challenger."]
            #[serde(rename = "origin")]
            pub origin: String,
            #[doc = "The authentication scheme used, such as basic or digest"]
            #[serde(rename = "scheme")]
            pub scheme: String,
            #[doc = "The realm of the challenge. May be empty."]
            #[serde(rename = "realm")]
            pub realm: String,
        }
        #[doc = "Source of the authentication challenge."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AuthChallengeSource {
            #[serde(rename = "Server")]
            Server,
            #[serde(rename = "Proxy")]
            Proxy,
        }
        impl AsRef<str> for AuthChallengeSource {
            fn as_ref(&self) -> &str {
                match self {
                    AuthChallengeSource::Server => "Server",
                    AuthChallengeSource::Proxy => "Proxy",
                }
            }
        }
        impl ::std::str::FromStr for AuthChallengeSource {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Server" | "server" => Ok(AuthChallengeSource::Server),
                    "Proxy" | "proxy" => Ok(AuthChallengeSource::Proxy),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl AuthChallenge {
            pub fn new(
                origin: impl Into<String>,
                scheme: impl Into<String>,
                realm: impl Into<String>,
            ) -> Self {
                Self {
                    origin: origin.into(),
                    scheme: scheme.into(),
                    realm: realm.into(),
                    source: None,
                }
            }
        }
        impl AuthChallenge {
            pub fn builder() -> AuthChallengeBuilder {
                AuthChallengeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AuthChallengeBuilder {
            source: Option<AuthChallengeSource>,
            origin: Option<String>,
            scheme: Option<String>,
            realm: Option<String>,
        }
        impl AuthChallengeBuilder {
            pub fn source(mut self, source: impl Into<AuthChallengeSource>) -> Self {
                self.source = Some(source.into());
                self
            }
            pub fn origin(mut self, origin: impl Into<String>) -> Self {
                self.origin = Some(origin.into());
                self
            }
            pub fn scheme(mut self, scheme: impl Into<String>) -> Self {
                self.scheme = Some(scheme.into());
                self
            }
            pub fn realm(mut self, realm: impl Into<String>) -> Self {
                self.realm = Some(realm.into());
                self
            }
            pub fn build(self) -> Result<AuthChallenge, String> {
                Ok(AuthChallenge {
                    source: self.source,
                    origin: self.origin.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(origin))
                    })?,
                    scheme: self.scheme.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(scheme))
                    })?,
                    realm: self.realm.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(realm))
                    })?,
                })
            }
        }
        impl AuthChallenge {
            pub const IDENTIFIER: &'static str = "Fetch.AuthChallenge";
        }
        #[doc = "Response to an AuthChallenge.\n[AuthChallengeResponse](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#type-AuthChallengeResponse)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AuthChallengeResponse {
            #[doc = "The decision on what to do in response to the authorization challenge.  Default means\ndeferring to the default behavior of the net stack, which will likely either the Cancel\nauthentication or display a popup dialog box."]
            #[serde(rename = "response")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub response: AuthChallengeResponseResponse,
            #[doc = "The username to provide, possibly empty. Should only be set if response is\nProvideCredentials."]
            #[serde(rename = "username")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub username: Option<String>,
            #[doc = "The password to provide, possibly empty. Should only be set if response is\nProvideCredentials."]
            #[serde(rename = "password")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub password: Option<String>,
        }
        #[doc = "The decision on what to do in response to the authorization challenge.  Default means\ndeferring to the default behavior of the net stack, which will likely either the Cancel\nauthentication or display a popup dialog box."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AuthChallengeResponseResponse {
            #[serde(rename = "Default")]
            Default,
            #[serde(rename = "CancelAuth")]
            CancelAuth,
            #[serde(rename = "ProvideCredentials")]
            ProvideCredentials,
        }
        impl AsRef<str> for AuthChallengeResponseResponse {
            fn as_ref(&self) -> &str {
                match self {
                    AuthChallengeResponseResponse::Default => "Default",
                    AuthChallengeResponseResponse::CancelAuth => "CancelAuth",
                    AuthChallengeResponseResponse::ProvideCredentials => "ProvideCredentials",
                }
            }
        }
        impl ::std::str::FromStr for AuthChallengeResponseResponse {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "Default" | "default" => Ok(AuthChallengeResponseResponse::Default),
                    "CancelAuth" | "cancelauth" => Ok(AuthChallengeResponseResponse::CancelAuth),
                    "ProvideCredentials" | "providecredentials" => {
                        Ok(AuthChallengeResponseResponse::ProvideCredentials)
                    }
                    _ => Err(s.to_string()),
                }
            }
        }
        impl AuthChallengeResponse {
            pub fn new(response: impl Into<AuthChallengeResponseResponse>) -> Self {
                Self {
                    response: response.into(),
                    username: None,
                    password: None,
                }
            }
        }
        impl AuthChallengeResponse {
            pub fn builder() -> AuthChallengeResponseBuilder {
                AuthChallengeResponseBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AuthChallengeResponseBuilder {
            response: Option<AuthChallengeResponseResponse>,
            username: Option<String>,
            password: Option<String>,
        }
        impl AuthChallengeResponseBuilder {
            pub fn response(mut self, response: impl Into<AuthChallengeResponseResponse>) -> Self {
                self.response = Some(response.into());
                self
            }
            pub fn username(mut self, username: impl Into<String>) -> Self {
                self.username = Some(username.into());
                self
            }
            pub fn password(mut self, password: impl Into<String>) -> Self {
                self.password = Some(password.into());
                self
            }
            pub fn build(self) -> Result<AuthChallengeResponse, String> {
                Ok(AuthChallengeResponse {
                    response: self.response.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(response))
                    })?,
                    username: self.username,
                    password: self.password,
                })
            }
        }
        impl AuthChallengeResponse {
            pub const IDENTIFIER: &'static str = "Fetch.AuthChallengeResponse";
        }
        #[doc = "Disables the fetch domain.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Fetch.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables the fetch domain.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Enables issuing of requestPaused events. A request will be paused until client\ncalls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {
            #[doc = "If specified, only requests matching any of these patterns will produce\nfetchRequested event and will be paused until clients response. If not set,\nall requests will be affected."]
            #[serde(rename = "patterns")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub patterns: Option<Vec<RequestPattern>>,
            #[doc = "If true, authRequired events will be issued and requests will be paused\nexpecting a call to continueWithAuth."]
            #[serde(rename = "handleAuthRequests")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub handle_auth_requests: Option<bool>,
        }
        impl EnableParams {
            pub fn builder() -> EnableParamsBuilder {
                EnableParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EnableParamsBuilder {
            patterns: Option<Vec<RequestPattern>>,
            handle_auth_requests: Option<bool>,
        }
        impl EnableParamsBuilder {
            pub fn pattern(mut self, pattern: impl Into<RequestPattern>) -> Self {
                let v = self.patterns.get_or_insert(Vec::new());
                v.push(pattern.into());
                self
            }
            pub fn patterns<I, S>(mut self, patterns: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<RequestPattern>,
            {
                let v = self.patterns.get_or_insert(Vec::new());
                for val in patterns {
                    v.push(val.into());
                }
                self
            }
            pub fn handle_auth_requests(mut self, handle_auth_requests: impl Into<bool>) -> Self {
                self.handle_auth_requests = Some(handle_auth_requests.into());
                self
            }
            pub fn build(self) -> EnableParams {
                EnableParams {
                    patterns: self.patterns,
                    handle_auth_requests: self.handle_auth_requests,
                }
            }
        }
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Fetch.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables issuing of requestPaused events. A request will be paused until client\ncalls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Causes the request to fail with specified reason.\n[failRequest](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-failRequest)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct FailRequestParams {
            #[doc = "An id the client received in requestPaused event."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Causes the request to fail with the given reason."]
            #[serde(rename = "errorReason")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub error_reason: super::network::ErrorReason,
        }
        impl FailRequestParams {
            pub fn new(
                request_id: impl Into<RequestId>,
                error_reason: impl Into<super::network::ErrorReason>,
            ) -> Self {
                Self {
                    request_id: request_id.into(),
                    error_reason: error_reason.into(),
                }
            }
        }
        impl FailRequestParams {
            pub fn builder() -> FailRequestParamsBuilder {
                FailRequestParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FailRequestParamsBuilder {
            request_id: Option<RequestId>,
            error_reason: Option<super::network::ErrorReason>,
        }
        impl FailRequestParamsBuilder {
            pub fn request_id(mut self, request_id: impl Into<RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn error_reason(
                mut self,
                error_reason: impl Into<super::network::ErrorReason>,
            ) -> Self {
                self.error_reason = Some(error_reason.into());
                self
            }
            pub fn build(self) -> Result<FailRequestParams, String> {
                Ok(FailRequestParams {
                    request_id: self.request_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_id))
                    })?,
                    error_reason: self.error_reason.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(error_reason))
                    })?,
                })
            }
        }
        impl FailRequestParams {
            pub const IDENTIFIER: &'static str = "Fetch.failRequest";
        }
        impl chromiumoxide_types::Method for FailRequestParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for FailRequestParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Causes the request to fail with specified reason.\n[failRequest](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-failRequest)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct FailRequestReturns {}
        impl chromiumoxide_types::Command for FailRequestParams {
            type Response = FailRequestReturns;
        }
        #[doc = "Provides response to the request.\n[fulfillRequest](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-fulfillRequest)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct FulfillRequestParams {
            #[doc = "An id the client received in requestPaused event."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "An HTTP response code."]
            #[serde(rename = "responseCode")]
            pub response_code: i64,
            #[doc = "Response headers."]
            #[serde(rename = "responseHeaders")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub response_headers: Option<Vec<HeaderEntry>>,
            #[doc = "Alternative way of specifying response headers as a \\0-separated\nseries of name: value pairs. Prefer the above method unless you\nneed to represent some non-UTF8 values that can't be transmitted\nover the protocol as text."]
            #[serde(rename = "binaryResponseHeaders")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub binary_response_headers: Option<chromiumoxide_types::Binary>,
            #[doc = "A response body. If absent, original response body will be used if\nthe request is intercepted at the response stage and empty body\nwill be used if the request is intercepted at the request stage."]
            #[serde(rename = "body")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub body: Option<chromiumoxide_types::Binary>,
            #[doc = "A textual representation of responseCode.\nIf absent, a standard phrase matching responseCode is used."]
            #[serde(rename = "responsePhrase")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub response_phrase: Option<String>,
        }
        impl FulfillRequestParams {
            pub fn new(request_id: impl Into<RequestId>, response_code: impl Into<i64>) -> Self {
                Self {
                    request_id: request_id.into(),
                    response_code: response_code.into(),
                    response_headers: None,
                    binary_response_headers: None,
                    body: None,
                    response_phrase: None,
                }
            }
        }
        impl FulfillRequestParams {
            pub fn builder() -> FulfillRequestParamsBuilder {
                FulfillRequestParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct FulfillRequestParamsBuilder {
            request_id: Option<RequestId>,
            response_code: Option<i64>,
            response_headers: Option<Vec<HeaderEntry>>,
            binary_response_headers: Option<chromiumoxide_types::Binary>,
            body: Option<chromiumoxide_types::Binary>,
            response_phrase: Option<String>,
        }
        impl FulfillRequestParamsBuilder {
            pub fn request_id(mut self, request_id: impl Into<RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn response_code(mut self, response_code: impl Into<i64>) -> Self {
                self.response_code = Some(response_code.into());
                self
            }
            pub fn response_header(mut self, response_header: impl Into<HeaderEntry>) -> Self {
                let v = self.response_headers.get_or_insert(Vec::new());
                v.push(response_header.into());
                self
            }
            pub fn response_headers<I, S>(mut self, response_headers: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<HeaderEntry>,
            {
                let v = self.response_headers.get_or_insert(Vec::new());
                for val in response_headers {
                    v.push(val.into());
                }
                self
            }
            pub fn binary_response_headers(
                mut self,
                binary_response_headers: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                self.binary_response_headers = Some(binary_response_headers.into());
                self
            }
            pub fn body(mut self, body: impl Into<chromiumoxide_types::Binary>) -> Self {
                self.body = Some(body.into());
                self
            }
            pub fn response_phrase(mut self, response_phrase: impl Into<String>) -> Self {
                self.response_phrase = Some(response_phrase.into());
                self
            }
            pub fn build(self) -> Result<FulfillRequestParams, String> {
                Ok(FulfillRequestParams {
                    request_id: self.request_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_id))
                    })?,
                    response_code: self.response_code.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(response_code))
                    })?,
                    response_headers: self.response_headers,
                    binary_response_headers: self.binary_response_headers,
                    body: self.body,
                    response_phrase: self.response_phrase,
                })
            }
        }
        impl FulfillRequestParams {
            pub const IDENTIFIER: &'static str = "Fetch.fulfillRequest";
        }
        impl chromiumoxide_types::Method for FulfillRequestParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for FulfillRequestParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Provides response to the request.\n[fulfillRequest](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-fulfillRequest)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct FulfillRequestReturns {}
        impl chromiumoxide_types::Command for FulfillRequestParams {
            type Response = FulfillRequestReturns;
        }
        #[doc = "Continues the request, optionally modifying some of its parameters.\n[continueRequest](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueRequest)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ContinueRequestParams {
            #[doc = "An id the client received in requestPaused event."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "If set, the request url will be modified in a way that's not observable by page."]
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub url: Option<String>,
            #[doc = "If set, the request method is overridden."]
            #[serde(rename = "method")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub method: Option<String>,
            #[doc = "If set, overrides the post data in the request."]
            #[serde(rename = "postData")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub post_data: Option<chromiumoxide_types::Binary>,
            #[doc = "If set, overrides the request headers."]
            #[serde(rename = "headers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub headers: Option<Vec<HeaderEntry>>,
            #[doc = "If set, overrides response interception behavior for this request."]
            #[serde(rename = "interceptResponse")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub intercept_response: Option<bool>,
        }
        impl ContinueRequestParams {
            pub fn new(request_id: impl Into<RequestId>) -> Self {
                Self {
                    request_id: request_id.into(),
                    url: None,
                    method: None,
                    post_data: None,
                    headers: None,
                    intercept_response: None,
                }
            }
        }
        impl ContinueRequestParams {
            pub fn builder() -> ContinueRequestParamsBuilder {
                ContinueRequestParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ContinueRequestParamsBuilder {
            request_id: Option<RequestId>,
            url: Option<String>,
            method: Option<String>,
            post_data: Option<chromiumoxide_types::Binary>,
            headers: Option<Vec<HeaderEntry>>,
            intercept_response: Option<bool>,
        }
        impl ContinueRequestParamsBuilder {
            pub fn request_id(mut self, request_id: impl Into<RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn url(mut self, url: impl Into<String>) -> Self {
                self.url = Some(url.into());
                self
            }
            pub fn method(mut self, method: impl Into<String>) -> Self {
                self.method = Some(method.into());
                self
            }
            pub fn post_data(mut self, post_data: impl Into<chromiumoxide_types::Binary>) -> Self {
                self.post_data = Some(post_data.into());
                self
            }
            pub fn header(mut self, header: impl Into<HeaderEntry>) -> Self {
                let v = self.headers.get_or_insert(Vec::new());
                v.push(header.into());
                self
            }
            pub fn headers<I, S>(mut self, headers: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<HeaderEntry>,
            {
                let v = self.headers.get_or_insert(Vec::new());
                for val in headers {
                    v.push(val.into());
                }
                self
            }
            pub fn intercept_response(mut self, intercept_response: impl Into<bool>) -> Self {
                self.intercept_response = Some(intercept_response.into());
                self
            }
            pub fn build(self) -> Result<ContinueRequestParams, String> {
                Ok(ContinueRequestParams {
                    request_id: self.request_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_id))
                    })?,
                    url: self.url,
                    method: self.method,
                    post_data: self.post_data,
                    headers: self.headers,
                    intercept_response: self.intercept_response,
                })
            }
        }
        impl ContinueRequestParams {
            pub const IDENTIFIER: &'static str = "Fetch.continueRequest";
        }
        impl chromiumoxide_types::Method for ContinueRequestParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ContinueRequestParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Continues the request, optionally modifying some of its parameters.\n[continueRequest](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueRequest)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ContinueRequestReturns {}
        impl chromiumoxide_types::Command for ContinueRequestParams {
            type Response = ContinueRequestReturns;
        }
        #[doc = "Continues a request supplying authChallengeResponse following authRequired event.\n[continueWithAuth](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueWithAuth)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ContinueWithAuthParams {
            #[doc = "An id the client received in authRequired event."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "Response to  with an authChallenge."]
            #[serde(rename = "authChallengeResponse")]
            pub auth_challenge_response: AuthChallengeResponse,
        }
        impl ContinueWithAuthParams {
            pub fn new(
                request_id: impl Into<RequestId>,
                auth_challenge_response: impl Into<AuthChallengeResponse>,
            ) -> Self {
                Self {
                    request_id: request_id.into(),
                    auth_challenge_response: auth_challenge_response.into(),
                }
            }
        }
        impl ContinueWithAuthParams {
            pub fn builder() -> ContinueWithAuthParamsBuilder {
                ContinueWithAuthParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ContinueWithAuthParamsBuilder {
            request_id: Option<RequestId>,
            auth_challenge_response: Option<AuthChallengeResponse>,
        }
        impl ContinueWithAuthParamsBuilder {
            pub fn request_id(mut self, request_id: impl Into<RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn auth_challenge_response(
                mut self,
                auth_challenge_response: impl Into<AuthChallengeResponse>,
            ) -> Self {
                self.auth_challenge_response = Some(auth_challenge_response.into());
                self
            }
            pub fn build(self) -> Result<ContinueWithAuthParams, String> {
                Ok(ContinueWithAuthParams {
                    request_id: self.request_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_id))
                    })?,
                    auth_challenge_response: self.auth_challenge_response.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(auth_challenge_response)
                        )
                    })?,
                })
            }
        }
        impl ContinueWithAuthParams {
            pub const IDENTIFIER: &'static str = "Fetch.continueWithAuth";
        }
        impl chromiumoxide_types::Method for ContinueWithAuthParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ContinueWithAuthParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Continues a request supplying authChallengeResponse following authRequired event.\n[continueWithAuth](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueWithAuth)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ContinueWithAuthReturns {}
        impl chromiumoxide_types::Command for ContinueWithAuthParams {
            type Response = ContinueWithAuthReturns;
        }
        #[doc = "Continues loading of the paused response, optionally modifying the\nresponse headers. If either responseCode or headers are modified, all of them\nmust be present.\n[continueResponse](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueResponse)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ContinueResponseParams {
            #[doc = "An id the client received in requestPaused event."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "An HTTP response code. If absent, original response code will be used."]
            #[serde(rename = "responseCode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub response_code: Option<i64>,
            #[doc = "A textual representation of responseCode.\nIf absent, a standard phrase matching responseCode is used."]
            #[serde(rename = "responsePhrase")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub response_phrase: Option<String>,
            #[doc = "Response headers. If absent, original response headers will be used."]
            #[serde(rename = "responseHeaders")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub response_headers: Option<Vec<HeaderEntry>>,
            #[doc = "Alternative way of specifying response headers as a \\0-separated\nseries of name: value pairs. Prefer the above method unless you\nneed to represent some non-UTF8 values that can't be transmitted\nover the protocol as text."]
            #[serde(rename = "binaryResponseHeaders")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub binary_response_headers: Option<chromiumoxide_types::Binary>,
        }
        impl ContinueResponseParams {
            pub fn new(request_id: impl Into<RequestId>) -> Self {
                Self {
                    request_id: request_id.into(),
                    response_code: None,
                    response_phrase: None,
                    response_headers: None,
                    binary_response_headers: None,
                }
            }
        }
        impl ContinueResponseParams {
            pub fn builder() -> ContinueResponseParamsBuilder {
                ContinueResponseParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ContinueResponseParamsBuilder {
            request_id: Option<RequestId>,
            response_code: Option<i64>,
            response_phrase: Option<String>,
            response_headers: Option<Vec<HeaderEntry>>,
            binary_response_headers: Option<chromiumoxide_types::Binary>,
        }
        impl ContinueResponseParamsBuilder {
            pub fn request_id(mut self, request_id: impl Into<RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn response_code(mut self, response_code: impl Into<i64>) -> Self {
                self.response_code = Some(response_code.into());
                self
            }
            pub fn response_phrase(mut self, response_phrase: impl Into<String>) -> Self {
                self.response_phrase = Some(response_phrase.into());
                self
            }
            pub fn response_header(mut self, response_header: impl Into<HeaderEntry>) -> Self {
                let v = self.response_headers.get_or_insert(Vec::new());
                v.push(response_header.into());
                self
            }
            pub fn response_headers<I, S>(mut self, response_headers: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<HeaderEntry>,
            {
                let v = self.response_headers.get_or_insert(Vec::new());
                for val in response_headers {
                    v.push(val.into());
                }
                self
            }
            pub fn binary_response_headers(
                mut self,
                binary_response_headers: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                self.binary_response_headers = Some(binary_response_headers.into());
                self
            }
            pub fn build(self) -> Result<ContinueResponseParams, String> {
                Ok(ContinueResponseParams {
                    request_id: self.request_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_id))
                    })?,
                    response_code: self.response_code,
                    response_phrase: self.response_phrase,
                    response_headers: self.response_headers,
                    binary_response_headers: self.binary_response_headers,
                })
            }
        }
        impl ContinueResponseParams {
            pub const IDENTIFIER: &'static str = "Fetch.continueResponse";
        }
        impl chromiumoxide_types::Method for ContinueResponseParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ContinueResponseParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Continues loading of the paused response, optionally modifying the\nresponse headers. If either responseCode or headers are modified, all of them\nmust be present.\n[continueResponse](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueResponse)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ContinueResponseReturns {}
        impl chromiumoxide_types::Command for ContinueResponseParams {
            type Response = ContinueResponseReturns;
        }
        #[doc = "Causes the body of the response to be received from the server and\nreturned as a single string. May only be issued for a request that\nis paused in the Response stage and is mutually exclusive with\ntakeResponseBodyForInterceptionAsStream. Calling other methods that\naffect the request or disabling fetch domain before body is received\nresults in an undefined behavior.\n[getResponseBody](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-getResponseBody)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetResponseBodyParams {
            #[doc = "Identifier for the intercepted request to get body for."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
        }
        impl GetResponseBodyParams {
            pub fn new(request_id: impl Into<RequestId>) -> Self {
                Self {
                    request_id: request_id.into(),
                }
            }
        }
        impl GetResponseBodyParams {
            pub fn builder() -> GetResponseBodyParamsBuilder {
                GetResponseBodyParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetResponseBodyParamsBuilder {
            request_id: Option<RequestId>,
        }
        impl GetResponseBodyParamsBuilder {
            pub fn request_id(mut self, request_id: impl Into<RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn build(self) -> Result<GetResponseBodyParams, String> {
                Ok(GetResponseBodyParams {
                    request_id: self.request_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_id))
                    })?,
                })
            }
        }
        impl GetResponseBodyParams {
            pub const IDENTIFIER: &'static str = "Fetch.getResponseBody";
        }
        impl chromiumoxide_types::Method for GetResponseBodyParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetResponseBodyParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Causes the body of the response to be received from the server and\nreturned as a single string. May only be issued for a request that\nis paused in the Response stage and is mutually exclusive with\ntakeResponseBodyForInterceptionAsStream. Calling other methods that\naffect the request or disabling fetch domain before body is received\nresults in an undefined behavior.\n[getResponseBody](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-getResponseBody)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetResponseBodyReturns {
            #[doc = "Response body."]
            #[serde(rename = "body")]
            pub body: String,
            #[doc = "True, if content was sent as base64."]
            #[serde(rename = "base64Encoded")]
            pub base64_encoded: bool,
        }
        impl GetResponseBodyReturns {
            pub fn new(body: impl Into<String>, base64_encoded: impl Into<bool>) -> Self {
                Self {
                    body: body.into(),
                    base64_encoded: base64_encoded.into(),
                }
            }
        }
        impl GetResponseBodyReturns {
            pub fn builder() -> GetResponseBodyReturnsBuilder {
                GetResponseBodyReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetResponseBodyReturnsBuilder {
            body: Option<String>,
            base64_encoded: Option<bool>,
        }
        impl GetResponseBodyReturnsBuilder {
            pub fn body(mut self, body: impl Into<String>) -> Self {
                self.body = Some(body.into());
                self
            }
            pub fn base64_encoded(mut self, base64_encoded: impl Into<bool>) -> Self {
                self.base64_encoded = Some(base64_encoded.into());
                self
            }
            pub fn build(self) -> Result<GetResponseBodyReturns, String> {
                Ok(GetResponseBodyReturns {
                    body: self.body.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(body))
                    })?,
                    base64_encoded: self.base64_encoded.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(base64_encoded))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetResponseBodyParams {
            type Response = GetResponseBodyReturns;
        }
        #[doc = "Returns a handle to the stream representing the response body.\nThe request must be paused in the HeadersReceived stage.\nNote that after this command the request can't be continued\nas is -- client either needs to cancel it or to provide the\nresponse body.\nThe stream only supports sequential read, IO.read will fail if the position\nis specified.\nThis method is mutually exclusive with getResponseBody.\nCalling other methods that affect the request or disabling fetch\ndomain before body is received results in an undefined behavior.\n[takeResponseBodyAsStream](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-takeResponseBodyAsStream)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TakeResponseBodyAsStreamParams {
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
        }
        impl TakeResponseBodyAsStreamParams {
            pub fn new(request_id: impl Into<RequestId>) -> Self {
                Self {
                    request_id: request_id.into(),
                }
            }
        }
        impl TakeResponseBodyAsStreamParams {
            pub fn builder() -> TakeResponseBodyAsStreamParamsBuilder {
                TakeResponseBodyAsStreamParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TakeResponseBodyAsStreamParamsBuilder {
            request_id: Option<RequestId>,
        }
        impl TakeResponseBodyAsStreamParamsBuilder {
            pub fn request_id(mut self, request_id: impl Into<RequestId>) -> Self {
                self.request_id = Some(request_id.into());
                self
            }
            pub fn build(self) -> Result<TakeResponseBodyAsStreamParams, String> {
                Ok(TakeResponseBodyAsStreamParams {
                    request_id: self.request_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(request_id))
                    })?,
                })
            }
        }
        impl TakeResponseBodyAsStreamParams {
            pub const IDENTIFIER: &'static str = "Fetch.takeResponseBodyAsStream";
        }
        impl chromiumoxide_types::Method for TakeResponseBodyAsStreamParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for TakeResponseBodyAsStreamParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns a handle to the stream representing the response body.\nThe request must be paused in the HeadersReceived stage.\nNote that after this command the request can't be continued\nas is -- client either needs to cancel it or to provide the\nresponse body.\nThe stream only supports sequential read, IO.read will fail if the position\nis specified.\nThis method is mutually exclusive with getResponseBody.\nCalling other methods that affect the request or disabling fetch\ndomain before body is received results in an undefined behavior.\n[takeResponseBodyAsStream](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-takeResponseBodyAsStream)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct TakeResponseBodyAsStreamReturns {
            #[serde(rename = "stream")]
            pub stream: super::io::StreamHandle,
        }
        impl TakeResponseBodyAsStreamReturns {
            pub fn new(stream: impl Into<super::io::StreamHandle>) -> Self {
                Self {
                    stream: stream.into(),
                }
            }
        }
        impl TakeResponseBodyAsStreamReturns {
            pub fn builder() -> TakeResponseBodyAsStreamReturnsBuilder {
                TakeResponseBodyAsStreamReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct TakeResponseBodyAsStreamReturnsBuilder {
            stream: Option<super::io::StreamHandle>,
        }
        impl TakeResponseBodyAsStreamReturnsBuilder {
            pub fn stream(mut self, stream: impl Into<super::io::StreamHandle>) -> Self {
                self.stream = Some(stream.into());
                self
            }
            pub fn build(self) -> Result<TakeResponseBodyAsStreamReturns, String> {
                Ok(TakeResponseBodyAsStreamReturns {
                    stream: self.stream.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(stream))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for TakeResponseBodyAsStreamParams {
            type Response = TakeResponseBodyAsStreamReturns;
        }
        #[doc = "Issued when the domain is enabled and the request URL matches the\nspecified filter. The request is paused until the client responds\nwith one of continueRequest, failRequest or fulfillRequest.\nThe stage of the request can be determined by presence of responseErrorReason\nand responseStatusCode -- the request is at the response stage if either\nof these fields is present and in the request stage otherwise.\n[requestPaused](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#event-requestPaused)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventRequestPaused {
            #[doc = "Each request the page makes will have a unique id."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "The details of the request."]
            #[serde(rename = "request")]
            pub request: super::network::Request,
            #[doc = "The id of the frame that initiated the request."]
            #[serde(rename = "frameId")]
            pub frame_id: super::page::FrameId,
            #[doc = "How the requested resource will be used."]
            #[serde(rename = "resourceType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub resource_type: super::network::ResourceType,
            #[doc = "Response error if intercepted at response stage."]
            #[serde(rename = "responseErrorReason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub response_error_reason: Option<super::network::ErrorReason>,
            #[doc = "Response code if intercepted at response stage."]
            #[serde(rename = "responseStatusCode")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub response_status_code: Option<i64>,
            #[doc = "Response status text if intercepted at response stage."]
            #[serde(rename = "responseStatusText")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub response_status_text: Option<String>,
            #[doc = "Response headers if intercepted at the response stage."]
            #[serde(rename = "responseHeaders")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub response_headers: Option<Vec<HeaderEntry>>,
            #[doc = "If the intercepted request had a corresponding Network.requestWillBeSent event fired for it,\nthen this networkId will be the same as the requestId present in the requestWillBeSent event."]
            #[serde(rename = "networkId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub network_id: Option<RequestId>,
        }
        impl EventRequestPaused {
            pub const IDENTIFIER: &'static str = "Fetch.requestPaused";
        }
        impl chromiumoxide_types::Method for EventRequestPaused {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventRequestPaused {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Issued when the domain is enabled with handleAuthRequests set to true.\nThe request is paused until client responds with continueWithAuth.\n[authRequired](https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#event-authRequired)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAuthRequired {
            #[doc = "Each request the page makes will have a unique id."]
            #[serde(rename = "requestId")]
            pub request_id: RequestId,
            #[doc = "The details of the request."]
            #[serde(rename = "request")]
            pub request: super::network::Request,
            #[doc = "The id of the frame that initiated the request."]
            #[serde(rename = "frameId")]
            pub frame_id: super::page::FrameId,
            #[doc = "How the requested resource will be used."]
            #[serde(rename = "resourceType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub resource_type: super::network::ResourceType,
            #[doc = "Details of the Authorization Challenge encountered.\nIf this is set, client should respond with continueRequest that\ncontains AuthChallengeResponse."]
            #[serde(rename = "authChallenge")]
            pub auth_challenge: AuthChallenge,
        }
        impl EventAuthRequired {
            pub const IDENTIFIER: &'static str = "Fetch.authRequired";
        }
        impl chromiumoxide_types::Method for EventAuthRequired {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAuthRequired {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "This domain allows inspection of Web Audio API.\nhttps://webaudio.github.io/web-audio-api/"]
    pub mod web_audio {
        use serde::{Deserialize, Serialize};
        #[doc = "An unique ID for a graph object (AudioContext, AudioNode, AudioParam) in Web Audio API\n[GraphObjectId](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#type-GraphObjectId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct GraphObjectId(String);
        impl GraphObjectId {
            pub fn new(val: impl Into<String>) -> Self {
                GraphObjectId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for GraphObjectId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<GraphObjectId> for String {
            fn from(el: GraphObjectId) -> String {
                el.0
            }
        }
        impl From<String> for GraphObjectId {
            fn from(expr: String) -> Self {
                GraphObjectId(expr)
            }
        }
        impl std::borrow::Borrow<str> for GraphObjectId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl GraphObjectId {
            pub const IDENTIFIER: &'static str = "WebAudio.GraphObjectId";
        }
        #[doc = "Enum of BaseAudioContext types"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ContextType {
            #[serde(rename = "realtime")]
            Realtime,
            #[serde(rename = "offline")]
            Offline,
        }
        impl AsRef<str> for ContextType {
            fn as_ref(&self) -> &str {
                match self {
                    ContextType::Realtime => "realtime",
                    ContextType::Offline => "offline",
                }
            }
        }
        impl ::std::str::FromStr for ContextType {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "realtime" | "Realtime" => Ok(ContextType::Realtime),
                    "offline" | "Offline" => Ok(ContextType::Offline),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Enum of AudioContextState from the spec"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ContextState {
            #[serde(rename = "suspended")]
            Suspended,
            #[serde(rename = "running")]
            Running,
            #[serde(rename = "closed")]
            Closed,
        }
        impl AsRef<str> for ContextState {
            fn as_ref(&self) -> &str {
                match self {
                    ContextState::Suspended => "suspended",
                    ContextState::Running => "running",
                    ContextState::Closed => "closed",
                }
            }
        }
        impl ::std::str::FromStr for ContextState {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "suspended" | "Suspended" => Ok(ContextState::Suspended),
                    "running" | "Running" => Ok(ContextState::Running),
                    "closed" | "Closed" => Ok(ContextState::Closed),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Enum of AudioNode types\n[NodeType](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#type-NodeType)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct NodeType(String);
        impl NodeType {
            pub fn new(val: impl Into<String>) -> Self {
                NodeType(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for NodeType {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<NodeType> for String {
            fn from(el: NodeType) -> String {
                el.0
            }
        }
        impl From<String> for NodeType {
            fn from(expr: String) -> Self {
                NodeType(expr)
            }
        }
        impl NodeType {
            pub const IDENTIFIER: &'static str = "WebAudio.NodeType";
        }
        #[doc = "Enum of AudioNode::ChannelCountMode from the spec"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ChannelCountMode {
            #[serde(rename = "clamped-max")]
            ClampedMax,
            #[serde(rename = "explicit")]
            Explicit,
            #[serde(rename = "max")]
            Max,
        }
        impl AsRef<str> for ChannelCountMode {
            fn as_ref(&self) -> &str {
                match self {
                    ChannelCountMode::ClampedMax => "clamped-max",
                    ChannelCountMode::Explicit => "explicit",
                    ChannelCountMode::Max => "max",
                }
            }
        }
        impl ::std::str::FromStr for ChannelCountMode {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "clamped-max" | "ClampedMax" => Ok(ChannelCountMode::ClampedMax),
                    "explicit" | "Explicit" => Ok(ChannelCountMode::Explicit),
                    "max" | "Max" => Ok(ChannelCountMode::Max),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Enum of AudioNode::ChannelInterpretation from the spec"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ChannelInterpretation {
            #[serde(rename = "discrete")]
            Discrete,
            #[serde(rename = "speakers")]
            Speakers,
        }
        impl AsRef<str> for ChannelInterpretation {
            fn as_ref(&self) -> &str {
                match self {
                    ChannelInterpretation::Discrete => "discrete",
                    ChannelInterpretation::Speakers => "speakers",
                }
            }
        }
        impl ::std::str::FromStr for ChannelInterpretation {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "discrete" | "Discrete" => Ok(ChannelInterpretation::Discrete),
                    "speakers" | "Speakers" => Ok(ChannelInterpretation::Speakers),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Enum of AudioParam types\n[ParamType](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#type-ParamType)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct ParamType(String);
        impl ParamType {
            pub fn new(val: impl Into<String>) -> Self {
                ParamType(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for ParamType {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<ParamType> for String {
            fn from(el: ParamType) -> String {
                el.0
            }
        }
        impl From<String> for ParamType {
            fn from(expr: String) -> Self {
                ParamType(expr)
            }
        }
        impl ParamType {
            pub const IDENTIFIER: &'static str = "WebAudio.ParamType";
        }
        #[doc = "Enum of AudioParam::AutomationRate from the spec"]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AutomationRate {
            #[serde(rename = "a-rate")]
            ARate,
            #[serde(rename = "k-rate")]
            KRate,
        }
        impl AsRef<str> for AutomationRate {
            fn as_ref(&self) -> &str {
                match self {
                    AutomationRate::ARate => "a-rate",
                    AutomationRate::KRate => "k-rate",
                }
            }
        }
        impl ::std::str::FromStr for AutomationRate {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "a-rate" | "ARate" => Ok(AutomationRate::ARate),
                    "k-rate" | "KRate" => Ok(AutomationRate::KRate),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[doc = "Fields in AudioContext that change in real-time.\n[ContextRealtimeData](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#type-ContextRealtimeData)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ContextRealtimeData {
            #[doc = "The current context time in second in BaseAudioContext."]
            #[serde(rename = "currentTime")]
            pub current_time: f64,
            #[doc = "The time spent on rendering graph divided by render quantum duration,\nand multiplied by 100. 100 means the audio renderer reached the full\ncapacity and glitch may occur."]
            #[serde(rename = "renderCapacity")]
            pub render_capacity: f64,
            #[doc = "A running mean of callback interval."]
            #[serde(rename = "callbackIntervalMean")]
            pub callback_interval_mean: f64,
            #[doc = "A running variance of callback interval."]
            #[serde(rename = "callbackIntervalVariance")]
            pub callback_interval_variance: f64,
        }
        impl ContextRealtimeData {
            pub fn new(
                current_time: impl Into<f64>,
                render_capacity: impl Into<f64>,
                callback_interval_mean: impl Into<f64>,
                callback_interval_variance: impl Into<f64>,
            ) -> Self {
                Self {
                    current_time: current_time.into(),
                    render_capacity: render_capacity.into(),
                    callback_interval_mean: callback_interval_mean.into(),
                    callback_interval_variance: callback_interval_variance.into(),
                }
            }
        }
        impl ContextRealtimeData {
            pub fn builder() -> ContextRealtimeDataBuilder {
                ContextRealtimeDataBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ContextRealtimeDataBuilder {
            current_time: Option<f64>,
            render_capacity: Option<f64>,
            callback_interval_mean: Option<f64>,
            callback_interval_variance: Option<f64>,
        }
        impl ContextRealtimeDataBuilder {
            pub fn current_time(mut self, current_time: impl Into<f64>) -> Self {
                self.current_time = Some(current_time.into());
                self
            }
            pub fn render_capacity(mut self, render_capacity: impl Into<f64>) -> Self {
                self.render_capacity = Some(render_capacity.into());
                self
            }
            pub fn callback_interval_mean(
                mut self,
                callback_interval_mean: impl Into<f64>,
            ) -> Self {
                self.callback_interval_mean = Some(callback_interval_mean.into());
                self
            }
            pub fn callback_interval_variance(
                mut self,
                callback_interval_variance: impl Into<f64>,
            ) -> Self {
                self.callback_interval_variance = Some(callback_interval_variance.into());
                self
            }
            pub fn build(self) -> Result<ContextRealtimeData, String> {
                Ok(ContextRealtimeData {
                    current_time: self.current_time.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(current_time))
                    })?,
                    render_capacity: self.render_capacity.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(render_capacity))
                    })?,
                    callback_interval_mean: self.callback_interval_mean.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(callback_interval_mean)
                        )
                    })?,
                    callback_interval_variance: self.callback_interval_variance.ok_or_else(
                        || {
                            format!(
                                "Field `{}` is mandatory.",
                                std::stringify!(callback_interval_variance)
                            )
                        },
                    )?,
                })
            }
        }
        impl ContextRealtimeData {
            pub const IDENTIFIER: &'static str = "WebAudio.ContextRealtimeData";
        }
        #[doc = "Protocol object for BaseAudioContext\n[BaseAudioContext](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#type-BaseAudioContext)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct BaseAudioContext {
            #[serde(rename = "contextId")]
            pub context_id: GraphObjectId,
            #[serde(rename = "contextType")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub context_type: ContextType,
            #[serde(rename = "contextState")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub context_state: ContextState,
            #[serde(rename = "realtimeData")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub realtime_data: Option<ContextRealtimeData>,
            #[doc = "Platform-dependent callback buffer size."]
            #[serde(rename = "callbackBufferSize")]
            pub callback_buffer_size: f64,
            #[doc = "Number of output channels supported by audio hardware in use."]
            #[serde(rename = "maxOutputChannelCount")]
            pub max_output_channel_count: f64,
            #[doc = "Context sample rate."]
            #[serde(rename = "sampleRate")]
            pub sample_rate: f64,
        }
        impl BaseAudioContext {
            pub fn builder() -> BaseAudioContextBuilder {
                BaseAudioContextBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct BaseAudioContextBuilder {
            context_id: Option<GraphObjectId>,
            context_type: Option<ContextType>,
            context_state: Option<ContextState>,
            realtime_data: Option<ContextRealtimeData>,
            callback_buffer_size: Option<f64>,
            max_output_channel_count: Option<f64>,
            sample_rate: Option<f64>,
        }
        impl BaseAudioContextBuilder {
            pub fn context_id(mut self, context_id: impl Into<GraphObjectId>) -> Self {
                self.context_id = Some(context_id.into());
                self
            }
            pub fn context_type(mut self, context_type: impl Into<ContextType>) -> Self {
                self.context_type = Some(context_type.into());
                self
            }
            pub fn context_state(mut self, context_state: impl Into<ContextState>) -> Self {
                self.context_state = Some(context_state.into());
                self
            }
            pub fn realtime_data(mut self, realtime_data: impl Into<ContextRealtimeData>) -> Self {
                self.realtime_data = Some(realtime_data.into());
                self
            }
            pub fn callback_buffer_size(mut self, callback_buffer_size: impl Into<f64>) -> Self {
                self.callback_buffer_size = Some(callback_buffer_size.into());
                self
            }
            pub fn max_output_channel_count(
                mut self,
                max_output_channel_count: impl Into<f64>,
            ) -> Self {
                self.max_output_channel_count = Some(max_output_channel_count.into());
                self
            }
            pub fn sample_rate(mut self, sample_rate: impl Into<f64>) -> Self {
                self.sample_rate = Some(sample_rate.into());
                self
            }
            pub fn build(self) -> Result<BaseAudioContext, String> {
                Ok(BaseAudioContext {
                    context_id: self.context_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(context_id))
                    })?,
                    context_type: self.context_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(context_type))
                    })?,
                    context_state: self.context_state.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(context_state))
                    })?,
                    realtime_data: self.realtime_data,
                    callback_buffer_size: self.callback_buffer_size.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(callback_buffer_size)
                        )
                    })?,
                    max_output_channel_count: self.max_output_channel_count.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(max_output_channel_count)
                        )
                    })?,
                    sample_rate: self.sample_rate.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(sample_rate))
                    })?,
                })
            }
        }
        impl BaseAudioContext {
            pub const IDENTIFIER: &'static str = "WebAudio.BaseAudioContext";
        }
        #[doc = "Protocol object for AudioListener\n[AudioListener](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#type-AudioListener)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AudioListener {
            #[serde(rename = "listenerId")]
            pub listener_id: GraphObjectId,
            #[serde(rename = "contextId")]
            pub context_id: GraphObjectId,
        }
        impl AudioListener {
            pub fn new(
                listener_id: impl Into<GraphObjectId>,
                context_id: impl Into<GraphObjectId>,
            ) -> Self {
                Self {
                    listener_id: listener_id.into(),
                    context_id: context_id.into(),
                }
            }
        }
        impl AudioListener {
            pub fn builder() -> AudioListenerBuilder {
                AudioListenerBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AudioListenerBuilder {
            listener_id: Option<GraphObjectId>,
            context_id: Option<GraphObjectId>,
        }
        impl AudioListenerBuilder {
            pub fn listener_id(mut self, listener_id: impl Into<GraphObjectId>) -> Self {
                self.listener_id = Some(listener_id.into());
                self
            }
            pub fn context_id(mut self, context_id: impl Into<GraphObjectId>) -> Self {
                self.context_id = Some(context_id.into());
                self
            }
            pub fn build(self) -> Result<AudioListener, String> {
                Ok(AudioListener {
                    listener_id: self.listener_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(listener_id))
                    })?,
                    context_id: self.context_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(context_id))
                    })?,
                })
            }
        }
        impl AudioListener {
            pub const IDENTIFIER: &'static str = "WebAudio.AudioListener";
        }
        #[doc = "Protocol object for AudioNode\n[AudioNode](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#type-AudioNode)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AudioNode {
            #[serde(rename = "nodeId")]
            pub node_id: GraphObjectId,
            #[serde(rename = "contextId")]
            pub context_id: GraphObjectId,
            #[serde(rename = "nodeType")]
            pub node_type: NodeType,
            #[serde(rename = "numberOfInputs")]
            pub number_of_inputs: f64,
            #[serde(rename = "numberOfOutputs")]
            pub number_of_outputs: f64,
            #[serde(rename = "channelCount")]
            pub channel_count: f64,
            #[serde(rename = "channelCountMode")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub channel_count_mode: ChannelCountMode,
            #[serde(rename = "channelInterpretation")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub channel_interpretation: ChannelInterpretation,
        }
        impl AudioNode {
            pub fn builder() -> AudioNodeBuilder {
                AudioNodeBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AudioNodeBuilder {
            node_id: Option<GraphObjectId>,
            context_id: Option<GraphObjectId>,
            node_type: Option<NodeType>,
            number_of_inputs: Option<f64>,
            number_of_outputs: Option<f64>,
            channel_count: Option<f64>,
            channel_count_mode: Option<ChannelCountMode>,
            channel_interpretation: Option<ChannelInterpretation>,
        }
        impl AudioNodeBuilder {
            pub fn node_id(mut self, node_id: impl Into<GraphObjectId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn context_id(mut self, context_id: impl Into<GraphObjectId>) -> Self {
                self.context_id = Some(context_id.into());
                self
            }
            pub fn node_type(mut self, node_type: impl Into<NodeType>) -> Self {
                self.node_type = Some(node_type.into());
                self
            }
            pub fn number_of_inputs(mut self, number_of_inputs: impl Into<f64>) -> Self {
                self.number_of_inputs = Some(number_of_inputs.into());
                self
            }
            pub fn number_of_outputs(mut self, number_of_outputs: impl Into<f64>) -> Self {
                self.number_of_outputs = Some(number_of_outputs.into());
                self
            }
            pub fn channel_count(mut self, channel_count: impl Into<f64>) -> Self {
                self.channel_count = Some(channel_count.into());
                self
            }
            pub fn channel_count_mode(
                mut self,
                channel_count_mode: impl Into<ChannelCountMode>,
            ) -> Self {
                self.channel_count_mode = Some(channel_count_mode.into());
                self
            }
            pub fn channel_interpretation(
                mut self,
                channel_interpretation: impl Into<ChannelInterpretation>,
            ) -> Self {
                self.channel_interpretation = Some(channel_interpretation.into());
                self
            }
            pub fn build(self) -> Result<AudioNode, String> {
                Ok(AudioNode {
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    context_id: self.context_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(context_id))
                    })?,
                    node_type: self.node_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_type))
                    })?,
                    number_of_inputs: self.number_of_inputs.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(number_of_inputs)
                        )
                    })?,
                    number_of_outputs: self.number_of_outputs.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(number_of_outputs)
                        )
                    })?,
                    channel_count: self.channel_count.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(channel_count))
                    })?,
                    channel_count_mode: self.channel_count_mode.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(channel_count_mode)
                        )
                    })?,
                    channel_interpretation: self.channel_interpretation.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(channel_interpretation)
                        )
                    })?,
                })
            }
        }
        impl AudioNode {
            pub const IDENTIFIER: &'static str = "WebAudio.AudioNode";
        }
        #[doc = "Protocol object for AudioParam\n[AudioParam](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#type-AudioParam)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AudioParam {
            #[serde(rename = "paramId")]
            pub param_id: GraphObjectId,
            #[serde(rename = "nodeId")]
            pub node_id: GraphObjectId,
            #[serde(rename = "contextId")]
            pub context_id: GraphObjectId,
            #[serde(rename = "paramType")]
            pub param_type: ParamType,
            #[serde(rename = "rate")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub rate: AutomationRate,
            #[serde(rename = "defaultValue")]
            pub default_value: f64,
            #[serde(rename = "minValue")]
            pub min_value: f64,
            #[serde(rename = "maxValue")]
            pub max_value: f64,
        }
        impl AudioParam {
            pub fn builder() -> AudioParamBuilder {
                AudioParamBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AudioParamBuilder {
            param_id: Option<GraphObjectId>,
            node_id: Option<GraphObjectId>,
            context_id: Option<GraphObjectId>,
            param_type: Option<ParamType>,
            rate: Option<AutomationRate>,
            default_value: Option<f64>,
            min_value: Option<f64>,
            max_value: Option<f64>,
        }
        impl AudioParamBuilder {
            pub fn param_id(mut self, param_id: impl Into<GraphObjectId>) -> Self {
                self.param_id = Some(param_id.into());
                self
            }
            pub fn node_id(mut self, node_id: impl Into<GraphObjectId>) -> Self {
                self.node_id = Some(node_id.into());
                self
            }
            pub fn context_id(mut self, context_id: impl Into<GraphObjectId>) -> Self {
                self.context_id = Some(context_id.into());
                self
            }
            pub fn param_type(mut self, param_type: impl Into<ParamType>) -> Self {
                self.param_type = Some(param_type.into());
                self
            }
            pub fn rate(mut self, rate: impl Into<AutomationRate>) -> Self {
                self.rate = Some(rate.into());
                self
            }
            pub fn default_value(mut self, default_value: impl Into<f64>) -> Self {
                self.default_value = Some(default_value.into());
                self
            }
            pub fn min_value(mut self, min_value: impl Into<f64>) -> Self {
                self.min_value = Some(min_value.into());
                self
            }
            pub fn max_value(mut self, max_value: impl Into<f64>) -> Self {
                self.max_value = Some(max_value.into());
                self
            }
            pub fn build(self) -> Result<AudioParam, String> {
                Ok(AudioParam {
                    param_id: self.param_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(param_id))
                    })?,
                    node_id: self.node_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(node_id))
                    })?,
                    context_id: self.context_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(context_id))
                    })?,
                    param_type: self.param_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(param_type))
                    })?,
                    rate: self.rate.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(rate))
                    })?,
                    default_value: self.default_value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(default_value))
                    })?,
                    min_value: self.min_value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(min_value))
                    })?,
                    max_value: self.max_value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(max_value))
                    })?,
                })
            }
        }
        impl AudioParam {
            pub const IDENTIFIER: &'static str = "WebAudio.AudioParam";
        }
        #[doc = "Enables the WebAudio domain and starts sending context lifetime events.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "WebAudio.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables the WebAudio domain and starts sending context lifetime events.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Disables the WebAudio domain.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "WebAudio.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables the WebAudio domain.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Fetch the realtime data from the registered contexts.\n[getRealtimeData](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#method-getRealtimeData)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetRealtimeDataParams {
            #[serde(rename = "contextId")]
            pub context_id: GraphObjectId,
        }
        impl GetRealtimeDataParams {
            pub fn new(context_id: impl Into<GraphObjectId>) -> Self {
                Self {
                    context_id: context_id.into(),
                }
            }
        }
        impl GetRealtimeDataParams {
            pub fn builder() -> GetRealtimeDataParamsBuilder {
                GetRealtimeDataParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetRealtimeDataParamsBuilder {
            context_id: Option<GraphObjectId>,
        }
        impl GetRealtimeDataParamsBuilder {
            pub fn context_id(mut self, context_id: impl Into<GraphObjectId>) -> Self {
                self.context_id = Some(context_id.into());
                self
            }
            pub fn build(self) -> Result<GetRealtimeDataParams, String> {
                Ok(GetRealtimeDataParams {
                    context_id: self.context_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(context_id))
                    })?,
                })
            }
        }
        impl GetRealtimeDataParams {
            pub const IDENTIFIER: &'static str = "WebAudio.getRealtimeData";
        }
        impl chromiumoxide_types::Method for GetRealtimeDataParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetRealtimeDataParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Fetch the realtime data from the registered contexts.\n[getRealtimeData](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#method-getRealtimeData)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetRealtimeDataReturns {
            #[serde(rename = "realtimeData")]
            pub realtime_data: ContextRealtimeData,
        }
        impl GetRealtimeDataReturns {
            pub fn new(realtime_data: impl Into<ContextRealtimeData>) -> Self {
                Self {
                    realtime_data: realtime_data.into(),
                }
            }
        }
        impl GetRealtimeDataReturns {
            pub fn builder() -> GetRealtimeDataReturnsBuilder {
                GetRealtimeDataReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetRealtimeDataReturnsBuilder {
            realtime_data: Option<ContextRealtimeData>,
        }
        impl GetRealtimeDataReturnsBuilder {
            pub fn realtime_data(mut self, realtime_data: impl Into<ContextRealtimeData>) -> Self {
                self.realtime_data = Some(realtime_data.into());
                self
            }
            pub fn build(self) -> Result<GetRealtimeDataReturns, String> {
                Ok(GetRealtimeDataReturns {
                    realtime_data: self.realtime_data.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(realtime_data))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetRealtimeDataParams {
            type Response = GetRealtimeDataReturns;
        }
        #[doc = "Notifies that a new BaseAudioContext has been created.\n[contextCreated](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-contextCreated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventContextCreated {
            #[serde(rename = "context")]
            pub context: BaseAudioContext,
        }
        impl EventContextCreated {
            pub const IDENTIFIER: &'static str = "WebAudio.contextCreated";
        }
        impl chromiumoxide_types::Method for EventContextCreated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventContextCreated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Notifies that an existing BaseAudioContext will be destroyed.\n[contextWillBeDestroyed](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-contextWillBeDestroyed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventContextWillBeDestroyed {
            #[serde(rename = "contextId")]
            pub context_id: GraphObjectId,
        }
        impl EventContextWillBeDestroyed {
            pub const IDENTIFIER: &'static str = "WebAudio.contextWillBeDestroyed";
        }
        impl chromiumoxide_types::Method for EventContextWillBeDestroyed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventContextWillBeDestroyed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Notifies that existing BaseAudioContext has changed some properties (id stays the same)..\n[contextChanged](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-contextChanged)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventContextChanged {
            #[serde(rename = "context")]
            pub context: BaseAudioContext,
        }
        impl EventContextChanged {
            pub const IDENTIFIER: &'static str = "WebAudio.contextChanged";
        }
        impl chromiumoxide_types::Method for EventContextChanged {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventContextChanged {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Notifies that the construction of an AudioListener has finished.\n[audioListenerCreated](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-audioListenerCreated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAudioListenerCreated {
            #[serde(rename = "listener")]
            pub listener: AudioListener,
        }
        impl EventAudioListenerCreated {
            pub const IDENTIFIER: &'static str = "WebAudio.audioListenerCreated";
        }
        impl chromiumoxide_types::Method for EventAudioListenerCreated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAudioListenerCreated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Notifies that a new AudioListener has been created.\n[audioListenerWillBeDestroyed](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-audioListenerWillBeDestroyed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAudioListenerWillBeDestroyed {
            #[serde(rename = "contextId")]
            pub context_id: GraphObjectId,
            #[serde(rename = "listenerId")]
            pub listener_id: GraphObjectId,
        }
        impl EventAudioListenerWillBeDestroyed {
            pub const IDENTIFIER: &'static str = "WebAudio.audioListenerWillBeDestroyed";
        }
        impl chromiumoxide_types::Method for EventAudioListenerWillBeDestroyed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAudioListenerWillBeDestroyed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Notifies that a new AudioNode has been created.\n[audioNodeCreated](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-audioNodeCreated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAudioNodeCreated {
            #[serde(rename = "node")]
            pub node: AudioNode,
        }
        impl EventAudioNodeCreated {
            pub const IDENTIFIER: &'static str = "WebAudio.audioNodeCreated";
        }
        impl chromiumoxide_types::Method for EventAudioNodeCreated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAudioNodeCreated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Notifies that an existing AudioNode has been destroyed.\n[audioNodeWillBeDestroyed](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-audioNodeWillBeDestroyed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAudioNodeWillBeDestroyed {
            #[serde(rename = "contextId")]
            pub context_id: GraphObjectId,
            #[serde(rename = "nodeId")]
            pub node_id: GraphObjectId,
        }
        impl EventAudioNodeWillBeDestroyed {
            pub const IDENTIFIER: &'static str = "WebAudio.audioNodeWillBeDestroyed";
        }
        impl chromiumoxide_types::Method for EventAudioNodeWillBeDestroyed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAudioNodeWillBeDestroyed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Notifies that a new AudioParam has been created.\n[audioParamCreated](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-audioParamCreated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAudioParamCreated {
            #[serde(rename = "param")]
            pub param: AudioParam,
        }
        impl EventAudioParamCreated {
            pub const IDENTIFIER: &'static str = "WebAudio.audioParamCreated";
        }
        impl chromiumoxide_types::Method for EventAudioParamCreated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAudioParamCreated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Notifies that an existing AudioParam has been destroyed.\n[audioParamWillBeDestroyed](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-audioParamWillBeDestroyed)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventAudioParamWillBeDestroyed {
            #[serde(rename = "contextId")]
            pub context_id: GraphObjectId,
            #[serde(rename = "nodeId")]
            pub node_id: GraphObjectId,
            #[serde(rename = "paramId")]
            pub param_id: GraphObjectId,
        }
        impl EventAudioParamWillBeDestroyed {
            pub const IDENTIFIER: &'static str = "WebAudio.audioParamWillBeDestroyed";
        }
        impl chromiumoxide_types::Method for EventAudioParamWillBeDestroyed {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventAudioParamWillBeDestroyed {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Notifies that two AudioNodes are connected.\n[nodesConnected](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-nodesConnected)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventNodesConnected {
            #[serde(rename = "contextId")]
            pub context_id: GraphObjectId,
            #[serde(rename = "sourceId")]
            pub source_id: GraphObjectId,
            #[serde(rename = "destinationId")]
            pub destination_id: GraphObjectId,
            #[serde(rename = "sourceOutputIndex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub source_output_index: Option<f64>,
            #[serde(rename = "destinationInputIndex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub destination_input_index: Option<f64>,
        }
        impl EventNodesConnected {
            pub const IDENTIFIER: &'static str = "WebAudio.nodesConnected";
        }
        impl chromiumoxide_types::Method for EventNodesConnected {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventNodesConnected {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Notifies that AudioNodes are disconnected. The destination can be null, and it means all the outgoing connections from the source are disconnected.\n[nodesDisconnected](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-nodesDisconnected)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventNodesDisconnected {
            #[serde(rename = "contextId")]
            pub context_id: GraphObjectId,
            #[serde(rename = "sourceId")]
            pub source_id: GraphObjectId,
            #[serde(rename = "destinationId")]
            pub destination_id: GraphObjectId,
            #[serde(rename = "sourceOutputIndex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub source_output_index: Option<f64>,
            #[serde(rename = "destinationInputIndex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub destination_input_index: Option<f64>,
        }
        impl EventNodesDisconnected {
            pub const IDENTIFIER: &'static str = "WebAudio.nodesDisconnected";
        }
        impl chromiumoxide_types::Method for EventNodesDisconnected {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventNodesDisconnected {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Notifies that an AudioNode is connected to an AudioParam.\n[nodeParamConnected](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-nodeParamConnected)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventNodeParamConnected {
            #[serde(rename = "contextId")]
            pub context_id: GraphObjectId,
            #[serde(rename = "sourceId")]
            pub source_id: GraphObjectId,
            #[serde(rename = "destinationId")]
            pub destination_id: GraphObjectId,
            #[serde(rename = "sourceOutputIndex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub source_output_index: Option<f64>,
        }
        impl EventNodeParamConnected {
            pub const IDENTIFIER: &'static str = "WebAudio.nodeParamConnected";
        }
        impl chromiumoxide_types::Method for EventNodeParamConnected {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventNodeParamConnected {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Notifies that an AudioNode is disconnected to an AudioParam.\n[nodeParamDisconnected](https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-nodeParamDisconnected)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventNodeParamDisconnected {
            #[serde(rename = "contextId")]
            pub context_id: GraphObjectId,
            #[serde(rename = "sourceId")]
            pub source_id: GraphObjectId,
            #[serde(rename = "destinationId")]
            pub destination_id: GraphObjectId,
            #[serde(rename = "sourceOutputIndex")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub source_output_index: Option<f64>,
        }
        impl EventNodeParamDisconnected {
            pub const IDENTIFIER: &'static str = "WebAudio.nodeParamDisconnected";
        }
        impl chromiumoxide_types::Method for EventNodeParamDisconnected {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventNodeParamDisconnected {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
    #[doc = "This domain allows configuring virtual authenticators to test the WebAuthn\nAPI."]
    pub mod web_authn {
        use serde::{Deserialize, Serialize};
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct AuthenticatorId(String);
        impl AuthenticatorId {
            pub fn new(val: impl Into<String>) -> Self {
                AuthenticatorId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for AuthenticatorId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<AuthenticatorId> for String {
            fn from(el: AuthenticatorId) -> String {
                el.0
            }
        }
        impl From<String> for AuthenticatorId {
            fn from(expr: String) -> Self {
                AuthenticatorId(expr)
            }
        }
        impl std::borrow::Borrow<str> for AuthenticatorId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl AuthenticatorId {
            pub const IDENTIFIER: &'static str = "WebAuthn.AuthenticatorId";
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AuthenticatorProtocol {
            #[doc = "Universal 2nd Factor."]
            #[serde(rename = "u2f")]
            U2f,
            #[doc = "Client To Authenticator Protocol 2."]
            #[serde(rename = "ctap2")]
            Ctap2,
        }
        impl AsRef<str> for AuthenticatorProtocol {
            fn as_ref(&self) -> &str {
                match self {
                    AuthenticatorProtocol::U2f => "u2f",
                    AuthenticatorProtocol::Ctap2 => "ctap2",
                }
            }
        }
        impl ::std::str::FromStr for AuthenticatorProtocol {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "u2f" | "U2f" => Ok(AuthenticatorProtocol::U2f),
                    "ctap2" | "Ctap2" => Ok(AuthenticatorProtocol::Ctap2),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum Ctap2Version {
            #[serde(rename = "ctap2_0")]
            Ctap20,
            #[serde(rename = "ctap2_1")]
            Ctap21,
        }
        impl AsRef<str> for Ctap2Version {
            fn as_ref(&self) -> &str {
                match self {
                    Ctap2Version::Ctap20 => "ctap2_0",
                    Ctap2Version::Ctap21 => "ctap2_1",
                }
            }
        }
        impl ::std::str::FromStr for Ctap2Version {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "ctap2_0" | "Ctap20" => Ok(Ctap2Version::Ctap20),
                    "ctap2_1" | "Ctap21" => Ok(Ctap2Version::Ctap21),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AuthenticatorTransport {
            #[doc = "Cross-Platform authenticator attachments:"]
            #[serde(rename = "usb")]
            Usb,
            #[serde(rename = "nfc")]
            Nfc,
            #[serde(rename = "ble")]
            Ble,
            #[serde(rename = "cable")]
            Cable,
            #[doc = "Platform authenticator attachment:"]
            #[serde(rename = "internal")]
            Internal,
        }
        impl AsRef<str> for AuthenticatorTransport {
            fn as_ref(&self) -> &str {
                match self {
                    AuthenticatorTransport::Usb => "usb",
                    AuthenticatorTransport::Nfc => "nfc",
                    AuthenticatorTransport::Ble => "ble",
                    AuthenticatorTransport::Cable => "cable",
                    AuthenticatorTransport::Internal => "internal",
                }
            }
        }
        impl ::std::str::FromStr for AuthenticatorTransport {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "usb" | "Usb" => Ok(AuthenticatorTransport::Usb),
                    "nfc" | "Nfc" => Ok(AuthenticatorTransport::Nfc),
                    "ble" | "Ble" => Ok(AuthenticatorTransport::Ble),
                    "cable" | "Cable" => Ok(AuthenticatorTransport::Cable),
                    "internal" | "Internal" => Ok(AuthenticatorTransport::Internal),
                    _ => Err(s.to_string()),
                }
            }
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct VirtualAuthenticatorOptions {
            #[serde(rename = "protocol")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub protocol: AuthenticatorProtocol,
            #[doc = "Defaults to ctap2_0. Ignored if |protocol| == u2f."]
            #[serde(rename = "ctap2Version")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(default)]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str_optional")]
            pub ctap2_version: Option<Ctap2Version>,
            #[serde(rename = "transport")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub transport: AuthenticatorTransport,
            #[doc = "Defaults to false."]
            #[serde(rename = "hasResidentKey")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub has_resident_key: Option<bool>,
            #[doc = "Defaults to false."]
            #[serde(rename = "hasUserVerification")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub has_user_verification: Option<bool>,
            #[doc = "If set to true, the authenticator will support the largeBlob extension.\nhttps://w3c.github.io/webauthn#largeBlob\nDefaults to false."]
            #[serde(rename = "hasLargeBlob")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub has_large_blob: Option<bool>,
            #[doc = "If set to true, the authenticator will support the credBlob extension.\nhttps://fidoalliance.org/specs/fido-v2.1-rd-20201208/fido-client-to-authenticator-protocol-v2.1-rd-20201208.html#sctn-credBlob-extension\nDefaults to false."]
            #[serde(rename = "hasCredBlob")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub has_cred_blob: Option<bool>,
            #[doc = "If set to true, the authenticator will support the minPinLength extension.\nhttps://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html#sctn-minpinlength-extension\nDefaults to false."]
            #[serde(rename = "hasMinPinLength")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub has_min_pin_length: Option<bool>,
            #[doc = "If set to true, tests of user presence will succeed immediately.\nOtherwise, they will not be resolved. Defaults to true."]
            #[serde(rename = "automaticPresenceSimulation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub automatic_presence_simulation: Option<bool>,
            #[doc = "Sets whether User Verification succeeds or fails for an authenticator.\nDefaults to false."]
            #[serde(rename = "isUserVerified")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub is_user_verified: Option<bool>,
        }
        impl VirtualAuthenticatorOptions {
            pub fn new(
                protocol: impl Into<AuthenticatorProtocol>,
                transport: impl Into<AuthenticatorTransport>,
            ) -> Self {
                Self {
                    protocol: protocol.into(),
                    transport: transport.into(),
                    ctap2_version: None,
                    has_resident_key: None,
                    has_user_verification: None,
                    has_large_blob: None,
                    has_cred_blob: None,
                    has_min_pin_length: None,
                    automatic_presence_simulation: None,
                    is_user_verified: None,
                }
            }
        }
        impl VirtualAuthenticatorOptions {
            pub fn builder() -> VirtualAuthenticatorOptionsBuilder {
                VirtualAuthenticatorOptionsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct VirtualAuthenticatorOptionsBuilder {
            protocol: Option<AuthenticatorProtocol>,
            ctap2_version: Option<Ctap2Version>,
            transport: Option<AuthenticatorTransport>,
            has_resident_key: Option<bool>,
            has_user_verification: Option<bool>,
            has_large_blob: Option<bool>,
            has_cred_blob: Option<bool>,
            has_min_pin_length: Option<bool>,
            automatic_presence_simulation: Option<bool>,
            is_user_verified: Option<bool>,
        }
        impl VirtualAuthenticatorOptionsBuilder {
            pub fn protocol(mut self, protocol: impl Into<AuthenticatorProtocol>) -> Self {
                self.protocol = Some(protocol.into());
                self
            }
            pub fn ctap2_version(mut self, ctap2_version: impl Into<Ctap2Version>) -> Self {
                self.ctap2_version = Some(ctap2_version.into());
                self
            }
            pub fn transport(mut self, transport: impl Into<AuthenticatorTransport>) -> Self {
                self.transport = Some(transport.into());
                self
            }
            pub fn has_resident_key(mut self, has_resident_key: impl Into<bool>) -> Self {
                self.has_resident_key = Some(has_resident_key.into());
                self
            }
            pub fn has_user_verification(mut self, has_user_verification: impl Into<bool>) -> Self {
                self.has_user_verification = Some(has_user_verification.into());
                self
            }
            pub fn has_large_blob(mut self, has_large_blob: impl Into<bool>) -> Self {
                self.has_large_blob = Some(has_large_blob.into());
                self
            }
            pub fn has_cred_blob(mut self, has_cred_blob: impl Into<bool>) -> Self {
                self.has_cred_blob = Some(has_cred_blob.into());
                self
            }
            pub fn has_min_pin_length(mut self, has_min_pin_length: impl Into<bool>) -> Self {
                self.has_min_pin_length = Some(has_min_pin_length.into());
                self
            }
            pub fn automatic_presence_simulation(
                mut self,
                automatic_presence_simulation: impl Into<bool>,
            ) -> Self {
                self.automatic_presence_simulation = Some(automatic_presence_simulation.into());
                self
            }
            pub fn is_user_verified(mut self, is_user_verified: impl Into<bool>) -> Self {
                self.is_user_verified = Some(is_user_verified.into());
                self
            }
            pub fn build(self) -> Result<VirtualAuthenticatorOptions, String> {
                Ok(VirtualAuthenticatorOptions {
                    protocol: self.protocol.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(protocol))
                    })?,
                    ctap2_version: self.ctap2_version,
                    transport: self.transport.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(transport))
                    })?,
                    has_resident_key: self.has_resident_key,
                    has_user_verification: self.has_user_verification,
                    has_large_blob: self.has_large_blob,
                    has_cred_blob: self.has_cred_blob,
                    has_min_pin_length: self.has_min_pin_length,
                    automatic_presence_simulation: self.automatic_presence_simulation,
                    is_user_verified: self.is_user_verified,
                })
            }
        }
        impl VirtualAuthenticatorOptions {
            pub const IDENTIFIER: &'static str = "WebAuthn.VirtualAuthenticatorOptions";
        }
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct Credential {
            #[serde(rename = "credentialId")]
            pub credential_id: chromiumoxide_types::Binary,
            #[serde(rename = "isResidentCredential")]
            pub is_resident_credential: bool,
            #[doc = "Relying Party ID the credential is scoped to. Must be set when adding a\ncredential."]
            #[serde(rename = "rpId")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub rp_id: Option<String>,
            #[doc = "The ECDSA P-256 private key in PKCS#8 format."]
            #[serde(rename = "privateKey")]
            pub private_key: chromiumoxide_types::Binary,
            #[doc = "An opaque byte sequence with a maximum size of 64 bytes mapping the\ncredential to a specific user."]
            #[serde(rename = "userHandle")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub user_handle: Option<chromiumoxide_types::Binary>,
            #[doc = "Signature counter. This is incremented by one for each successful\nassertion.\nSee https://w3c.github.io/webauthn/#signature-counter"]
            #[serde(rename = "signCount")]
            pub sign_count: i64,
            #[doc = "The large blob associated with the credential.\nSee https://w3c.github.io/webauthn/#sctn-large-blob-extension"]
            #[serde(rename = "largeBlob")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub large_blob: Option<chromiumoxide_types::Binary>,
        }
        impl Credential {
            pub fn new(
                credential_id: impl Into<chromiumoxide_types::Binary>,
                is_resident_credential: impl Into<bool>,
                private_key: impl Into<chromiumoxide_types::Binary>,
                sign_count: impl Into<i64>,
            ) -> Self {
                Self {
                    credential_id: credential_id.into(),
                    is_resident_credential: is_resident_credential.into(),
                    private_key: private_key.into(),
                    sign_count: sign_count.into(),
                    rp_id: None,
                    user_handle: None,
                    large_blob: None,
                }
            }
        }
        impl Credential {
            pub fn builder() -> CredentialBuilder {
                CredentialBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct CredentialBuilder {
            credential_id: Option<chromiumoxide_types::Binary>,
            is_resident_credential: Option<bool>,
            rp_id: Option<String>,
            private_key: Option<chromiumoxide_types::Binary>,
            user_handle: Option<chromiumoxide_types::Binary>,
            sign_count: Option<i64>,
            large_blob: Option<chromiumoxide_types::Binary>,
        }
        impl CredentialBuilder {
            pub fn credential_id(
                mut self,
                credential_id: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                self.credential_id = Some(credential_id.into());
                self
            }
            pub fn is_resident_credential(
                mut self,
                is_resident_credential: impl Into<bool>,
            ) -> Self {
                self.is_resident_credential = Some(is_resident_credential.into());
                self
            }
            pub fn rp_id(mut self, rp_id: impl Into<String>) -> Self {
                self.rp_id = Some(rp_id.into());
                self
            }
            pub fn private_key(
                mut self,
                private_key: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                self.private_key = Some(private_key.into());
                self
            }
            pub fn user_handle(
                mut self,
                user_handle: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                self.user_handle = Some(user_handle.into());
                self
            }
            pub fn sign_count(mut self, sign_count: impl Into<i64>) -> Self {
                self.sign_count = Some(sign_count.into());
                self
            }
            pub fn large_blob(
                mut self,
                large_blob: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                self.large_blob = Some(large_blob.into());
                self
            }
            pub fn build(self) -> Result<Credential, String> {
                Ok(Credential {
                    credential_id: self.credential_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(credential_id))
                    })?,
                    is_resident_credential: self.is_resident_credential.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(is_resident_credential)
                        )
                    })?,
                    rp_id: self.rp_id,
                    private_key: self.private_key.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(private_key))
                    })?,
                    user_handle: self.user_handle,
                    sign_count: self.sign_count.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(sign_count))
                    })?,
                    large_blob: self.large_blob,
                })
            }
        }
        impl Credential {
            pub const IDENTIFIER: &'static str = "WebAuthn.Credential";
        }
        #[doc = "Enable the WebAuthn domain and start intercepting credential storage and\nretrieval with a virtual authenticator.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {
            #[doc = "Whether to enable the WebAuthn user interface. Enabling the UI is\nrecommended for debugging and demo purposes, as it is closer to the real\nexperience. Disabling the UI is recommended for automated testing.\nSupported at the embedder's discretion if UI is available.\nDefaults to false."]
            #[serde(rename = "enableUI")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub enable_ui: Option<bool>,
        }
        impl EnableParams {
            pub fn builder() -> EnableParamsBuilder {
                EnableParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct EnableParamsBuilder {
            enable_ui: Option<bool>,
        }
        impl EnableParamsBuilder {
            pub fn enable_ui(mut self, enable_ui: impl Into<bool>) -> Self {
                self.enable_ui = Some(enable_ui.into());
                self
            }
            pub fn build(self) -> EnableParams {
                EnableParams {
                    enable_ui: self.enable_ui,
                }
            }
        }
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "WebAuthn.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enable the WebAuthn domain and start intercepting credential storage and\nretrieval with a virtual authenticator.\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Disable the WebAuthn domain.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "WebAuthn.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disable the WebAuthn domain.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "Creates and adds a virtual authenticator.\n[addVirtualAuthenticator](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-addVirtualAuthenticator)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AddVirtualAuthenticatorParams {
            #[serde(rename = "options")]
            pub options: VirtualAuthenticatorOptions,
        }
        impl AddVirtualAuthenticatorParams {
            pub fn new(options: impl Into<VirtualAuthenticatorOptions>) -> Self {
                Self {
                    options: options.into(),
                }
            }
        }
        impl AddVirtualAuthenticatorParams {
            pub fn builder() -> AddVirtualAuthenticatorParamsBuilder {
                AddVirtualAuthenticatorParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AddVirtualAuthenticatorParamsBuilder {
            options: Option<VirtualAuthenticatorOptions>,
        }
        impl AddVirtualAuthenticatorParamsBuilder {
            pub fn options(mut self, options: impl Into<VirtualAuthenticatorOptions>) -> Self {
                self.options = Some(options.into());
                self
            }
            pub fn build(self) -> Result<AddVirtualAuthenticatorParams, String> {
                Ok(AddVirtualAuthenticatorParams {
                    options: self.options.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(options))
                    })?,
                })
            }
        }
        impl AddVirtualAuthenticatorParams {
            pub const IDENTIFIER: &'static str = "WebAuthn.addVirtualAuthenticator";
        }
        impl chromiumoxide_types::Method for AddVirtualAuthenticatorParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for AddVirtualAuthenticatorParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Creates and adds a virtual authenticator.\n[addVirtualAuthenticator](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-addVirtualAuthenticator)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AddVirtualAuthenticatorReturns {
            #[serde(rename = "authenticatorId")]
            pub authenticator_id: AuthenticatorId,
        }
        impl AddVirtualAuthenticatorReturns {
            pub fn new(authenticator_id: impl Into<AuthenticatorId>) -> Self {
                Self {
                    authenticator_id: authenticator_id.into(),
                }
            }
        }
        impl AddVirtualAuthenticatorReturns {
            pub fn builder() -> AddVirtualAuthenticatorReturnsBuilder {
                AddVirtualAuthenticatorReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AddVirtualAuthenticatorReturnsBuilder {
            authenticator_id: Option<AuthenticatorId>,
        }
        impl AddVirtualAuthenticatorReturnsBuilder {
            pub fn authenticator_id(
                mut self,
                authenticator_id: impl Into<AuthenticatorId>,
            ) -> Self {
                self.authenticator_id = Some(authenticator_id.into());
                self
            }
            pub fn build(self) -> Result<AddVirtualAuthenticatorReturns, String> {
                Ok(AddVirtualAuthenticatorReturns {
                    authenticator_id: self.authenticator_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(authenticator_id)
                        )
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for AddVirtualAuthenticatorParams {
            type Response = AddVirtualAuthenticatorReturns;
        }
        #[doc = "Removes the given authenticator.\n[removeVirtualAuthenticator](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-removeVirtualAuthenticator)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoveVirtualAuthenticatorParams {
            #[serde(rename = "authenticatorId")]
            pub authenticator_id: AuthenticatorId,
        }
        impl RemoveVirtualAuthenticatorParams {
            pub fn new(authenticator_id: impl Into<AuthenticatorId>) -> Self {
                Self {
                    authenticator_id: authenticator_id.into(),
                }
            }
        }
        impl RemoveVirtualAuthenticatorParams {
            pub fn builder() -> RemoveVirtualAuthenticatorParamsBuilder {
                RemoveVirtualAuthenticatorParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoveVirtualAuthenticatorParamsBuilder {
            authenticator_id: Option<AuthenticatorId>,
        }
        impl RemoveVirtualAuthenticatorParamsBuilder {
            pub fn authenticator_id(
                mut self,
                authenticator_id: impl Into<AuthenticatorId>,
            ) -> Self {
                self.authenticator_id = Some(authenticator_id.into());
                self
            }
            pub fn build(self) -> Result<RemoveVirtualAuthenticatorParams, String> {
                Ok(RemoveVirtualAuthenticatorParams {
                    authenticator_id: self.authenticator_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(authenticator_id)
                        )
                    })?,
                })
            }
        }
        impl RemoveVirtualAuthenticatorParams {
            pub const IDENTIFIER: &'static str = "WebAuthn.removeVirtualAuthenticator";
        }
        impl chromiumoxide_types::Method for RemoveVirtualAuthenticatorParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RemoveVirtualAuthenticatorParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Removes the given authenticator.\n[removeVirtualAuthenticator](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-removeVirtualAuthenticator)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RemoveVirtualAuthenticatorReturns {}
        impl chromiumoxide_types::Command for RemoveVirtualAuthenticatorParams {
            type Response = RemoveVirtualAuthenticatorReturns;
        }
        #[doc = "Adds the credential to the specified authenticator.\n[addCredential](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-addCredential)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AddCredentialParams {
            #[serde(rename = "authenticatorId")]
            pub authenticator_id: AuthenticatorId,
            #[serde(rename = "credential")]
            pub credential: Credential,
        }
        impl AddCredentialParams {
            pub fn new(
                authenticator_id: impl Into<AuthenticatorId>,
                credential: impl Into<Credential>,
            ) -> Self {
                Self {
                    authenticator_id: authenticator_id.into(),
                    credential: credential.into(),
                }
            }
        }
        impl AddCredentialParams {
            pub fn builder() -> AddCredentialParamsBuilder {
                AddCredentialParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct AddCredentialParamsBuilder {
            authenticator_id: Option<AuthenticatorId>,
            credential: Option<Credential>,
        }
        impl AddCredentialParamsBuilder {
            pub fn authenticator_id(
                mut self,
                authenticator_id: impl Into<AuthenticatorId>,
            ) -> Self {
                self.authenticator_id = Some(authenticator_id.into());
                self
            }
            pub fn credential(mut self, credential: impl Into<Credential>) -> Self {
                self.credential = Some(credential.into());
                self
            }
            pub fn build(self) -> Result<AddCredentialParams, String> {
                Ok(AddCredentialParams {
                    authenticator_id: self.authenticator_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(authenticator_id)
                        )
                    })?,
                    credential: self.credential.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(credential))
                    })?,
                })
            }
        }
        impl AddCredentialParams {
            pub const IDENTIFIER: &'static str = "WebAuthn.addCredential";
        }
        impl chromiumoxide_types::Method for AddCredentialParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for AddCredentialParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Adds the credential to the specified authenticator.\n[addCredential](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-addCredential)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct AddCredentialReturns {}
        impl chromiumoxide_types::Command for AddCredentialParams {
            type Response = AddCredentialReturns;
        }
        #[doc = "Returns a single credential stored in the given virtual authenticator that\nmatches the credential ID.\n[getCredential](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-getCredential)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetCredentialParams {
            #[serde(rename = "authenticatorId")]
            pub authenticator_id: AuthenticatorId,
            #[serde(rename = "credentialId")]
            pub credential_id: chromiumoxide_types::Binary,
        }
        impl GetCredentialParams {
            pub fn new(
                authenticator_id: impl Into<AuthenticatorId>,
                credential_id: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                Self {
                    authenticator_id: authenticator_id.into(),
                    credential_id: credential_id.into(),
                }
            }
        }
        impl GetCredentialParams {
            pub fn builder() -> GetCredentialParamsBuilder {
                GetCredentialParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetCredentialParamsBuilder {
            authenticator_id: Option<AuthenticatorId>,
            credential_id: Option<chromiumoxide_types::Binary>,
        }
        impl GetCredentialParamsBuilder {
            pub fn authenticator_id(
                mut self,
                authenticator_id: impl Into<AuthenticatorId>,
            ) -> Self {
                self.authenticator_id = Some(authenticator_id.into());
                self
            }
            pub fn credential_id(
                mut self,
                credential_id: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                self.credential_id = Some(credential_id.into());
                self
            }
            pub fn build(self) -> Result<GetCredentialParams, String> {
                Ok(GetCredentialParams {
                    authenticator_id: self.authenticator_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(authenticator_id)
                        )
                    })?,
                    credential_id: self.credential_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(credential_id))
                    })?,
                })
            }
        }
        impl GetCredentialParams {
            pub const IDENTIFIER: &'static str = "WebAuthn.getCredential";
        }
        impl chromiumoxide_types::Method for GetCredentialParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetCredentialParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns a single credential stored in the given virtual authenticator that\nmatches the credential ID.\n[getCredential](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-getCredential)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetCredentialReturns {
            #[serde(rename = "credential")]
            pub credential: Credential,
        }
        impl GetCredentialReturns {
            pub fn new(credential: impl Into<Credential>) -> Self {
                Self {
                    credential: credential.into(),
                }
            }
        }
        impl GetCredentialReturns {
            pub fn builder() -> GetCredentialReturnsBuilder {
                GetCredentialReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetCredentialReturnsBuilder {
            credential: Option<Credential>,
        }
        impl GetCredentialReturnsBuilder {
            pub fn credential(mut self, credential: impl Into<Credential>) -> Self {
                self.credential = Some(credential.into());
                self
            }
            pub fn build(self) -> Result<GetCredentialReturns, String> {
                Ok(GetCredentialReturns {
                    credential: self.credential.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(credential))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetCredentialParams {
            type Response = GetCredentialReturns;
        }
        #[doc = "Returns all the credentials stored in the given virtual authenticator.\n[getCredentials](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-getCredentials)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetCredentialsParams {
            #[serde(rename = "authenticatorId")]
            pub authenticator_id: AuthenticatorId,
        }
        impl GetCredentialsParams {
            pub fn new(authenticator_id: impl Into<AuthenticatorId>) -> Self {
                Self {
                    authenticator_id: authenticator_id.into(),
                }
            }
        }
        impl GetCredentialsParams {
            pub fn builder() -> GetCredentialsParamsBuilder {
                GetCredentialsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetCredentialsParamsBuilder {
            authenticator_id: Option<AuthenticatorId>,
        }
        impl GetCredentialsParamsBuilder {
            pub fn authenticator_id(
                mut self,
                authenticator_id: impl Into<AuthenticatorId>,
            ) -> Self {
                self.authenticator_id = Some(authenticator_id.into());
                self
            }
            pub fn build(self) -> Result<GetCredentialsParams, String> {
                Ok(GetCredentialsParams {
                    authenticator_id: self.authenticator_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(authenticator_id)
                        )
                    })?,
                })
            }
        }
        impl GetCredentialsParams {
            pub const IDENTIFIER: &'static str = "WebAuthn.getCredentials";
        }
        impl chromiumoxide_types::Method for GetCredentialsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for GetCredentialsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Returns all the credentials stored in the given virtual authenticator.\n[getCredentials](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-getCredentials)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct GetCredentialsReturns {
            #[serde(rename = "credentials")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub credentials: Vec<Credential>,
        }
        impl GetCredentialsReturns {
            pub fn new(credentials: Vec<Credential>) -> Self {
                Self { credentials }
            }
        }
        impl GetCredentialsReturns {
            pub fn builder() -> GetCredentialsReturnsBuilder {
                GetCredentialsReturnsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct GetCredentialsReturnsBuilder {
            credentials: Option<Vec<Credential>>,
        }
        impl GetCredentialsReturnsBuilder {
            pub fn credential(mut self, credential: impl Into<Credential>) -> Self {
                let v = self.credentials.get_or_insert(Vec::new());
                v.push(credential.into());
                self
            }
            pub fn credentials<I, S>(mut self, credentials: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<Credential>,
            {
                let v = self.credentials.get_or_insert(Vec::new());
                for val in credentials {
                    v.push(val.into());
                }
                self
            }
            pub fn build(self) -> Result<GetCredentialsReturns, String> {
                Ok(GetCredentialsReturns {
                    credentials: self.credentials.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(credentials))
                    })?,
                })
            }
        }
        impl chromiumoxide_types::Command for GetCredentialsParams {
            type Response = GetCredentialsReturns;
        }
        #[doc = "Removes a credential from the authenticator.\n[removeCredential](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-removeCredential)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RemoveCredentialParams {
            #[serde(rename = "authenticatorId")]
            pub authenticator_id: AuthenticatorId,
            #[serde(rename = "credentialId")]
            pub credential_id: chromiumoxide_types::Binary,
        }
        impl RemoveCredentialParams {
            pub fn new(
                authenticator_id: impl Into<AuthenticatorId>,
                credential_id: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                Self {
                    authenticator_id: authenticator_id.into(),
                    credential_id: credential_id.into(),
                }
            }
        }
        impl RemoveCredentialParams {
            pub fn builder() -> RemoveCredentialParamsBuilder {
                RemoveCredentialParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct RemoveCredentialParamsBuilder {
            authenticator_id: Option<AuthenticatorId>,
            credential_id: Option<chromiumoxide_types::Binary>,
        }
        impl RemoveCredentialParamsBuilder {
            pub fn authenticator_id(
                mut self,
                authenticator_id: impl Into<AuthenticatorId>,
            ) -> Self {
                self.authenticator_id = Some(authenticator_id.into());
                self
            }
            pub fn credential_id(
                mut self,
                credential_id: impl Into<chromiumoxide_types::Binary>,
            ) -> Self {
                self.credential_id = Some(credential_id.into());
                self
            }
            pub fn build(self) -> Result<RemoveCredentialParams, String> {
                Ok(RemoveCredentialParams {
                    authenticator_id: self.authenticator_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(authenticator_id)
                        )
                    })?,
                    credential_id: self.credential_id.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(credential_id))
                    })?,
                })
            }
        }
        impl RemoveCredentialParams {
            pub const IDENTIFIER: &'static str = "WebAuthn.removeCredential";
        }
        impl chromiumoxide_types::Method for RemoveCredentialParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for RemoveCredentialParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Removes a credential from the authenticator.\n[removeCredential](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-removeCredential)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct RemoveCredentialReturns {}
        impl chromiumoxide_types::Command for RemoveCredentialParams {
            type Response = RemoveCredentialReturns;
        }
        #[doc = "Clears all the credentials from the specified device.\n[clearCredentials](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-clearCredentials)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ClearCredentialsParams {
            #[serde(rename = "authenticatorId")]
            pub authenticator_id: AuthenticatorId,
        }
        impl ClearCredentialsParams {
            pub fn new(authenticator_id: impl Into<AuthenticatorId>) -> Self {
                Self {
                    authenticator_id: authenticator_id.into(),
                }
            }
        }
        impl ClearCredentialsParams {
            pub fn builder() -> ClearCredentialsParamsBuilder {
                ClearCredentialsParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct ClearCredentialsParamsBuilder {
            authenticator_id: Option<AuthenticatorId>,
        }
        impl ClearCredentialsParamsBuilder {
            pub fn authenticator_id(
                mut self,
                authenticator_id: impl Into<AuthenticatorId>,
            ) -> Self {
                self.authenticator_id = Some(authenticator_id.into());
                self
            }
            pub fn build(self) -> Result<ClearCredentialsParams, String> {
                Ok(ClearCredentialsParams {
                    authenticator_id: self.authenticator_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(authenticator_id)
                        )
                    })?,
                })
            }
        }
        impl ClearCredentialsParams {
            pub const IDENTIFIER: &'static str = "WebAuthn.clearCredentials";
        }
        impl chromiumoxide_types::Method for ClearCredentialsParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for ClearCredentialsParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Clears all the credentials from the specified device.\n[clearCredentials](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-clearCredentials)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct ClearCredentialsReturns {}
        impl chromiumoxide_types::Command for ClearCredentialsParams {
            type Response = ClearCredentialsReturns;
        }
        #[doc = "Sets whether User Verification succeeds or fails for an authenticator.\nThe default is true.\n[setUserVerified](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-setUserVerified)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetUserVerifiedParams {
            #[serde(rename = "authenticatorId")]
            pub authenticator_id: AuthenticatorId,
            #[serde(rename = "isUserVerified")]
            pub is_user_verified: bool,
        }
        impl SetUserVerifiedParams {
            pub fn new(
                authenticator_id: impl Into<AuthenticatorId>,
                is_user_verified: impl Into<bool>,
            ) -> Self {
                Self {
                    authenticator_id: authenticator_id.into(),
                    is_user_verified: is_user_verified.into(),
                }
            }
        }
        impl SetUserVerifiedParams {
            pub fn builder() -> SetUserVerifiedParamsBuilder {
                SetUserVerifiedParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetUserVerifiedParamsBuilder {
            authenticator_id: Option<AuthenticatorId>,
            is_user_verified: Option<bool>,
        }
        impl SetUserVerifiedParamsBuilder {
            pub fn authenticator_id(
                mut self,
                authenticator_id: impl Into<AuthenticatorId>,
            ) -> Self {
                self.authenticator_id = Some(authenticator_id.into());
                self
            }
            pub fn is_user_verified(mut self, is_user_verified: impl Into<bool>) -> Self {
                self.is_user_verified = Some(is_user_verified.into());
                self
            }
            pub fn build(self) -> Result<SetUserVerifiedParams, String> {
                Ok(SetUserVerifiedParams {
                    authenticator_id: self.authenticator_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(authenticator_id)
                        )
                    })?,
                    is_user_verified: self.is_user_verified.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(is_user_verified)
                        )
                    })?,
                })
            }
        }
        impl SetUserVerifiedParams {
            pub const IDENTIFIER: &'static str = "WebAuthn.setUserVerified";
        }
        impl chromiumoxide_types::Method for SetUserVerifiedParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetUserVerifiedParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets whether User Verification succeeds or fails for an authenticator.\nThe default is true.\n[setUserVerified](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-setUserVerified)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetUserVerifiedReturns {}
        impl chromiumoxide_types::Command for SetUserVerifiedParams {
            type Response = SetUserVerifiedReturns;
        }
        #[doc = "Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.\nThe default is true.\n[setAutomaticPresenceSimulation](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-setAutomaticPresenceSimulation)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SetAutomaticPresenceSimulationParams {
            #[serde(rename = "authenticatorId")]
            pub authenticator_id: AuthenticatorId,
            #[serde(rename = "enabled")]
            pub enabled: bool,
        }
        impl SetAutomaticPresenceSimulationParams {
            pub fn new(
                authenticator_id: impl Into<AuthenticatorId>,
                enabled: impl Into<bool>,
            ) -> Self {
                Self {
                    authenticator_id: authenticator_id.into(),
                    enabled: enabled.into(),
                }
            }
        }
        impl SetAutomaticPresenceSimulationParams {
            pub fn builder() -> SetAutomaticPresenceSimulationParamsBuilder {
                SetAutomaticPresenceSimulationParamsBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct SetAutomaticPresenceSimulationParamsBuilder {
            authenticator_id: Option<AuthenticatorId>,
            enabled: Option<bool>,
        }
        impl SetAutomaticPresenceSimulationParamsBuilder {
            pub fn authenticator_id(
                mut self,
                authenticator_id: impl Into<AuthenticatorId>,
            ) -> Self {
                self.authenticator_id = Some(authenticator_id.into());
                self
            }
            pub fn enabled(mut self, enabled: impl Into<bool>) -> Self {
                self.enabled = Some(enabled.into());
                self
            }
            pub fn build(self) -> Result<SetAutomaticPresenceSimulationParams, String> {
                Ok(SetAutomaticPresenceSimulationParams {
                    authenticator_id: self.authenticator_id.ok_or_else(|| {
                        format!(
                            "Field `{}` is mandatory.",
                            std::stringify!(authenticator_id)
                        )
                    })?,
                    enabled: self.enabled.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(enabled))
                    })?,
                })
            }
        }
        impl SetAutomaticPresenceSimulationParams {
            pub const IDENTIFIER: &'static str = "WebAuthn.setAutomaticPresenceSimulation";
        }
        impl chromiumoxide_types::Method for SetAutomaticPresenceSimulationParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for SetAutomaticPresenceSimulationParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.\nThe default is true.\n[setAutomaticPresenceSimulation](https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-setAutomaticPresenceSimulation)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct SetAutomaticPresenceSimulationReturns {}
        impl chromiumoxide_types::Command for SetAutomaticPresenceSimulationParams {
            type Response = SetAutomaticPresenceSimulationReturns;
        }
    }
    #[doc = "This domain allows detailed inspection of media elements"]
    pub mod media {
        use serde::{Deserialize, Serialize};
        #[doc = "Players will get an ID that is unique within the agent context.\n[PlayerId](https://chromedevtools.github.io/devtools-protocol/tot/Media/#type-PlayerId)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize, Eq, Hash)]
        pub struct PlayerId(String);
        impl PlayerId {
            pub fn new(val: impl Into<String>) -> Self {
                PlayerId(val.into())
            }
            pub fn inner(&self) -> &String {
                &self.0
            }
        }
        impl AsRef<str> for PlayerId {
            fn as_ref(&self) -> &str {
                self.0.as_str()
            }
        }
        impl From<PlayerId> for String {
            fn from(el: PlayerId) -> String {
                el.0
            }
        }
        impl From<String> for PlayerId {
            fn from(expr: String) -> Self {
                PlayerId(expr)
            }
        }
        impl std::borrow::Borrow<str> for PlayerId {
            fn borrow(&self) -> &str {
                &self.0
            }
        }
        impl PlayerId {
            pub const IDENTIFIER: &'static str = "Media.PlayerId";
        }
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct Timestamp(f64);
        impl Timestamp {
            pub fn new(val: impl Into<f64>) -> Self {
                Timestamp(val.into())
            }
            pub fn inner(&self) -> &f64 {
                &self.0
            }
        }
        impl Timestamp {
            pub const IDENTIFIER: &'static str = "Media.Timestamp";
        }
        #[doc = "Have one type per entry in MediaLogRecord::Type\nCorresponds to kMessage\n[PlayerMessage](https://chromedevtools.github.io/devtools-protocol/tot/Media/#type-PlayerMessage)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PlayerMessage {
            #[doc = "Keep in sync with MediaLogMessageLevel\nWe are currently keeping the message level 'error' separate from the\nPlayerError type because right now they represent different things,\nthis one being a DVLOG(ERROR) style log message that gets printed\nbased on what log level is selected in the UI, and the other is a\nrepresentation of a media::PipelineStatus object. Soon however we're\ngoing to be moving away from using PipelineStatus for errors and\nintroducing a new error type which should hopefully let us integrate\nthe error log level into the PlayerError type."]
            #[serde(rename = "level")]
            #[serde(deserialize_with = "super::super::de::deserialize_from_str")]
            pub level: PlayerMessageLevel,
            #[serde(rename = "message")]
            pub message: String,
        }
        #[doc = "Keep in sync with MediaLogMessageLevel\nWe are currently keeping the message level 'error' separate from the\nPlayerError type because right now they represent different things,\nthis one being a DVLOG(ERROR) style log message that gets printed\nbased on what log level is selected in the UI, and the other is a\nrepresentation of a media::PipelineStatus object. Soon however we're\ngoing to be moving away from using PipelineStatus for errors and\nintroducing a new error type which should hopefully let us integrate\nthe error log level into the PlayerError type."]
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PlayerMessageLevel {
            #[serde(rename = "error")]
            Error,
            #[serde(rename = "warning")]
            Warning,
            #[serde(rename = "info")]
            Info,
            #[serde(rename = "debug")]
            Debug,
        }
        impl AsRef<str> for PlayerMessageLevel {
            fn as_ref(&self) -> &str {
                match self {
                    PlayerMessageLevel::Error => "error",
                    PlayerMessageLevel::Warning => "warning",
                    PlayerMessageLevel::Info => "info",
                    PlayerMessageLevel::Debug => "debug",
                }
            }
        }
        impl ::std::str::FromStr for PlayerMessageLevel {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "error" | "Error" => Ok(PlayerMessageLevel::Error),
                    "warning" | "Warning" => Ok(PlayerMessageLevel::Warning),
                    "info" | "Info" => Ok(PlayerMessageLevel::Info),
                    "debug" | "Debug" => Ok(PlayerMessageLevel::Debug),
                    _ => Err(s.to_string()),
                }
            }
        }
        impl PlayerMessage {
            pub fn new(level: impl Into<PlayerMessageLevel>, message: impl Into<String>) -> Self {
                Self {
                    level: level.into(),
                    message: message.into(),
                }
            }
        }
        impl PlayerMessage {
            pub fn builder() -> PlayerMessageBuilder {
                PlayerMessageBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PlayerMessageBuilder {
            level: Option<PlayerMessageLevel>,
            message: Option<String>,
        }
        impl PlayerMessageBuilder {
            pub fn level(mut self, level: impl Into<PlayerMessageLevel>) -> Self {
                self.level = Some(level.into());
                self
            }
            pub fn message(mut self, message: impl Into<String>) -> Self {
                self.message = Some(message.into());
                self
            }
            pub fn build(self) -> Result<PlayerMessage, String> {
                Ok(PlayerMessage {
                    level: self.level.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(level))
                    })?,
                    message: self.message.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(message))
                    })?,
                })
            }
        }
        impl PlayerMessage {
            pub const IDENTIFIER: &'static str = "Media.PlayerMessage";
        }
        #[doc = "Corresponds to kMediaPropertyChange\n[PlayerProperty](https://chromedevtools.github.io/devtools-protocol/tot/Media/#type-PlayerProperty)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PlayerProperty {
            #[serde(rename = "name")]
            pub name: String,
            #[serde(rename = "value")]
            pub value: String,
        }
        impl PlayerProperty {
            pub fn new(name: impl Into<String>, value: impl Into<String>) -> Self {
                Self {
                    name: name.into(),
                    value: value.into(),
                }
            }
        }
        impl PlayerProperty {
            pub fn builder() -> PlayerPropertyBuilder {
                PlayerPropertyBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PlayerPropertyBuilder {
            name: Option<String>,
            value: Option<String>,
        }
        impl PlayerPropertyBuilder {
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<PlayerProperty, String> {
                Ok(PlayerProperty {
                    name: self.name.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(name))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl PlayerProperty {
            pub const IDENTIFIER: &'static str = "Media.PlayerProperty";
        }
        #[doc = "Corresponds to kMediaEventTriggered\n[PlayerEvent](https://chromedevtools.github.io/devtools-protocol/tot/Media/#type-PlayerEvent)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PlayerEvent {
            #[serde(rename = "timestamp")]
            pub timestamp: Timestamp,
            #[serde(rename = "value")]
            pub value: String,
        }
        impl PlayerEvent {
            pub fn new(timestamp: impl Into<Timestamp>, value: impl Into<String>) -> Self {
                Self {
                    timestamp: timestamp.into(),
                    value: value.into(),
                }
            }
        }
        impl PlayerEvent {
            pub fn builder() -> PlayerEventBuilder {
                PlayerEventBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PlayerEventBuilder {
            timestamp: Option<Timestamp>,
            value: Option<String>,
        }
        impl PlayerEventBuilder {
            pub fn timestamp(mut self, timestamp: impl Into<Timestamp>) -> Self {
                self.timestamp = Some(timestamp.into());
                self
            }
            pub fn value(mut self, value: impl Into<String>) -> Self {
                self.value = Some(value.into());
                self
            }
            pub fn build(self) -> Result<PlayerEvent, String> {
                Ok(PlayerEvent {
                    timestamp: self.timestamp.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(timestamp))
                    })?,
                    value: self.value.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(value))
                    })?,
                })
            }
        }
        impl PlayerEvent {
            pub const IDENTIFIER: &'static str = "Media.PlayerEvent";
        }
        #[doc = "Represents logged source line numbers reported in an error.\nNOTE: file and line are from chromium c++ implementation code, not js.\n[PlayerErrorSourceLocation](https://chromedevtools.github.io/devtools-protocol/tot/Media/#type-PlayerErrorSourceLocation)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PlayerErrorSourceLocation {
            #[serde(rename = "file")]
            pub file: String,
            #[serde(rename = "line")]
            pub line: i64,
        }
        impl PlayerErrorSourceLocation {
            pub fn new(file: impl Into<String>, line: impl Into<i64>) -> Self {
                Self {
                    file: file.into(),
                    line: line.into(),
                }
            }
        }
        impl PlayerErrorSourceLocation {
            pub fn builder() -> PlayerErrorSourceLocationBuilder {
                PlayerErrorSourceLocationBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PlayerErrorSourceLocationBuilder {
            file: Option<String>,
            line: Option<i64>,
        }
        impl PlayerErrorSourceLocationBuilder {
            pub fn file(mut self, file: impl Into<String>) -> Self {
                self.file = Some(file.into());
                self
            }
            pub fn line(mut self, line: impl Into<i64>) -> Self {
                self.line = Some(line.into());
                self
            }
            pub fn build(self) -> Result<PlayerErrorSourceLocation, String> {
                Ok(PlayerErrorSourceLocation {
                    file: self.file.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(file))
                    })?,
                    line: self.line.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(line))
                    })?,
                })
            }
        }
        impl PlayerErrorSourceLocation {
            pub const IDENTIFIER: &'static str = "Media.PlayerErrorSourceLocation";
        }
        #[doc = "Corresponds to kMediaError\n[PlayerError](https://chromedevtools.github.io/devtools-protocol/tot/Media/#type-PlayerError)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct PlayerError {
            #[serde(rename = "errorType")]
            pub error_type: String,
            #[doc = "Code is the numeric enum entry for a specific set of error codes, such\nas PipelineStatusCodes in media/base/pipeline_status.h"]
            #[serde(rename = "code")]
            pub code: i64,
            #[doc = "A trace of where this error was caused / where it passed through."]
            #[serde(rename = "stack")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub stack: Vec<PlayerErrorSourceLocation>,
            #[doc = "Errors potentially have a root cause error, ie, a DecoderError might be\ncaused by an WindowsError"]
            #[serde(rename = "cause")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub cause: Vec<PlayerError>,
            #[doc = "Extra data attached to an error, such as an HRESULT, Video Codec, etc."]
            #[serde(rename = "data")]
            pub data: serde_json::Value,
        }
        impl PlayerError {
            pub fn builder() -> PlayerErrorBuilder {
                PlayerErrorBuilder::default()
            }
        }
        #[derive(Default, Clone)]
        pub struct PlayerErrorBuilder {
            error_type: Option<String>,
            code: Option<i64>,
            stack: Option<Vec<PlayerErrorSourceLocation>>,
            cause: Option<Vec<PlayerError>>,
            data: Option<serde_json::Value>,
        }
        impl PlayerErrorBuilder {
            pub fn error_type(mut self, error_type: impl Into<String>) -> Self {
                self.error_type = Some(error_type.into());
                self
            }
            pub fn code(mut self, code: impl Into<i64>) -> Self {
                self.code = Some(code.into());
                self
            }
            pub fn stack(mut self, stack: impl Into<PlayerErrorSourceLocation>) -> Self {
                let v = self.stack.get_or_insert(Vec::new());
                v.push(stack.into());
                self
            }
            pub fn stacks<I, S>(mut self, stacks: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PlayerErrorSourceLocation>,
            {
                let v = self.stack.get_or_insert(Vec::new());
                for val in stacks {
                    v.push(val.into());
                }
                self
            }
            pub fn cause(mut self, cause: impl Into<PlayerError>) -> Self {
                let v = self.cause.get_or_insert(Vec::new());
                v.push(cause.into());
                self
            }
            pub fn causes<I, S>(mut self, causes: I) -> Self
            where
                I: IntoIterator<Item = S>,
                S: Into<PlayerError>,
            {
                let v = self.cause.get_or_insert(Vec::new());
                for val in causes {
                    v.push(val.into());
                }
                self
            }
            pub fn data(mut self, data: impl Into<serde_json::Value>) -> Self {
                self.data = Some(data.into());
                self
            }
            pub fn build(self) -> Result<PlayerError, String> {
                Ok(PlayerError {
                    error_type: self.error_type.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(error_type))
                    })?,
                    code: self.code.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(code))
                    })?,
                    stack: self.stack.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(stack))
                    })?,
                    cause: self.cause.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(cause))
                    })?,
                    data: self.data.ok_or_else(|| {
                        format!("Field `{}` is mandatory.", std::stringify!(data))
                    })?,
                })
            }
        }
        impl PlayerError {
            pub const IDENTIFIER: &'static str = "Media.PlayerError";
        }
        #[doc = "Enables the Media domain\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Media/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableParams {}
        impl EnableParams {
            pub const IDENTIFIER: &'static str = "Media.enable";
        }
        impl chromiumoxide_types::Method for EnableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EnableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Enables the Media domain\n[enable](https://chromedevtools.github.io/devtools-protocol/tot/Media/#method-enable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct EnableReturns {}
        impl chromiumoxide_types::Command for EnableParams {
            type Response = EnableReturns;
        }
        #[doc = "Disables the Media domain.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Media/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableParams {}
        impl DisableParams {
            pub const IDENTIFIER: &'static str = "Media.disable";
        }
        impl chromiumoxide_types::Method for DisableParams {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for DisableParams {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Disables the Media domain.\n[disable](https://chromedevtools.github.io/devtools-protocol/tot/Media/#method-disable)"]
        #[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
        pub struct DisableReturns {}
        impl chromiumoxide_types::Command for DisableParams {
            type Response = DisableReturns;
        }
        #[doc = "This can be called multiple times, and can be used to set / override /\nremove player properties. A null propValue indicates removal.\n[playerPropertiesChanged](https://chromedevtools.github.io/devtools-protocol/tot/Media/#event-playerPropertiesChanged)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventPlayerPropertiesChanged {
            #[serde(rename = "playerId")]
            pub player_id: PlayerId,
            #[serde(rename = "properties")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub properties: Vec<PlayerProperty>,
        }
        impl EventPlayerPropertiesChanged {
            pub const IDENTIFIER: &'static str = "Media.playerPropertiesChanged";
        }
        impl chromiumoxide_types::Method for EventPlayerPropertiesChanged {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventPlayerPropertiesChanged {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Send events as a list, allowing them to be batched on the browser for less\ncongestion. If batched, events must ALWAYS be in chronological order.\n[playerEventsAdded](https://chromedevtools.github.io/devtools-protocol/tot/Media/#event-playerEventsAdded)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventPlayerEventsAdded {
            #[serde(rename = "playerId")]
            pub player_id: PlayerId,
            #[serde(rename = "events")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub events: Vec<PlayerEvent>,
        }
        impl EventPlayerEventsAdded {
            pub const IDENTIFIER: &'static str = "Media.playerEventsAdded";
        }
        impl chromiumoxide_types::Method for EventPlayerEventsAdded {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventPlayerEventsAdded {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Send a list of any messages that need to be delivered.\n[playerMessagesLogged](https://chromedevtools.github.io/devtools-protocol/tot/Media/#event-playerMessagesLogged)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventPlayerMessagesLogged {
            #[serde(rename = "playerId")]
            pub player_id: PlayerId,
            #[serde(rename = "messages")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub messages: Vec<PlayerMessage>,
        }
        impl EventPlayerMessagesLogged {
            pub const IDENTIFIER: &'static str = "Media.playerMessagesLogged";
        }
        impl chromiumoxide_types::Method for EventPlayerMessagesLogged {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventPlayerMessagesLogged {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Send a list of any errors that need to be delivered.\n[playerErrorsRaised](https://chromedevtools.github.io/devtools-protocol/tot/Media/#event-playerErrorsRaised)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventPlayerErrorsRaised {
            #[serde(rename = "playerId")]
            pub player_id: PlayerId,
            #[serde(rename = "errors")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub errors: Vec<PlayerError>,
        }
        impl EventPlayerErrorsRaised {
            pub const IDENTIFIER: &'static str = "Media.playerErrorsRaised";
        }
        impl chromiumoxide_types::Method for EventPlayerErrorsRaised {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventPlayerErrorsRaised {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
        #[doc = "Called whenever a player is created, or when a new agent joins and receives\na list of active players. If an agent is restored, it will receive the full\nlist of player ids and all events again.\n[playersCreated](https://chromedevtools.github.io/devtools-protocol/tot/Media/#event-playersCreated)"]
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct EventPlayersCreated {
            #[serde(rename = "players")]
            #[serde(skip_serializing_if = "Vec::is_empty")]
            pub players: Vec<PlayerId>,
        }
        impl EventPlayersCreated {
            pub const IDENTIFIER: &'static str = "Media.playersCreated";
        }
        impl chromiumoxide_types::Method for EventPlayersCreated {
            fn identifier(&self) -> chromiumoxide_types::MethodId {
                Self::IDENTIFIER.into()
            }
        }
        impl chromiumoxide_types::MethodType for EventPlayersCreated {
            fn method_id() -> chromiumoxide_types::MethodId
            where
                Self: Sized,
            {
                Self::IDENTIFIER.into()
            }
        }
    }
}
pub mod de {
    use serde::{de, Deserialize, Deserializer};
    use std::str::FromStr;
    #[doc = r" Use the `FromStr` implementation to serialize an optional value"]
    pub fn deserialize_from_str_optional<'de, D, T>(data: D) -> Result<Option<T>, D::Error>
    where
        D: Deserializer<'de>,
        T: FromStr<Err = String>,
    {
        deserialize_from_str(data).map(Some)
    }
    #[doc = r" Use the `FromStr` implementation to serialize a value"]
    pub fn deserialize_from_str<'de, D, T>(data: D) -> Result<T, D::Error>
    where
        D: Deserializer<'de>,
        T: FromStr<Err = String>,
    {
        let s: String = Deserialize::deserialize(data)?;
        T::from_str(&s).map_err(de::Error::custom)
    }
}
